# Release Phase Workflow
#
# This reusable workflow handles release-specific finalization operations:
# - Deploying artifacts to Artifactory (Maven repository)
# - Generating and uploading Javadocs to S3
# - Triggering plugin repository updates
# - Generating and uploading SBOM (Software Bill of Materials)
# - Updating GitHub issue labels for release tracking
#
# This phase runs after the standard deployment phase (which handles Docker/NPM)
# and focuses on release-specific operations.
#
# Key features:
# - Configurable release operations (artifacts, javadocs, plugins, labels)
# - Java variant support: creates different Maven versions via runtime -Dchangelist override
# - SBOM generation and GitHub release asset upload
# - GitHub issue label management for release tracking
# - AWS S3 integration for javadoc hosting
# - Conditional operations: javadocs, plugins, labels, SBOM only run for primary release

name: Release Phase

on:
  workflow_call:
    inputs:
      release_version:
        description: 'Release version'
        required: true
        type: string
      release_tag:
        description: 'Release tag'
        required: true
        type: string
      artifact_run_id:
        description: 'Artifact run ID'
        required: false
        type: string
        default: ${{ github.run_id }}
      deploy_artifact:
        description: 'Deploy artifact to Artifactory'
        type: boolean
        default: true
      upload_javadocs:
        description: 'Upload Javadocs to S3'
        type: boolean
        default: true
      update_plugins:
        description: 'Update Plugins'
        type: boolean
        default: true
      update_github_labels:
        description: 'Update GitHub labels'
        type: boolean
        default: true
      java-version:
        description: 'Override Java version (SDKMAN format, e.g., 25.0.1-open)'
        required: false
        type: string
        default: ''
      artifact-suffix:
        description: 'Artifact suffix without leading separator (e.g., java25, java25-ms). Separators added automatically: dash (-) for Maven artifacts, underscore (_) for Docker tags. If not set, derived from java-version major (e.g., java25).'
        required: false
        type: string
        default: ''
    secrets:
      EE_REPO_USERNAME:
        required: false
        description: 'Artifactory username'
      EE_REPO_PASSWORD:
        required: false
        description: 'Artifactory password'
      AWS_ACCESS_KEY_ID:
        required: false
        description: 'AWS access key ID'
      AWS_SECRET_ACCESS_KEY:
        required: false
        description: 'AWS secret access key'
      CI_MACHINE_TOKEN:
        required: false
        description: 'CI machine token for GitHub API operations'

jobs:
  # Deploy release artifacts to Artifactory and S3
  release-artifacts:
    name: Release Artifacts
    runs-on: ubuntu-${{ vars.UBUNTU_RUNNER_VERSION || '24.04' }}
    env:
      AWS_REGION: us-east-1
      JVM_TEST_MAVEN_OPTS: '-e -B -Dorg.slf4j.simpleLogger.log.org.apache.maven.cli.transfer.Slf4jMavenTransferListener=warn'
    steps:
      - name: Checkout core
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.release_tag }}

      - uses: ./.github/actions/core-cicd/cleanup-runner

      - name: Compute Java Suffix
        id: java-suffix
        shell: bash
        run: |
          # Naming Convention for Java Variants:
          # - User input: suffix without leading separator (e.g., "java25" or "java25-ms")
          # - Maven artifacts: use dash separator (e.g., "-java25")
          # - Docker tags: use underscore separator (e.g., "_java25")
          #
          # Note: Underscore in Docker tags is non-standard but follows existing dotCMS convention.
          # Docker typically uses dash or no separator, but we use underscore to distinguish from
          # version dashes (e.g., "25.02.16-01_java25_abc123" vs "25.02.16-01-java25-abc123").
          # This convention may be revisited in future.

          if [ -n "${{ inputs.java-version }}" ]; then
            # Priority: explicit artifact-suffix > derived from java-version major
            if [ -n "${{ inputs.artifact-suffix }}" ]; then
              RAW_SUFFIX="${{ inputs.artifact-suffix }}"
              echo "Using explicit artifact suffix: ${RAW_SUFFIX}"
            else
              JAVA_MAJOR=$(echo "${{ inputs.java-version }}" | grep -oE '^[0-9]+')
              RAW_SUFFIX="java${JAVA_MAJOR}"
              echo "Using derived artifact suffix: ${RAW_SUFFIX}"
            fi

            # Normalize: strip any leading separators, then add appropriate separator
            while [[ "${RAW_SUFFIX}" =~ ^[-_] ]]; do
              RAW_SUFFIX="${RAW_SUFFIX:1}"
            done

            # For Maven artifacts: use dash separator
            MAVEN_SUFFIX="-${RAW_SUFFIX}"

            echo "Raw suffix: '${RAW_SUFFIX}'"
            echo "Maven suffix: '${MAVEN_SUFFIX}'"
          else
            RAW_SUFFIX=""
            MAVEN_SUFFIX=""
          fi
          echo "suffix=${MAVEN_SUFFIX}" >> "$GITHUB_OUTPUT"
          echo "raw_suffix=${RAW_SUFFIX}" >> "$GITHUB_OUTPUT"

      - name: Setup Java
        id: setup-java
        uses: ./.github/actions/core-cicd/setup-java
        with:
          java-version: ${{ inputs.java-version }}

      - name: Restore Maven Repository
        uses: actions/download-artifact@v4
        with:
          name: maven-repo${{ steps.java-suffix.outputs.suffix }}
          path: ~/.m2/repository

      - name: Configure Maven Settings
        uses: whelk-io/maven-settings-xml-action@v20
        with:
          servers: '[{ "id": "dotcms-libs-local", "username": "${{ secrets.EE_REPO_USERNAME }}", "password": "${{ secrets.EE_REPO_PASSWORD }}" }]'

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
        if: inputs.upload_javadocs == true

      - name: Deploy Release Artifacts to Artifactory
        run: |
          # Add changelist suffix for alternate Java versions
          CHANGELIST_ARG=""
          if [ -n "${{ steps.java-suffix.outputs.suffix }}" ]; then
            CHANGELIST_ARG="-Dchangelist=${{ steps.java-suffix.outputs.suffix }}"
            echo "Adding changelist suffix: ${{ steps.java-suffix.outputs.suffix }}"
          fi

          # shellcheck disable=SC2086
          # Reason: JVM_TEST_MAVEN_OPTS and CHANGELIST_ARG must be word-split to pass multiple Maven arguments
          ./mvnw -ntp \
            ${JVM_TEST_MAVEN_OPTS} \
            -Dprod=true \
            -DskipTests=true \
            ${CHANGELIST_ARG} \
            deploy
        if: inputs.deploy_artifact == true

      - name: Generate and Upload Javadocs
        run: |
          # shellcheck disable=SC2086
          # Reason: JVM_TEST_MAVEN_OPTS must be word-split to pass multiple Maven arguments
          ./mvnw -ntp \
            ${JVM_TEST_MAVEN_OPTS} \
            javadoc:javadoc \
            -pl :dotcms-core
          rc=$?
          if [[ $rc != 0 ]]; then
            echo "Javadoc generation failed with exit code $rc"
            exit $rc
          fi

          site_dir=./dotCMS/target/site
          javadoc_dir=${site_dir}/javadocs
          s3_uri=s3://static.dotcms.com/docs/${{ inputs.release_version }}${{ steps.java-suffix.outputs.suffix }}/javadocs

          mv ${site_dir}/apidocs ${javadoc_dir}
          echo "Running: aws s3 cp ${javadoc_dir} ${s3_uri} --recursive"
          aws s3 cp ${javadoc_dir} ${s3_uri} --recursive
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        if: inputs.upload_javadocs == true && inputs.java-version == ''

      - name: Trigger Plugin Repository Update
        env:
          RELEASE_VERSION: ${{ inputs.release_version }}
          CI_MACHINE_TOKEN: ${{ secrets.CI_MACHINE_TOKEN }}
        run: |
          # shellcheck disable=SC2153
          release_version="${RELEASE_VERSION}"
          response=$(curl -L \
            -X POST \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: Bearer ${CI_MACHINE_TOKEN}" \
            -H "X-GitHub-Api-Version: 2022-11-28" \
            https://api.github.com/repos/dotCMS/plugin-seeds/dispatches \
            -d "{\"event_type\": \"on-plugins-release\", \"client_payload\": {\"release_version\": \"${release_version}\"}}" \
            -w "\n%{http_code}" \
            -s)
          http_code=$(echo "$response" | tail -n1)
          if [ "${http_code}" != "204" ]; then
            echo "Failed to dispatch workflow. HTTP code: $http_code"
            echo "Response: $response"
          fi
        if: inputs.update_plugins == true && inputs.java-version == ''

  # Generate and upload SBOM to GitHub release
  # Only run for primary release (not Java variants) since SBOM is based on Docker image
  # and should represent the primary release artifact
  release-sbom:
    name: Release SBOM
    runs-on: ubuntu-${{ vars.UBUNTU_RUNNER_VERSION || '24.04' }}
    if: inputs.java-version == ''
    continue-on-error: true
    steps:
      - uses: actions/checkout@v4

      - uses: ./.github/actions/legacy-release/sbom-generator
        id: sbom-generator
        with:
          dotcms_version: ${{ inputs.release_version }}
          github_token: ${{ secrets.CI_MACHINE_TOKEN }}

      - name: Download SBOM Artifacts
        uses: actions/download-artifact@v4
        with:
          path: ${{ github.workspace }}/artifacts
          pattern: ${{ steps.sbom-generator.outputs.sbom-artifact }}

      - name: Upload SBOM to GitHub Release
        env:
          GITHUB_TOKEN: ${{ secrets.CI_MACHINE_TOKEN }}
        run: |
          echo "::group::Upload SBOM Asset"
          ARTIFACT_NAME=${{ steps.sbom-generator.outputs.sbom-artifact }}
          SBOM="./artifacts/${ARTIFACT_NAME}/${ARTIFACT_NAME}.json"

          if [ -f "${SBOM}" ]; then
            echo "SBOM: ${SBOM}"
            cat "${SBOM}"

            zip "${ARTIFACT_NAME}.zip" "${SBOM}"
            gh release upload "${{ inputs.release_tag }}" "${ARTIFACT_NAME}.zip"
          else
            echo "SBOM artifact not found."
          fi
          echo "::endgroup::"

  # Update GitHub labels for release tracking
  # Only updates labels if release-artifacts (Artifactory/Javadocs) succeeded.
  # The calling workflow's dependency chain ensures deployment also succeeded.
  release-labeling:
    name: Release Labeling
    needs: [ release-artifacts ]
    if: success() && inputs.update_github_labels == true && inputs.java-version == ''
    uses: ./.github/workflows/issue_comp_release-labeling.yml
    with:
      new_label: 'Release : ${{ inputs.release_version }}'
      rename_label: 'Next Release'
    secrets:
      CI_MACHINE_TOKEN: ${{ secrets.CI_MACHINE_TOKEN }}