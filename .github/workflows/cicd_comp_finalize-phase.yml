# Finalize Phase Workflow
#
# This reusable workflow is responsible for preparing a final report of the build process,
# aggregating data from various build steps, and determining the overall status of the workflow.
#
# Key features:
# - Aggregates build reports from multiple steps
# - Determines overall workflow status (SUCCESS, FAILURE, or CANCELLED)
# - Prepares a comprehensive JSON report of the entire workflow
# - Uploads the final report as an artifact
# - Provides a final status check based on the aggregate status

name: Finalize Phase

on:
  workflow_call:
    inputs:
      artifact-run-id:
        default: ${{ github.run_id }}
        type: string
      needsData:
        required: true
        type: string
    outputs:
      aggregate_status:
        value: ${{ jobs.prepare-report-data.outputs.aggregate_status }}

jobs:
  prepare-report-data:
    name: Prepare Report Data
    runs-on: ubuntu-${{ vars.UBUNTU_RUNNER_VERSION || '24.04' }}
    if: always()
    outputs:
      aggregate_status: ${{ steps.prepare-workflow-data.outputs.aggregate_status }}
    steps:
      # Download build reports from previous steps
      - name: Download build reports
        id: download-artifact
        uses: actions/download-artifact@v4
        with:
          path: /tmp/build-step-reports
          pattern: build-reports-*
          merge-multiple: false
          github-token: ${{ secrets.GITHUB_TOKEN }}
          run-id: ${{ inputs.artifact-run-id }}

      # Prepare the final workflow data report
      - name: Prepare workflow data
        id: prepare-workflow-data
        env:
          PR_TITLE: ${{ github.event.pull_request.title }}
          HEAD_REF: ${{ github.head_ref }}
          HEAD_NAME: ${{ github.event.pull_request.head.ref }}
          HEAD_SHA: ${{ github.event.pull_request.head.sha }}
          HEAD_USER: ${{ github.event.pull_request.head.user.login }}
          BASE_SHA: ${{ github.event.pull_request.base.sha }}
          BASE_USER: ${{ github.event.pull_request.base.user.login }}
          PR_AUTHOR: ${{ github.event.pull_request.user.login }}
          PR_MERGE_STATE: ${{ github.event.pull_request.mergeable_state }}
          GITHUB_REF: ${{ github.ref }}
          NEEDS_DATA: ${{ inputs.needsData }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "NEEDS_DATA=${NEEDS_DATA}"

          # Check for 'cancelled' and 'failure' results from direct dependencies
          cancelled=false
          failure=false

          # Using jq to parse the JSON and check the conditions, with -e option
          if echo "$NEEDS_DATA" | jq -e 'any(.[]; .result == "cancelled")' >/dev/null; then
            cancelled=true
          elif echo "$NEEDS_DATA" | jq -e 'any(.[]; .result == "failure")' >/dev/null; then
            failure=true
          fi

          echo "Direct dependencies - Cancelled: $cancelled, Failure: $failure"

          # Enhanced detection: Check ALL jobs in the current workflow run via GitHub API
          echo "Checking all workflow jobs via GitHub API..."

          # Fetch workflow jobs with error handling
          if workflow_response=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
            "https://api.github.com/repos/${{ github.repository }}/actions/runs/${{ github.run_id }}/jobs" 2>/dev/null); then

            # Parse job information safely using jq to avoid colon parsing issues
            if [[ -n "$workflow_response" ]]; then
              echo "All workflow jobs:"
              echo "$workflow_response" | jq -r '.jobs[]? | "Name: \(.name // "unknown"), Status: \(.status // "unknown"), Conclusion: \(.conclusion // "null")"' 2>/dev/null

              # Check for any cancelled or failed jobs in the entire workflow
              # Use temporary file for broader shell compatibility
              temp_jobs_file=$(mktemp)
              echo "$workflow_response" | jq -c '.jobs[]?' 2>/dev/null > "$temp_jobs_file"

              while read -r job_data; do
                if [[ -z "$job_data" ]]; then continue; fi

                job_name=$(echo "$job_data" | jq -r '.name // "unknown"')
                job_status=$(echo "$job_data" | jq -r '.status // "unknown"')
                job_conclusion=$(echo "$job_data" | jq -r '.conclusion // "null"')

                # Skip the finalize job itself and related jobs to avoid self-reference
                if [[ "$job_name" =~ ^(Finalize|Final Status|.*[Ff]inalize.*)$ ]]; then
                  continue
                fi

                echo "Checking job: $job_name (status: $job_status, conclusion: $job_conclusion)"

                # Only check conclusion for completed jobs (status API is reliable)
                if [[ "$job_status" == "completed" ]]; then
                  # Detect cancelled jobs (only conclusion can be "cancelled")
                  if [[ "$job_conclusion" == "cancelled" ]]; then
                    echo "Found cancelled job: $job_name"
                    cancelled=true
                  fi

                  # Detect failed jobs (conclusion: failure)
                  if [[ "$job_conclusion" == "failure" ]]; then
                    echo "Found failed job: $job_name"
                    failure=true
                  fi
                elif [[ "$job_status" == "in_progress" || "$job_status" == "queued" ]]; then
                  echo "Job $job_name is still running (status: $job_status), will rely on dependency data"
                fi
              done < "$temp_jobs_file"

              # Clean up temporary file
              rm -f "$temp_jobs_file"
            else
              echo "Warning: No job data returned from API, using dependency data only"
            fi
          else
            echo "Warning: Failed to fetch workflow jobs from API, using dependency data only"
          fi

          # Output the final results
          echo "Final status - Cancelled: $cancelled, Failure: $failure"

          AGGREGATE_STATUS="SUCCESS"
          FIRST_FAIL_STEP=""
          FIRST_FAIL_MODULE=""

          echo '{' > workflow-data.json

          EVENT_TYPE="${{ github.event_name }}"

          if [[ "$EVENT_TYPE" == "pull_request" ]]; then
            echo "Creating workflow data for pull request ${PR_TITLE}"
            BRANCH="${HEAD_REF}"
          else
              PR_TITLE="N/A"
              BRANCH="${GITHUB_REF}"

              echo "Creating workflow data for branch ${BRANCH}"
          fi

          BRANCH="${BRANCH##*/}"

          PR_TITLE_JQ=$(jq --arg title "$PR_TITLE" -n '$title')

          echo '"branch": "'$BRANCH'",' >> workflow-data.json
          echo '"run_id": "'${{ github.run_id }}'",' >> workflow-data.json
          echo '"trigger_event_name": "'$GITHUB_EVENT_NAME'",' >> workflow-data.json
          echo '"source_repository": "'$GITHUB_REPOSITORY'",' >> workflow-data.json

          echo '"merge_sha": "'${{ github.sha }}'",' >> workflow-data.json

          echo '"base_sha": "'${BASE_SHA}'",' >> workflow-data.json
          echo '"base_branch": "'${BASE_SHA}'",' >> workflow-data.json
          echo '"base_author": "'${BASE_USER}'",' >> workflow-data.json

          echo '"head_author": "'${HEAD_USER}'",' >> workflow-data.json
          echo '"head_name": "'${HEAD_NAME}'",' >> workflow-data.json
          echo '"head_sha": "'${HEAD_SHA}'",' >> workflow-data.json

          echo '"pr_id": "'${{ github.event.pull_request.id }}'",' >> workflow-data.json
          echo '"pr_number": "'${{ github.event.pull_request.number }}'",' >> workflow-data.json
          echo "\"pr_title\": $PR_TITLE_JQ," >> workflow-data.json
          echo '"pr_author": "'${PR_AUTHOR}'",' >> workflow-data.json
          echo '"pr_merge_state": "'${PR_MERGE_STATE}'",' >> workflow-data.json


          echo '"build_reports": [' >> workflow-data.json
          total_reports=$(find /tmp/build-step-reports/build-reports-*/target -name build-report.json 2>/dev/null | wc -l)

          report_index=0
          if [ "$total_reports" -eq "0" ]; then
            echo "No build report files found."
          else
            for build_report in "/tmp/build-step-reports/build-reports-"*/target/build-report.json; do
              ((report_index=report_index+1))
              step_name=$(basename "$(dirname "$(dirname "$build_report")")" | sed 's/build-reports-//')
              cat "$build_report" | jq ".step_name = \"$step_name\"" >> workflow-data.json
              # If the aggregate status is still SUCCESS, check if this module failed
              if [[ "$AGGREGATE_STATUS" == "SUCCESS" ]]; then
                # Loop over each projectReport
                length=$(jq '.projectReports | length' "$build_report")
                for (( i=0; i<$length; i++ )); do
                status=$(jq -r ".projectReports[$i].status" "$build_report")
                if [[ "$status" == "FAILURE" ]]; then
                  AGGREGATE_STATUS="FAILURE"
                  FIRST_FAIL_STEP="$step_name"
                  FIRST_FAIL_MODULE="$(jq -r ".projectReports[$i].name" "$build_report")"
                  FIRST_FAIL_ERROR="$(jq -r ".projectReports[$i].error" "$build_report")"
                fi
                done
              fi

              # If not the last file, append a comma
              if (( report_index != total_reports )); then
                echo ',' >> workflow-data.json
              fi
            done
          fi

          echo '],' >> workflow-data.json
          if [[ "$AGGREGATE_STATUS" == "SUCCESS" ]]; then
            if [[ "$cancelled" == "true" ]]; then
              echo "Setting cancelled status from job status"
              AGGREGATE_STATUS="CANCELLED"
            elif [[ "$failure" == "true" ]]; then
              echo "Setting failure status from job status"
              AGGREGATE_STATUS="FAILURE"
            fi
          fi
          echo '"aggregate_status": "'$AGGREGATE_STATUS'"' >> workflow-data.json
          if [[ "$AGGREGATE_STATUS" == "FAILURE" ]]; then
            echo ',' >> workflow-data.json
            echo '"first_fail_step": "'$FIRST_FAIL_STEP'",' >> workflow-data.json
            echo '"first_fail_module": "'$FIRST_FAIL_MODULE'",' >> workflow-data.json
            echo '"first_fail_error": "'$FIRST_FAIL_ERROR'"' >> workflow-data.json
          fi
          echo '}' >> workflow-data.json

          echo "aggregate_status=${AGGREGATE_STATUS}" >> $GITHUB_OUTPUT
      # Upload the final workflow data report as an artifact
      - name: Upload workflow data
        uses: actions/upload-artifact@v4
        with:
          name: workflow-data
          path: ./workflow-data.json

  final-status:
    name: Final Status
    needs: prepare-report-data
    if: always()
    runs-on: ubuntu-${{ vars.UBUNTU_RUNNER_VERSION || '24.04' }}
    steps:
      # Check the final status and fail the workflow if not successful
      - name: Check Final Status
        run: |
          if [ "${{ needs.prepare-report-data.outputs.aggregate_status }}" != "SUCCESS" ]; then
            echo "One or more jobs failed or cancelled!"
            exit 1
          fi

      # Check can be removed if we have resolved root cause
      # We cannot use a local github action for this as it is run before we checkout the repo
      # secrets.GITHUB_TOKEN is not available in composite workflows so it needs to be passed in.
      - name: Check API Rate Limit
        shell: bash
        run: |
          curl -s -H "Authorization: token ${{ secrets.GITHUB_TOKEN}}" https://api.github.com/rate_limit || true
