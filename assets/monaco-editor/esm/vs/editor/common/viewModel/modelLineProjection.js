import{LineTokens}from"../tokens/lineTokens.js";import{Position}from"../core/position.js";import{LineInjectedText}from"../textModelEvents.js";import{SingleLineInlineDecoration,ViewLineData}from"../viewModel.js";export function createModelLineProjection(lineBreakData,isVisible){return null===lineBreakData?isVisible?IdentityModelLineProjection.INSTANCE:HiddenModelLineProjection.INSTANCE:new ModelLineProjection(lineBreakData,isVisible)}class ModelLineProjection{constructor(lineBreakData,isVisible){this._projectionData=lineBreakData,this._isVisible=isVisible}isVisible(){return this._isVisible}setVisible(isVisible){return this._isVisible=isVisible,this}getProjectionData(){return this._projectionData}getViewLineCount(){return this._isVisible?this._projectionData.getOutputLineCount():0}getViewLineContent(model,modelLineNumber,outputLineIndex){this._assertVisible();const startOffsetInInputWithInjections=outputLineIndex>0?this._projectionData.breakOffsets[outputLineIndex-1]:0,endOffsetInInputWithInjections=this._projectionData.breakOffsets[outputLineIndex];let r;if(null!==this._projectionData.injectionOffsets){const injectedTexts=this._projectionData.injectionOffsets.map(((offset,idx)=>new LineInjectedText(0,0,offset+1,this._projectionData.injectionOptions[idx],0)));r=LineInjectedText.applyInjectedText(model.getLineContent(modelLineNumber),injectedTexts).substring(startOffsetInInputWithInjections,endOffsetInInputWithInjections)}else r=model.getValueInRange({startLineNumber:modelLineNumber,startColumn:startOffsetInInputWithInjections+1,endLineNumber:modelLineNumber,endColumn:endOffsetInInputWithInjections+1});return outputLineIndex>0&&(r=spaces(this._projectionData.wrappedTextIndentLength)+r),r}getViewLineLength(model,modelLineNumber,outputLineIndex){return this._assertVisible(),this._projectionData.getLineLength(outputLineIndex)}getViewLineMinColumn(_model,_modelLineNumber,outputLineIndex){return this._assertVisible(),this._projectionData.getMinOutputOffset(outputLineIndex)+1}getViewLineMaxColumn(model,modelLineNumber,outputLineIndex){return this._assertVisible(),this._projectionData.getMaxOutputOffset(outputLineIndex)+1}getViewLineData(model,modelLineNumber,outputLineIndex){const arr=new Array;return this.getViewLinesData(model,modelLineNumber,outputLineIndex,1,0,[!0],arr),arr[0]}getViewLinesData(model,modelLineNumber,outputLineIdx,lineCount,globalStartIndex,needed,result){this._assertVisible();const lineBreakData=this._projectionData,injectionOffsets=lineBreakData.injectionOffsets,injectionOptions=lineBreakData.injectionOptions;let lineWithInjections,inlineDecorationsPerOutputLine=null;if(injectionOffsets){inlineDecorationsPerOutputLine=[];let totalInjectedTextLengthBefore=0,currentInjectedOffset=0;for(let outputLineIndex=0;outputLineIndex<lineBreakData.getOutputLineCount();outputLineIndex++){const inlineDecorations=new Array;inlineDecorationsPerOutputLine[outputLineIndex]=inlineDecorations;const lineStartOffsetInInputWithInjections=outputLineIndex>0?lineBreakData.breakOffsets[outputLineIndex-1]:0,lineEndOffsetInInputWithInjections=lineBreakData.breakOffsets[outputLineIndex];for(;currentInjectedOffset<injectionOffsets.length;){const length=injectionOptions[currentInjectedOffset].content.length,injectedTextStartOffsetInInputWithInjections=injectionOffsets[currentInjectedOffset]+totalInjectedTextLengthBefore,injectedTextEndOffsetInInputWithInjections=injectedTextStartOffsetInInputWithInjections+length;if(injectedTextStartOffsetInInputWithInjections>lineEndOffsetInInputWithInjections)break;if(lineStartOffsetInInputWithInjections<injectedTextEndOffsetInInputWithInjections){const options=injectionOptions[currentInjectedOffset];if(options.inlineClassName){const offset=outputLineIndex>0?lineBreakData.wrappedTextIndentLength:0,start=offset+Math.max(injectedTextStartOffsetInInputWithInjections-lineStartOffsetInInputWithInjections,0),end=offset+Math.min(injectedTextEndOffsetInInputWithInjections-lineStartOffsetInInputWithInjections,lineEndOffsetInInputWithInjections);start!==end&&inlineDecorations.push(new SingleLineInlineDecoration(start,end,options.inlineClassName,options.inlineClassNameAffectsLetterSpacing))}}if(!(injectedTextEndOffsetInInputWithInjections<=lineEndOffsetInInputWithInjections))break;totalInjectedTextLengthBefore+=length,currentInjectedOffset++}}}lineWithInjections=injectionOffsets?model.getLineTokens(modelLineNumber).withInserted(injectionOffsets.map(((offset,idx)=>({offset,text:injectionOptions[idx].content,tokenMetadata:LineTokens.defaultTokenMetadata})))):model.getLineTokens(modelLineNumber);for(let outputLineIndex=outputLineIdx;outputLineIndex<outputLineIdx+lineCount;outputLineIndex++){const globalIndex=globalStartIndex+outputLineIndex-outputLineIdx;needed[globalIndex]?result[globalIndex]=this._getViewLineData(lineWithInjections,inlineDecorationsPerOutputLine?inlineDecorationsPerOutputLine[outputLineIndex]:null,outputLineIndex):result[globalIndex]=null}}_getViewLineData(lineWithInjections,inlineDecorations,outputLineIndex){this._assertVisible();const lineBreakData=this._projectionData,deltaStartIndex=outputLineIndex>0?lineBreakData.wrappedTextIndentLength:0,lineStartOffsetInInputWithInjections=outputLineIndex>0?lineBreakData.breakOffsets[outputLineIndex-1]:0,lineEndOffsetInInputWithInjections=lineBreakData.breakOffsets[outputLineIndex],tokens=lineWithInjections.sliceAndInflate(lineStartOffsetInInputWithInjections,lineEndOffsetInInputWithInjections,deltaStartIndex);let lineContent=tokens.getLineContent();outputLineIndex>0&&(lineContent=spaces(lineBreakData.wrappedTextIndentLength)+lineContent);const minColumn=this._projectionData.getMinOutputOffset(outputLineIndex)+1,maxColumn=lineContent.length+1,continuesWithWrappedLine=outputLineIndex+1<this.getViewLineCount(),startVisibleColumn=0===outputLineIndex?0:lineBreakData.breakOffsetsVisibleColumn[outputLineIndex-1];return new ViewLineData(lineContent,continuesWithWrappedLine,minColumn,maxColumn,startVisibleColumn,tokens,inlineDecorations)}getModelColumnOfViewPosition(outputLineIndex,outputColumn){return this._assertVisible(),this._projectionData.translateToInputOffset(outputLineIndex,outputColumn-1)+1}getViewPositionOfModelPosition(deltaLineNumber,inputColumn,affinity=2){this._assertVisible();return this._projectionData.translateToOutputPosition(inputColumn-1,affinity).toPosition(deltaLineNumber)}getViewLineNumberOfModelPosition(deltaLineNumber,inputColumn){this._assertVisible();return deltaLineNumber+this._projectionData.translateToOutputPosition(inputColumn-1).outputLineIndex}normalizePosition(outputLineIndex,outputPosition,affinity){const baseViewLineNumber=outputPosition.lineNumber-outputLineIndex;return this._projectionData.normalizeOutputPosition(outputLineIndex,outputPosition.column-1,affinity).toPosition(baseViewLineNumber)}getInjectedTextAt(outputLineIndex,outputColumn){return this._projectionData.getInjectedText(outputLineIndex,outputColumn-1)}_assertVisible(){if(!this._isVisible)throw new Error("Not supported")}}class IdentityModelLineProjection{constructor(){}isVisible(){return!0}setVisible(isVisible){return isVisible?this:HiddenModelLineProjection.INSTANCE}getProjectionData(){return null}getViewLineCount(){return 1}getViewLineContent(model,modelLineNumber,_outputLineIndex){return model.getLineContent(modelLineNumber)}getViewLineLength(model,modelLineNumber,_outputLineIndex){return model.getLineLength(modelLineNumber)}getViewLineMinColumn(model,modelLineNumber,_outputLineIndex){return model.getLineMinColumn(modelLineNumber)}getViewLineMaxColumn(model,modelLineNumber,_outputLineIndex){return model.getLineMaxColumn(modelLineNumber)}getViewLineData(model,modelLineNumber,_outputLineIndex){const lineTokens=model.getLineTokens(modelLineNumber),lineContent=lineTokens.getLineContent();return new ViewLineData(lineContent,!1,1,lineContent.length+1,0,lineTokens.inflate(),null)}getViewLinesData(model,modelLineNumber,_fromOuputLineIndex,_toOutputLineIndex,globalStartIndex,needed,result){needed[globalStartIndex]?result[globalStartIndex]=this.getViewLineData(model,modelLineNumber,0):result[globalStartIndex]=null}getModelColumnOfViewPosition(_outputLineIndex,outputColumn){return outputColumn}getViewPositionOfModelPosition(deltaLineNumber,inputColumn){return new Position(deltaLineNumber,inputColumn)}getViewLineNumberOfModelPosition(deltaLineNumber,_inputColumn){return deltaLineNumber}normalizePosition(outputLineIndex,outputPosition,affinity){return outputPosition}getInjectedTextAt(_outputLineIndex,_outputColumn){return null}}IdentityModelLineProjection.INSTANCE=new IdentityModelLineProjection;class HiddenModelLineProjection{constructor(){}isVisible(){return!1}setVisible(isVisible){return isVisible?IdentityModelLineProjection.INSTANCE:this}getProjectionData(){return null}getViewLineCount(){return 0}getViewLineContent(_model,_modelLineNumber,_outputLineIndex){throw new Error("Not supported")}getViewLineLength(_model,_modelLineNumber,_outputLineIndex){throw new Error("Not supported")}getViewLineMinColumn(_model,_modelLineNumber,_outputLineIndex){throw new Error("Not supported")}getViewLineMaxColumn(_model,_modelLineNumber,_outputLineIndex){throw new Error("Not supported")}getViewLineData(_model,_modelLineNumber,_outputLineIndex){throw new Error("Not supported")}getViewLinesData(_model,_modelLineNumber,_fromOuputLineIndex,_toOutputLineIndex,_globalStartIndex,_needed,_result){throw new Error("Not supported")}getModelColumnOfViewPosition(_outputLineIndex,_outputColumn){throw new Error("Not supported")}getViewPositionOfModelPosition(_deltaLineNumber,_inputColumn){throw new Error("Not supported")}getViewLineNumberOfModelPosition(_deltaLineNumber,_inputColumn){throw new Error("Not supported")}normalizePosition(outputLineIndex,outputPosition,affinity){throw new Error("Not supported")}getInjectedTextAt(_outputLineIndex,_outputColumn){throw new Error("Not supported")}}HiddenModelLineProjection.INSTANCE=new HiddenModelLineProjection;let _spaces=[""];function spaces(count){if(count>=_spaces.length)for(let i=1;i<=count;i++)_spaces[i]=_makeSpaces(i);return _spaces[count]}function _makeSpaces(count){return new Array(count+1).join(" ")}