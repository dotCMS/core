import*as arrays from"../../../base/common/arrays.js";import{LineTokens}from"./lineTokens.js";export class SparseTokensStore{constructor(languageIdCodec){this._pieces=[],this._isComplete=!1,this._languageIdCodec=languageIdCodec}flush(){this._pieces=[],this._isComplete=!1}isEmpty(){return 0===this._pieces.length}set(pieces,isComplete){this._pieces=pieces||[],this._isComplete=isComplete}setPartial(_range,pieces){let range=_range;if(pieces.length>0){const _firstRange=pieces[0].getRange(),_lastRange=pieces[pieces.length-1].getRange();if(!_firstRange||!_lastRange)return _range;range=_range.plusRange(_firstRange).plusRange(_lastRange)}let insertPosition=null;for(let i=0,len=this._pieces.length;i<len;i++){const piece=this._pieces[i];if(piece.endLineNumber<range.startLineNumber)continue;if(piece.startLineNumber>range.endLineNumber){insertPosition=insertPosition||{index:i};break}if(piece.removeTokens(range),piece.isEmpty()){this._pieces.splice(i,1),i--,len--;continue}if(piece.endLineNumber<range.startLineNumber)continue;if(piece.startLineNumber>range.endLineNumber){insertPosition=insertPosition||{index:i};continue}const[a,b]=piece.split(range);a.isEmpty()?insertPosition=insertPosition||{index:i}:b.isEmpty()||(this._pieces.splice(i,1,a,b),i++,len++,insertPosition=insertPosition||{index:i})}return insertPosition=insertPosition||{index:this._pieces.length},pieces.length>0&&(this._pieces=arrays.arrayInsert(this._pieces,insertPosition.index,pieces)),range}isComplete(){return this._isComplete}addSparseTokens(lineNumber,aTokens){const pieces=this._pieces;if(0===pieces.length)return aTokens;const bTokens=pieces[SparseTokensStore._findFirstPieceWithLine(pieces,lineNumber)].getLineTokens(lineNumber);if(!bTokens)return aTokens;const aLen=aTokens.getCount(),bLen=bTokens.getCount();let aIndex=0;const result=[];let resultLen=0,lastEndOffset=0;const emitToken=(endOffset,metadata)=>{endOffset!==lastEndOffset&&(lastEndOffset=endOffset,result[resultLen++]=endOffset,result[resultLen++]=metadata)};for(let bIndex=0;bIndex<bLen;bIndex++){const bStartCharacter=bTokens.getStartCharacter(bIndex),bEndCharacter=bTokens.getEndCharacter(bIndex),bMetadata=bTokens.getMetadata(bIndex),bMask=((1&bMetadata?1024:0)|(2&bMetadata?2048:0)|(4&bMetadata?4096:0)|(8&bMetadata?8192:0)|(16&bMetadata?8372224:0)|(32&bMetadata?4286578688:0))>>>0,aMask=~bMask>>>0;for(;aIndex<aLen&&aTokens.getEndOffset(aIndex)<=bStartCharacter;)emitToken(aTokens.getEndOffset(aIndex),aTokens.getMetadata(aIndex)),aIndex++;for(aIndex<aLen&&aTokens.getStartOffset(aIndex)<bStartCharacter&&emitToken(bStartCharacter,aTokens.getMetadata(aIndex));aIndex<aLen&&aTokens.getEndOffset(aIndex)<bEndCharacter;)emitToken(aTokens.getEndOffset(aIndex),aTokens.getMetadata(aIndex)&aMask|bMetadata&bMask),aIndex++;if(aIndex<aLen)emitToken(bEndCharacter,aTokens.getMetadata(aIndex)&aMask|bMetadata&bMask),aTokens.getEndOffset(aIndex)===bEndCharacter&&aIndex++;else{const aMergeIndex=Math.min(Math.max(0,aIndex-1),aLen-1);emitToken(bEndCharacter,aTokens.getMetadata(aMergeIndex)&aMask|bMetadata&bMask)}}for(;aIndex<aLen;)emitToken(aTokens.getEndOffset(aIndex),aTokens.getMetadata(aIndex)),aIndex++;return new LineTokens(new Uint32Array(result),aTokens.getLineContent(),this._languageIdCodec)}static _findFirstPieceWithLine(pieces,lineNumber){let low=0,high=pieces.length-1;for(;low<high;){let mid=low+Math.floor((high-low)/2);if(pieces[mid].endLineNumber<lineNumber)low=mid+1;else{if(!(pieces[mid].startLineNumber>lineNumber)){for(;mid>low&&pieces[mid-1].startLineNumber<=lineNumber&&lineNumber<=pieces[mid-1].endLineNumber;)mid--;return mid}high=mid-1}}return low}acceptEdit(range,eolCount,firstLineLength,lastLineLength,firstCharCode){for(const piece of this._pieces)piece.acceptEdit(range,eolCount,firstLineLength,lastLineLength,firstCharCode)}}