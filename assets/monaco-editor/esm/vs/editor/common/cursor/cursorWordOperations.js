import*as strings from"../../../base/common/strings.js";import{SingleCursorState}from"../cursorCommon.js";import{DeleteOperations}from"./cursorDeleteOperations.js";import{getMapForWordSeparators}from"../core/wordCharacterClassifier.js";import{Position}from"../core/position.js";import{Range}from"../core/range.js";export class WordOperations{static _createWord(lineContent,wordType,nextCharClass,start,end){return{start,end,wordType,nextCharClass}}static _findPreviousWordOnLine(wordSeparators,model,position){const lineContent=model.getLineContent(position.lineNumber);return this._doFindPreviousWordOnLine(lineContent,wordSeparators,position)}static _doFindPreviousWordOnLine(lineContent,wordSeparators,position){let wordType=0;for(let chIndex=position.column-2;chIndex>=0;chIndex--){const chCode=lineContent.charCodeAt(chIndex),chClass=wordSeparators.get(chCode);if(0===chClass){if(2===wordType)return this._createWord(lineContent,wordType,chClass,chIndex+1,this._findEndOfWord(lineContent,wordSeparators,wordType,chIndex+1));wordType=1}else if(2===chClass){if(1===wordType)return this._createWord(lineContent,wordType,chClass,chIndex+1,this._findEndOfWord(lineContent,wordSeparators,wordType,chIndex+1));wordType=2}else if(1===chClass&&0!==wordType)return this._createWord(lineContent,wordType,chClass,chIndex+1,this._findEndOfWord(lineContent,wordSeparators,wordType,chIndex+1))}return 0!==wordType?this._createWord(lineContent,wordType,1,0,this._findEndOfWord(lineContent,wordSeparators,wordType,0)):null}static _findEndOfWord(lineContent,wordSeparators,wordType,startIndex){const len=lineContent.length;for(let chIndex=startIndex;chIndex<len;chIndex++){const chCode=lineContent.charCodeAt(chIndex),chClass=wordSeparators.get(chCode);if(1===chClass)return chIndex;if(1===wordType&&2===chClass)return chIndex;if(2===wordType&&0===chClass)return chIndex}return len}static _findNextWordOnLine(wordSeparators,model,position){const lineContent=model.getLineContent(position.lineNumber);return this._doFindNextWordOnLine(lineContent,wordSeparators,position)}static _doFindNextWordOnLine(lineContent,wordSeparators,position){let wordType=0;const len=lineContent.length;for(let chIndex=position.column-1;chIndex<len;chIndex++){const chCode=lineContent.charCodeAt(chIndex),chClass=wordSeparators.get(chCode);if(0===chClass){if(2===wordType)return this._createWord(lineContent,wordType,chClass,this._findStartOfWord(lineContent,wordSeparators,wordType,chIndex-1),chIndex);wordType=1}else if(2===chClass){if(1===wordType)return this._createWord(lineContent,wordType,chClass,this._findStartOfWord(lineContent,wordSeparators,wordType,chIndex-1),chIndex);wordType=2}else if(1===chClass&&0!==wordType)return this._createWord(lineContent,wordType,chClass,this._findStartOfWord(lineContent,wordSeparators,wordType,chIndex-1),chIndex)}return 0!==wordType?this._createWord(lineContent,wordType,1,this._findStartOfWord(lineContent,wordSeparators,wordType,len-1),len):null}static _findStartOfWord(lineContent,wordSeparators,wordType,startIndex){for(let chIndex=startIndex;chIndex>=0;chIndex--){const chCode=lineContent.charCodeAt(chIndex),chClass=wordSeparators.get(chCode);if(1===chClass)return chIndex+1;if(1===wordType&&2===chClass)return chIndex+1;if(2===wordType&&0===chClass)return chIndex+1}return 0}static moveWordLeft(wordSeparators,model,position,wordNavigationType){let lineNumber=position.lineNumber,column=position.column;1===column&&lineNumber>1&&(lineNumber-=1,column=model.getLineMaxColumn(lineNumber));let prevWordOnLine=WordOperations._findPreviousWordOnLine(wordSeparators,model,new Position(lineNumber,column));if(0===wordNavigationType)return new Position(lineNumber,prevWordOnLine?prevWordOnLine.start+1:1);if(1===wordNavigationType)return prevWordOnLine&&2===prevWordOnLine.wordType&&prevWordOnLine.end-prevWordOnLine.start==1&&0===prevWordOnLine.nextCharClass&&(prevWordOnLine=WordOperations._findPreviousWordOnLine(wordSeparators,model,new Position(lineNumber,prevWordOnLine.start+1))),new Position(lineNumber,prevWordOnLine?prevWordOnLine.start+1:1);if(3===wordNavigationType){for(;prevWordOnLine&&2===prevWordOnLine.wordType;)prevWordOnLine=WordOperations._findPreviousWordOnLine(wordSeparators,model,new Position(lineNumber,prevWordOnLine.start+1));return new Position(lineNumber,prevWordOnLine?prevWordOnLine.start+1:1)}return prevWordOnLine&&column<=prevWordOnLine.end+1&&(prevWordOnLine=WordOperations._findPreviousWordOnLine(wordSeparators,model,new Position(lineNumber,prevWordOnLine.start+1))),new Position(lineNumber,prevWordOnLine?prevWordOnLine.end+1:1)}static _moveWordPartLeft(model,position){const lineNumber=position.lineNumber,maxColumn=model.getLineMaxColumn(lineNumber);if(1===position.column)return lineNumber>1?new Position(lineNumber-1,model.getLineMaxColumn(lineNumber-1)):position;const lineContent=model.getLineContent(lineNumber);for(let column=position.column-1;column>1;column--){const left=lineContent.charCodeAt(column-2),right=lineContent.charCodeAt(column-1);if(95===left&&95!==right)return new Position(lineNumber,column);if(strings.isLowerAsciiLetter(left)&&strings.isUpperAsciiLetter(right))return new Position(lineNumber,column);if(strings.isUpperAsciiLetter(left)&&strings.isUpperAsciiLetter(right)&&column+1<maxColumn){const rightRight=lineContent.charCodeAt(column);if(strings.isLowerAsciiLetter(rightRight))return new Position(lineNumber,column)}}return new Position(lineNumber,1)}static moveWordRight(wordSeparators,model,position,wordNavigationType){let lineNumber=position.lineNumber,column=position.column,movedDown=!1;column===model.getLineMaxColumn(lineNumber)&&lineNumber<model.getLineCount()&&(movedDown=!0,lineNumber+=1,column=1);let nextWordOnLine=WordOperations._findNextWordOnLine(wordSeparators,model,new Position(lineNumber,column));if(2===wordNavigationType)nextWordOnLine&&2===nextWordOnLine.wordType&&nextWordOnLine.end-nextWordOnLine.start==1&&0===nextWordOnLine.nextCharClass&&(nextWordOnLine=WordOperations._findNextWordOnLine(wordSeparators,model,new Position(lineNumber,nextWordOnLine.end+1))),column=nextWordOnLine?nextWordOnLine.end+1:model.getLineMaxColumn(lineNumber);else if(3===wordNavigationType){for(movedDown&&(column=0);nextWordOnLine&&(2===nextWordOnLine.wordType||nextWordOnLine.start+1<=column);)nextWordOnLine=WordOperations._findNextWordOnLine(wordSeparators,model,new Position(lineNumber,nextWordOnLine.end+1));column=nextWordOnLine?nextWordOnLine.start+1:model.getLineMaxColumn(lineNumber)}else nextWordOnLine&&!movedDown&&column>=nextWordOnLine.start+1&&(nextWordOnLine=WordOperations._findNextWordOnLine(wordSeparators,model,new Position(lineNumber,nextWordOnLine.end+1))),column=nextWordOnLine?nextWordOnLine.start+1:model.getLineMaxColumn(lineNumber);return new Position(lineNumber,column)}static _moveWordPartRight(model,position){const lineNumber=position.lineNumber,maxColumn=model.getLineMaxColumn(lineNumber);if(position.column===maxColumn)return lineNumber<model.getLineCount()?new Position(lineNumber+1,1):position;const lineContent=model.getLineContent(lineNumber);for(let column=position.column+1;column<maxColumn;column++){const left=lineContent.charCodeAt(column-2),right=lineContent.charCodeAt(column-1);if(95!==left&&95===right)return new Position(lineNumber,column);if(strings.isLowerAsciiLetter(left)&&strings.isUpperAsciiLetter(right))return new Position(lineNumber,column);if(strings.isUpperAsciiLetter(left)&&strings.isUpperAsciiLetter(right)&&column+1<maxColumn){const rightRight=lineContent.charCodeAt(column);if(strings.isLowerAsciiLetter(rightRight))return new Position(lineNumber,column)}}return new Position(lineNumber,maxColumn)}static _deleteWordLeftWhitespace(model,position){const lineContent=model.getLineContent(position.lineNumber),startIndex=position.column-2,lastNonWhitespace=strings.lastNonWhitespaceIndex(lineContent,startIndex);return lastNonWhitespace+1<startIndex?new Range(position.lineNumber,lastNonWhitespace+2,position.lineNumber,position.column):null}static deleteWordLeft(ctx,wordNavigationType){const wordSeparators=ctx.wordSeparators,model=ctx.model,selection=ctx.selection,whitespaceHeuristics=ctx.whitespaceHeuristics;if(!selection.isEmpty())return selection;if(DeleteOperations.isAutoClosingPairDelete(ctx.autoClosingDelete,ctx.autoClosingBrackets,ctx.autoClosingQuotes,ctx.autoClosingPairs.autoClosingPairsOpenByEnd,ctx.model,[ctx.selection],ctx.autoClosedCharacters)){const position=ctx.selection.getPosition();return new Range(position.lineNumber,position.column-1,position.lineNumber,position.column+1)}const position=new Position(selection.positionLineNumber,selection.positionColumn);let lineNumber=position.lineNumber,column=position.column;if(1===lineNumber&&1===column)return null;if(whitespaceHeuristics){const r=this._deleteWordLeftWhitespace(model,position);if(r)return r}let prevWordOnLine=WordOperations._findPreviousWordOnLine(wordSeparators,model,position);return 0===wordNavigationType?prevWordOnLine?column=prevWordOnLine.start+1:column>1?column=1:(lineNumber--,column=model.getLineMaxColumn(lineNumber)):(prevWordOnLine&&column<=prevWordOnLine.end+1&&(prevWordOnLine=WordOperations._findPreviousWordOnLine(wordSeparators,model,new Position(lineNumber,prevWordOnLine.start+1))),prevWordOnLine?column=prevWordOnLine.end+1:column>1?column=1:(lineNumber--,column=model.getLineMaxColumn(lineNumber))),new Range(lineNumber,column,position.lineNumber,position.column)}static deleteInsideWord(wordSeparators,model,selection){if(!selection.isEmpty())return selection;const position=new Position(selection.positionLineNumber,selection.positionColumn),r=this._deleteInsideWordWhitespace(model,position);return r||this._deleteInsideWordDetermineDeleteRange(wordSeparators,model,position)}static _charAtIsWhitespace(str,index){const charCode=str.charCodeAt(index);return 32===charCode||9===charCode}static _deleteInsideWordWhitespace(model,position){const lineContent=model.getLineContent(position.lineNumber),lineContentLength=lineContent.length;if(0===lineContentLength)return null;let leftIndex=Math.max(position.column-2,0);if(!this._charAtIsWhitespace(lineContent,leftIndex))return null;let rightIndex=Math.min(position.column-1,lineContentLength-1);if(!this._charAtIsWhitespace(lineContent,rightIndex))return null;for(;leftIndex>0&&this._charAtIsWhitespace(lineContent,leftIndex-1);)leftIndex--;for(;rightIndex+1<lineContentLength&&this._charAtIsWhitespace(lineContent,rightIndex+1);)rightIndex++;return new Range(position.lineNumber,leftIndex+1,position.lineNumber,rightIndex+2)}static _deleteInsideWordDetermineDeleteRange(wordSeparators,model,position){const lineContent=model.getLineContent(position.lineNumber),lineLength=lineContent.length;if(0===lineLength)return position.lineNumber>1?new Range(position.lineNumber-1,model.getLineMaxColumn(position.lineNumber-1),position.lineNumber,1):position.lineNumber<model.getLineCount()?new Range(position.lineNumber,1,position.lineNumber+1,1):new Range(position.lineNumber,1,position.lineNumber,1);const touchesWord=word=>word.start+1<=position.column&&position.column<=word.end+1,createRangeWithPosition=(startColumn,endColumn)=>(startColumn=Math.min(startColumn,position.column),endColumn=Math.max(endColumn,position.column),new Range(position.lineNumber,startColumn,position.lineNumber,endColumn)),deleteWordAndAdjacentWhitespace=word=>{let startColumn=word.start+1,endColumn=word.end+1,expandedToTheRight=!1;for(;endColumn-1<lineLength&&this._charAtIsWhitespace(lineContent,endColumn-1);)expandedToTheRight=!0,endColumn++;if(!expandedToTheRight)for(;startColumn>1&&this._charAtIsWhitespace(lineContent,startColumn-2);)startColumn--;return createRangeWithPosition(startColumn,endColumn)},prevWordOnLine=WordOperations._findPreviousWordOnLine(wordSeparators,model,position);if(prevWordOnLine&&touchesWord(prevWordOnLine))return deleteWordAndAdjacentWhitespace(prevWordOnLine);const nextWordOnLine=WordOperations._findNextWordOnLine(wordSeparators,model,position);return nextWordOnLine&&touchesWord(nextWordOnLine)?deleteWordAndAdjacentWhitespace(nextWordOnLine):prevWordOnLine&&nextWordOnLine?createRangeWithPosition(prevWordOnLine.end+1,nextWordOnLine.start+1):prevWordOnLine?createRangeWithPosition(prevWordOnLine.start+1,prevWordOnLine.end+1):nextWordOnLine?createRangeWithPosition(nextWordOnLine.start+1,nextWordOnLine.end+1):createRangeWithPosition(1,lineLength+1)}static _deleteWordPartLeft(model,selection){if(!selection.isEmpty())return selection;const pos=selection.getPosition(),toPosition=WordOperations._moveWordPartLeft(model,pos);return new Range(pos.lineNumber,pos.column,toPosition.lineNumber,toPosition.column)}static _findFirstNonWhitespaceChar(str,startIndex){const len=str.length;for(let chIndex=startIndex;chIndex<len;chIndex++){const ch=str.charAt(chIndex);if(" "!==ch&&"\t"!==ch)return chIndex}return len}static _deleteWordRightWhitespace(model,position){const lineContent=model.getLineContent(position.lineNumber),startIndex=position.column-1,firstNonWhitespace=this._findFirstNonWhitespaceChar(lineContent,startIndex);return startIndex+1<firstNonWhitespace?new Range(position.lineNumber,position.column,position.lineNumber,firstNonWhitespace+1):null}static deleteWordRight(ctx,wordNavigationType){const wordSeparators=ctx.wordSeparators,model=ctx.model,selection=ctx.selection,whitespaceHeuristics=ctx.whitespaceHeuristics;if(!selection.isEmpty())return selection;const position=new Position(selection.positionLineNumber,selection.positionColumn);let lineNumber=position.lineNumber,column=position.column;const lineCount=model.getLineCount(),maxColumn=model.getLineMaxColumn(lineNumber);if(lineNumber===lineCount&&column===maxColumn)return null;if(whitespaceHeuristics){const r=this._deleteWordRightWhitespace(model,position);if(r)return r}let nextWordOnLine=WordOperations._findNextWordOnLine(wordSeparators,model,position);return 2===wordNavigationType?nextWordOnLine?column=nextWordOnLine.end+1:column<maxColumn||lineNumber===lineCount?column=maxColumn:(lineNumber++,nextWordOnLine=WordOperations._findNextWordOnLine(wordSeparators,model,new Position(lineNumber,1)),column=nextWordOnLine?nextWordOnLine.start+1:model.getLineMaxColumn(lineNumber)):(nextWordOnLine&&column>=nextWordOnLine.start+1&&(nextWordOnLine=WordOperations._findNextWordOnLine(wordSeparators,model,new Position(lineNumber,nextWordOnLine.end+1))),nextWordOnLine?column=nextWordOnLine.start+1:column<maxColumn||lineNumber===lineCount?column=maxColumn:(lineNumber++,nextWordOnLine=WordOperations._findNextWordOnLine(wordSeparators,model,new Position(lineNumber,1)),column=nextWordOnLine?nextWordOnLine.start+1:model.getLineMaxColumn(lineNumber))),new Range(lineNumber,column,position.lineNumber,position.column)}static _deleteWordPartRight(model,selection){if(!selection.isEmpty())return selection;const pos=selection.getPosition(),toPosition=WordOperations._moveWordPartRight(model,pos);return new Range(pos.lineNumber,pos.column,toPosition.lineNumber,toPosition.column)}static _createWordAtPosition(model,lineNumber,word){const range=new Range(lineNumber,word.start+1,lineNumber,word.end+1);return{word:model.getValueInRange(range),startColumn:range.startColumn,endColumn:range.endColumn}}static getWordAtPosition(model,_wordSeparators,position){const wordSeparators=getMapForWordSeparators(_wordSeparators),prevWord=WordOperations._findPreviousWordOnLine(wordSeparators,model,position);if(prevWord&&1===prevWord.wordType&&prevWord.start<=position.column-1&&position.column-1<=prevWord.end)return WordOperations._createWordAtPosition(model,position.lineNumber,prevWord);const nextWord=WordOperations._findNextWordOnLine(wordSeparators,model,position);return nextWord&&1===nextWord.wordType&&nextWord.start<=position.column-1&&position.column-1<=nextWord.end?WordOperations._createWordAtPosition(model,position.lineNumber,nextWord):null}static word(config,model,cursor,inSelectionMode,position){const wordSeparators=getMapForWordSeparators(config.wordSeparators),prevWord=WordOperations._findPreviousWordOnLine(wordSeparators,model,position),nextWord=WordOperations._findNextWordOnLine(wordSeparators,model,position);if(!inSelectionMode){let startColumn,endColumn;return prevWord&&1===prevWord.wordType&&prevWord.start<=position.column-1&&position.column-1<=prevWord.end?(startColumn=prevWord.start+1,endColumn=prevWord.end+1):nextWord&&1===nextWord.wordType&&nextWord.start<=position.column-1&&position.column-1<=nextWord.end?(startColumn=nextWord.start+1,endColumn=nextWord.end+1):(startColumn=prevWord?prevWord.end+1:1,endColumn=nextWord?nextWord.start+1:model.getLineMaxColumn(position.lineNumber)),new SingleCursorState(new Range(position.lineNumber,startColumn,position.lineNumber,endColumn),0,new Position(position.lineNumber,endColumn),0)}let startColumn,endColumn;prevWord&&1===prevWord.wordType&&prevWord.start<position.column-1&&position.column-1<prevWord.end?(startColumn=prevWord.start+1,endColumn=prevWord.end+1):nextWord&&1===nextWord.wordType&&nextWord.start<position.column-1&&position.column-1<nextWord.end?(startColumn=nextWord.start+1,endColumn=nextWord.end+1):(startColumn=position.column,endColumn=position.column);const lineNumber=position.lineNumber;let column;if(cursor.selectionStart.containsPosition(position))column=cursor.selectionStart.endColumn;else if(position.isBeforeOrEqual(cursor.selectionStart.getStartPosition())){column=startColumn;const possiblePosition=new Position(lineNumber,column);cursor.selectionStart.containsPosition(possiblePosition)&&(column=cursor.selectionStart.endColumn)}else{column=endColumn;const possiblePosition=new Position(lineNumber,column);cursor.selectionStart.containsPosition(possiblePosition)&&(column=cursor.selectionStart.startColumn)}return cursor.move(!0,lineNumber,column,0)}}export class WordPartOperations extends WordOperations{static deleteWordPartLeft(ctx){const candidates=enforceDefined([WordOperations.deleteWordLeft(ctx,0),WordOperations.deleteWordLeft(ctx,2),WordOperations._deleteWordPartLeft(ctx.model,ctx.selection)]);return candidates.sort(Range.compareRangesUsingEnds),candidates[2]}static deleteWordPartRight(ctx){const candidates=enforceDefined([WordOperations.deleteWordRight(ctx,0),WordOperations.deleteWordRight(ctx,2),WordOperations._deleteWordPartRight(ctx.model,ctx.selection)]);return candidates.sort(Range.compareRangesUsingStarts),candidates[0]}static moveWordPartLeft(wordSeparators,model,position){const candidates=enforceDefined([WordOperations.moveWordLeft(wordSeparators,model,position,0),WordOperations.moveWordLeft(wordSeparators,model,position,2),WordOperations._moveWordPartLeft(model,position)]);return candidates.sort(Position.compare),candidates[2]}static moveWordPartRight(wordSeparators,model,position){const candidates=enforceDefined([WordOperations.moveWordRight(wordSeparators,model,position,0),WordOperations.moveWordRight(wordSeparators,model,position,2),WordOperations._moveWordPartRight(model,position)]);return candidates.sort(Position.compare),candidates[0]}}function enforceDefined(arr){return arr.filter((el=>Boolean(el)))}