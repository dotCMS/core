import{onUnexpectedExternalError}from"../../../../base/common/errors.js";import{DisposableStore}from"../../../../base/common/lifecycle.js";import{FoldingRegions,MAX_LINE_NUMBER}from"./foldingRanges.js";const foldingContext={};export const ID_SYNTAX_PROVIDER="syntax";export class SyntaxRangeProvider{constructor(editorModel,providers,handleFoldingRangesChange,limit){this.editorModel=editorModel,this.providers=providers,this.limit=limit,this.id="syntax";for(const provider of providers)"function"==typeof provider.onDidChange&&(this.disposables||(this.disposables=new DisposableStore),this.disposables.add(provider.onDidChange(handleFoldingRangesChange)))}compute(cancellationToken,notifyTooManyRegions){return collectSyntaxRanges(this.providers,this.editorModel,cancellationToken).then((ranges=>{if(ranges){return sanitizeRanges(ranges,this.limit,notifyTooManyRegions)}return null}))}dispose(){var _a;null===(_a=this.disposables)||void 0===_a||_a.dispose()}}function collectSyntaxRanges(providers,model,cancellationToken){let rangeData=null,promises=providers.map(((provider,i)=>Promise.resolve(provider.provideFoldingRanges(model,foldingContext,cancellationToken)).then((ranges=>{if(!cancellationToken.isCancellationRequested&&Array.isArray(ranges)){Array.isArray(rangeData)||(rangeData=[]);let nLines=model.getLineCount();for(let r of ranges)r.start>0&&r.end>r.start&&r.end<=nLines&&rangeData.push({start:r.start,end:r.end,rank:i,kind:r.kind})}}),onUnexpectedExternalError)));return Promise.all(promises).then((_=>rangeData))}export class RangesCollector{constructor(foldingRangesLimit,_notifyTooManyRegions){this._notifyTooManyRegions=_notifyTooManyRegions,this._startIndexes=[],this._endIndexes=[],this._nestingLevels=[],this._nestingLevelCounts=[],this._types=[],this._length=0,this._foldingRangesLimit=foldingRangesLimit}add(startLineNumber,endLineNumber,type,nestingLevel){if(startLineNumber>MAX_LINE_NUMBER||endLineNumber>MAX_LINE_NUMBER)return;let index=this._length;this._startIndexes[index]=startLineNumber,this._endIndexes[index]=endLineNumber,this._nestingLevels[index]=nestingLevel,this._types[index]=type,this._length++,nestingLevel<30&&(this._nestingLevelCounts[nestingLevel]=(this._nestingLevelCounts[nestingLevel]||0)+1)}toIndentRanges(){if(this._length<=this._foldingRangesLimit){let startIndexes=new Uint32Array(this._length),endIndexes=new Uint32Array(this._length);for(let i=0;i<this._length;i++)startIndexes[i]=this._startIndexes[i],endIndexes[i]=this._endIndexes[i];return new FoldingRegions(startIndexes,endIndexes,this._types)}{this._notifyTooManyRegions&&this._notifyTooManyRegions(this._foldingRangesLimit);let entries=0,maxLevel=this._nestingLevelCounts.length;for(let i=0;i<this._nestingLevelCounts.length;i++){let n=this._nestingLevelCounts[i];if(n){if(n+entries>this._foldingRangesLimit){maxLevel=i;break}entries+=n}}let startIndexes=new Uint32Array(this._foldingRangesLimit),endIndexes=new Uint32Array(this._foldingRangesLimit),types=[];for(let i=0,k=0;i<this._length;i++){let level=this._nestingLevels[i];(level<maxLevel||level===maxLevel&&entries++<this._foldingRangesLimit)&&(startIndexes[k]=this._startIndexes[i],endIndexes[k]=this._endIndexes[i],types[k]=this._types[i],k++)}return new FoldingRegions(startIndexes,endIndexes,types)}}}export function sanitizeRanges(rangeData,limit,notifyTooManyRegions){let top,sorted=rangeData.sort(((d1,d2)=>{let diff=d1.start-d2.start;return 0===diff&&(diff=d1.rank-d2.rank),diff})),collector=new RangesCollector(limit,notifyTooManyRegions),previous=[];for(let entry of sorted)if(top){if(entry.start>top.start)if(entry.end<=top.end)previous.push(top),top=entry,collector.add(entry.start,entry.end,entry.kind&&entry.kind.value,previous.length);else{if(entry.start>top.end){do{top=previous.pop()}while(top&&entry.start>top.end);top&&previous.push(top),top=entry}collector.add(entry.start,entry.end,entry.kind&&entry.kind.value,previous.length)}}else top=entry,collector.add(entry.start,entry.end,entry.kind&&entry.kind.value,previous.length);return collector.toIndentRanges()}