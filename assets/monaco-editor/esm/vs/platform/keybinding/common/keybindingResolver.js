import{implies,expressionsAreEqualWithConstantSubstitution}from"../../contextkey/common/contextkey.js";export class KeybindingResolver{constructor(defaultKeybindings,overrides,log){this._log=log,this._defaultKeybindings=defaultKeybindings,this._defaultBoundCommands=new Map;for(const defaultKeybinding of defaultKeybindings){const command=defaultKeybinding.command;command&&"-"!==command.charAt(0)&&this._defaultBoundCommands.set(command,!0)}this._map=new Map,this._lookupMap=new Map,this._keybindings=KeybindingResolver.handleRemovals([].concat(defaultKeybindings).concat(overrides));for(let i=0,len=this._keybindings.length;i<len;i++){let k=this._keybindings[i];0!==k.keypressParts.length&&(k.when&&0===k.when.type||this._addKeyPress(k.keypressParts[0],k))}}static _isTargetedForRemoval(defaultKb,keypressFirstPart,keypressChordPart,when){if(keypressFirstPart&&defaultKb.keypressParts[0]!==keypressFirstPart)return!1;if(keypressChordPart&&defaultKb.keypressParts[1]!==keypressChordPart)return!1;if(when){if(!defaultKb.when)return!1;if(!expressionsAreEqualWithConstantSubstitution(when,defaultKb.when))return!1}return!0}static handleRemovals(rules){const removals=new Map;for(let i=0,len=rules.length;i<len;i++){const rule=rules[i];if(rule.command&&"-"===rule.command.charAt(0)){const command=rule.command.substring(1);removals.has(command)?removals.get(command).push(rule):removals.set(command,[rule])}}if(0===removals.size)return rules;const result=[];for(let i=0,len=rules.length;i<len;i++){const rule=rules[i];if(!rule.command||0===rule.command.length){result.push(rule);continue}if("-"===rule.command.charAt(0))continue;const commandRemovals=removals.get(rule.command);if(!commandRemovals||!rule.isDefault){result.push(rule);continue}let isRemoved=!1;for(const commandRemoval of commandRemovals){const keypressFirstPart=commandRemoval.keypressParts[0],keypressChordPart=commandRemoval.keypressParts[1],when=commandRemoval.when;if(this._isTargetedForRemoval(rule,keypressFirstPart,keypressChordPart,when)){isRemoved=!0;break}}isRemoved||result.push(rule)}return result}_addKeyPress(keypress,item){const conflicts=this._map.get(keypress);if(void 0===conflicts)return this._map.set(keypress,[item]),void this._addToLookupMap(item);for(let i=conflicts.length-1;i>=0;i--){let conflict=conflicts[i];if(conflict.command===item.command)continue;const conflictIsChord=conflict.keypressParts.length>1,itemIsChord=item.keypressParts.length>1;conflictIsChord&&itemIsChord&&conflict.keypressParts[1]!==item.keypressParts[1]||KeybindingResolver.whenIsEntirelyIncluded(conflict.when,item.when)&&this._removeFromLookupMap(conflict)}conflicts.push(item),this._addToLookupMap(item)}_addToLookupMap(item){if(!item.command)return;let arr=this._lookupMap.get(item.command);void 0===arr?(arr=[item],this._lookupMap.set(item.command,arr)):arr.push(item)}_removeFromLookupMap(item){if(!item.command)return;let arr=this._lookupMap.get(item.command);if(void 0!==arr)for(let i=0,len=arr.length;i<len;i++)if(arr[i]===item)return void arr.splice(i,1)}static whenIsEntirelyIncluded(a,b){return!b||1===b.type||!(!a||1===a.type)&&implies(a,b)}getKeybindings(){return this._keybindings}lookupPrimaryKeybinding(commandId,context){const items=this._lookupMap.get(commandId);if(void 0===items||0===items.length)return null;if(1===items.length)return items[0];for(let i=items.length-1;i>=0;i--){const item=items[i];if(context.contextMatchesRules(item.when))return item}return items[items.length-1]}resolve(context,currentChord,keypress){this._log(`| Resolving ${keypress}${currentChord?` chorded from ${currentChord}`:""}`);let lookupMap=null;if(null!==currentChord){const candidates=this._map.get(currentChord);if(void 0===candidates)return this._log("\\ No keybinding entries."),null;lookupMap=[];for(let i=0,len=candidates.length;i<len;i++){let candidate=candidates[i];candidate.keypressParts[1]===keypress&&lookupMap.push(candidate)}}else{const candidates=this._map.get(keypress);if(void 0===candidates)return this._log("\\ No keybinding entries."),null;lookupMap=candidates}let result=this._findCommand(context,lookupMap);return result?null===currentChord&&result.keypressParts.length>1&&null!==result.keypressParts[1]?(this._log(`\\ From ${lookupMap.length} keybinding entries, matched chord, when: ${printWhenExplanation(result.when)}, source: ${printSourceExplanation(result)}.`),{enterChord:!0,leaveChord:!1,commandId:null,commandArgs:null,bubble:!1}):(this._log(`\\ From ${lookupMap.length} keybinding entries, matched ${result.command}, when: ${printWhenExplanation(result.when)}, source: ${printSourceExplanation(result)}.`),{enterChord:!1,leaveChord:result.keypressParts.length>1,commandId:result.command,commandArgs:result.commandArgs,bubble:result.bubble}):(this._log(`\\ From ${lookupMap.length} keybinding entries, no when clauses matched the context.`),null)}_findCommand(context,matches){for(let i=matches.length-1;i>=0;i--){let k=matches[i];if(KeybindingResolver._contextMatchesRules(context,k.when))return k}return null}static _contextMatchesRules(context,rules){return!rules||rules.evaluate(context)}}function printWhenExplanation(when){return when?`${when.serialize()}`:"no when condition"}function printSourceExplanation(kb){return kb.extensionId?kb.isBuiltinExtension?`built-in extension ${kb.extensionId}`:`user extension ${kb.extensionId}`:kb.isDefault?"built-in":"user"}