export class Node{constructor(data){this.incoming=new Map,this.outgoing=new Map,this.data=data}}export class Graph{constructor(_hashFn){this._hashFn=_hashFn,this._nodes=new Map}roots(){const ret=[];for(let node of this._nodes.values())0===node.outgoing.size&&ret.push(node);return ret}insertEdge(from,to){const fromNode=this.lookupOrInsertNode(from),toNode=this.lookupOrInsertNode(to);fromNode.outgoing.set(this._hashFn(to),toNode),toNode.incoming.set(this._hashFn(from),fromNode)}removeNode(data){const key=this._hashFn(data);this._nodes.delete(key);for(let node of this._nodes.values())node.outgoing.delete(key),node.incoming.delete(key)}lookupOrInsertNode(data){const key=this._hashFn(data);let node=this._nodes.get(key);return node||(node=new Node(data),this._nodes.set(key,node)),node}isEmpty(){return 0===this._nodes.size}toString(){let data=[];for(let[key,value]of this._nodes)data.push(`${key}, (incoming)[${[...value.incoming.keys()].join(", ")}], (outgoing)[${[...value.outgoing.keys()].join(",")}]`);return data.join("\n")}findCycleSlow(){for(let[id,node]of this._nodes){const seen=new Set([id]),res=this._findCycle(node,seen);if(res)return res}}_findCycle(node,seen){for(let[id,outgoing]of node.outgoing){if(seen.has(id))return[...seen,id].join(" -> ");seen.add(id);const value=this._findCycle(outgoing,seen);if(value)return value;seen.delete(id)}}}