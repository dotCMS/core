import{isArray,isObject,isUndefinedOrNull}from"./types.js";export function deepClone(obj){if(!obj||"object"!=typeof obj)return obj;if(obj instanceof RegExp)return obj;const result=Array.isArray(obj)?[]:{};return Object.keys(obj).forEach((key=>{obj[key]&&"object"==typeof obj[key]?result[key]=deepClone(obj[key]):result[key]=obj[key]})),result}export function deepFreeze(obj){if(!obj||"object"!=typeof obj)return obj;const stack=[obj];for(;stack.length>0;){const obj=stack.shift();Object.freeze(obj);for(const key in obj)if(_hasOwnProperty.call(obj,key)){const prop=obj[key];"object"!=typeof prop||Object.isFrozen(prop)||stack.push(prop)}}return obj}const _hasOwnProperty=Object.prototype.hasOwnProperty;export function cloneAndChange(obj,changer){return _cloneAndChange(obj,changer,new Set)}function _cloneAndChange(obj,changer,seen){if(isUndefinedOrNull(obj))return obj;const changed=changer(obj);if(void 0!==changed)return changed;if(isArray(obj)){const r1=[];for(const e of obj)r1.push(_cloneAndChange(e,changer,seen));return r1}if(isObject(obj)){if(seen.has(obj))throw new Error("Cannot clone recursive data-structure");seen.add(obj);const r2={};for(let i2 in obj)_hasOwnProperty.call(obj,i2)&&(r2[i2]=_cloneAndChange(obj[i2],changer,seen));return seen.delete(obj),r2}return obj}export function mixin(destination,source,overwrite=!0){return isObject(destination)?(isObject(source)&&Object.keys(source).forEach((key=>{key in destination?overwrite&&(isObject(destination[key])&&isObject(source[key])?mixin(destination[key],source[key],overwrite):destination[key]=source[key]):destination[key]=source[key]})),destination):source}export function equals(one,other){if(one===other)return!0;if(null==one||null==other)return!1;if(typeof one!=typeof other)return!1;if("object"!=typeof one)return!1;if(Array.isArray(one)!==Array.isArray(other))return!1;let i,key;if(Array.isArray(one)){if(one.length!==other.length)return!1;for(i=0;i<one.length;i++)if(!equals(one[i],other[i]))return!1}else{const oneKeys=[];for(key in one)oneKeys.push(key);oneKeys.sort();const otherKeys=[];for(key in other)otherKeys.push(key);if(otherKeys.sort(),!equals(oneKeys,otherKeys))return!1;for(i=0;i<oneKeys.length;i++)if(!equals(one[oneKeys[i]],other[oneKeys[i]]))return!1}return!0}export function getOrDefault(obj,fn,defaultValue){const result=fn(obj);return void 0===result?defaultValue:result}