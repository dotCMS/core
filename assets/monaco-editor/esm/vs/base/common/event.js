import{onUnexpectedError}from"./errors.js";import{combinedDisposable,Disposable,DisposableStore,SafeDisposable,toDisposable}from"./lifecycle.js";import{LinkedList}from"./linkedList.js";import{StopWatch}from"./stopwatch.js";let _enableDisposeWithListenerWarning=!1,_enableSnapshotPotentialLeakWarning=!1;export var Event;!function(Event){function _addLeakageTraceLogic(options){if(_enableSnapshotPotentialLeakWarning){const{onListenerDidAdd:origListenerDidAdd}=options,stack=Stacktrace.create();let count=0;options.onListenerDidAdd=()=>{2==++count&&(console.warn("snapshotted emitter LIKELY used public and SHOULD HAVE BEEN created with DisposableStore. snapshotted here"),stack.print()),null==origListenerDidAdd||origListenerDidAdd()}}}function once(event){return(listener,thisArgs=null,disposables)=>{let result,didFire=!1;return result=event((e=>{if(!didFire)return result?result.dispose():didFire=!0,listener.call(thisArgs,e)}),null,disposables),didFire&&result.dispose(),result}}function map(event,map,disposable){return snapshot(((listener,thisArgs=null,disposables)=>event((i=>listener.call(thisArgs,map(i))),null,disposables)),disposable)}function forEach(event,each,disposable){return snapshot(((listener,thisArgs=null,disposables)=>event((i=>{each(i),listener.call(thisArgs,i)}),null,disposables)),disposable)}function filter(event,filter,disposable){return snapshot(((listener,thisArgs=null,disposables)=>event((e=>filter(e)&&listener.call(thisArgs,e)),null,disposables)),disposable)}function reduce(event,merge,initial,disposable){let output=initial;return map(event,(e=>(output=merge(output,e),output)),disposable)}function snapshot(event,disposable){let listener;const options={onFirstListenerAdd(){listener=event(emitter.fire,emitter)},onLastListenerRemove(){listener.dispose()}};disposable||_addLeakageTraceLogic(options);const emitter=new Emitter(options);return disposable&&disposable.add(emitter),emitter.event}function debounce(event,merge,delay=100,leading=!1,leakWarningThreshold,disposable){let subscription,output,handle,numDebouncedCalls=0;const options={leakWarningThreshold,onFirstListenerAdd(){subscription=event((cur=>{numDebouncedCalls++,output=merge(output,cur),leading&&!handle&&(emitter.fire(output),output=void 0),clearTimeout(handle),handle=setTimeout((()=>{const _output=output;output=void 0,handle=void 0,(!leading||numDebouncedCalls>1)&&emitter.fire(_output),numDebouncedCalls=0}),delay)}))},onLastListenerRemove(){subscription.dispose()}};disposable||_addLeakageTraceLogic(options);const emitter=new Emitter(options);return disposable&&disposable.add(emitter),emitter.event}function latch(event,equals=((a,b)=>a===b),disposable){let cache,firstCall=!0;return filter(event,(value=>{const shouldEmit=firstCall||!equals(value,cache);return firstCall=!1,cache=value,shouldEmit}),disposable)}Event.None=()=>Disposable.None,Event.once=once,Event.map=map,Event.forEach=forEach,Event.filter=filter,Event.signal=function signal(event){return event},Event.any=function any(...events){return(listener,thisArgs=null,disposables)=>combinedDisposable(...events.map((event=>event((e=>listener.call(thisArgs,e)),null,disposables))))},Event.reduce=reduce,Event.debounce=debounce,Event.latch=latch,Event.split=function split(event,isT,disposable){return[Event.filter(event,isT,disposable),Event.filter(event,(e=>!isT(e)),disposable)]},Event.buffer=function buffer(event,flushAfterTimeout=!1,_buffer=[]){let buffer=_buffer.slice(),listener=event((e=>{buffer?buffer.push(e):emitter.fire(e)}));const flush=()=>{buffer&&buffer.forEach((e=>emitter.fire(e))),buffer=null},emitter=new Emitter({onFirstListenerAdd(){listener||(listener=event((e=>emitter.fire(e))))},onFirstListenerDidAdd(){buffer&&(flushAfterTimeout?setTimeout(flush):flush())},onLastListenerRemove(){listener&&listener.dispose(),listener=null}});return emitter.event};class ChainableEvent{constructor(event){this.event=event}map(fn){return new ChainableEvent(map(this.event,fn))}forEach(fn){return new ChainableEvent(forEach(this.event,fn))}filter(fn){return new ChainableEvent(filter(this.event,fn))}reduce(merge,initial){return new ChainableEvent(reduce(this.event,merge,initial))}latch(){return new ChainableEvent(latch(this.event))}debounce(merge,delay=100,leading=!1,leakWarningThreshold){return new ChainableEvent(debounce(this.event,merge,delay,leading,leakWarningThreshold))}on(listener,thisArgs,disposables){return this.event(listener,thisArgs,disposables)}once(listener,thisArgs,disposables){return once(this.event)(listener,thisArgs,disposables)}}Event.chain=function chain(event){return new ChainableEvent(event)},Event.fromNodeEventEmitter=function fromNodeEventEmitter(emitter,eventName,map=(id=>id)){const fn=(...args)=>result.fire(map(...args)),result=new Emitter({onFirstListenerAdd:()=>emitter.on(eventName,fn),onLastListenerRemove:()=>emitter.removeListener(eventName,fn)});return result.event},Event.fromDOMEventEmitter=function fromDOMEventEmitter(emitter,eventName,map=(id=>id)){const fn=(...args)=>result.fire(map(...args)),result=new Emitter({onFirstListenerAdd:()=>emitter.addEventListener(eventName,fn),onLastListenerRemove:()=>emitter.removeEventListener(eventName,fn)});return result.event},Event.toPromise=function toPromise(event){return new Promise((resolve=>once(event)(resolve)))},Event.runAndSubscribe=function runAndSubscribe(event,handler){return handler(void 0),event((e=>handler(e)))},Event.runAndSubscribeWithStore=function runAndSubscribeWithStore(event,handler){let store=null;function run(e){null==store||store.dispose(),store=new DisposableStore,handler(e,store)}run(void 0);const disposable=event((e=>run(e)));return toDisposable((()=>{disposable.dispose(),null==store||store.dispose()}))}}(Event||(Event={}));class EventProfiling{constructor(name){this._listenerCount=0,this._invocationCount=0,this._elapsedOverall=0,this._name=`${name}_${EventProfiling._idPool++}`}start(listenerCount){this._stopWatch=new StopWatch(!0),this._listenerCount=listenerCount}stop(){if(this._stopWatch){const elapsed=this._stopWatch.elapsed();this._elapsedOverall+=elapsed,this._invocationCount+=1,console.info(`did FIRE ${this._name}: elapsed_ms: ${elapsed.toFixed(5)}, listener: ${this._listenerCount} (elapsed_overall: ${this._elapsedOverall.toFixed(2)}, invocations: ${this._invocationCount})`),this._stopWatch=void 0}}}EventProfiling._idPool=0;let _globalLeakWarningThreshold=-1;class LeakageMonitor{constructor(customThreshold,name=Math.random().toString(18).slice(2,5)){this.customThreshold=customThreshold,this.name=name,this._warnCountdown=0}dispose(){this._stacks&&this._stacks.clear()}check(stack,listenerCount){let threshold=_globalLeakWarningThreshold;if("number"==typeof this.customThreshold&&(threshold=this.customThreshold),threshold<=0||listenerCount<threshold)return;this._stacks||(this._stacks=new Map);const count=this._stacks.get(stack.value)||0;if(this._stacks.set(stack.value,count+1),this._warnCountdown-=1,this._warnCountdown<=0){let topStack;this._warnCountdown=.5*threshold;let topCount=0;for(const[stack,count]of this._stacks)(!topStack||topCount<count)&&(topStack=stack,topCount=count);console.warn(`[${this.name}] potential listener LEAK detected, having ${listenerCount} listeners already. MOST frequent listener (${topCount}):`),console.warn(topStack)}return()=>{const count=this._stacks.get(stack.value)||0;this._stacks.set(stack.value,count-1)}}}class Stacktrace{constructor(value){this.value=value}static create(){var _a;return new Stacktrace(null!==(_a=(new Error).stack)&&void 0!==_a?_a:"")}print(){console.warn(this.value.split("\n").slice(2).join("\n"))}}class Listener{constructor(callback,callbackThis,stack){this.callback=callback,this.callbackThis=callbackThis,this.stack=stack,this.subscription=new SafeDisposable}invoke(e){this.callback.call(this.callbackThis,e)}}export class Emitter{constructor(options){var _a;this._disposed=!1,this._options=options,this._leakageMon=_globalLeakWarningThreshold>0?new LeakageMonitor(this._options&&this._options.leakWarningThreshold):void 0,this._perfMon=(null===(_a=this._options)||void 0===_a?void 0:_a._profName)?new EventProfiling(this._options._profName):void 0}dispose(){var _a,_b,_c,_d;if(!this._disposed){if(this._disposed=!0,this._listeners){if(_enableDisposeWithListenerWarning){const listeners=Array.from(this._listeners);queueMicrotask((()=>{var _a;for(const listener of listeners)listener.subscription.isset()&&(listener.subscription.unset(),null===(_a=listener.stack)||void 0===_a||_a.print())}))}this._listeners.clear()}null===(_a=this._deliveryQueue)||void 0===_a||_a.clear(),null===(_c=null===(_b=this._options)||void 0===_b?void 0:_b.onLastListenerRemove)||void 0===_c||_c.call(_b),null===(_d=this._leakageMon)||void 0===_d||_d.dispose()}}get event(){return this._event||(this._event=(callback,thisArgs,disposables)=>{var _a,_b,_c;this._listeners||(this._listeners=new LinkedList);const firstListener=this._listeners.isEmpty();let removeMonitor,stack;firstListener&&(null===(_a=this._options)||void 0===_a?void 0:_a.onFirstListenerAdd)&&this._options.onFirstListenerAdd(this),this._leakageMon&&this._listeners.size>=30&&(stack=Stacktrace.create(),removeMonitor=this._leakageMon.check(stack,this._listeners.size+1)),_enableDisposeWithListenerWarning&&(stack=null!=stack?stack:Stacktrace.create());const listener=new Listener(callback,thisArgs,stack),removeListener=this._listeners.push(listener);firstListener&&(null===(_b=this._options)||void 0===_b?void 0:_b.onFirstListenerDidAdd)&&this._options.onFirstListenerDidAdd(this),(null===(_c=this._options)||void 0===_c?void 0:_c.onListenerDidAdd)&&this._options.onListenerDidAdd(this,callback,thisArgs);const result=listener.subscription.set((()=>{if(removeMonitor&&removeMonitor(),!this._disposed&&(removeListener(),this._options&&this._options.onLastListenerRemove)){this._listeners&&!this._listeners.isEmpty()||this._options.onLastListenerRemove(this)}}));return disposables instanceof DisposableStore?disposables.add(result):Array.isArray(disposables)&&disposables.push(result),result}),this._event}fire(event){var _a,_b;if(this._listeners){this._deliveryQueue||(this._deliveryQueue=new LinkedList);for(let listener of this._listeners)this._deliveryQueue.push([listener,event]);for(null===(_a=this._perfMon)||void 0===_a||_a.start(this._deliveryQueue.size);this._deliveryQueue.size>0;){const[listener,event]=this._deliveryQueue.shift();try{listener.invoke(event)}catch(e){onUnexpectedError(e)}}null===(_b=this._perfMon)||void 0===_b||_b.stop()}}}export class PauseableEmitter extends Emitter{constructor(options){super(options),this._isPaused=0,this._eventQueue=new LinkedList,this._mergeFn=null==options?void 0:options.merge}pause(){this._isPaused++}resume(){if(0!==this._isPaused&&0==--this._isPaused)if(this._mergeFn){const events=Array.from(this._eventQueue);this._eventQueue.clear(),super.fire(this._mergeFn(events))}else for(;!this._isPaused&&0!==this._eventQueue.size;)super.fire(this._eventQueue.shift())}fire(event){this._listeners&&(0!==this._isPaused?this._eventQueue.push(event):super.fire(event))}}export class DebounceEmitter extends PauseableEmitter{constructor(options){var _a;super(options),this._delay=null!==(_a=options.delay)&&void 0!==_a?_a:100}fire(event){this._handle||(this.pause(),this._handle=setTimeout((()=>{this._handle=void 0,this.resume()}),this._delay)),super.fire(event)}}export class EventBufferer{constructor(){this.buffers=[]}wrapEvent(event){return(listener,thisArgs,disposables)=>event((i=>{const buffer=this.buffers[this.buffers.length-1];buffer?buffer.push((()=>listener.call(thisArgs,i))):listener.call(thisArgs,i)}),void 0,disposables)}bufferEvents(fn){const buffer=[];this.buffers.push(buffer);const r=fn();return this.buffers.pop(),buffer.forEach((flush=>flush())),r}}export class Relay{constructor(){this.listening=!1,this.inputEvent=Event.None,this.inputEventListener=Disposable.None,this.emitter=new Emitter({onFirstListenerDidAdd:()=>{this.listening=!0,this.inputEventListener=this.inputEvent(this.emitter.fire,this.emitter)},onLastListenerRemove:()=>{this.listening=!1,this.inputEventListener.dispose()}}),this.event=this.emitter.event}set input(event){this.inputEvent=event,this.listening&&(this.inputEventListener.dispose(),this.inputEventListener=event(this.emitter.fire,this.emitter))}dispose(){this.inputEventListener.dispose(),this.emitter.dispose()}}