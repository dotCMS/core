import{isThenable}from"./async.js";import{isEqualOrParent}from"./extpath.js";import{LRUCache}from"./map.js";import{basename,extname,posix,sep}from"./path.js";import{isLinux}from"./platform.js";import{escapeRegExpCharacters}from"./strings.js";export const GLOBSTAR="**";export const GLOB_SPLIT="/";const PATH_REGEX="[/\\\\]",NO_PATH_REGEX="[^/\\\\]",ALL_FORWARD_SLASHES=/\//g;function starsToRegExp(starCount){switch(starCount){case 0:return"";case 1:return`${NO_PATH_REGEX}*?`;default:return`(?:${PATH_REGEX}|${NO_PATH_REGEX}+${PATH_REGEX}|${PATH_REGEX}${NO_PATH_REGEX}+)*?`}}export function splitGlobAware(pattern,splitChar){if(!pattern)return[];const segments=[];let inBraces=!1,inBrackets=!1,curVal="";for(const char of pattern){switch(char){case splitChar:if(!inBraces&&!inBrackets){segments.push(curVal),curVal="";continue}break;case"{":inBraces=!0;break;case"}":inBraces=!1;break;case"[":inBrackets=!0;break;case"]":inBrackets=!1}curVal+=char}return curVal&&segments.push(curVal),segments}function parseRegExp(pattern){if(!pattern)return"";let regEx="";const segments=splitGlobAware(pattern,GLOB_SPLIT);if(segments.every((s=>s===GLOBSTAR)))regEx=".*";else{let previousSegmentWasGlobStar=!1;segments.forEach(((segment,index)=>{if(segment===GLOBSTAR)return void(previousSegmentWasGlobStar||(regEx+=starsToRegExp(2),previousSegmentWasGlobStar=!0));let inBraces=!1,braceVal="",inBrackets=!1,bracketVal="";for(const char of segment)if("}"!==char&&inBraces)braceVal+=char;else if(!inBrackets||"]"===char&&bracketVal)switch(char){case"{":inBraces=!0;continue;case"[":inBrackets=!0;continue;case"}":{const braceRegExp=`(?:${splitGlobAware(braceVal,",").map((c=>parseRegExp(c))).join("|")})`;regEx+=braceRegExp,inBraces=!1,braceVal="";break}case"]":regEx+="["+bracketVal+"]",inBrackets=!1,bracketVal="";break;case"?":regEx+=NO_PATH_REGEX;continue;case"*":regEx+=starsToRegExp(1);continue;default:regEx+=escapeRegExpCharacters(char)}else{let res;res="-"===char?char:"^"!==char&&"!"!==char||bracketVal?char===GLOB_SPLIT?"":escapeRegExpCharacters(char):"^",bracketVal+=res}index<segments.length-1&&(segments[index+1]!==GLOBSTAR||index+2<segments.length)&&(regEx+=PATH_REGEX),previousSegmentWasGlobStar=!1}))}return regEx}const T1=/^\*\*\/\*\.[\w\.-]+$/,T2=/^\*\*\/([\w\.-]+)\/?$/,T3=/^{\*\*\/\*?[\w\.-]+\/?(,\*\*\/\*?[\w\.-]+\/?)*}$/,T3_2=/^{\*\*\/\*?[\w\.-]+(\/(\*\*)?)?(,\*\*\/\*?[\w\.-]+(\/(\*\*)?)?)*}$/,T4=/^\*\*((\/[\w\.-]+)+)\/?$/,T5=/^([\w\.-]+(\/[\w\.-]+)*)\/?$/,CACHE=new LRUCache(1e4),FALSE=function(){return!1},NULL=function(){return null};function parsePattern(arg1,options){if(!arg1)return NULL;let pattern;pattern="string"!=typeof arg1?arg1.pattern:arg1,pattern=pattern.trim();const patternKey=`${pattern}_${!!options.trimForExclusions}`;let match,parsedPattern=CACHE.get(patternKey);if(parsedPattern)return wrapRelativePattern(parsedPattern,arg1);if(T1.test(pattern)){const base=pattern.substr(4);parsedPattern=function(path,basename){return"string"==typeof path&&path.endsWith(base)?pattern:null}}else parsedPattern=(match=T2.exec(trimForExclusions(pattern,options)))?trivia2(match[1],pattern):(options.trimForExclusions?T3_2:T3).test(pattern)?trivia3(pattern,options):(match=T4.exec(trimForExclusions(pattern,options)))?trivia4and5(match[1].substr(1),pattern,!0):(match=T5.exec(trimForExclusions(pattern,options)))?trivia4and5(match[1],pattern,!1):toRegExp(pattern);return CACHE.set(patternKey,parsedPattern),wrapRelativePattern(parsedPattern,arg1)}function wrapRelativePattern(parsedPattern,arg2){return"string"==typeof arg2?parsedPattern:function(path,basename){return isEqualOrParent(path,arg2.base,!isLinux)?parsedPattern(path.substr(arg2.base.length+1),basename):null}}function trimForExclusions(pattern,options){return options.trimForExclusions&&pattern.endsWith("/**")?pattern.substr(0,pattern.length-2):pattern}function trivia2(base,originalPattern){const slashBase=`/${base}`,backslashBase=`\\${base}`,parsedPattern=function(path,basename){return"string"!=typeof path?null:basename?basename===base?originalPattern:null:path===base||path.endsWith(slashBase)||path.endsWith(backslashBase)?originalPattern:null},basenames=[base];return parsedPattern.basenames=basenames,parsedPattern.patterns=[originalPattern],parsedPattern.allBasenames=basenames,parsedPattern}function trivia3(pattern,options){const parsedPatterns=aggregateBasenameMatches(pattern.slice(1,-1).split(",").map((pattern=>parsePattern(pattern,options))).filter((pattern=>pattern!==NULL)),pattern),n=parsedPatterns.length;if(!n)return NULL;if(1===n)return parsedPatterns[0];const parsedPattern=function(path,basename){for(let i=0,n=parsedPatterns.length;i<n;i++)if(parsedPatterns[i](path,basename))return pattern;return null},withBasenames=parsedPatterns.find((pattern=>!!pattern.allBasenames));withBasenames&&(parsedPattern.allBasenames=withBasenames.allBasenames);const allPaths=parsedPatterns.reduce(((all,current)=>current.allPaths?all.concat(current.allPaths):all),[]);return allPaths.length&&(parsedPattern.allPaths=allPaths),parsedPattern}function trivia4and5(targetPath,pattern,matchPathEnds){const usingPosixSep=sep===posix.sep,nativePath=usingPosixSep?targetPath:targetPath.replace(ALL_FORWARD_SLASHES,sep),nativePathEnd=sep+nativePath,targetPathEnd=posix.sep+targetPath,parsedPattern=matchPathEnds?function(testPath,basename){return"string"!=typeof testPath||testPath!==nativePath&&!testPath.endsWith(nativePathEnd)&&(usingPosixSep||testPath!==targetPath&&!testPath.endsWith(targetPathEnd))?null:pattern}:function(testPath,basename){return"string"!=typeof testPath||testPath!==nativePath&&(usingPosixSep||testPath!==targetPath)?null:pattern};return parsedPattern.allPaths=[(matchPathEnds?"*/":"./")+targetPath],parsedPattern}function toRegExp(pattern){try{const regExp=new RegExp(`^${parseRegExp(pattern)}$`);return function(path){return regExp.lastIndex=0,"string"==typeof path&&regExp.test(path)?pattern:null}}catch(error){return NULL}}export function match(arg1,path,hasSibling){return!(!arg1||"string"!=typeof path)&&parse(arg1)(path,void 0,hasSibling)}export function parse(arg1,options={}){if(!arg1)return FALSE;if("string"==typeof arg1||isRelativePattern(arg1)){const parsedPattern=parsePattern(arg1,options);if(parsedPattern===NULL)return FALSE;const resultPattern=function(path,basename){return!!parsedPattern(path,basename)};return parsedPattern.allBasenames&&(resultPattern.allBasenames=parsedPattern.allBasenames),parsedPattern.allPaths&&(resultPattern.allPaths=parsedPattern.allPaths),resultPattern}return parsedExpression(arg1,options)}export function isRelativePattern(obj){const rp=obj;return!!rp&&("string"==typeof rp.base&&"string"==typeof rp.pattern)}function parsedExpression(expression,options){const parsedPatterns=aggregateBasenameMatches(Object.getOwnPropertyNames(expression).map((pattern=>parseExpressionPattern(pattern,expression[pattern],options))).filter((pattern=>pattern!==NULL))),n=parsedPatterns.length;if(!n)return NULL;if(!parsedPatterns.some((parsedPattern=>!!parsedPattern.requiresSiblings))){if(1===n)return parsedPatterns[0];const resultExpression=function(path,basename){for(let i=0,n=parsedPatterns.length;i<n;i++){const result=parsedPatterns[i](path,basename);if(result)return result}return null},withBasenames=parsedPatterns.find((pattern=>!!pattern.allBasenames));withBasenames&&(resultExpression.allBasenames=withBasenames.allBasenames);const allPaths=parsedPatterns.reduce(((all,current)=>current.allPaths?all.concat(current.allPaths):all),[]);return allPaths.length&&(resultExpression.allPaths=allPaths),resultExpression}const resultExpression=function(path,base,hasSibling){let name;for(let i=0,n=parsedPatterns.length;i<n;i++){const parsedPattern=parsedPatterns[i];parsedPattern.requiresSiblings&&hasSibling&&(base||(base=basename(path)),name||(name=base.substr(0,base.length-extname(path).length)));const result=parsedPattern(path,base,name,hasSibling);if(result)return result}return null},withBasenames=parsedPatterns.find((pattern=>!!pattern.allBasenames));withBasenames&&(resultExpression.allBasenames=withBasenames.allBasenames);const allPaths=parsedPatterns.reduce(((all,current)=>current.allPaths?all.concat(current.allPaths):all),[]);return allPaths.length&&(resultExpression.allPaths=allPaths),resultExpression}function parseExpressionPattern(pattern,value,options){if(!1===value)return NULL;const parsedPattern=parsePattern(pattern,options);if(parsedPattern===NULL)return NULL;if("boolean"==typeof value)return parsedPattern;if(value){const when=value.when;if("string"==typeof when){const result=(path,basename,name,hasSibling)=>{if(!hasSibling||!parsedPattern(path,basename))return null;const matched=hasSibling(when.replace("$(basename)",name));return isThenable(matched)?matched.then((m=>m?pattern:null)):matched?pattern:null};return result.requiresSiblings=!0,result}}return parsedPattern}function aggregateBasenameMatches(parsedPatterns,result){const basenamePatterns=parsedPatterns.filter((parsedPattern=>!!parsedPattern.basenames));if(basenamePatterns.length<2)return parsedPatterns;const basenames=basenamePatterns.reduce(((all,current)=>{const basenames=current.basenames;return basenames?all.concat(basenames):all}),[]);let patterns;if(result){patterns=[];for(let i=0,n=basenames.length;i<n;i++)patterns.push(result)}else patterns=basenamePatterns.reduce(((all,current)=>{const patterns=current.patterns;return patterns?all.concat(patterns):all}),[]);const aggregate=function(path,basename){if("string"!=typeof path)return null;if(!basename){let i;for(i=path.length;i>0;i--){const ch=path.charCodeAt(i-1);if(47===ch||92===ch)break}basename=path.substr(i)}const index=basenames.indexOf(basename);return-1!==index?patterns[index]:null};aggregate.basenames=basenames,aggregate.patterns=patterns,aggregate.allBasenames=basenames;const aggregatedPatterns=parsedPatterns.filter((parsedPattern=>!parsedPattern.basenames));return aggregatedPatterns.push(aggregate),aggregatedPatterns}