export function tail(array,n=0){return array[array.length-(1+n)]}export function tail2(arr){if(0===arr.length)throw new Error("Invalid tail call");return[arr.slice(0,arr.length-1),arr[arr.length-1]]}export function equals(one,other,itemEquals=((a,b)=>a===b)){if(one===other)return!0;if(!one||!other)return!1;if(one.length!==other.length)return!1;for(let i=0,len=one.length;i<len;i++)if(!itemEquals(one[i],other[i]))return!1;return!0}export function binarySearch(array,key,comparator){let low=0,high=array.length-1;for(;low<=high;){const mid=(low+high)/2|0,comp=comparator(array[mid],key);if(comp<0)low=mid+1;else{if(!(comp>0))return mid;high=mid-1}}return-(low+1)}export function findFirstInSorted(array,p){let low=0,high=array.length;if(0===high)return 0;for(;low<high;){const mid=Math.floor((low+high)/2);p(array[mid])?high=mid:low=mid+1}return low}export function quickSelect(nth,data,compare){if((nth|=0)>=data.length)throw new TypeError("invalid index");let pivotValue=data[Math.floor(data.length*Math.random())],lower=[],higher=[],pivots=[];for(let value of data){const val=compare(value,pivotValue);val<0?lower.push(value):val>0?higher.push(value):pivots.push(value)}return nth<lower.length?quickSelect(nth,lower,compare):nth<lower.length+pivots.length?pivots[0]:quickSelect(nth-(lower.length+pivots.length),higher,compare)}export function groupBy(data,compare){const result=[];let currentGroup;for(const element of data.slice(0).sort(compare))currentGroup&&0===compare(currentGroup[0],element)?currentGroup.push(element):(currentGroup=[element],result.push(currentGroup));return result}export function coalesce(array){return array.filter((e=>!!e))}export function isFalsyOrEmpty(obj){return!Array.isArray(obj)||0===obj.length}export function isNonEmptyArray(obj){return Array.isArray(obj)&&obj.length>0}export function distinct(array,keyFn=(value=>value)){const seen=new Set;return array.filter((element=>{const key=keyFn(element);return!seen.has(key)&&(seen.add(key),!0)}))}export function findLast(arr,predicate){const idx=lastIndex(arr,predicate);if(-1!==idx)return arr[idx]}export function lastIndex(array,fn){for(let i=array.length-1;i>=0;i--){if(fn(array[i]))return i}return-1}export function firstOrDefault(array,notFoundValue){return array.length>0?array[0]:notFoundValue}export function flatten(arr){return[].concat(...arr)}export function range(arg,to){let from="number"==typeof to?arg:0;"number"==typeof to?from=arg:(from=0,to=arg);const result=[];if(from<=to)for(let i=from;i<to;i++)result.push(i);else for(let i=from;i>to;i--)result.push(i);return result}export function arrayInsert(target,insertIndex,insertArr){const before=target.slice(0,insertIndex),after=target.slice(insertIndex);return before.concat(insertArr,after)}export function pushToStart(arr,value){const index=arr.indexOf(value);index>-1&&(arr.splice(index,1),arr.unshift(value))}export function pushToEnd(arr,value){const index=arr.indexOf(value);index>-1&&(arr.splice(index,1),arr.push(value))}export function asArray(x){return Array.isArray(x)?x:[x]}export function insertInto(array,start,newItems){const startIdx=getActualStartIndex(array,start),originalLength=array.length,newItemsLength=newItems.length;array.length=originalLength+newItemsLength;for(let i=originalLength-1;i>=startIdx;i--)array[i+newItemsLength]=array[i];for(let i=0;i<newItemsLength;i++)array[i+startIdx]=newItems[i]}export function splice(array,start,deleteCount,newItems){const index=getActualStartIndex(array,start),result=array.splice(index,deleteCount);return insertInto(array,index,newItems),result}function getActualStartIndex(array,start){return start<0?Math.max(start+array.length,0):Math.min(start,array.length)}export function compareBy(selector,comparator){return(a,b)=>comparator(selector(a),selector(b))}export const numberComparator=(a,b)=>a-b;export function findMaxBy(items,comparator){if(0===items.length)return;let max=items[0];for(let i=1;i<items.length;i++){const item=items[i];comparator(item,max)>0&&(max=item)}return max}export function findLastMaxBy(items,comparator){if(0===items.length)return;let max=items[0];for(let i=1;i<items.length;i++){const item=items[i];comparator(item,max)>=0&&(max=item)}return max}export function findMinBy(items,comparator){return findMaxBy(items,((a,b)=>-comparator(a,b)))}export class ArrayQueue{constructor(items){this.items=items,this.firstIdx=0,this.lastIdx=this.items.length-1}takeWhile(predicate){let startIdx=this.firstIdx;for(;startIdx<this.items.length&&predicate(this.items[startIdx]);)startIdx++;const result=startIdx===this.firstIdx?null:this.items.slice(this.firstIdx,startIdx);return this.firstIdx=startIdx,result}takeFromEndWhile(predicate){let endIdx=this.lastIdx;for(;endIdx>=0&&predicate(this.items[endIdx]);)endIdx--;const result=endIdx===this.lastIdx?null:this.items.slice(endIdx+1,this.lastIdx+1);return this.lastIdx=endIdx,result}peek(){return this.items[this.firstIdx]}dequeue(){const result=this.items[this.firstIdx];return this.firstIdx++,result}takeCount(count){const result=this.items.slice(this.firstIdx,this.firstIdx+count);return this.firstIdx+=count,result}}