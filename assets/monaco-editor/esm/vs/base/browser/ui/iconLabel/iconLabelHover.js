var __awaiter=this&&this.__awaiter||function(thisArg,_arguments,P,generator){return new(P||(P=Promise))((function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator.throw(value))}catch(e){reject(e)}}function step(result){result.done?resolve(result.value):function adopt(value){return value instanceof P?value:new P((function(resolve){resolve(value)}))}(result.value).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())}))};import*as dom from"../../dom.js";import{TimeoutTimer}from"../../../common/async.js";import{CancellationTokenSource}from"../../../common/cancellation.js";import{isMarkdownString}from"../../../common/htmlContent.js";import{stripIcons}from"../../../common/iconLabels.js";import{DisposableStore}from"../../../common/lifecycle.js";import{isFunction,isString}from"../../../common/types.js";import{localize}from"../../../../nls.js";export function setupNativeHover(htmlElement,tooltip){isString(tooltip)?htmlElement.title=stripIcons(tooltip):(null==tooltip?void 0:tooltip.markdownNotSupportedFallback)?htmlElement.title=tooltip.markdownNotSupportedFallback:htmlElement.removeAttribute("title")}class UpdatableHoverWidget{constructor(hoverDelegate,target,fadeInAnimation){this.hoverDelegate=hoverDelegate,this.target=target,this.fadeInAnimation=fadeInAnimation}update(content,focus){var _a;return __awaiter(this,void 0,void 0,(function*(){if(this._cancellationTokenSource&&(this._cancellationTokenSource.dispose(!0),this._cancellationTokenSource=void 0),this.isDisposed)return;let resolvedContent;if(void 0===content||isString(content)||content instanceof HTMLElement)resolvedContent=content;else if(isFunction(content.markdown)){this._hoverWidget||this.show(localize("iconLabel.loading","Loading..."),focus),this._cancellationTokenSource=new CancellationTokenSource;const token=this._cancellationTokenSource.token;if(resolvedContent=yield content.markdown(token),void 0===resolvedContent&&(resolvedContent=content.markdownNotSupportedFallback),this.isDisposed||token.isCancellationRequested)return}else resolvedContent=null!==(_a=content.markdown)&&void 0!==_a?_a:content.markdownNotSupportedFallback;this.show(resolvedContent,focus)}))}show(content,focus){const oldHoverWidget=this._hoverWidget;if(this.hasContent(content)){const hoverOptions={content,target:this.target,showPointer:"element"===this.hoverDelegate.placement,hoverPosition:2,skipFadeInAnimation:!this.fadeInAnimation||!!oldHoverWidget};this._hoverWidget=this.hoverDelegate.showHover(hoverOptions,focus)}null==oldHoverWidget||oldHoverWidget.dispose()}hasContent(content){return!!content&&(!isMarkdownString(content)||!!content.value)}get isDisposed(){var _a;return null===(_a=this._hoverWidget)||void 0===_a?void 0:_a.isDisposed}dispose(){var _a,_b;null===(_a=this._hoverWidget)||void 0===_a||_a.dispose(),null===(_b=this._cancellationTokenSource)||void 0===_b||_b.dispose(!0),this._cancellationTokenSource=void 0}}export function setupCustomHover(hoverDelegate,htmlElement,content){let hoverPreparation,hoverWidget;const hideHover=(disposeWidget,disposePreparation)=>{var _a;disposeWidget&&(null==hoverWidget||hoverWidget.dispose(),hoverWidget=void 0),disposePreparation&&(null==hoverPreparation||hoverPreparation.dispose(),hoverPreparation=void 0),null===(_a=hoverDelegate.onDidHideHover)||void 0===_a||_a.call(hoverDelegate)},triggerShowHover=(delay,focus,target)=>new TimeoutTimer((()=>__awaiter(this,void 0,void 0,(function*(){hoverWidget&&!hoverWidget.isDisposed||(hoverWidget=new UpdatableHoverWidget(hoverDelegate,target||htmlElement,delay>0),yield hoverWidget.update(content,focus))}))),delay),mouseOverDomEmitter=dom.addDisposableListener(htmlElement,dom.EventType.MOUSE_OVER,(()=>{if(hoverPreparation)return;const toDispose=new DisposableStore;toDispose.add(dom.addDisposableListener(htmlElement,dom.EventType.MOUSE_LEAVE,(e=>hideHover(!1,e.fromElement===htmlElement)),!0));toDispose.add(dom.addDisposableListener(htmlElement,dom.EventType.MOUSE_DOWN,(()=>hideHover(!0,!0)),!0));const target={targetElements:[htmlElement],dispose:()=>{}};if(void 0===hoverDelegate.placement||"mouse"===hoverDelegate.placement){const onMouseMove=e=>target.x=e.x+10;toDispose.add(dom.addDisposableListener(htmlElement,dom.EventType.MOUSE_MOVE,onMouseMove,!0))}toDispose.add(triggerShowHover(hoverDelegate.delay,!1,target)),hoverPreparation=toDispose}),!0);return{show:focus=>{hideHover(!1,!0),triggerShowHover(0,focus)},hide:()=>{hideHover(!0,!0)},update:newContent=>__awaiter(this,void 0,void 0,(function*(){content=newContent,yield null==hoverWidget?void 0:hoverWidget.update(content)})),dispose:()=>{mouseOverDomEmitter.dispose(),hideHover(!0,!0)}}}