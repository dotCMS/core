#-- Redis data-cache configuration

# - ${ENV_VARIABLE_NAME}

#- redis hosts. ex: 127.0.0.1:6379, 127.0.0.2:6379, 127.0.0.2:6380, ....
redis.hosts=${TOMCAT_REDIS_SESSION_HOSTS}

#- redis password.
redis.password=${TOMCAT_REDIS_SESSION_PASSWORD}

#- set true to enable redis cluster mode. (default value: false)
redis.cluster.enabled=${TOMCAT_REDIS_SESSION_CLUSTER_ENABLED}

#- set true to enable redis sentinel mode. (default value: false)
redis.sentinel.enabled=${TOMCAT_REDIS_SESSION_SENTINEL_ENABLED}
# redis sentinel master name. (default value: mymaster)
redis.sentinel.master=${TOMCAT_REDIS_SESSION_SENTINEL_MASTER}

#- redis database. (default value: 0)
#redis.database=${TOMCAT_REDIS_SESSION_DATABASE}

#- redis connection timeout. (default value: 2000 ms)
#redis.timeout=${TOMCAT_REDIS_SESSION_TIMEOUT}

#- enable redis and standard session mode. (default value: false)
# If enabled,
#   1. Must be enabled sticky session in your load balancer configuration. Else this manager may not return the updated session values.
#   2. Session values are stored in local jvm and redis.
#   3. If redis is down/not responding, requests uses jvm stored session values to process user requests. Redis comes back the values will be synced.
lb.sticky-session.enabled=${TOMCAT_REDIS_SESSION_STICKY_SESSION_ENABLED}

#- session persistent policies. (default value: DEFAULT) ex: DEFAULT, SAVE_ON_CHANGE
# policies - DEFAULT, SAVE_ON_CHANGE, ALWAYS_SAVE_AFTER_REQUEST
#   1. SAVE_ON_CHANGE: every time session.setAttribute() or session.removeAttribute() is called the session will be saved.
#   2. ALWAYS_SAVE_AFTER_REQUEST: force saving after every request, regardless of whether or not the manager has detected changes to the session.
session.persistent.policies=${TOMCAT_REDIS_SESSION_PERSISTENT_POLICIES}

#- single-sign-on session timeout. (default value: 0 ms (-no expiry))
redis.sso.timeout=${TOMCAT_REDIS_SESSION_SSO_TIMEOUT}