#!/usr/bin/env bash

# Color definitions
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# This script is used as a pre-commit hook for a Git repository.
# It performs operations such as formatting and linting on staged files.

. "$(dirname "$0")/_/husky.sh"  # Source the husky.sh script

error_occurred=false

# Function to check if sdk-client is affected
check_sdk_client_affected() {
    local affected=$(npx nx print-affected --select=projects)
    if echo "$affected" | grep -q "sdk-client"; then
        return 0
    else
        return 1
    fi
}

# Perform fix operations on the staged files
perform_fixes() {
    local -a files=($1)         # Convert string to array
    local add_to_index=$2       # Should be 'true' or 'false'
    local file                  # Declare file variable for use in loop

    if ! npx nx format:write; then
        error_occurred=true
    fi

    if ! npx nx affected -t lint --exclude='tag:skip:lint' --fix=true; then
        error_occurred=true
    fi

    if [ "$add_to_index" = "true" ]; then
        # Get a list of modified files in the working tree (excluding untracked/new files)
        local modified_files=$(git diff --name-only)

        # Loop through the list of files that were originally considered
        for file in "${files[@]}"; do
            if echo "$modified_files" | grep -Fxq "$file"; then
                if ! git add -- "${root_dir}/${file}"; then
                    error_occurred=true  # Record that an error occurred
                fi
            fi
        done
    fi
}

# Backup current working directory
original_pwd=${PWD}
root_dir="$(git rev-parse --show-toplevel)"



# Check for sdkman before running other initializations

# This will ensure that the correct version of node and yarn is installed
# from core-web/pom.xml and .nvmrc files are updated
cd "${root_dir}" || exit 1

check_sdkman

echo "Setting up Java"
sdk env install
echo "Initializing Maven, Node, and Yarn versions"
if ! ./mvnw validate -pl :dotcms-core --am -q; then
    echo "Failed to run './mvnw validate -pl :dotcms-core --am'"
    echo "Please run the following command to see the detailed output:"
    echo "./mvnw validate -pl :dotcms-core --am"
    exit 1
else
    echo "Completed Maven init"
fi


core_web_dir="${root_dir}/core-web"
cd "${core_web_dir}" || exit 1

staged_files=$(git diff --cached --name-only)
modified_files=$(git diff --name-only)

# Check if sdk-client is affected
if check_sdk_client_affected; then
    # Run sdk-client build command
    if ! npx nx run sdk-client:build:js; then
        echo "Failed to build sdk-client"
        exit 1
    fi

    # Remove specific file
    file_to_remove="${root_dir}/dotCMS/src/main/webapp/html/js/editor-js/package.json"
    if [ -f "$file_to_remove" ]; then
        rm "$file_to_remove"
        echo "Removed $file_to_remove"

        # Stage the removal of the file
        if ! git add "${root_dir}/dotCMS/src/main/webapp/html/js/editor-js/sdk-editor.js"; then
            echo "Failed to stage the removal of sdk-client.js"
            exit 1
        fi
    else
        echo "$file_to_remove does not exist"
    fi

    cd "${core_web_dir}" || exit  # Ensure we return to core-web directory
fi

# Find untracked files in core-web
staged_files=$(git diff --cached --name-only)  # Get a list of staged files
modified_files=$(git diff --name-only)  # Get a list of modified but unstaged files

# Find common files which are both staged and modified but not staged
untracked_files=$(printf "%s\n%s" "$staged_files" "$modified_files" | sort | uniq -d)

# Only create a temporary directory if there are untracked files
if [ -n "${untracked_files}" ]; then
    temp_dir=$(mktemp -d)
    if [ ! -d "${temp_dir}" ]; then
        echo "Failed to create temporary directory."
        exit 1
    fi
    echo "Created temporary directory ${temp_dir}"


    for file in $untracked_files; do
        if echo "${staged_files}" | grep -q "^${file}$"; then
            mkdir -p "${temp_dir}/$(dirname "${file}")"  # Ensure the directory structure exists in the temp directory
            cp "${root_dir}/${file}" "${temp_dir}/${file}"  # Copy the file to the temp directory, preserving the directory structure
            echo "Backing up ${file} to ${temp_dir}/${file}"
            # Restore the original file state in the repo, removing unstaged changes
            git restore "${root_dir}/${file}"  # Using relative path relative to current directory
        fi
    done

    # Set trap to ensure restore_untracked_files is called on exit
    trap restore_untracked_files EXIT

    for file in $untracked_files; do
            if echo "${staged_files}" | grep -q "^${file}$"; then
                git restore "${root_dir}/${file}"  # Using relative path relative to current directory
            fi
    done

    echo "Backed up workspace to ${temp_dir}"
fi

current_subdir=$(basename "$(pwd)")  # Get the current subdirectory

# Convert paths if necessary (adjust this logic based on your exact directory structure)
for file in ${untracked_files}; do
    relative_path="${file#${current_subdir}/}"  # Construct the path relative to the current directory

    if echo "${staged_files}" | grep -q "^${file}$"; then
        mkdir -p "${temp_dir}/$(dirname "${file}")"  # Ensure the directory structure exists in the temp directory
        cp "${root_dir}/${file}" "${temp_dir}/${file}"  # Copy the file to the temp directory, preserving the directory structure
        echo "Backing up ${file} to ${temp_dir}/${file}"
        # Restore the original file state in the repo, removing unstaged changes
        git checkout -- "${relative_path}"  # Using relative path relative to current directory
    fi
done

echo "Backed up workspace to ${temp_dir}"
git status

# Perform operations on staged files and capture the error count
if [ -n "${staged_files}" ]; then
    perform_fixes "${staged_files}" true
    errors=$?  # Capture the return value from perform_fixes
fi
# Restore untracked files if necessary
restore_untracked_files

## Running fixes on untracked files
core_web_files_untracked=$(echo "untracked_files" | grep -E '^core-web/' || true )
if [ -n "$core_web_files_untracked" ]; then
    perform_frontend_fixes "${core_web_files_untracked}" false
fi

# Restore original working directory
cd "${original_pwd}" || exit 1  # Exit if the directory does not exist

# Final check before exiting
if [ "$has_errors" = true ]; then
    echo "Checks failed. Force commit with --no-verify option if bypass required."
    exit 1  # Change the exit code to reflect that an error occurred
else
    echo "Commit checks completed successfully."
    exit 0  # No errors, exit normally
fi
