#!/usr/bin/env bash

# Ensure this script runs with bash
if [ -z "$BASH_VERSION" ]; then
    exec bash "$0" "$@"
fi

# Increase resource limits for git hook subprocess environment
# Git hooks run with restricted limits which can cause ENOBUFS errors
# Set soft limits to match typical shell environment
ulimit -n 10240 2>/dev/null || true  # Open files (file descriptors)
ulimit -u 2048 2>/dev/null || true   # Max user processes

# Color definitions
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Function to print colored output
print_color() {
    printf "%b%s%b\n" "$1" "$2" "$NC"
}

# This script is used as a pre-commit hook for a Git repository.
# It performs operations such as formatting and linting on staged files.

# Display mise installation instructions
show_mise_install_instructions() {
    print_color "$RED" "‚ùå mise not found - required for consistent tooling"
    print_color "$YELLOW" "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
    print_color "$BLUE" "üì¶ Please install mise to continue:"
    printf "\n"
    print_color "$GREEN" "  macOS/Linux:"
    printf "    curl https://mise.run | sh\n"
    printf "\n"
    print_color "$GREEN" "  Or with Homebrew:"
    printf "    brew install mise\n"
    printf "\n"
    print_color "$BLUE" "  Then activate in your shell (~/.zshrc or ~/.bashrc):"
    printf "    eval \"\$(mise activate zsh)\"   # for zsh\n"
    printf "    eval \"\$(mise activate bash)\"  # for bash\n"
    printf "\n"
    print_color "$BLUE" "  Reload your shell:"
    printf "    source ~/.zshrc  # or restart terminal\n"
    printf "\n"
    print_color "$YELLOW" "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
    print_color "$BLUE" "  For more info: https://mise.jdx.dev/getting-started.html"
    }

# Determine the root directory of the git repository
root_dir="$(git rev-parse --show-toplevel)"

# Check for mise first - required for all operations
if ! command -v mise >/dev/null 2>&1; then
    show_mise_install_instructions
    exit 1
fi

print_color "$GREEN" "‚úÖ mise is installed ($(mise --version))"
# mise will automatically use version config from .nvmrc, .sdkmanrc, or .mise.toml

# Check if mise configuration is trusted
# Use mise trust --show which outputs "path: trusted" or "path: untrusted"
trust_status=$(mise trust --show 2>&1)
if ! echo "$trust_status" | grep -q "trusted"; then
    print_color "$RED" "‚ùå mise configuration not trusted - required for security"
    print_color "$YELLOW" "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
    print_color "$BLUE" "üìã mise requires you to explicitly trust configuration files before using them."
    printf "\n"
    print_color "$GREEN" "  To trust this configuration, run:"
    printf "    mise trust\n"
    printf "\n"
    print_color "$BLUE" "  This will mark the .mise.toml configuration as trusted on your system."
    print_color "$YELLOW" "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
    exit 1
fi

print_color "$GREEN" "‚úÖ mise configuration is trusted"

# Auto-setup Husky if needed
if [ ! -f "$(dirname "$0")/_/husky.sh" ]; then
    print_color "$YELLOW" "üì¶ Husky setup incomplete: _/husky.sh not found"
    print_color "$BLUE" "üîß Auto-installing Husky dependencies with mise..."

    # Install Husky using mise-managed yarn
    cd "${root_dir}/core-web" || exit 1
    print_color "$BLUE" "üîß Running yarn install to set up Husky..."
    if mise exec -- yarn install --frozen-lockfile 2>/dev/null || mise exec -- yarn install 2>/dev/null; then
        print_color "$GREEN" "‚úÖ Husky setup completed successfully"
    else
        print_color "$RED" "‚ùå Failed to install Husky dependencies"
        print_color "$YELLOW" "üí° Please run 'yarn install' in the core-web directory"
        exit 1
    fi

    # Go back to original directory
    cd - >/dev/null || exit 1

    # Verify husky.sh now exists
    if [ ! -f "$(dirname "$0")/_/husky.sh" ]; then
        print_color "$RED" "‚ùå Husky setup still incomplete after installation"
        print_color "$YELLOW" "üí° Please run 'yarn install' in the core-web directory to complete setup"
        exit 1
    fi

    print_color "$GREEN" "‚úÖ Husky is now ready - continuing with pre-commit checks..."
fi

# Source husky script
. "$(dirname "$0")/_/husky.sh" || {
    print_color "$RED" "‚ùå Failed to source husky.sh"
    exit 1
}

check_sdk_client_affected() {
    # Check if initial build has been done (nx cache and build artifacts exist)
    if [ ! -d "${root_dir}/core-web/.nx" ] || [ ! -d "${root_dir}/core-web/dist" ]; then
        print_color "$YELLOW" "‚ö†Ô∏è  Initial build not detected - nx cache or dist directory missing"
        print_color "$BLUE" "üí° Run 'yarn install && yarn nx run-many -t build' in the core-web directory to build frontend"
        print_color "$YELLOW" "Skipping sdk-uve build check for now"
        return 0
    fi

    # Check if sdk-uve related files have been modified (avoid nx affected due to ENOBUFS)
    local sdk_uve_affected=false

    # Check staged files for sdk-uve related changes
    if git diff --cached --name-only | grep -E "(sdk-uve|uve)" >/dev/null 2>&1; then
        sdk_uve_affected=true
        print_color "$BLUE" "üìã SDK-UVE related files detected in staged changes"
    else
        # Also check if libs/sdk-uve directory exists and has changes
        if [ -d "${root_dir}/core-web/libs/sdk-uve" ]; then
            # Check if any files in sdk-uve directory are modified
            if git status --porcelain 2>/dev/null | grep -E "libs/sdk-uve" >/dev/null 2>&1; then
                sdk_uve_affected=true
                print_color "$BLUE" "üìã SDK-UVE directory changes detected"
            fi
        fi
    fi

    if [ "$sdk_uve_affected" = false ]; then
        print_color "$GREEN" "‚úÖ No SDK-UVE related changes detected, skipping build"
    fi

    # Build sdk-client if affected
    if [ "$sdk_uve_affected" = true ]; then
        print_color "$BLUE" "üî® Building sdk-client"
        if ! mise exec -- yarn nx run sdk-uve:build:js 2>/dev/null; then
            print_color "$YELLOW" "‚ö†Ô∏è SDK-UVE build failed or not available, continuing..."
            # Don't set has_errors=true here as sdk-uve might not always be available
        fi
    fi

    file_to_remove="${root_dir}/dotCMS/src/main/webapp/ext/uve/package.json"

    # Check if the file exists, then delete it
    if [ -f "$file_to_remove" ]; then
        rm "$file_to_remove"
        print_color "$GREEN" "üóëÔ∏è Removed ${file_to_remove}"
    else
        print_color "$BLUE" "‚ÑπÔ∏è ${file_to_remove} does not exist"
    fi

    # Only try to stage the file if it exists and we're in the right git context
    uve_js_file="${root_dir}/dotCMS/src/main/webapp/ext/uve/dot-uve.js"
    if [ -f "$uve_js_file" ]; then
        # Change to root directory to ensure proper git context
        cd "$root_dir" || exit 1
        if ! git add "dotCMS/src/main/webapp/ext/uve/dot-uve.js"; then
            print_color "$RED" "‚ùå Failed to stage computed dot-uve.js"
            exit 1
        fi
        # Change back to core-web directory
        cd "${root_dir}/core-web" || exit 1
        print_color "$GREEN" "‚úÖ Staged computed dot-uve.js"
    else
        print_color "$BLUE" "‚ÑπÔ∏è dot-uve.js does not exist, skipping staging"
    fi
}

# SDKMAN check removed - mise handles Java versions from .sdkmanrc
# check_sdkman() function is no longer needed

has_errors=false

original_pwd=${PWD}

# Setup development tools with mise
cd "${root_dir}" || exit 1

print_color "$BLUE" "üîß Setting up development tools with mise..."

# Display tool versions - mise automatically reads from .nvmrc, .sdkmanrc, and .mise.toml
java_version=$(mise current java 2>&1 | grep -v "WARN" || echo "not configured")
node_version=$(mise current node 2>&1 | grep -v "WARN" || echo "not configured")

print_color "$GREEN" "  ‚úì Java: ${java_version} (from .sdkmanrc)"
print_color "$GREEN" "  ‚úì Node: ${node_version} (from .nvmrc)"
print_color "$GREEN" "  ‚úì Yarn: $(mise exec -- yarn --version) (via Node Corepack)"
print_color "$GREEN" "  ‚úì Maven: $(mise exec -- mvn --version 2>&1 | head -n 1 | sed 's/Apache //')"

# Function to check if Maven is needed at all
needs_maven() {
    local staged_files=$(git diff --cached --name-only)

    # Check if there are any non-core-web files or core-web/pom.xml
    if echo "$staged_files" | grep -v "^core-web/" > /dev/null 2>&1; then
        return 0  # Non-core-web files changed, Maven needed
    fi

    # Check if core-web/pom.xml is changed
    if echo "$staged_files" | grep -E "^core-web/pom\.xml$" > /dev/null 2>&1; then
        return 0  # core-web/pom.xml changed, Maven needed
    fi

    return 1  # Only core-web files (excluding pom.xml) changed, no Maven needed
}

# Function to check if OpenAPI generation is needed
needs_openapi_compile() {
    local openapi_file="${root_dir}/dotCMS/src/main/webapp/WEB-INF/openapi/openapi.yaml"
    local staged_files=$(git diff --cached --name-only)

    # Check if any REST API related files are staged
    local rest_files_changed=false

    # Check for changes in OpenAPI configuration files
    if echo "$staged_files" | grep -E "(DotRestApplication\.java)" > /dev/null 2>&1; then
        rest_files_changed=true
    fi

    # Check for changes in any @Path annotated files
    if echo "$staged_files" | grep -E "\.java$" > /dev/null 2>&1; then
        # Check if any staged Java files contain REST annotations
        # Use macOS-compatible approach to handle files with spaces and special characters
        local java_files_list
        java_files_list=$(echo "$staged_files" | grep "\.java$")

        # Use a more portable approach for iterating over filenames
        local IFS=$'\n'
        for file in $java_files_list; do
            # Check if file exists (for modified files) or if it's a deleted file containing REST annotations
            if [ -f "${root_dir}/${file}" ]; then
                # File exists, check for REST annotations
                if grep -E "@Path|@GET|@POST|@PUT|@DELETE|@OpenAPIDefinition|@Tag|@Operation" "${root_dir}/${file}" > /dev/null 2>&1; then
                    rest_files_changed=true
                    break
                fi
            else
                # File was deleted, check git show for REST annotations in the deleted content
                if git show "HEAD:${file}" 2>/dev/null | grep -E "@Path|@GET|@POST|@PUT|@DELETE|@OpenAPIDefinition|@Tag|@Operation" > /dev/null 2>&1; then
                    rest_files_changed=true
                    break
                fi
            fi
        done

        # Restore IFS to default
        unset IFS
    fi

    # If no REST files changed, no compile needed
    if [ "$rest_files_changed" = false ]; then
        return 1
    fi

    # If OpenAPI file doesn't exist, compile is needed
    if [ ! -f "$openapi_file" ]; then
        return 0
    fi

    # If REST files changed, compile is needed
    return 0
}

print_color "$BLUE" "üîç Analyzing staged files to determine required build steps..."

# Check if Maven is needed at all
if needs_maven; then
    # Maven is needed, determine if we need compile or just validate
    if needs_openapi_compile; then
        print_color "$YELLOW" "üîÑ REST API files detected - running compile to update OpenAPI specification"
        if ! ./mvnw compile -pl :dotcms-core --am -q; then
            print_color "$RED" "‚ùå Failed to run './mvnw compile -pl :dotcms-core --am'"
            print_color "$YELLOW" "üí° Please run the following command to see the detailed output:"
            printf "./mvnw compile -pl :dotcms-core --am\n"
            exit 1
        else
            print_color "$GREEN" "‚úÖ Completed Maven compile with OpenAPI generation"
            # Stage the updated OpenAPI file if it was regenerated
            if [ -f "${root_dir}/dotCMS/src/main/webapp/WEB-INF/openapi/openapi.yaml" ]; then
                git add "${root_dir}/dotCMS/src/main/webapp/WEB-INF/openapi/openapi.yaml"
                print_color "$GREEN" "üìã Updated OpenAPI specification staged for commit"
            fi
        fi
    else
        print_color "$GREEN" "‚ö° No REST API changes detected - running validation only"
        # Run lightweight validation to ensure Maven/Node/Yarn are available
        if ! ./mvnw validate -pl :dotcms-core --am -q; then
            print_color "$RED" "‚ùå Failed to run './mvnw validate -pl :dotcms-core --am'"
            print_color "$YELLOW" "üí° Please run the following command to see the detailed output:"
            printf "./mvnw validate -pl :dotcms-core --am\n"
            exit 1
        else
            print_color "$GREEN" "‚úÖ Completed Maven validation"
        fi
    fi
else
    print_color "$GREEN" "üöÄ Only core-web files changed (excluding pom.xml) - skipping Maven entirely"
fi

core_web_dir="${root_dir}/core-web"
cd "${core_web_dir}" || exit 1

# CRITICAL FIX: Unset Git environment variables that prevent .gitignore from working correctly
# Git sets GIT_DIR and GIT_INDEX_FILE during pre-commit hooks in worktrees
# These cause git ls-files to return massive output including .nx/cache files
# Solution validated by lint-staged PR #887: https://github.com/lint-staged/lint-staged/pull/887
unset GIT_DIR
unset GIT_INDEX_FILE
unset GIT_WORK_TREE

# Run lint-staged for frontend linting and formatting
# lint-staged will:
# - Only process staged files (more precise than nx affected)
# - Handle backup/restore of unstaged changes automatically
# - Handle git environment variables correctly
# - Stage fixed files automatically
print_color "$BLUE" "üîç Running lint-staged on staged frontend files..."
if ! NX_DAEMON=false mise exec -- yarn lint-staged; then
    print_color "$RED" "‚ùå lint-staged failed"
    has_errors=true
fi

# Check if sdk-client is affected
check_sdk_client_affected

# Restore original working directory
cd "${original_pwd}" || exit 1  # Exit if the directory does not exist

# Final check before exiting
if [ "$has_errors" = true ]; then
    print_color "$RED" "‚ùå Checks failed. Force commit with --no-verify option if bypass required."
    exit 1  # Change the exit code to reflect that an error occurred
else
    print_color "$GREEN" "üéâ Commit checks completed successfully."
    exit 0  # No errors, exit normally
fi
