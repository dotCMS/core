#!/usr/bin/env bash
# This script is used as a pre-commit hook for a Git repository.
# It performs operations such as formatting and linting on staged files.

. "$(dirname "$0")/_/husky.sh"  # Source the husky.sh script

error_occurred=false

# Perform fix operations on the staged files
perform_fixes() {
    local files="$1"
    local add_to_index="$2"
    local file

    YARN_EXEC="${root_dir}/installs/node/yarn/dist/bin/yarn"
    NODE_EXEC="${root_dir}/installs/node/node"

    echo "Yarn version: $($YARN_EXEC --version 2>/dev/null)"
    echo "Node version: $($NODE_EXEC --version)"

    if ! $YARN_EXEC nx affected -t lint --exclude='tag:skip:lint' --fix=true; then
        error_occurred=true
    fi

    if ! $YARN_EXEC nx format:write; then
        error_occurred=true
    fi

    if [ "$add_to_index" = "true" ]; then
        local modified_files
        modified_files=$( (git diff --name-only && git diff --name-only --cached) | sort | uniq)

        local unmatched_files=()

        for file in $files; do
            if echo "$modified_files" | grep -Fxq "$file"; then
                if ! git add -- "${root_dir}/${file}"; then
                    error_occurred=true
                fi
            else
                unmatched_files+=("$file")
            fi
        done

        if [ ${#unmatched_files[@]} -ne 0 ]; then
            echo "==================================="
            echo "Warning: The following unrelated files in the affected modules should be linted and/or formatted"
            echo ""
            for file in "${unmatched_files[@]}"; do
                echo "    ${file}"
                git restore "${file}"
            done
            echo ""
            echo "You can fix these files by running the following commands:"
            echo "nx affected -t lint --exclude='tag:skip:lint' --fix=true"
            echo "nx format:write;"
        fi
    fi
}

# Function to run yarn install with --frozen-lockfile and handle failure
run_yarn_install_frozen_lockfile() {
    if ! yarn install --frozen-lockfile; then
        echo "Failed to install dependencies with --frozen-lockfile."
        echo "Please run 'yarn install' to update the lockfile and make sure you commit this with any package.json changes."
        exit 1
    fi
}

original_pwd=${PWD}
root_dir="$(git rev-parse --show-toplevel)"

# This will ensure that the correct version of node and yarn is installed
# from core-web/pom.xml and .nvmrc files are updated
cd "${root_dir}" || exit
echo "Initializing maven, node and yarn versions"
if ! ./mvnw validate -pl :dotcms-core --am -q; then
    echo "Failed to run './mvnw validate -pl :dotcms-core --am'"
    echo "Please run the following command to see the detailed output:"
    echo "./mvnw validate -pl :dotcms-core --am"
    exit 1
else
    echo "Completed Maven init"
fi


core_web_dir="${root_dir}/core-web"
cd "${core_web_dir}" || exit

yarn config set registry https://dotcms-npm.b-cdn.net
run_yarn_install_frozen_lockfile

staged_files=$(git diff --cached --name-only)
modified_files=$(git diff --name-only)

untracked_files=$(printf "%s\n%s" "$staged_files" "$modified_files" | sort | uniq -d)



# Only create a temporary directory if there are untracked files
if [ -n "${untracked_files}" ]; then
    temp_dir=$(mktemp -d)
    if [ ! -d "${temp_dir}" ]; then
        echo "Failed to create temporary directory."
        exit 1
    fi
fi

current_subdir=$(basename "$(pwd)")  # Get the current subdirectory

# Convert paths if necessary (adjust this logic based on your exact directory structure)
for file in $untracked_files; do
    relative_path="${file#${current_subdir}/}"  # Construct the path relative to the current directory

    if echo "${staged_files}" | grep -q "^${file}$"; then
        mkdir -p "${temp_dir}/$(dirname "${file}")"  # Ensure the directory structure exists in the temp directory
        cp "${root_dir}/${file}" "${temp_dir}/${file}"  # Copy the file to the temp directory, preserving the directory structure
        echo "Backing up ${file} to ${temp_dir}/${file}"
        # Restore the original file state in the repo, removing unstaged changes
        git checkout -- "${relative_path}"  # Using relative path relative to current directory
    fi
done

echo "Backed up workspace to ${temp_dir}"

# Perform operations on staged files and capture the error count
if [ -n "${staged_files}" ]; then
    perform_fixes "${staged_files}" true
    errors=$?  # Capture the return value from perform_fixes
fi

# Check if the temporary directory is not empty
if [ -n "${untracked_files}" ] && [ "$(ls -A "${temp_dir}")" ]; then
    echo "Restoring untracked files..."
    # Copy each file back from the temporary directory while maintaining the directory structure
    find "${temp_dir}" -type f -exec sh -c '
        for file; do
            temp_dir='"${temp_dir}"'
            root_dir='"${root_dir}"'
            rel_path="${file#${temp_dir}/}"  # Extract the relative path by removing the temp directory prefix
            dest_dir="$(dirname "${rel_path}")"  # Determine the destination directory based on the relative path
            full_dest_path="${root_dir}/${rel_path}"  # Construct the full destination path
            mkdir -p "${root_dir}/${dest_dir}"  # Ensure the destination directory exists
            cp "${file}" "${full_dest_path}"  # Copy the file to the destination directory
        done
    ' sh {} +

    # After restoring, perform actions like formatting on the originally staged files
    if [ -n "${staged_files}" ]; then
      perform_fixes "${untracked_files}" false
    fi
fi

# After restoring files and before exiting, check if there were any errors
if [ -n "${untracked_files}" ]; then
    rm -r "${temp_dir}"
fi

# Restore original working directory
cd "${original_pwd}" || exit  # Exit if the directory does not exist

# Final check before exiting
if [ "$error_occurred" = true ]; then
    echo "Checks failed.  force commit with --no-verify option if bypass required"
    exit 1  # Change the exit code to reflect that an error occurred
else
    echo "Commit checks completed OK"
    exit 0  # No errors, exit normally
fi
