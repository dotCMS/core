package com.dotcms.rest.api.v1.vtl;

import com.dotcms.api.vtl.model.DotJSON;
import com.dotcms.cache.DotJSONCache;
import com.dotcms.cache.DotJSONCacheFactory;
import com.dotcms.rendering.util.ScriptingReaderParams;
import com.dotcms.rendering.util.ScriptingUtil;
import com.dotcms.rendering.velocity.util.VelocityUtil;
import com.dotcms.rendering.velocity.viewtools.exception.DotToolException;
import com.dotmarketing.util.json.JSONException;
import com.dotcms.rest.InitDataObject;
import com.dotcms.rest.PATCH;
import com.dotcms.rest.WebResource;
import com.dotcms.rest.annotation.NoCache;
import com.dotcms.rest.annotation.SwaggerCompliant;
import com.dotcms.rest.api.MultiPartUtils;
import com.dotcms.rest.api.v1.HTTPMethod;
import com.dotcms.rest.api.v1.authentication.ResponseUtil;
import com.dotcms.util.CollectionsUtils;
import com.dotmarketing.util.Logger;
import com.dotmarketing.util.PageMode;
import com.dotmarketing.util.UtilMethods;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.google.common.annotations.VisibleForTesting;
import com.liferay.portal.model.User;
import java.io.File;
import java.io.IOException;
import java.io.Reader;
import java.io.StringWriter;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import javax.ws.rs.Consumes;
import javax.ws.rs.DELETE;
import javax.ws.rs.GET;
import javax.ws.rs.POST;
import javax.ws.rs.PUT;
import javax.ws.rs.Path;
import javax.ws.rs.PathParam;
import javax.ws.rs.Produces;
import javax.ws.rs.core.Context;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;
import javax.ws.rs.core.UriInfo;
import org.apache.velocity.exception.MethodInvocationException;
import org.glassfish.jersey.media.multipart.FormDataMultiPart;
import org.glassfish.jersey.server.JSONP;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;


@SwaggerCompliant(value = "Modern APIs and specialized services", batch = 7)
@Path("/vtl")
@Tag(name = "VTL")
public class VTLResource {

    public static final String IDENTIFIER = "identifier";
    public static final String VELOCITY = "velocity";
    private final MultiPartUtils multiPartUtils;
    private final WebResource webResource;
    @VisibleForTesting
    static final String VTL_PATH = "/application/apivtl";

    public VTLResource() {
        this(new WebResource(), new MultiPartUtils());
    }

    @VisibleForTesting
    VTLResource(final WebResource webResource, final MultiPartUtils multiPartUtils) {
        this.webResource   = webResource;
        this.multiPartUtils = multiPartUtils;
    }

    @Operation(
        summary = "Process GET request with VTL template",
        description = "Returns the output of a convention based 'get.vtl' file, located under the given folder after being evaluated using the velocity engine. The VTL code determines whether the response is JSON, XML, or plain text."
    )
    @ApiResponses(value = {
        @ApiResponse(responseCode = "200", 
                    description = "VTL template processed successfully",
                    content = @Content(mediaType = "application/json",
                                      schema = @Schema(type = "object", description = "Dynamic content generated by VTL template processing - format determined by template logic"))),
        @ApiResponse(responseCode = "400", 
                    description = "Bad request - invalid template or parameters",
                    content = @Content(mediaType = "application/json")),
        @ApiResponse(responseCode = "401", 
                    description = "Unauthorized - authentication may be required",
                    content = @Content(mediaType = "application/json")),
        @ApiResponse(responseCode = "404", 
                    description = "VTL template not found",
                    content = @Content(mediaType = "application/json")),
        @ApiResponse(responseCode = "500", 
                    description = "Internal server error during template processing",
                    content = @Content(mediaType = "application/json"))
    })
    @GET
    @Path("/{folder}/{pathParam:.*}")
    @NoCache
    @Produces({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML, MediaType.TEXT_PLAIN})
    @Consumes(MediaType.APPLICATION_JSON)
    public Response get(@Context final HttpServletRequest request, @Context final HttpServletResponse response,
                        @Context UriInfo uriInfo, @Parameter(description = "VTL template folder name", required = true) @PathParam("folder") final String folderName,
                        @Parameter(description = "Additional path parameters") @PathParam("pathParam") final String pathParam, 
                        @io.swagger.v3.oas.annotations.parameters.RequestBody(
                            description = "Request body parameters for template processing", 
                            content = @Content(schema = @Schema(type = "object", description = "JSON object with parameters for VTL template processing"))
                        ) final Map<String, Object> bodyMap) {

        return processRequest(request, response, uriInfo, folderName, pathParam, HTTPMethod.GET, bodyMap);
    }

    @Operation(
        summary = "Process GET request with VTL template (folder only)",
        description = "Returns the output of a convention based 'get.vtl' file, located under the given folder after being evaluated using the velocity engine."
    )
    @ApiResponses(value = {
        @ApiResponse(responseCode = "200", 
                    description = "VTL template processed successfully",
                    content = @Content(mediaType = "application/json",
                                      schema = @Schema(type = "object", description = "Dynamic content generated by VTL template processing - format determined by template logic"))),
        @ApiResponse(responseCode = "400", 
                    description = "Bad request - invalid template or parameters",
                    content = @Content(mediaType = "application/json")),
        @ApiResponse(responseCode = "401", 
                    description = "Unauthorized - authentication may be required",
                    content = @Content(mediaType = "application/json")),
        @ApiResponse(responseCode = "404", 
                    description = "VTL template not found",
                    content = @Content(mediaType = "application/json")),
        @ApiResponse(responseCode = "500", 
                    description = "Internal server error during template processing",
                    content = @Content(mediaType = "application/json"))
    })
    @GET
    @Path("/{folder}")
    @NoCache
    @Produces({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML, MediaType.TEXT_PLAIN})
    @Consumes(MediaType.APPLICATION_JSON)
    public Response get(@Context final HttpServletRequest request, @Context final HttpServletResponse response,
                        @Context UriInfo uriInfo, @Parameter(description = "VTL template folder name", required = true) @PathParam("folder") final String folderName,
                        @io.swagger.v3.oas.annotations.parameters.RequestBody(
                            description = "Request body parameters for template processing", 
                            content = @Content(schema = @Schema(type = "object", description = "JSON object with parameters for VTL template processing"))
                        ) final Map<String, Object> bodyMap) {

        return processRequest(request, response, uriInfo, folderName, null, HTTPMethod.GET, bodyMap);
    }

    @Operation(
        summary = "Process POST request with VTL template",
        description = "Returns the output of a convention based 'post.vtl' file, located under the given folder after being evaluated using the velocity engine. The VTL code determines whether the response is JSON, XML, or plain text."
    )
    @ApiResponses(value = {
        @ApiResponse(responseCode = "200", 
                    description = "VTL template processed successfully",
                    content = @Content(mediaType = "application/json",
                                      schema = @Schema(type = "object", description = "Dynamic content generated by VTL template processing - format determined by template logic"))),
        @ApiResponse(responseCode = "400", 
                    description = "Bad request - invalid template or parameters",
                    content = @Content(mediaType = "application/json")),
        @ApiResponse(responseCode = "401", 
                    description = "Unauthorized - authentication may be required",
                    content = @Content(mediaType = "application/json")),
        @ApiResponse(responseCode = "404", 
                    description = "VTL template not found",
                    content = @Content(mediaType = "application/json")),
        @ApiResponse(responseCode = "500", 
                    description = "Internal server error during template processing",
                    content = @Content(mediaType = "application/json"))
    })
    @POST
    @Path("/{folder}/{pathParam: .*}")
    @JSONP
    @NoCache
    @Produces({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML, MediaType.TEXT_PLAIN})
    @Consumes(MediaType.APPLICATION_JSON)
    public final Response post(@Context final HttpServletRequest request, @Context final HttpServletResponse response,
                               @Context UriInfo uriInfo, @Parameter(description = "VTL template folder name", required = true) @PathParam("folder") final String folderName,
                               @Parameter(description = "Additional path parameters") @PathParam("pathParam") final String pathParam,
                               @io.swagger.v3.oas.annotations.parameters.RequestBody(
                                   description = "Request body parameters for template processing", 
                                   content = @Content(schema = @Schema(type = "object", description = "JSON object with parameters for VTL template processing"))
                               ) final Map<String, Object> bodyMap) {

        return processRequest(request, response, uriInfo, folderName, pathParam, HTTPMethod.POST, bodyMap);
    }

    @Operation(
        summary = "Process POST request with VTL template (folder only)",
        description = "Returns the output of a convention based 'post.vtl' file, located under the given folder after being evaluated using the velocity engine."
    )
    @ApiResponses(value = {
        @ApiResponse(responseCode = "200", 
                    description = "VTL template processed successfully",
                    content = @Content(mediaType = "application/json",
                                      schema = @Schema(type = "object", description = "Dynamic content generated by VTL template processing - format determined by template logic"))),
        @ApiResponse(responseCode = "400", 
                    description = "Bad request - invalid template or parameters",
                    content = @Content(mediaType = "application/json")),
        @ApiResponse(responseCode = "401", 
                    description = "Unauthorized - authentication may be required",
                    content = @Content(mediaType = "application/json")),
        @ApiResponse(responseCode = "404", 
                    description = "VTL template not found",
                    content = @Content(mediaType = "application/json")),
        @ApiResponse(responseCode = "500", 
                    description = "Internal server error during template processing",
                    content = @Content(mediaType = "application/json"))
    })
    @POST
    @Path("/{folder}")
    @JSONP
    @NoCache
    @Produces({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML, MediaType.TEXT_PLAIN})
    @Consumes(MediaType.APPLICATION_JSON)
    public final Response post(@Context final HttpServletRequest request, @Context final HttpServletResponse response,
                               @Context UriInfo uriInfo, @Parameter(description = "VTL template folder name", required = true) @PathParam("folder") final String folderName,
                               @io.swagger.v3.oas.annotations.parameters.RequestBody(
                                   description = "Request body parameters for template processing", 
                                   content = @Content(schema = @Schema(type = "object", description = "JSON object with parameters for VTL template processing"))
                               ) final Map<String, Object> bodyMap) {

        return processRequest(request, response, uriInfo, folderName, null, HTTPMethod.POST, bodyMap);
    }

    @Operation(
        summary = "Process PUT request with VTL template",
        description = "Returns the output of a convention based 'put.vtl' file, located under the given folder after being evaluated using the velocity engine. The VTL code determines whether the response is JSON, XML, or plain text."
    )
    @ApiResponses(value = {
        @ApiResponse(responseCode = "200", 
                    description = "VTL template processed successfully",
                    content = @Content(mediaType = "application/json",
                                      schema = @Schema(type = "object", description = "Dynamic content generated by VTL template processing - format determined by template logic"))),
        @ApiResponse(responseCode = "400", 
                    description = "Bad request - invalid template or parameters",
                    content = @Content(mediaType = "application/json")),
        @ApiResponse(responseCode = "401", 
                    description = "Unauthorized - authentication may be required",
                    content = @Content(mediaType = "application/json")),
        @ApiResponse(responseCode = "404", 
                    description = "VTL template not found",
                    content = @Content(mediaType = "application/json")),
        @ApiResponse(responseCode = "500", 
                    description = "Internal server error during template processing",
                    content = @Content(mediaType = "application/json"))
    })
    @PUT
    @Path("/{folder}/{pathParam: .*}")
    @JSONP
    @NoCache
    @Produces({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML, MediaType.TEXT_PLAIN})
    @Consumes(MediaType.APPLICATION_JSON)
    public final Response put(@Context final HttpServletRequest request, @Context final HttpServletResponse response,
                               @Context UriInfo uriInfo, @Parameter(description = "VTL template folder name", required = true) @PathParam("folder") final String folderName,
                               @Parameter(description = "Additional path parameters") @PathParam("pathParam") final String pathParam,
                               @io.swagger.v3.oas.annotations.parameters.RequestBody(
                                   description = "Request body parameters for template processing", 
                                   content = @Content(schema = @Schema(type = "object", description = "JSON object with parameters for VTL template processing"))
                               ) final Map<String, Object> bodyMap) {

        return processRequest(request, response, uriInfo, folderName, pathParam, HTTPMethod.PUT, bodyMap);
    }

    @Operation(
        summary = "Process PUT request with VTL template (folder only)",
        description = "Returns the output of a convention based 'put.vtl' file, located under the given folder after being evaluated using the velocity engine."
    )
    @ApiResponses(value = {
        @ApiResponse(responseCode = "200", 
                    description = "VTL template processed successfully",
                    content = @Content(mediaType = "application/json",
                                      schema = @Schema(type = "object", description = "Dynamic content generated by VTL template processing - format determined by template logic"))),
        @ApiResponse(responseCode = "400", 
                    description = "Bad request - invalid template or parameters",
                    content = @Content(mediaType = "application/json")),
        @ApiResponse(responseCode = "401", 
                    description = "Unauthorized - authentication may be required",
                    content = @Content(mediaType = "application/json")),
        @ApiResponse(responseCode = "404", 
                    description = "VTL template not found",
                    content = @Content(mediaType = "application/json")),
        @ApiResponse(responseCode = "500", 
                    description = "Internal server error during template processing",
                    content = @Content(mediaType = "application/json"))
    })
    @PUT
    @Path("/{folder}")
    @JSONP
    @NoCache
    @Produces({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML, MediaType.TEXT_PLAIN})
    @Consumes(MediaType.APPLICATION_JSON)
    public final Response put(@Context final HttpServletRequest request, @Context final HttpServletResponse response,
                              @Context UriInfo uriInfo, @Parameter(description = "VTL template folder name", required = true) @PathParam("folder") final String folderName,
                              @io.swagger.v3.oas.annotations.parameters.RequestBody(
                                  description = "Request body parameters for template processing", 
                                  content = @Content(schema = @Schema(type = "object", description = "JSON object with parameters for VTL template processing"))
                              ) final Map<String, Object> bodyMap) {

        return processRequest(request, response, uriInfo, folderName, null, HTTPMethod.PUT, bodyMap);
    }

    @Operation(
        summary = "Process PATCH request with VTL template",
        description = "Returns the output of a convention based 'patch.vtl' file, located under the given folder after being evaluated using the velocity engine. The VTL code determines whether the response is JSON, XML, or plain text."
    )
    @ApiResponses(value = {
        @ApiResponse(responseCode = "200", 
                    description = "VTL template processed successfully",
                    content = @Content(mediaType = "application/json",
                                      schema = @Schema(type = "object", description = "Dynamic content generated by VTL template processing - format determined by template logic"))),
        @ApiResponse(responseCode = "400", 
                    description = "Bad request - invalid template or parameters",
                    content = @Content(mediaType = "application/json")),
        @ApiResponse(responseCode = "401", 
                    description = "Unauthorized - authentication may be required",
                    content = @Content(mediaType = "application/json")),
        @ApiResponse(responseCode = "404", 
                    description = "VTL template not found",
                    content = @Content(mediaType = "application/json")),
        @ApiResponse(responseCode = "500", 
                    description = "Internal server error during template processing",
                    content = @Content(mediaType = "application/json"))
    })
    @PATCH
    @Path("/{folder}/{pathParam: .*}")
    @JSONP
    @NoCache
    @Produces({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML, MediaType.TEXT_PLAIN})
    @Consumes(MediaType.APPLICATION_JSON)
    public final Response patch(@Context final HttpServletRequest request, @Context final HttpServletResponse response,
                              @Context UriInfo uriInfo, @Parameter(description = "VTL template folder name", required = true) @PathParam("folder") final String folderName,
                              @Parameter(description = "Additional path parameters") @PathParam("pathParam") final String pathParam,
                              @io.swagger.v3.oas.annotations.parameters.RequestBody(
                                  description = "Request body parameters for template processing", 
                                  content = @Content(schema = @Schema(type = "object", description = "JSON object with parameters for VTL template processing"))
                              ) final Map<String, Object> bodyMap) {

        return processRequest(request, response, uriInfo, folderName, pathParam, HTTPMethod.PATCH, bodyMap);
    }

    @Operation(
        summary = "Process PATCH request with VTL template (folder only)",
        description = "Returns the output of a convention based 'patch.vtl' file, located under the given folder after being evaluated using the velocity engine."
    )
    @ApiResponses(value = {
        @ApiResponse(responseCode = "200", 
                    description = "VTL template processed successfully",
                    content = @Content(mediaType = "application/json",
                                      schema = @Schema(type = "object", description = "Dynamic content generated by VTL template processing - format determined by template logic"))),
        @ApiResponse(responseCode = "400", 
                    description = "Bad request - invalid template or parameters",
                    content = @Content(mediaType = "application/json")),
        @ApiResponse(responseCode = "401", 
                    description = "Unauthorized - authentication may be required",
                    content = @Content(mediaType = "application/json")),
        @ApiResponse(responseCode = "404", 
                    description = "VTL template not found",
                    content = @Content(mediaType = "application/json")),
        @ApiResponse(responseCode = "500", 
                    description = "Internal server error during template processing",
                    content = @Content(mediaType = "application/json"))
    })
    @PATCH
    @Path("/{folder}")
    @JSONP
    @NoCache
    @Produces({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML, MediaType.TEXT_PLAIN})
    @Consumes(MediaType.APPLICATION_JSON)
    public final Response patch(@Context final HttpServletRequest request, @Context final HttpServletResponse response,
                                @Context UriInfo uriInfo, @Parameter(description = "VTL template folder name", required = true) @PathParam("folder") final String folderName,
                                @io.swagger.v3.oas.annotations.parameters.RequestBody(
                                    description = "Request body parameters for template processing", 
                                    content = @Content(schema = @Schema(type = "object", description = "JSON object with parameters for VTL template processing"))
                                ) final Map<String, Object> bodyMap) {

        return processRequest(request, response, uriInfo, folderName, null, HTTPMethod.PATCH, bodyMap);
    }

    @Operation(
        summary = "Process DELETE request with VTL template",
        description = "Returns the output of a convention based 'delete.vtl' file, located under the given folder after being evaluated using the velocity engine. The VTL code determines whether the response is JSON, XML, or plain text."
    )
    @ApiResponses(value = {
        @ApiResponse(responseCode = "200", 
                    description = "VTL template processed successfully",
                    content = @Content(mediaType = "application/json",
                                      schema = @Schema(type = "object", description = "Dynamic content generated by VTL template processing - format determined by template logic"))),
        @ApiResponse(responseCode = "400", 
                    description = "Bad request - invalid template or parameters",
                    content = @Content(mediaType = "application/json")),
        @ApiResponse(responseCode = "401", 
                    description = "Unauthorized - authentication may be required",
                    content = @Content(mediaType = "application/json")),
        @ApiResponse(responseCode = "404", 
                    description = "VTL template not found",
                    content = @Content(mediaType = "application/json")),
        @ApiResponse(responseCode = "500", 
                    description = "Internal server error during template processing",
                    content = @Content(mediaType = "application/json"))
    })
    @DELETE
    @Path("/{folder}/{pathParam: .*}")
    @JSONP
    @NoCache
    @Produces({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML, MediaType.TEXT_PLAIN})
    @Consumes(MediaType.APPLICATION_JSON)
    public final Response delete(@Context final HttpServletRequest request, @Context final HttpServletResponse response,
                               @Context UriInfo uriInfo, @Parameter(description = "VTL template folder name", required = true) @PathParam("folder") final String folderName,
                               @Parameter(description = "Additional path parameters") @PathParam("pathParam") final String pathParam,
                               @io.swagger.v3.oas.annotations.parameters.RequestBody(
                                   description = "Request body parameters for template processing", 
                                   content = @Content(schema = @Schema(type = "object", description = "JSON object with parameters for VTL template processing"))
                               ) final Map<String, Object> requestJSONMap) {

        return processRequest(request, response, uriInfo, folderName, pathParam, HTTPMethod.DELETE, requestJSONMap);
    }

    @Operation(
        summary = "Process DELETE request with VTL template (folder only)",
        description = "Returns the output of a convention based 'delete.vtl' file, located under the given folder after being evaluated using the velocity engine."
    )
    @ApiResponses(value = {
        @ApiResponse(responseCode = "200", 
                    description = "VTL template processed successfully",
                    content = @Content(mediaType = "application/json",
                                      schema = @Schema(type = "object", description = "Dynamic content generated by VTL template processing - format determined by template logic"))),
        @ApiResponse(responseCode = "400", 
                    description = "Bad request - invalid template or parameters",
                    content = @Content(mediaType = "application/json")),
        @ApiResponse(responseCode = "401", 
                    description = "Unauthorized - authentication may be required",
                    content = @Content(mediaType = "application/json")),
        @ApiResponse(responseCode = "404", 
                    description = "VTL template not found",
                    content = @Content(mediaType = "application/json")),
        @ApiResponse(responseCode = "500", 
                    description = "Internal server error during template processing",
                    content = @Content(mediaType = "application/json"))
    })
    @DELETE
    @Path("/{folder}")
    @JSONP
    @NoCache
    @Produces({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML, MediaType.TEXT_PLAIN})
    @Consumes(MediaType.APPLICATION_JSON)
    public final Response delete(@Context final HttpServletRequest request, @Context final HttpServletResponse response,
                                 @Context UriInfo uriInfo, @Parameter(description = "VTL template folder name", required = true) @PathParam("folder") final String folderName,
                                 @io.swagger.v3.oas.annotations.parameters.RequestBody(
                                     description = "Request body parameters for template processing", 
                                     content = @Content(schema = @Schema(type = "object", description = "JSON object with parameters for VTL template processing"))
                                 ) final Map<String, Object> requestJSONMap) {

        return processRequest(request, response, uriInfo, folderName, null, HTTPMethod.DELETE, requestJSONMap);
    }

    @Operation(
        summary = "Process POST multipart request with VTL template",
        description = "Same as regular POST but supporting multipart request for file uploads along with VTL template processing"
    )
    @ApiResponses(value = {
        @ApiResponse(responseCode = "200", 
                    description = "VTL template processed successfully with multipart data",
                    content = @Content(mediaType = "application/json")),
        @ApiResponse(responseCode = "400", 
                    description = "Bad request - invalid template, parameters, or multipart data",
                    content = @Content(mediaType = "application/json")),
        @ApiResponse(responseCode = "401", 
                    description = "Unauthorized - authentication may be required",
                    content = @Content(mediaType = "application/json")),
        @ApiResponse(responseCode = "404", 
                    description = "VTL template not found",
                    content = @Content(mediaType = "application/json")),
        @ApiResponse(responseCode = "500", 
                    description = "Internal server error during template processing",
                    content = @Content(mediaType = "application/json"))
    })
    @POST
    @Path("/{folder}/{pathParam: .*}")
    @JSONP
    @NoCache
    @Produces({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML, MediaType.TEXT_PLAIN})
    @Consumes(MediaType.MULTIPART_FORM_DATA)
    public final Response postMultipart(@Context final HttpServletRequest request, @Context final HttpServletResponse response,
                                        @io.swagger.v3.oas.annotations.parameters.RequestBody(
                                            description = "Multipart form data for file uploads and parameters", 
                                            content = @Content(mediaType = MediaType.MULTIPART_FORM_DATA)
                                        ) FormDataMultiPart multipart,
                                        @Parameter(description = "Additional path parameters") @PathParam("pathParam") final String pathParam,
                                        @Context UriInfo uriInfo, @Parameter(description = "VTL template folder name", required = true) @PathParam("folder") final String folderName) {

        return processMultiPartRequest(request, response, uriInfo, folderName, pathParam, HTTPMethod.POST, multipart);

    }

    @Operation(
        summary = "Process VTL template via POST with multipart form data",
        description = "Returns the output of a convention based 'post.vtl' file, located under the given folder after being evaluated using the velocity engine. Supports multipart form data for file uploads and complex data submission."
    )
    @ApiResponses(value = {
        @ApiResponse(responseCode = "200", 
                    description = "VTL template processed successfully",
                    content = @Content(mediaType = "application/json",
                                      schema = @Schema(type = "object", description = "Dynamic content generated by VTL template processing - format determined by template logic"))),
        @ApiResponse(responseCode = "400", 
                    description = "Bad request - invalid template, folder, or multipart data",
                    content = @Content(mediaType = "application/json")),
        @ApiResponse(responseCode = "401", 
                    description = "Unauthorized - authentication may be required",
                    content = @Content(mediaType = "application/json")),
        @ApiResponse(responseCode = "404", 
                    description = "VTL template not found in the specified folder",
                    content = @Content(mediaType = "application/json")),
        @ApiResponse(responseCode = "500", 
                    description = "Internal server error during template processing",
                    content = @Content(mediaType = "application/json"))
    })
    @POST
    @Path("/{folder}")
    @JSONP
    @NoCache
    @Produces({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML, MediaType.TEXT_PLAIN})
    @Consumes(MediaType.MULTIPART_FORM_DATA)
    public final Response postMultipart(@Context final HttpServletRequest request, @Context final HttpServletResponse response,
                                        @io.swagger.v3.oas.annotations.parameters.RequestBody(
                                            description = "Multipart form data containing files and form fields for VTL template processing", 
                                            content = @Content(mediaType = MediaType.MULTIPART_FORM_DATA)
                                        ) FormDataMultiPart multipart,
                                        @Context UriInfo uriInfo, 
                                        @Parameter(description = "VTL template folder name", required = true) 
                                        @PathParam("folder") final String folderName) {

        return processMultiPartRequest(request, response, uriInfo, folderName, null, HTTPMethod.POST, multipart);

    }

    /**
     * Same as {@link #put} but supporting a multipart request
     */
    @Operation(
        summary = "Process VTL template via PUT with multipart form data and path parameters",
        description = "Returns the output of a convention based 'put.vtl' file, located under the given folder after being evaluated using the velocity engine. Supports multipart form data for file uploads and complex data submission with additional path parameters."
    )
    @ApiResponses(value = {
        @ApiResponse(responseCode = "200", 
                    description = "VTL template processed successfully",
                    content = @Content(mediaType = "application/json",
                                      schema = @Schema(type = "object", description = "Dynamic content generated by VTL template processing - format determined by template logic"))),
        @ApiResponse(responseCode = "400", 
                    description = "Bad request - invalid template, folder, path parameters, or multipart data",
                    content = @Content(mediaType = "application/json")),
        @ApiResponse(responseCode = "401", 
                    description = "Unauthorized - authentication may be required",
                    content = @Content(mediaType = "application/json")),
        @ApiResponse(responseCode = "404", 
                    description = "VTL template not found in the specified folder",
                    content = @Content(mediaType = "application/json")),
        @ApiResponse(responseCode = "500", 
                    description = "Internal server error during template processing",
                    content = @Content(mediaType = "application/json"))
    })
    @PUT
    @Path("/{folder}/{pathParam: .*}")
    @JSONP
    @NoCache
    @Produces({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML, MediaType.TEXT_PLAIN})
    @Consumes(MediaType.MULTIPART_FORM_DATA)
    public final Response putMultipart(@Context final HttpServletRequest request, @Context final HttpServletResponse response,
                                        @io.swagger.v3.oas.annotations.parameters.RequestBody(
                                            description = "Multipart form data containing files and form fields for VTL template processing", 
                                            content = @Content(mediaType = MediaType.MULTIPART_FORM_DATA)
                                        ) FormDataMultiPart multipart,
                                        @Parameter(description = "Additional path parameters for VTL template processing", required = true)
                                        @PathParam("pathParam") final String pathParam,
                                        @Context UriInfo uriInfo, 
                                        @Parameter(description = "VTL template folder name", required = true)
                                        @PathParam("folder") final String folderName) {

        return processMultiPartRequest(request, response, uriInfo, folderName, pathParam, HTTPMethod.PUT, multipart);

    }

    @Operation(
        summary = "Process VTL template via PUT with multipart form data",
        description = "Returns the output of a convention based 'put.vtl' file, located under the given folder after being evaluated using the velocity engine. Supports multipart form data for file uploads and complex data submission."
    )
    @ApiResponses(value = {
        @ApiResponse(responseCode = "200", 
                    description = "VTL template processed successfully",
                    content = @Content(mediaType = "application/json",
                                      schema = @Schema(type = "object", description = "Dynamic content generated by VTL template processing - format determined by template logic"))),
        @ApiResponse(responseCode = "400", 
                    description = "Bad request - invalid template, folder, or multipart data",
                    content = @Content(mediaType = "application/json")),
        @ApiResponse(responseCode = "401", 
                    description = "Unauthorized - authentication may be required",
                    content = @Content(mediaType = "application/json")),
        @ApiResponse(responseCode = "404", 
                    description = "VTL template not found in the specified folder",
                    content = @Content(mediaType = "application/json")),
        @ApiResponse(responseCode = "500", 
                    description = "Internal server error during template processing",
                    content = @Content(mediaType = "application/json"))
    })
    @PUT
    @Path("/{folder}")
    @JSONP
    @NoCache
    @Produces({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML, MediaType.TEXT_PLAIN})
    @Consumes(MediaType.MULTIPART_FORM_DATA)
    public final Response putMultipart(@Context final HttpServletRequest request, @Context final HttpServletResponse response,
                                       @io.swagger.v3.oas.annotations.parameters.RequestBody(
                                            description = "Multipart form data containing files and form fields for VTL template processing", 
                                            content = @Content(mediaType = MediaType.MULTIPART_FORM_DATA)
                                        ) final FormDataMultiPart multipart,
                                       @Context final UriInfo uriInfo, 
                                       @Parameter(description = "VTL template folder name", required = true)
                                       @PathParam("folder") final String folderName) {

        return processMultiPartRequest(request, response, uriInfo, folderName, null, HTTPMethod.PUT, multipart);
    }

    /**
     * Same as {@link #patch} but supporting a multipart request
     */
    @Operation(
        summary = "Process VTL template via PATCH with multipart form data and path parameters",
        description = "Returns the output of a convention based 'patch.vtl' file, located under the given folder after being evaluated using the velocity engine. Supports multipart form data for file uploads and complex data submission with additional path parameters."
    )
    @ApiResponses(value = {
        @ApiResponse(responseCode = "200", 
                    description = "VTL template processed successfully",
                    content = @Content(mediaType = "application/json",
                                      schema = @Schema(type = "object", description = "Dynamic content generated by VTL template processing - format determined by template logic"))),
        @ApiResponse(responseCode = "400", 
                    description = "Bad request - invalid template, folder, path parameters, or multipart data",
                    content = @Content(mediaType = "application/json")),
        @ApiResponse(responseCode = "401", 
                    description = "Unauthorized - authentication may be required",
                    content = @Content(mediaType = "application/json")),
        @ApiResponse(responseCode = "404", 
                    description = "VTL template not found in the specified folder",
                    content = @Content(mediaType = "application/json")),
        @ApiResponse(responseCode = "500", 
                    description = "Internal server error during template processing",
                    content = @Content(mediaType = "application/json"))
    })
    @PATCH
    @Path("/{folder}/{pathParam: .*}")
    @JSONP
    @NoCache
    @Produces({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML, MediaType.TEXT_PLAIN})
    @Consumes(MediaType.MULTIPART_FORM_DATA)
    public final Response patchMultipart(@Context final HttpServletRequest request, @Context final HttpServletResponse response,
                                        @io.swagger.v3.oas.annotations.parameters.RequestBody(
                                            description = "Multipart form data containing files and form fields for VTL template processing", 
                                            content = @Content(mediaType = MediaType.MULTIPART_FORM_DATA)
                                        ) FormDataMultiPart multipart,
                                        @Parameter(description = "Additional path parameters for VTL template processing", required = true)
                                        @PathParam("pathParam") final String pathParam,
                                        @Context UriInfo uriInfo, 
                                        @Parameter(description = "VTL template folder name", required = true)
                                        @PathParam("folder") final String folderName) {

        return processMultiPartRequest(request, response, uriInfo, folderName, pathParam, HTTPMethod.PATCH, multipart);

    }

    @Operation(
        summary = "Process VTL template via PATCH with multipart form data",
        description = "Returns the output of a convention based 'patch.vtl' file, located under the given folder after being evaluated using the velocity engine. Supports multipart form data for file uploads and complex data submission."
    )
    @ApiResponses(value = {
        @ApiResponse(responseCode = "200", 
                    description = "VTL template processed successfully",
                    content = @Content(mediaType = "application/json",
                                      schema = @Schema(type = "object", description = "Dynamic content generated by VTL template processing - format determined by template logic"))),
        @ApiResponse(responseCode = "400", 
                    description = "Bad request - invalid template, folder, or multipart data",
                    content = @Content(mediaType = "application/json")),
        @ApiResponse(responseCode = "401", 
                    description = "Unauthorized - authentication may be required",
                    content = @Content(mediaType = "application/json")),
        @ApiResponse(responseCode = "404", 
                    description = "VTL template not found in the specified folder",
                    content = @Content(mediaType = "application/json")),
        @ApiResponse(responseCode = "500", 
                    description = "Internal server error during template processing",
                    content = @Content(mediaType = "application/json"))
    })
    @PATCH
    @Path("/{folder}")
    @JSONP
    @NoCache
    @Produces({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML, MediaType.TEXT_PLAIN})
    @Consumes(MediaType.MULTIPART_FORM_DATA)
    public final Response patchMultipart(@Context final HttpServletRequest request, @Context final HttpServletResponse response,
                                         @io.swagger.v3.oas.annotations.parameters.RequestBody(
                                            description = "Multipart form data containing files and form fields for VTL template processing", 
                                            content = @Content(mediaType = MediaType.MULTIPART_FORM_DATA)
                                        ) final FormDataMultiPart multipart,
                                         @Context final UriInfo uriInfo, 
                                         @Parameter(description = "VTL template folder name", required = true)
                                         @PathParam("folder") final String folderName) {

        return processMultiPartRequest(request, response, uriInfo, folderName, null, HTTPMethod.PATCH, multipart);
    }

    @Operation(
        summary = "Process dynamic GET request with embedded VTL",
        description = "Same as regular GET but supporting sending the velocity to be rendered embedded (properly escaped) in the JSON in a 'velocity' property"
    )
    @ApiResponses(value = {
        @ApiResponse(responseCode = "200", 
                    description = "Dynamic VTL template processed successfully",
                    content = @Content(mediaType = "application/json")),
        @ApiResponse(responseCode = "400", 
                    description = "Bad request - invalid embedded velocity template",
                    content = @Content(mediaType = "application/json")),
        @ApiResponse(responseCode = "401", 
                    description = "Unauthorized - authentication may be required",
                    content = @Content(mediaType = "application/json")),
        @ApiResponse(responseCode = "500", 
                    description = "Internal server error during template processing",
                    content = @Content(mediaType = "application/json"))
    })
    @GET
    @Path("/dynamic/{pathParam:.*}")
    @NoCache
    @Produces({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML, MediaType.TEXT_PLAIN})
    @Consumes({MediaType.APPLICATION_JSON, MediaType.TEXT_PLAIN})
    public Response dynamicGet(@Context final HttpServletRequest request, @Context final HttpServletResponse response,
                               @Context UriInfo uriInfo, @Parameter(description = "Additional path parameters") @PathParam("pathParam") final String pathParam,
                               @io.swagger.v3.oas.annotations.parameters.RequestBody(
                                   description = "JSON string or plain text containing embedded velocity template", 
                                   content = @Content(schema = @Schema(type = "string"))
                               ) final String bodyMapString) {

        final Map<String, Object> bodyMap = parseBodyMap(bodyMapString);

        return processRequest(request, response, uriInfo, null, pathParam, HTTPMethod.GET, bodyMap);
    }

    @Operation(
        summary = "Process dynamic VTL template",
        description = "Executes a dynamically provided Velocity template sent in the request body. The template code is embedded in the request and processed on-demand without requiring a file on the server."
    )
    @ApiResponses(value = {
        @ApiResponse(responseCode = "200", 
                    description = "Dynamic VTL template processed successfully",
                    content = @Content(mediaType = "application/json")),
        @ApiResponse(responseCode = "400", 
                    description = "Bad request - invalid template syntax or parameters",
                    content = @Content(mediaType = "application/json")),
        @ApiResponse(responseCode = "401", 
                    description = "Unauthorized - authentication may be required",
                    content = @Content(mediaType = "application/json")),
        @ApiResponse(responseCode = "500", 
                    description = "Internal server error during template processing",
                    content = @Content(mediaType = "application/json"))
    })
    @GET
    @Path("/dynamic")
    @NoCache
    @Produces({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML, MediaType.TEXT_PLAIN})
    @Consumes({MediaType.APPLICATION_JSON, MediaType.TEXT_PLAIN})
    public Response dynamicGet(@Context final HttpServletRequest request, @Context final HttpServletResponse response,
                               @Context UriInfo uriInfo,
                               @io.swagger.v3.oas.annotations.parameters.RequestBody(
                                   description = "JSON string or plain text containing embedded velocity template", 
                                   content = @Content(schema = @Schema(type = "string"))
                               ) final String bodyMapStr) {

        return dynamicGet(request, response, uriInfo, null,bodyMapStr);
    }

    /**
     * Same as {@link #post} but supporting sending the velocity to be rendered embedded (properly escaped) in the JSON
     * in a "velocity" property
     */
    @Operation(
        summary = "Process dynamic VTL template via POST with path parameters",
        description = "Executes a dynamically provided Velocity template sent in the request body via POST method. The template code is embedded in the request and processed on-demand without requiring a file on the server."
    )
    @ApiResponses(value = {
        @ApiResponse(responseCode = "200", 
                    description = "Dynamic VTL template processed successfully",
                    content = @Content(mediaType = "application/json")),
        @ApiResponse(responseCode = "400", 
                    description = "Bad request - invalid template syntax or parameters",
                    content = @Content(mediaType = "application/json")),
        @ApiResponse(responseCode = "401", 
                    description = "Unauthorized - authentication may be required",
                    content = @Content(mediaType = "application/json")),
        @ApiResponse(responseCode = "500", 
                    description = "Internal server error during template processing",
                    content = @Content(mediaType = "application/json"))
    })
    @POST
    @Path("/dynamic/{pathParam:.*}")
    @NoCache
    @Produces({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML, MediaType.TEXT_PLAIN})
    @Consumes({MediaType.APPLICATION_JSON, MediaType.TEXT_PLAIN})
    public Response dynamicPost(@Context final HttpServletRequest request, @Context final HttpServletResponse response,
                                @Context UriInfo uriInfo, 
                                @Parameter(description = "Additional path parameters for VTL template processing") 
                                @PathParam("pathParam") final String pathParam,
                                @io.swagger.v3.oas.annotations.parameters.RequestBody(
                                    description = "JSON string or plain text containing embedded velocity template",
                                    content = @Content(schema = @Schema(type = "string"))
                                ) final String bodyMapString) {

        final Map<String, Object> bodyMap = parseBodyMap(bodyMapString);

        return processRequest(request, response, uriInfo, null, pathParam, HTTPMethod.POST, bodyMap);
    }

    @Operation(
        summary = "Process dynamic VTL template via POST",
        description = "Executes a dynamically provided Velocity template sent in the request body via POST method. The template code is embedded in the request and processed on-demand without requiring a file on the server."
    )
    @ApiResponses(value = {
        @ApiResponse(responseCode = "200", 
                    description = "Dynamic VTL template processed successfully",
                    content = @Content(mediaType = "application/json")),
        @ApiResponse(responseCode = "400", 
                    description = "Bad request - invalid template syntax or parameters",
                    content = @Content(mediaType = "application/json")),
        @ApiResponse(responseCode = "401", 
                    description = "Unauthorized - authentication may be required",
                    content = @Content(mediaType = "application/json")),
        @ApiResponse(responseCode = "500", 
                    description = "Internal server error during template processing",
                    content = @Content(mediaType = "application/json"))
    })
    @POST
    @Path("/dynamic")
    @NoCache
    @Produces({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML, MediaType.TEXT_PLAIN})
    @Consumes({MediaType.APPLICATION_JSON, MediaType.TEXT_PLAIN})
    public Response dynamicPost(@Context final HttpServletRequest request, @Context final HttpServletResponse response,
                                @Context UriInfo uriInfo,
                                @io.swagger.v3.oas.annotations.parameters.RequestBody(
                                    description = "JSON string or plain text containing embedded velocity template",
                                    content = @Content(schema = @Schema(type = "string"))
                                ) final String bodyMapString) {

        return dynamicPost(request, response, uriInfo, null, bodyMapString);
    }

    /**
     * Same as {@link #put} but supporting sending the velocity to be rendered embedded (properly escaped) in the JSON
     * in a "velocity" property
     */
    @Operation(
        summary = "Process dynamic VTL template via PUT with path parameters",
        description = "Executes a dynamically provided Velocity template sent in the request body via PUT method. The template code is embedded in the request and processed on-demand without requiring a file on the server."
    )
    @ApiResponses(value = {
        @ApiResponse(responseCode = "200", 
                    description = "Dynamic VTL template processed successfully",
                    content = @Content(mediaType = "application/json")),
        @ApiResponse(responseCode = "400", 
                    description = "Bad request - invalid template syntax or parameters",
                    content = @Content(mediaType = "application/json")),
        @ApiResponse(responseCode = "401", 
                    description = "Unauthorized - authentication may be required",
                    content = @Content(mediaType = "application/json")),
        @ApiResponse(responseCode = "500", 
                    description = "Internal server error during template processing",
                    content = @Content(mediaType = "application/json"))
    })
    @PUT
    @Path("/dynamic/{pathParam:.*}")
    @NoCache
    @Produces({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML, MediaType.TEXT_PLAIN})
    @Consumes({MediaType.APPLICATION_JSON, MediaType.TEXT_PLAIN})
    public Response dynamicPut(@Context final HttpServletRequest request, @Context final HttpServletResponse response,
                               @Context UriInfo uriInfo, 
                               @Parameter(description = "Additional path parameters for VTL template processing") 
                               @PathParam("pathParam") final String pathParam,
                               @io.swagger.v3.oas.annotations.parameters.RequestBody(
                                   description = "JSON string or plain text containing embedded velocity template",
                                   content = @Content(schema = @Schema(type = "string"))
                               ) final String bodyMapString) {

        final Map<String, Object> bodyMap = parseBodyMap(bodyMapString);

        return processRequest(request, response, uriInfo, null, pathParam, HTTPMethod.PUT, bodyMap);
    }

    @Operation(
        summary = "Process dynamic VTL template via PUT",
        description = "Executes a dynamically provided Velocity template sent in the request body via PUT method. The template code is embedded in the request and processed on-demand without requiring a file on the server."
    )
    @ApiResponses(value = {
        @ApiResponse(responseCode = "200", 
                    description = "Dynamic VTL template processed successfully",
                    content = @Content(mediaType = "application/json")),
        @ApiResponse(responseCode = "400", 
                    description = "Bad request - invalid template syntax or parameters",
                    content = @Content(mediaType = "application/json")),
        @ApiResponse(responseCode = "401", 
                    description = "Unauthorized - authentication may be required",
                    content = @Content(mediaType = "application/json")),
        @ApiResponse(responseCode = "500", 
                    description = "Internal server error during template processing",
                    content = @Content(mediaType = "application/json"))
    })
    @PUT
    @Path("/dynamic")
    @NoCache
    @Produces({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML, MediaType.TEXT_PLAIN})
    @Consumes({MediaType.APPLICATION_JSON, MediaType.TEXT_PLAIN})
    public Response dynamicPut(@Context final HttpServletRequest request, @Context final HttpServletResponse response,
                               @Context final UriInfo uriInfo,
                               @io.swagger.v3.oas.annotations.parameters.RequestBody(
                                   description = "JSON string or plain text containing embedded velocity template",
                                   content = @Content(schema = @Schema(type = "string"))
                               ) final String bodyMapString) {

        return dynamicPut(request, response, uriInfo, null, bodyMapString);
    }

    /**
     * Same as {@link #patch} but supporting sending the velocity to be rendered embedded (properly escaped) in the JSON
     * in a "velocity" property
     */
    @Operation(
        summary = "Process dynamic VTL template via PATCH with path parameters",
        description = "Executes a dynamically provided Velocity template sent in the request body via PATCH method. The template code is embedded in the request and processed on-demand without requiring a file on the server."
    )
    @ApiResponses(value = {
        @ApiResponse(responseCode = "200", 
                    description = "Dynamic VTL template processed successfully",
                    content = @Content(mediaType = "application/json")),
        @ApiResponse(responseCode = "400", 
                    description = "Bad request - invalid template syntax or parameters",
                    content = @Content(mediaType = "application/json")),
        @ApiResponse(responseCode = "401", 
                    description = "Unauthorized - authentication may be required",
                    content = @Content(mediaType = "application/json")),
        @ApiResponse(responseCode = "500", 
                    description = "Internal server error during template processing",
                    content = @Content(mediaType = "application/json"))
    })
    @PATCH
    @Path("/dynamic/{pathParam:.*}")
    @NoCache
    @Produces({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML, MediaType.TEXT_PLAIN})
    @Consumes({MediaType.APPLICATION_JSON, MediaType.TEXT_PLAIN})
    public Response dynamicPatch(@Context final HttpServletRequest request, @Context final HttpServletResponse response,
                                 @Context UriInfo uriInfo, 
                                 @Parameter(description = "Additional path parameters for VTL template processing") 
                                 @PathParam("pathParam") final String pathParam,
                                 @io.swagger.v3.oas.annotations.parameters.RequestBody(
                                     description = "JSON string or plain text containing embedded velocity template",
                                     content = @Content(schema = @Schema(type = "string"))
                                 ) final String bodyMapString) {

        final Map<String, Object> bodyMap = parseBodyMap(bodyMapString);

        return processRequest(request, response, uriInfo, null, pathParam, HTTPMethod.PATCH, bodyMap);
    }


    /**
     * Same as {@link #delete} but supporting sending the velocity to be rendered embedded (properly escaped) in the JSON
     * in a "velocity" property
     */
    @Operation(
        summary = "Process dynamic VTL template via DELETE with path parameters",
        description = "Executes a dynamically provided Velocity template sent in the request body via DELETE method. The template code is embedded in the request and processed on-demand without requiring a file on the server."
    )
    @ApiResponses(value = {
        @ApiResponse(responseCode = "200", 
                    description = "Dynamic VTL template processed successfully",
                    content = @Content(mediaType = "application/json")),
        @ApiResponse(responseCode = "400", 
                    description = "Bad request - invalid template syntax or parameters",
                    content = @Content(mediaType = "application/json")),
        @ApiResponse(responseCode = "401", 
                    description = "Unauthorized - authentication may be required",
                    content = @Content(mediaType = "application/json")),
        @ApiResponse(responseCode = "500", 
                    description = "Internal server error during template processing",
                    content = @Content(mediaType = "application/json"))
    })
    @DELETE
    @Path("/dynamic/{pathParam:.*}")
    @NoCache
    @Produces({MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML, MediaType.TEXT_PLAIN})
    @Consumes({MediaType.APPLICATION_JSON, MediaType.TEXT_PLAIN})
    public Response dynamicDelete(@Context final HttpServletRequest request, @Context final HttpServletResponse response,
                                  final @Context UriInfo uriInfo, 
                                  @Parameter(description = "Additional path parameters for VTL template processing") 
                                  @PathParam("pathParam") final String pathParam,
                                  @io.swagger.v3.oas.annotations.parameters.RequestBody(
                                      description = "JSON string or plain text containing embedded velocity template",
                                      content = @Content(schema = @Schema(type = "string"))
                                  ) final String bodyMapString) {

        final Map<String, Object> bodyMap = parseBodyMap(bodyMapString);

        return processRequest(request, response, uriInfo, null, pathParam, HTTPMethod.DELETE, bodyMap);
    }

    private Response processMultiPartRequest(final HttpServletRequest request, final HttpServletResponse response,
                                    final UriInfo uriInfo, final String folderName,
                                    final String pathParam,
                                    final HTTPMethod httpMethod,
                                             final FormDataMultiPart multipart) {
        try {
            final List<File> binaries = getBinariesFromMultipart(multipart);
            final Map<String, Object> bodyMap = getBodyMapFromMultipart(multipart);

            return processRequest(request, response, uriInfo, folderName, pathParam, httpMethod, bodyMap,
                    binaries.toArray(new File[0]));
        }  catch(Exception e) {
            Logger.error(this,"Exception on VTL endpoint. POST method: " + e.getMessage(), e);
            return ResponseUtil.mapExceptionResponse(e);
        }
    }

    private Response processRequest(final HttpServletRequest request, final HttpServletResponse response,
                                    final UriInfo uriInfo, final String folderName,
                                    final String pathParam,
                                    final HTTPMethod httpMethod,
                                    final Map<String, Object> bodyMap,
                                    final File...binaries) {

        try {

            ScriptingUtil.getInstance().validateBodyMap(bodyMap, httpMethod);

            final InitDataObject initDataObject = this.webResource.init
                    (null, request, response, false, null);

            final User user = initDataObject.getUser();


            final DotJSONCache cache = DotJSONCacheFactory.getCache(httpMethod);
            final Optional<DotJSON> dotJSONOptional = cache.get(request, user);

            if(dotJSONOptional.isPresent()) {
                return Response.ok(dotJSONOptional.get().getMap()).build();
            }

            final ScriptingReaderParams velocityReaderParams = new ScriptingReaderParams.ScriptingReaderParamsBuilder()
                    .setBodyMap(bodyMap)
                    .setFolderName(folderName)
                    .setHttpMethod(httpMethod)
                    .setRequest(request)
                    .setUser(user)
                    .setPageMode(PageMode.get(request))
                    .build();

            final VelocityReader velocityReader = VelocityReaderFactory.getVelocityReader(UtilMethods.isSet(folderName));

            final Map<String, Object> contextParams = new HashMap<>();

            contextParams.put("pathParam", pathParam);
            contextParams.put("queryParams", uriInfo.getQueryParameters());
            contextParams.put("bodyMap", bodyMap);
            contextParams.put("binaries", Arrays.asList(binaries));

            try(Reader reader = velocityReader.getVelocity(velocityReaderParams)){
                return evalVelocity(request, response, reader, contextParams,
                    initDataObject.getUser(), cache);
            }
        }  catch(Exception e) {
            Logger.error(this,"Exception on VTL endpoint. GET method: " + e.getMessage(), e);
            return ResponseUtil.mapExceptionResponse(e);
        }
    }

    private Response evalVelocity(final HttpServletRequest request, final HttpServletResponse response,
                                  final Reader velocityReader, final Map<String, Object> contextParams,
                                  final User user, final DotJSONCache cache)
            throws Exception {
        final org.apache.velocity.context.Context context = VelocityUtil.getInstance().getContext(request, response);
        contextParams.forEach(context::put);
        context.put("dotJSON", new DotJSON());

        final StringWriter evalResult = new StringWriter();

        try {
            VelocityUtil.getEngine().evaluate(context, evalResult, "", velocityReader);
        } catch(MethodInvocationException e) {
            if(e.getCause() instanceof DotToolException) {
                Logger.error(this,"Error evaluating velocity: " + (e.getCause()).getCause().getMessage());
                throw (Exception) (e.getCause()).getCause();
            }
        }
        final DotJSON dotJSON = (DotJSON) context.get("dotJSON");

        if(dotJSON.size()==0) { // If dotJSON is not used let's return the raw evaluation of the velocity file
            final HttpServletResponse velocityResponse = (HttpServletResponse) context.get("response");
            
            final String contentType = (velocityResponse!=null && velocityResponse.getContentType()!=null) ? velocityResponse.getContentType() : MediaType.TEXT_PLAIN_TYPE.toString();
            if(velocityResponse!=null && velocityResponse.getHeaderNames()!=null){
              for(final String  headerName : velocityResponse.getHeaderNames()) {
                response.setHeader(headerName, velocityResponse.getHeader(headerName));
              }
            }

            return UtilMethods.isSet(contentType)
                    ? Response.ok(evalResult.toString()).type(contentType).build()
                    : Response.ok(evalResult.toString()).type(MediaType.TEXT_PLAIN_TYPE).build();

        } else {
            // let's add it to cache
            if(UtilMethods.isSet(dotJSON.get("errors"))) {
                return Response.status(Response.Status.BAD_REQUEST).entity(dotJSON.get("errors")).build();
            }

            cache.add(request, user, dotJSON);
            return Response.ok(dotJSON.getMap()).build();
        }
    }

    private Map<String, Object> getBodyMapFromMultipart(final FormDataMultiPart multipart) throws IOException, JSONException {

        return this.multiPartUtils.getBodyMapFromMultipart(multipart);
    }

    private List<File> getBinariesFromMultipart(final FormDataMultiPart multipart) throws IOException {

        return this.multiPartUtils.getBinariesFromMultipart(multipart);
    }

    private Map<String, Object> parseBodyMap(final String bodyMapString) {
        Map<String, Object> bodyMap = new HashMap<>();

        // 1) try parsing as is
        try {
            bodyMap = new ObjectMapper().readValue(bodyMapString, HashMap.class);

            if(bodyMap.containsKey(VELOCITY)){
                bodyMap.put(VELOCITY, ScriptingUtil.getInstance().unescapeValue((String)bodyMap.get(VELOCITY), "\n"));
            }
        } catch (IOException e) {
            // 2) let's try escaping then parsing
            String escapedJsonValues = ScriptingUtil.getInstance().escapeJsonValues(bodyMapString, '\n');

            try {
                bodyMap = new ObjectMapper().readValue(escapedJsonValues, HashMap.class);

                if(bodyMap.containsKey(VELOCITY)){
                    bodyMap.put(VELOCITY, ScriptingUtil.getInstance().unescapeValue((String)bodyMap.get(VELOCITY), "\n"));
                }
            } catch (IOException e1) {
                bodyMap.put(VELOCITY, bodyMapString);
            }
        }

        return bodyMap;
    }



}
