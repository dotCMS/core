<script type="module">
  // Global Constants
  const initialHostId =
    "$request.getSession().getAttribute('CMS_SELECTED_HOST_ID')";
  const defaultTemplateName =
    '$config.getStringProperty("DEFAULT_TEMPLATE_NAME", "System Template")';

  // Configuration constants
  const DEFAULT_PER_PAGE = 15;
  const ALL_SITES_IDENTIFIER = "0";
  const SYSTEM_HOST = "System Host";
  const ALL_SITES_TITLE = "All Sites";
  const ALL_SITES_FORMATTED = "-- All Sites ---";

  // UTILS
  /**
   * Normalizes the key of a template
   */
  const normalizeKey = function (template) {
    return template.fullTitle
      .replace(new RegExp("\\(" + template.hostName + "\\)"), "")
      .replace(/\s+/g, "")
      .toLowerCase();
  }; // [cite: 3]

  /**
   * Returns a map of templates by name and by id
   */
  const getTemplatesMaps = (templates) => {
    const mapByName = templates.reduce(function (map, template) {
      const key = normalizeKey(template);
      if (!map[key]) {
        map[key] = template;
      }
      return map;
    }, {});

    const mapById = templates.reduce(function (map, template) {
      map[template.identifier] = template;
      return map;
    }, {}); // [cite: 5]

    return {
      mapByName,
      mapById,
    };
  };

  /**
   * Validates if an inode is set and valid
   * @param {string} inode - The inode to validate
   * @returns {boolean} - True if inode is valid, false otherwise
   */
  function isInodeSet(inode) {
    if (!inode) {
      return false;
    }

    if (inode === "SYSTEM_HOST" || inode === "SYSTEM_FOLDER") {
      return true;
    }

    const inodeStr = String(inode);

    // UUID format: 8-4-4-4-12 hexadecimal characters (with or without hyphens)
    const validUUIDRegex =
      /^[a-f0-9]{8}-?[a-f0-9]{4}-?[a-f0-9]{4}-?[a-f0-9]{4}-?[a-f0-9]{12}$/i;
    // Older numeric inode format
    const olderInodeRegex = /^\d+$/;

    if (validUUIDRegex.test(inodeStr)) {
      return true;
    }

    if (olderInodeRegex.test(inodeStr) && inodeStr !== "0") {
      return true;
    }

    return false;
  }

  /**
   * Helper function to safely get DOM element
   * @param {string} id - Element ID
   * @returns {HTMLElement|null} - The element or null if not found
   */
  function getElement(id) {
    return document.getElementById(id);
  }

  /**
   * Updates the selected state of options in dropdown
   * @param {HTMLElement} dropdown - The dropdown element
   * @param {string} identifier - The identifier of the selected option
   */
  function updateSelectedOption(dropdown, identifier) {
    const options = dropdown.querySelectorAll("[data-option]");
    options.forEach((opt) => {
      opt.classList.remove("active", "bg-base-200");
      if (opt.dataset.identifier === identifier) {
        opt.classList.add("active", "bg-base-200");
      }
    });
  }

  /**
   * Shows or hides the template thumbnail container
   * @param {boolean} show - Whether to show or hide the container
   */
  function toggleThumbnailContainer(show) {
    const container = getElement("templateThumbnailContainer");
    if (container) {
      if (show) {
        container.classList.remove("hidden");
      } else {
        container.classList.add("hidden");
      }
    }
  }

  // UTILS END

  /**
   * Fetches a single template by ID (used when selected template is not in first page)
   */
  async function fetchTemplateById(templateId) {
    try {
      const response = await fetch(`/api/v1/templates/${templateId}/working`);
      if (response.ok) {
        const data = await response.json();
        return data.entity || null;
      }
    } catch (error) {
      console.warn(
        "Failed to fetch template by ID, returning null. Template may have been deleted or an error occurred.",
        {
          templateId,
          error,
        },
      );
    }
    return null;
  }

  /**
   * Fetches the template image from the server
   */
  async function fetchTemplateImage(templateId) {
    try {
      const response = await fetch("/api/v1/templates/image", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ templateId }),
      });

      // The ok value represents the result of the response status 200 codes
      if (response.ok) {
        const result = await response.json();
        getTemplateCallBack(result); // here we pass the result of the json response to the callback function
      } else {
        throw new Error("Error fetching template image");
      }
    } catch (error) {
      toggleThumbnailContainer(false);
    }
  }

  /**
   * Fetches templates from the API
   */
  async function fetchTemplates(queryParams) {
    const {
      hostId,
      filter = "",
      page = 1,
      perPage = 15,
      allSiteLabel = true,
    } = queryParams;
    const urlParams = new URLSearchParams();
    urlParams.set("per_page", perPage);
    urlParams.set("page", page);
    urlParams.set("filter", filter);

    if (hostId) {
      urlParams.set("host", hostId);
    }

    const url = `/api/v1/templates/?${urlParams.toString()}`;
    const response = await fetch(url);

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    const data = await response.json();

    const templates = data.entity || [];

    // Calculate hasMore BEFORE adding "All Sites" to avoid affecting pagination logic
    // Use pagination info from API response if available, otherwise fallback to length check
    let hasMore = false;
    if (data.pagination) {
      const {
        currentPage: apiCurrentPage,
        perPage: apiPerPage,
        totalEntries,
      } = data.pagination;
      // Check if there are more pages available
      hasMore = apiCurrentPage * apiPerPage < totalEntries;
    } else {
      // Fallback: check if we got a full page of results
      hasMore = templates.length === perPage;
    }

    // Check for first page and add the all site template, so it does not break the pagination
    // This matches the ALL_SITE_TEMPLATE from TemplateReadStore.js
    if (allSiteLabel && page === 1) {
      const ALL_SITE_TEMPLATE = {
        title: ALL_SITES_TITLE,
        fullTitle: ALL_SITES_TITLE,
        htmlTitle: `<div>${ALL_SITES_FORMATTED}</div>`,
        identifier: ALL_SITES_IDENTIFIER,
        inode: ALL_SITES_IDENTIFIER,
        hostName: SYSTEM_HOST,
      };
      templates.unshift(ALL_SITE_TEMPLATE);
    }

    return {
      templates,
      hasMore,
      currentPage: page,
    };
  }

  /**
   * Callback function to handle the template fetch
   */
  const onTemplateFetchComplete = async function (
    templates,
    templateField,
    selectedTemplate,
  ) {
    const templateId = templateField.getValue() || "";
    const isTemplateValid = templateId && templateId !== ALL_SITES_IDENTIFIER;

    if (!templates || templates.length === 0) {
      // If no templates, show "All Sites" as placeholder
      updateSelectButton(null);
      return;
    }

    let template = selectedTemplate;

    if (!template) {
      const { mapById, mapByName } = getTemplatesMaps(templates);
      const normalizedName = defaultTemplateName
        .replace(/\s+/g, "")
        .toLowerCase();
      template = isTemplateValid
        ? mapById[templateId]
        : mapByName[normalizedName]; // [cite: 18]
    }

    // When selected template is not in first page (e.g. user chose from page 2 and came back),
    // fetch it by ID so the correct option is displayed
    if (!template && isTemplateValid) {
      template = await fetchTemplateById(templateId);
    }

    if (!template) {
      // If no template found, show "All Sites" as placeholder
      updateSelectButton(null);
      return;
    }

    const { identifier, fullTitle } = template;
    // We set the values directly into the components
    const currentTemplateIdElement = getElement("currentTemplateId");
    if (currentTemplateIdElement) {
      currentTemplateIdElement.value = identifier;
    }
    templateField.setValue(identifier);

    updateSelectButton(template);

    // Update selected state in dropdown
    const dropdown = getElement("customDropdown");
    if (dropdown) {
      updateSelectedOption(dropdown, identifier);
    }

    fetchTemplateImage(identifier);
  };

  function resetTemplateSelection(templateField) {
    templateField.setValue("");

    const currentTemplateIdElement = getElement("currentTemplateId");
    if (currentTemplateIdElement) {
      currentTemplateIdElement.value = "";
    }

    updateSelectButton(null);

    // Update selected state in dropdown
    const dropdown = getElement("customDropdown");
    if (dropdown) {
      const options = dropdown.querySelectorAll("[data-option]");
      options.forEach((opt) => {
        opt.classList.remove("active");
      });
    }

    toggleThumbnailContainer(false);
  }

  /**
   * Get the template callback
   */
  function getTemplateCallBack(data) {
    const imageInode = data.identifier;
    const imageEl = getElement("templateThumbnailHolder");

    if (!imageEl) {
      return;
    }

    if (isInodeSet(imageInode)) {
      imageEl.src = `/dA/${imageInode}/250w`;
      toggleThumbnailContainer(true);
    } else {
      toggleThumbnailContainer(false);
    }
  }

  /**
   * Extracts hostName from template
   */
  function getHostName(template) {
    if (template.hostName) {
      return template.hostName;
    }

    // Try to extract from fullTitle if it contains hostname in parentheses
    const fullTitle = template.fullTitle || template.title || "";
    const match = fullTitle.match(/\(([^)]+)\)/);
    if (match) {
      return match[1];
    }

    return SYSTEM_HOST;
  }

  /**
   * Gets clean title without hostname in parentheses
   */
  function getCleanTitle(template) {
    const fullTitle = template.fullTitle || template.title || "";

    // For "All Sites", return the formatted version
    if (
      template.identifier === ALL_SITES_IDENTIFIER ||
      fullTitle === ALL_SITES_TITLE
    ) {
      return ALL_SITES_FORMATTED;
    }

    // Remove hostname in parentheses if present
    return fullTitle.replace(/\s*\([^)]+\)\s*$/, "").trim();
  }

  /**
   * Creates an option element for the DaisyUI dropdown menu
   */
  function createOptionElement(template, selectedValue) {
    const option = document.createElement("li");
    option.setAttribute("data-option", "");
    option.dataset.identifier = template.identifier;

    const hostName = getHostName(template);
    option.dataset.hostName = hostName;

    // DaisyUI menu item: one solid block, one hover for the whole option
    option.classList.add(
      "cursor-pointer",
      "rounded-btn",
      "py-2",
      "px-3",
      "flex",
      "flex-col",
      "gap-0",
      "leading-tight",
      "bg-white-100",
      "hover:bg-white-200",
      "transition-colors",
    );

    if (template.identifier === selectedValue) {
      option.classList.add("active", "bg-base-200");
    }

    if (template.identifier === ALL_SITES_IDENTIFIER) {
      option.classList.add("text-base-content/70");
    }

    // Primary line: title (strong) – no own hover, part of the single option block
    const title = document.createElement("strong");
    title.className =
      "block text-sm font-semibold text-base-content leading-tight pointer-events-none";

    if (template.identifier === ALL_SITES_IDENTIFIER) {
      if (template.htmlTitle) {
        const tempDiv = document.createElement("div");
        tempDiv.innerHTML = template.htmlTitle;
        title.textContent = tempDiv.textContent || ALL_SITES_FORMATTED;
      } else {
        title.textContent = ALL_SITES_FORMATTED;
      }
    } else {
      title.textContent = getCleanTitle(template);
    }

    // Secondary line: host/site (small) – no own hover, part of the single option block
    const subtitle = document.createElement("small");
    subtitle.className =
      "block text-xs text-base-content/60 font-normal leading-tight mt-0.5 pointer-events-none";
    subtitle.textContent = hostName;

    option.appendChild(title);
    option.appendChild(subtitle);

    return option;
  }

  /**
   * Creates and populates the custom dropdown
   */
  function populateCustomDropdown(templates, selectedValue, append = false) {
    const dropdown = getElement("customDropdown");
    if (!dropdown) {
      return;
    }

    const moreChoicesButton = getElement("moreChoicesButton");

    if (!append) {
      const existingOptions = dropdown.querySelectorAll("[data-option]");
      existingOptions.forEach((opt) => opt.remove());
    }

    templates.forEach((template) => {
      const option = createOptionElement(template, selectedValue);
      // Insert before the more choices button
      if (moreChoicesButton) {
        dropdown.insertBefore(option, moreChoicesButton);
      } else {
        dropdown.appendChild(option);
      }
    });
  }

  /**
   * Sets the select button label (span only, keeps PrimeNG chevron icon)
   */
  function setSelectButtonLabel(text) {
    const labelSpan = getElement("templateSelectButtonLabel");
    if (labelSpan) labelSpan.textContent = text;
    else {
      const button = getElement("customSelectButton");
      if (button) button.textContent = text;
    }
  }

  /**
   * Updates the button text with selected template
   */
  function updateSelectButton(template) {
    const button = getElement("customSelectButton");
    if (!button) {
      return;
    }

    if (template && template.identifier !== ALL_SITES_IDENTIFIER) {
      setSelectButtonLabel(getCleanTitle(template));
      button.classList.remove("opacity-60");
    } else {
      setSelectButtonLabel(ALL_SITES_TITLE);
      button.classList.add("opacity-60");
    }
  }

  /**
   * Handles the template selection
   */
  function handleTemplateSelection(
    template,
    templateField,
    setAllSiteLabel,
    reloadTemplates,
  ) {
    if (!template) {
      resetTemplateSelection(templateField);
      return;
    }

    const value = template.identifier;
    if (!value || value === ALL_SITES_IDENTIFIER) {
      // Handle all sites selection - similar to handleAllSiteClick in old code
      if (setAllSiteLabel) {
        setAllSiteLabel(false);
      }

      // Change hostId to "*" to show all sites templates
      if (reloadTemplates) {
        reloadTemplates("*", false);
      }

      resetTemplateSelection(templateField);
      return;
    }

    templateField.setValue(value);

    const currentTemplateIdElement = getElement("currentTemplateId");
    if (currentTemplateIdElement) {
      currentTemplateIdElement.value = value;
    }

    updateSelectButton(template);

    // Update selected state in dropdown
    const dropdown = getElement("customDropdown");
    if (dropdown) {
      updateSelectedOption(dropdown, value);
    }

    closeDropdown();
    fetchTemplateImage(value);
  }

  /**
   * Opens the DaisyUI dropdown (details element).
   * Per Daisy UI: open/close via JS by adding/removing the "open" attribute.
   */
  function openDropdown() {
    const holder = getElement("templateHolder");
    if (holder && holder.tagName === "DETAILS") {
      holder.setAttribute("open", "");
    }
  }

  /**
   * Closes the DaisyUI dropdown (details element).
   * Per Daisy UI: open/close via JS by adding/removing the "open" attribute.
   */
  function closeDropdown() {
    const holder = getElement("templateHolder");
    if (holder && holder.tagName === "DETAILS") {
      holder.removeAttribute("open");
    }
  }

  /**
   * Toggles the DaisyUI dropdown (details element).
   * Per Daisy UI: open/close via JS by adding/removing the "open" attribute.
   */
  function toggleDropdown() {
    const holder = getElement("templateHolder");
    if (holder && holder.tagName === "DETAILS") {
      if (holder.hasAttribute("open")) {
        holder.removeAttribute("open");
      } else {
        holder.setAttribute("open", "");
      }
    }
  }

  DotCustomFieldApi.ready(() => {
    const templateField = DotCustomFieldApi.getField("template");
    const templateId = templateField.getValue() || "";
    const isTemplateValid = templateId && templateId !== ALL_SITES_IDENTIFIER;

    const currentTemplateIdElement = getElement("currentTemplateId");
    if (currentTemplateIdElement) {
      currentTemplateIdElement.value = templateId;
    }

    let currentHostId = initialHostId || "";
    let allSiteLabel = true;
    let currentPage = 1;
    let allTemplates = [];
    let hasMore = false;
    let isLoading = false;

    const templateHolder = getElement("templateHolder");
    if (!templateHolder) {
      return;
    }

    // Grab existing DaisyUI dropdown elements
    const selectButton = getElement("customSelectButton");
    const dropdown = getElement("customDropdown");
    let moreChoicesButton = getElement("moreChoicesButton");

    if (!selectButton || !dropdown) {
      return;
    }

    if (!moreChoicesButton) {
      moreChoicesButton = document.createElement("li");
      moreChoicesButton.id = "moreChoicesButton";
      moreChoicesButton.setAttribute("data-action", "load-more");
      moreChoicesButton.className = "hidden border-t border-base-300";
      moreChoicesButton.textContent = "More choices";
      dropdown.appendChild(moreChoicesButton);
    }

    // Load more templates
    async function loadMoreTemplates() {
      if (isLoading || !hasMore) {
        return;
      }

      isLoading = true;
      moreChoicesButton.classList.add("cursor-wait", "opacity-70");
      moreChoicesButton.textContent = "Loading...";

      currentPage++;
      try {
        const result = await fetchTemplates({
          hostId: currentHostId,
          filter: "",
          page: currentPage,
          perPage: DEFAULT_PER_PAGE,
          allSiteLabel: false,
        });

        allTemplates = allTemplates.concat(result.templates);
        hasMore = result.hasMore;

        populateCustomDropdown(result.templates, templateId, true);

        if (!hasMore) {
          moreChoicesButton.classList.add("hidden");
        }

        isLoading = false;
        moreChoicesButton.classList.remove("cursor-wait", "opacity-70");
        moreChoicesButton.textContent = "More choices";
      } catch (error) {
        isLoading = false;
        moreChoicesButton.classList.remove("cursor-wait", "opacity-70");
        moreChoicesButton.textContent = "More choices";
      }
    }

    // Reload templates with new hostId (for "All Sites" functionality)
    async function reloadTemplates(newHostId, showAllSiteLabel) {
      currentHostId = newHostId || "";
      allSiteLabel = showAllSiteLabel;
      currentPage = 1;
      allTemplates = [];
      isLoading = true;

      // Show loading state
      const button = getElement("customSelectButton");
      if (button) {
        button.disabled = true;
      }

      try {
        const result = await fetchTemplates({
          hostId: currentHostId,
          filter: "",
          page: 1,
          perPage: DEFAULT_PER_PAGE,
          allSiteLabel: allSiteLabel,
        });

        allTemplates = result.templates;
        hasMore = result.hasMore;
        currentPage = 1;

        populateCustomDropdown(result.templates, "");

        if (hasMore) {
          moreChoicesButton.classList.remove("hidden");
        } else {
          moreChoicesButton.classList.add("hidden");
        }

        isLoading = false;
        if (button) {
          button.disabled = false;
        }
      } catch (error) {
        isLoading = false;
        if (button) {
          button.disabled = false;
        }
      }
    }

    dropdown.addEventListener("click", (e) => {
      if (e.target.closest("[data-action='load-more']")) {
        return;
      }

      const option = e.target.closest("[data-option]");
      if (option) {
        const identifier = option.dataset.identifier;
        const hostName = option.dataset.hostName;
        const titleEl = option.querySelector("strong");
        const fullTitle = titleEl ? titleEl.textContent : "";

        const template = allTemplates.find(
          (t) => t.identifier === identifier,
        ) || {
          identifier,
          fullTitle: fullTitle,
          title: fullTitle,
          hostName: hostName || SYSTEM_HOST,
        };
        handleTemplateSelection(
          template,
          templateField,
          (value) => {
            allSiteLabel = value;
          },
          reloadTemplates,
        );
      }
    });

    // Handle "More choices" button click
    moreChoicesButton.addEventListener("click", (e) => {
      e.stopPropagation();
      loadMoreTemplates();
    });

    // Toggle dropdown on button click.
    // preventDefault() is required: <summary> natively toggles its parent <details>;
    // without it the browser removes the "open" attribute right after we set it.
    selectButton.addEventListener("click", (e) => {
      e.preventDefault();
      e.stopPropagation();
      toggleDropdown();
    });

    // Close dropdown when clicking outside
    document.addEventListener("click", (e) => {
      if (!templateHolder.contains(e.target)) {
        closeDropdown();
      }
    });

    // Fetch initial templates
    (async () => {
      try {
        const result = await fetchTemplates({
          hostId: currentHostId,
          filter: "",
          page: 1,
          perPage: DEFAULT_PER_PAGE,
          allSiteLabel: allSiteLabel,
        });

        allTemplates = result.templates;
        hasMore = result.hasMore;
        currentPage = 1;

        populateCustomDropdown(result.templates, templateId);

        if (hasMore) {
          moreChoicesButton.classList.remove("hidden");
        } else {
          moreChoicesButton.classList.add("hidden");
        }

        // Find selected template
        let selectedTemplate = null;
        if (isTemplateValid) {
          selectedTemplate = allTemplates.find(
            (t) => t.identifier === templateId,
          );
        }

        await onTemplateFetchComplete(
          result.templates,
          templateField,
          selectedTemplate,
        );
      } catch (error) {
        console.error("Error fetching initial templates:", error);
      }
    })();

    if (isTemplateValid) {
      fetchTemplateImage(templateId);
    }
  });
</script>

<div class="flex flex-col gap-2 w-full">
  <details id="templateHolder" class="dropdown w-full">
    <summary
      id="customSelectButton"
      class="btn btn-outline w-full justify-between opacity-60"
      aria-label="Select template"
      aria-haspopup="listbox"
    >
      <span id="templateSelectButtonLabel">All Sites</span>
      <i class="pi pi-chevron-down" aria-hidden="true"></i>
    </summary>
    <ul
      id="customDropdown"
      class="menu dropdown-content bg-white-100 rounded-box z-[1] w-full max-h-96 overflow-y-auto shadow-sm"
      role="listbox"
    >
      <li
        id="moreChoicesButton"
        data-action="load-more"
        class="hidden border-t border-white-300"
      >
        More choices
      </li>
    </ul>
  </details>

  <input
    id="currentTemplateId"
    type="hidden"
    name="currentTemplateId"
    value=""
  />

  <div id="templateThumbnailContainer" class="hidden mt-4">
    <img
      id="templateThumbnailHolder"
      alt="Template Thumbnail"
      class="max-w-full rounded border border-base-300 transition-all duration-300 ease-in-out"
    />
  </div>
</div>
