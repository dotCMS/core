var runtime = (function (s) {
  "use strict";
  var v,
    C = Object.prototype,
    p = C.hasOwnProperty,
    G = "function" == typeof Symbol ? Symbol : {},
    w = G.iterator || "@@iterator",
    $ = G.asyncIterator || "@@asyncIterator",
    _ = G.toStringTag || "@@toStringTag";
  function h(r, t, e) {
    return (
      Object.defineProperty(r, t, {
        value: e,
        enumerable: !0,
        configurable: !0,
        writable: !0,
      }),
      r[t]
    );
  }
  try {
    h({}, "");
  } catch {
    h = function (t, e, o) {
      return (t[e] = o);
    };
  }
  function M(r, t, e, o) {
    var i = Object.create((t && t.prototype instanceof k ? t : k).prototype),
      a = new I(o || []);
    return (
      (i._invoke = (function B(r, t, e) {
        var o = R;
        return function (i, a) {
          if (o === Y) throw new Error("Generator is already running");
          if (o === L) {
            if ("throw" === i) throw a;
            return W();
          }
          for (e.method = i, e.arg = a; ; ) {
            var u = e.delegate;
            if (u) {
              var c = D(u, e);
              if (c) {
                if (c === l) continue;
                return c;
              }
            }
            if ("next" === e.method) e.sent = e._sent = e.arg;
            else if ("throw" === e.method) {
              if (o === R) throw ((o = L), e.arg);
              e.dispatchException(e.arg);
            } else "return" === e.method && e.abrupt("return", e.arg);
            o = Y;
            var f = O(r, t, e);
            if ("normal" === f.type) {
              if (((o = e.done ? L : z), f.arg === l)) continue;
              return { value: f.arg, done: e.done };
            }
            "throw" === f.type &&
              ((o = L), (e.method = "throw"), (e.arg = f.arg));
          }
        };
      })(r, e, a)),
      i
    );
  }
  function O(r, t, e) {
    try {
      return { type: "normal", arg: r.call(t, e) };
    } catch (o) {
      return { type: "throw", arg: o };
    }
  }
  s.wrap = M;
  var R = "suspendedStart",
    z = "suspendedYield",
    Y = "executing",
    L = "completed",
    l = {};
  function k() {}
  function b() {}
  function d() {}
  var T = {};
  h(T, w, function () {
    return this;
  });
  var N = Object.getPrototypeOf,
    S = N && N(N(P([])));
  S && S !== C && p.call(S, w) && (T = S);
  var g = (d.prototype = k.prototype = Object.create(T));
  function q(r) {
    ["next", "throw", "return"].forEach(function (t) {
      h(r, t, function (e) {
        return this._invoke(t, e);
      });
    });
  }
  function E(r, t) {
    function e(i, a, u, c) {
      var f = O(r[i], r, a);
      if ("throw" !== f.type) {
        var A = f.arg,
          m = A.value;
        return m && "object" == typeof m && p.call(m, "__await")
          ? t.resolve(m.__await).then(
              function (y) {
                e("next", y, u, c);
              },
              function (y) {
                e("throw", y, u, c);
              }
            )
          : t.resolve(m).then(
              function (y) {
                (A.value = y), u(A);
              },
              function (y) {
                return e("throw", y, u, c);
              }
            );
      }
      c(f.arg);
    }
    var o;
    this._invoke = function n(i, a) {
      function u() {
        return new t(function (c, f) {
          e(i, a, c, f);
        });
      }
      return (o = o ? o.then(u, u) : u());
    };
  }
  function D(r, t) {
    var e = r.iterator[t.method];
    if (e === v) {
      if (((t.delegate = null), "throw" === t.method)) {
        if (
          r.iterator.return &&
          ((t.method = "return"), (t.arg = v), D(r, t), "throw" === t.method)
        )
          return l;
        (t.method = "throw"),
          (t.arg = new TypeError(
            "The iterator does not provide a 'throw' method"
          ));
      }
      return l;
    }
    var o = O(e, r.iterator, t.arg);
    if ("throw" === o.type)
      return (t.method = "throw"), (t.arg = o.arg), (t.delegate = null), l;
    var n = o.arg;
    return n
      ? n.done
        ? ((t[r.resultName] = n.value),
          (t.next = r.nextLoc),
          "return" !== t.method && ((t.method = "next"), (t.arg = v)),
          (t.delegate = null),
          l)
        : n
      : ((t.method = "throw"),
        (t.arg = new TypeError("iterator result is not an object")),
        (t.delegate = null),
        l);
  }
  function H(r) {
    var t = { tryLoc: r[0] };
    1 in r && (t.catchLoc = r[1]),
      2 in r && ((t.finallyLoc = r[2]), (t.afterLoc = r[3])),
      this.tryEntries.push(t);
  }
  function j(r) {
    var t = r.completion || {};
    (t.type = "normal"), delete t.arg, (r.completion = t);
  }
  function I(r) {
    (this.tryEntries = [{ tryLoc: "root" }]),
      r.forEach(H, this),
      this.reset(!0);
  }
  function P(r) {
    if (r) {
      var t = r[w];
      if (t) return t.call(r);
      if ("function" == typeof r.next) return r;
      if (!isNaN(r.length)) {
        var e = -1,
          o = function n() {
            for (; ++e < r.length; )
              if (p.call(r, e)) return (n.value = r[e]), (n.done = !1), n;
            return (n.value = v), (n.done = !0), n;
          };
        return (o.next = o);
      }
    }
    return { next: W };
  }
  function W() {
    return { value: v, done: !0 };
  }
  return (
    (b.prototype = d),
    h(g, "constructor", d),
    h(d, "constructor", b),
    (b.displayName = h(d, _, "GeneratorFunction")),
    (s.isGeneratorFunction = function (r) {
      var t = "function" == typeof r && r.constructor;
      return (
        !!t && (t === b || "GeneratorFunction" === (t.displayName || t.name))
      );
    }),
    (s.mark = function (r) {
      return (
        Object.setPrototypeOf
          ? Object.setPrototypeOf(r, d)
          : ((r.__proto__ = d), h(r, _, "GeneratorFunction")),
        (r.prototype = Object.create(g)),
        r
      );
    }),
    (s.awrap = function (r) {
      return { __await: r };
    }),
    q(E.prototype),
    h(E.prototype, $, function () {
      return this;
    }),
    (s.AsyncIterator = E),
    (s.async = function (r, t, e, o, n) {
      void 0 === n && (n = Promise);
      var i = new E(M(r, t, e, o), n);
      return s.isGeneratorFunction(t)
        ? i
        : i.next().then(function (a) {
            return a.done ? a.value : i.next();
          });
    }),
    q(g),
    h(g, _, "Generator"),
    h(g, w, function () {
      return this;
    }),
    h(g, "toString", function () {
      return "[object Generator]";
    }),
    (s.keys = function (r) {
      var t = [];
      for (var e in r) t.push(e);
      return (
        t.reverse(),
        function o() {
          for (; t.length; ) {
            var n = t.pop();
            if (n in r) return (o.value = n), (o.done = !1), o;
          }
          return (o.done = !0), o;
        }
      );
    }),
    (s.values = P),
    (I.prototype = {
      constructor: I,
      reset: function (r) {
        if (
          ((this.prev = 0),
          (this.next = 0),
          (this.sent = this._sent = v),
          (this.done = !1),
          (this.delegate = null),
          (this.method = "next"),
          (this.arg = v),
          this.tryEntries.forEach(j),
          !r)
        )
          for (var t in this)
            "t" === t.charAt(0) &&
              p.call(this, t) &&
              !isNaN(+t.slice(1)) &&
              (this[t] = v);
      },
      stop: function () {
        this.done = !0;
        var t = this.tryEntries[0].completion;
        if ("throw" === t.type) throw t.arg;
        return this.rval;
      },
      dispatchException: function (r) {
        if (this.done) throw r;
        var t = this;
        function e(c, f) {
          return (
            (i.type = "throw"),
            (i.arg = r),
            (t.next = c),
            f && ((t.method = "next"), (t.arg = v)),
            !!f
          );
        }
        for (var o = this.tryEntries.length - 1; o >= 0; --o) {
          var n = this.tryEntries[o],
            i = n.completion;
          if ("root" === n.tryLoc) return e("end");
          if (n.tryLoc <= this.prev) {
            var a = p.call(n, "catchLoc"),
              u = p.call(n, "finallyLoc");
            if (a && u) {
              if (this.prev < n.catchLoc) return e(n.catchLoc, !0);
              if (this.prev < n.finallyLoc) return e(n.finallyLoc);
            } else if (a) {
              if (this.prev < n.catchLoc) return e(n.catchLoc, !0);
            } else {
              if (!u) throw new Error("try statement without catch or finally");
              if (this.prev < n.finallyLoc) return e(n.finallyLoc);
            }
          }
        }
      },
      abrupt: function (r, t) {
        for (var e = this.tryEntries.length - 1; e >= 0; --e) {
          var o = this.tryEntries[e];
          if (
            o.tryLoc <= this.prev &&
            p.call(o, "finallyLoc") &&
            this.prev < o.finallyLoc
          ) {
            var n = o;
            break;
          }
        }
        n &&
          ("break" === r || "continue" === r) &&
          n.tryLoc <= t &&
          t <= n.finallyLoc &&
          (n = null);
        var i = n ? n.completion : {};
        return (
          (i.type = r),
          (i.arg = t),
          n
            ? ((this.method = "next"), (this.next = n.finallyLoc), l)
            : this.complete(i)
        );
      },
      complete: function (r, t) {
        if ("throw" === r.type) throw r.arg;
        return (
          "break" === r.type || "continue" === r.type
            ? (this.next = r.arg)
            : "return" === r.type
            ? ((this.rval = this.arg = r.arg),
              (this.method = "return"),
              (this.next = "end"))
            : "normal" === r.type && t && (this.next = t),
          l
        );
      },
      finish: function (r) {
        for (var t = this.tryEntries.length - 1; t >= 0; --t) {
          var e = this.tryEntries[t];
          if (e.finallyLoc === r)
            return this.complete(e.completion, e.afterLoc), j(e), l;
        }
      },
      catch: function (r) {
        for (var t = this.tryEntries.length - 1; t >= 0; --t) {
          var e = this.tryEntries[t];
          if (e.tryLoc === r) {
            var o = e.completion;
            if ("throw" === o.type) {
              var n = o.arg;
              j(e);
            }
            return n;
          }
        }
        throw new Error("illegal catch attempt");
      },
      delegateYield: function (r, t, e) {
        return (
          (this.delegate = { iterator: P(r), resultName: t, nextLoc: e }),
          "next" === this.method && (this.arg = v),
          l
        );
      },
    }),
    s
  );
})("object" == typeof module ? module.exports : {});
try {
  regeneratorRuntime = runtime;
} catch {
  "object" == typeof globalThis
    ? (globalThis.regeneratorRuntime = runtime)
    : Function("r", "regeneratorRuntime = r")(runtime);
}
(() => {
  "use strict";
  var e,
    v = {},
    d = {};
  function n(e) {
    var a = d[e];
    if (void 0 !== a) return a.exports;
    var r = (d[e] = { exports: {} });
    return v[e](r, r.exports, n), r.exports;
  }
  (n.m = v),
    (e = []),
    (n.O = (a, r, l, o) => {
      if (!r) {
        var u = 1 / 0;
        for (t = 0; t < e.length; t++) {
          for (var [r, l, o] = e[t], s = !0, f = 0; f < r.length; f++)
            (!1 & o || u >= o) && Object.keys(n.O).every((h) => n.O[h](r[f]))
              ? r.splice(f--, 1)
              : ((s = !1), o < u && (u = o));
          if (s) {
            e.splice(t--, 1);
            var c = l();
            void 0 !== c && (a = c);
          }
        }
        return a;
      }
      o = o || 0;
      for (var t = e.length; t > 0 && e[t - 1][2] > o; t--) e[t] = e[t - 1];
      e[t] = [r, l, o];
    }),
    (n.n = (e) => {
      var a = e && e.__esModule ? () => e.default : () => e;
      return n.d(a, { a }), a;
    }),
    (n.d = (e, a) => {
      for (var r in a)
        n.o(a, r) &&
          !n.o(e, r) &&
          Object.defineProperty(e, r, { enumerable: !0, get: a[r] });
    }),
    (n.o = (e, a) => Object.prototype.hasOwnProperty.call(e, a)),
    (() => {
      var e = { 666: 0 };
      n.O.j = (l) => 0 === e[l];
      var a = (l, o) => {
          var f,
            c,
            [t, u, s] = o,
            _ = 0;
          if (t.some((i) => 0 !== e[i])) {
            for (f in u) n.o(u, f) && (n.m[f] = u[f]);
            if (s) var b = s(n);
          }
          for (l && l(o); _ < t.length; _++)
            n.o(e, (c = t[_])) && e[c] && e[c][0](), (e[c] = 0);
          return n.O(b);
        },
        r = (self.webpackChunkdotcms_block_editor =
          self.webpackChunkdotcms_block_editor || []);
      r.forEach(a.bind(null, 0)), (r.push = a.bind(null, r.push.bind(r)));
    })();
})();
(self.webpackChunkdotcms_block_editor =
  self.webpackChunkdotcms_block_editor || []).push([
  [429],
  {
    61: (X, oe, ge) => {
      "use strict";
      ge(583), ge(757);
    },
    757: () => {
      !(function (X, oe) {
        "use strict";
        function ge() {
          var e = Ue.splice(0, Ue.length);
          for (F = 0; e.length; ) e.shift().call(null, e.shift());
        }
        function ye(e, r) {
          for (var i = 0, h = e.length; i < h; i++) Ae(e[i], r);
        }
        function Ve(e) {
          return function (r) {
            L(r) && (Ae(r, e), le.length && ye(r.querySelectorAll(le), e));
          };
        }
        function Ie(e) {
          var r = R.call(e, "is"),
            i = e.nodeName.toUpperCase(),
            h = Ee.call(He, r ? st + r.toUpperCase() : qe + i);
          return r && -1 < h && !Je(i, r) ? -1 : h;
        }
        function Je(e, r) {
          return -1 < le.indexOf(e + '[is="' + r + '"]');
        }
        function Qe(e) {
          var r = e.currentTarget,
            i = e.attrChange,
            h = e.attrName,
            s = e.target,
            o = e[ot] || 2,
            l = e[pt] || 3;
          !n ||
            (s && s !== r) ||
            !r[pe] ||
            "style" === h ||
            (e.prevValue === e.newValue &&
              ("" !== e.newValue || (i !== o && i !== l))) ||
            r[pe](h, i === o ? null : e.prevValue, i === l ? null : e.newValue);
        }
        function et(e) {
          var r = Ve(e);
          return function (i) {
            Ue.push(r, i.target), F && clearTimeout(F), (F = setTimeout(ge, 1));
          };
        }
        function he(e) {
          k && ((k = !1), e.currentTarget.removeEventListener(bt, he)),
            le.length &&
              ye(
                (e.target || A).querySelectorAll(le),
                e.detail === me ? me : Le
              ),
            G &&
              (function lt() {
                for (var e, r = 0, i = T.length; r < i; r++)
                  De.contains((e = T[r])) || (i--, T.splice(r--, 1), Ae(e, me));
              })();
        }
        function ve(e, r) {
          var i = this;
          K.call(i, e, r), je.call(i, { target: i });
        }
        function Ze(e, r, i) {
          var h = r.apply(e, i),
            s = Ie(h);
          return (
            -1 < s && ae(h, We[s]),
            i.pop() &&
              le.length &&
              (function _t(e) {
                for (var r, i = 0, h = e.length; i < h; i++)
                  ae((r = e[i]), We[Ie(r)]);
              })(h.querySelectorAll(le)),
            h
          );
        }
        function Fe(e, r) {
          b(e, r),
            Ge
              ? Ge.observe(e, re)
              : (I && ((e.setAttribute = ve), (e[de] = nt(e)), e[be](Et, je)),
                e[be](Oe, Qe)),
            e[ze] && n && ((e.created = !0), e[ze](), (e.created = !1));
        }
        function U(e) {
          throw new Error("A " + e + " type is already registered");
        }
        function Ae(e, r) {
          var i,
            h,
            s = Ie(e);
          -1 < s &&
            !B.call(e, "TEMPLATE") &&
            (we(e, We[s]),
            (s = 0),
            r !== Le || e[Le]
              ? r !== me ||
                e[me] ||
                ((e[Le] = !1), (e[me] = !0), (h = "disconnected"), (s = 1))
              : ((e[me] = !1),
                (e[Le] = !0),
                (h = "connected"),
                (s = 1),
                G && Ee.call(T, e) < 0 && T.push(e)),
            s && (i = e[r + ce] || e[h + ce]) && i.call(e));
        }
        function ke() {}
        function J(e, r, i) {
          var h = (i && i[te]) || "",
            s = r.prototype,
            o = w(s),
            l = r.observedAttributes || Ne,
            d = { prototype: o };
          x(o, ze, {
            value: function () {
              if (f) f = !1;
              else if (!this[$e]) {
                (this[$e] = !0), new r(this), s[ze] && s[ze].call(this);
                var p = m[v.get(r)];
                (!t || p.create.length > 1) && tt(this);
              }
            },
          }),
            x(o, pe, {
              value: function (p) {
                -1 < Ee.call(l, p) && s[pe] && s[pe].apply(this, arguments);
              },
            }),
            s[rt] && x(o, vt, { value: s[rt] }),
            s[mt] && x(o, kt, { value: s[mt] }),
            h && (d[te] = h),
            (e = e.toUpperCase()),
            (m[e] = { constructor: r, create: h ? [h, C(e)] : [e] }),
            v.set(r, e),
            A[se](e.toLowerCase(), d),
            ut(e),
            E[e].r();
        }
        function gt(e) {
          var r = m[e.toUpperCase()];
          return r && r.constructor;
        }
        function yt(e) {
          return "string" == typeof e ? e : (e && e.is) || "";
        }
        function tt(e) {
          for (var r, i = e[pe], h = i ? e.attributes : Ne, s = h.length; s--; )
            i.call(
              e,
              (r = h[s]).name || r.nodeName,
              null,
              r.value || r.nodeValue
            );
        }
        function ut(e) {
          return (
            (e = e.toUpperCase()) in E ||
              ((E[e] = {}),
              (E[e].p = new c(function (r) {
                E[e].r = r;
              }))),
            E[e].p
          );
        }
        function ft() {
          Me && delete X.customElements,
            Re(X, "customElements", { configurable: !0, value: new ke() }),
            Re(X, "CustomElementRegistry", { configurable: !0, value: ke });
          for (
            var e = ht.get(/^HTML[A-Z]*[a-z]/), r = e.length;
            r--;
            (function (i) {
              var h = X[i];
              if (h) {
                (X[i] = function (s) {
                  var o, l;
                  return (
                    s || (s = this),
                    s[$e] ||
                      ((f = !0),
                      (o = m[v.get(s.constructor)]),
                      ((s = (l = t && 1 === o.create.length)
                        ? Reflect.construct(h, Ne, o.constructor)
                        : A.createElement.apply(A, o.create))[$e] = !0),
                      (f = !1),
                      l || tt(s)),
                    s
                  );
                }),
                  (X[i].prototype = h.prototype);
                try {
                  h.prototype.constructor = X[i];
                } catch {
                  Re(h, $e, { value: X[i] });
                }
              }
            })(e[r])
          );
          (A.createElement = function (i, h) {
            var s = yt(h);
            return s ? O.call(this, i, C(s)) : O.call(this, i);
          }),
            ue || ((W = !0), A[se](""));
        }
        var A = X.document,
          ne = X.Object,
          ht = (function (e) {
            var r,
              i,
              h,
              s,
              o = /^[A-Z]+[a-z]/,
              d = function (_, g) {
                (g = g.toLowerCase()) in p ||
                  ((p[_] = (p[_] || []).concat(g)),
                  (p[g] = p[g.toUpperCase()] = _));
              },
              p = (ne.create || ne)(null),
              y = {};
            for (i in e)
              for (s in e[i])
                for (p[s] = h = e[i][s], r = 0; r < h.length; r++)
                  p[h[r].toLowerCase()] = p[h[r].toUpperCase()] = s;
            return (
              (y.get = function (_) {
                return "string" == typeof _
                  ? p[_] || (o.test(_) ? [] : "")
                  : (function (_) {
                      var g,
                        M = [];
                      for (g in p) _.test(g) && M.push(g);
                      return M;
                    })(_);
              }),
              (y.set = function (_, g) {
                return o.test(_) ? d(_, g) : d(g, _), y;
              }),
              y
            );
          })({
            collections: {
              HTMLAllCollection: ["all"],
              HTMLCollection: ["forms"],
              HTMLFormControlsCollection: ["elements"],
              HTMLOptionsCollection: ["options"],
            },
            elements: {
              Element: ["element"],
              HTMLAnchorElement: ["a"],
              HTMLAppletElement: ["applet"],
              HTMLAreaElement: ["area"],
              HTMLAttachmentElement: ["attachment"],
              HTMLAudioElement: ["audio"],
              HTMLBRElement: ["br"],
              HTMLBaseElement: ["base"],
              HTMLBodyElement: ["body"],
              HTMLButtonElement: ["button"],
              HTMLCanvasElement: ["canvas"],
              HTMLContentElement: ["content"],
              HTMLDListElement: ["dl"],
              HTMLDataElement: ["data"],
              HTMLDataListElement: ["datalist"],
              HTMLDetailsElement: ["details"],
              HTMLDialogElement: ["dialog"],
              HTMLDirectoryElement: ["dir"],
              HTMLDivElement: ["div"],
              HTMLDocument: ["document"],
              HTMLElement: [
                "element",
                "abbr",
                "address",
                "article",
                "aside",
                "b",
                "bdi",
                "bdo",
                "cite",
                "code",
                "command",
                "dd",
                "dfn",
                "dt",
                "em",
                "figcaption",
                "figure",
                "footer",
                "header",
                "i",
                "kbd",
                "mark",
                "nav",
                "noscript",
                "rp",
                "rt",
                "ruby",
                "s",
                "samp",
                "section",
                "small",
                "strong",
                "sub",
                "summary",
                "sup",
                "u",
                "var",
                "wbr",
              ],
              HTMLEmbedElement: ["embed"],
              HTMLFieldSetElement: ["fieldset"],
              HTMLFontElement: ["font"],
              HTMLFormElement: ["form"],
              HTMLFrameElement: ["frame"],
              HTMLFrameSetElement: ["frameset"],
              HTMLHRElement: ["hr"],
              HTMLHeadElement: ["head"],
              HTMLHeadingElement: ["h1", "h2", "h3", "h4", "h5", "h6"],
              HTMLHtmlElement: ["html"],
              HTMLIFrameElement: ["iframe"],
              HTMLImageElement: ["img"],
              HTMLInputElement: ["input"],
              HTMLKeygenElement: ["keygen"],
              HTMLLIElement: ["li"],
              HTMLLabelElement: ["label"],
              HTMLLegendElement: ["legend"],
              HTMLLinkElement: ["link"],
              HTMLMapElement: ["map"],
              HTMLMarqueeElement: ["marquee"],
              HTMLMediaElement: ["media"],
              HTMLMenuElement: ["menu"],
              HTMLMenuItemElement: ["menuitem"],
              HTMLMetaElement: ["meta"],
              HTMLMeterElement: ["meter"],
              HTMLModElement: ["del", "ins"],
              HTMLOListElement: ["ol"],
              HTMLObjectElement: ["object"],
              HTMLOptGroupElement: ["optgroup"],
              HTMLOptionElement: ["option"],
              HTMLOutputElement: ["output"],
              HTMLParagraphElement: ["p"],
              HTMLParamElement: ["param"],
              HTMLPictureElement: ["picture"],
              HTMLPreElement: ["pre"],
              HTMLProgressElement: ["progress"],
              HTMLQuoteElement: ["blockquote", "q", "quote"],
              HTMLScriptElement: ["script"],
              HTMLSelectElement: ["select"],
              HTMLShadowElement: ["shadow"],
              HTMLSlotElement: ["slot"],
              HTMLSourceElement: ["source"],
              HTMLSpanElement: ["span"],
              HTMLStyleElement: ["style"],
              HTMLTableCaptionElement: ["caption"],
              HTMLTableCellElement: ["td", "th"],
              HTMLTableColElement: ["col", "colgroup"],
              HTMLTableElement: ["table"],
              HTMLTableRowElement: ["tr"],
              HTMLTableSectionElement: ["thead", "tbody", "tfoot"],
              HTMLTemplateElement: ["template"],
              HTMLTextAreaElement: ["textarea"],
              HTMLTimeElement: ["time"],
              HTMLTitleElement: ["title"],
              HTMLTrackElement: ["track"],
              HTMLUListElement: ["ul"],
              HTMLUnknownElement: ["unknown", "vhgroupv", "vkeygen"],
              HTMLVideoElement: ["video"],
            },
            nodes: {
              Attr: ["node"],
              Audio: ["audio"],
              CDATASection: ["node"],
              CharacterData: ["node"],
              Comment: ["#comment"],
              Document: ["#document"],
              DocumentFragment: ["#document-fragment"],
              DocumentType: ["node"],
              HTMLDocument: ["#document"],
              Image: ["img"],
              Option: ["option"],
              ProcessingInstruction: ["node"],
              ShadowRoot: ["#shadow-root"],
              Text: ["#text"],
              XMLDocument: ["xml"],
            },
          });
        "object" != typeof oe && (oe = { type: oe || "auto" });
        var Ue,
          je,
          Be,
          nt,
          Ge,
          ie,
          we,
          ae,
          Ce,
          e,
          r,
          i,
          h,
          s,
          se = "registerElement",
          dt = (1e5 * X.Math.random()) >> 0,
          de = "__" + se + dt,
          be = "addEventListener",
          Le = "attached",
          ce = "Callback",
          me = "detached",
          te = "extends",
          pe = "attributeChanged" + ce,
          vt = Le + ce,
          rt = "connected" + ce,
          mt = "disconnected" + ce,
          ze = "created" + ce,
          kt = me + ce,
          ot = "ADDITION",
          pt = "REMOVAL",
          Oe = "DOMAttrModified",
          bt = "DOMContentLoaded",
          Et = "DOMSubtreeModified",
          qe = "<",
          st = "=",
          Mt = /^[A-Z][._A-Z0-9]*-[-._A-Z0-9]*$/,
          wt = [
            "ANNOTATION-XML",
            "COLOR-PROFILE",
            "FONT-FACE",
            "FONT-FACE-SRC",
            "FONT-FACE-URI",
            "FONT-FACE-FORMAT",
            "FONT-FACE-NAME",
            "MISSING-GLYPH",
          ],
          He = [],
          We = [],
          le = "",
          De = A.documentElement,
          Ee =
            He.indexOf ||
            function (e) {
              for (var r = this.length; r-- && this[r] !== e; );
              return r;
            },
          it = ne.prototype,
          Pe = it.hasOwnProperty,
          at = it.isPrototypeOf,
          Re = ne.defineProperty,
          Ne = [],
          Xe = ne.getOwnPropertyDescriptor,
          Y = ne.getOwnPropertyNames,
          Ct = ne.getPrototypeOf,
          Ye = ne.setPrototypeOf,
          Se = !!ne.__proto__,
          $e = "__dreCEv1",
          Me = X.customElements,
          t =
            !/^force/.test(oe.type) &&
            !!(Me && Me.define && Me.get && Me.whenDefined),
          a = ne.create || ne,
          u =
            X.Map ||
            function () {
              var e,
                r = [],
                i = [];
              return {
                get: function (h) {
                  return i[Ee.call(r, h)];
                },
                set: function (h, s) {
                  (e = Ee.call(r, h)) < 0 ? (i[r.push(h) - 1] = s) : (i[e] = s);
                },
              };
            },
          c =
            X.Promise ||
            function (e) {
              function r(o) {
                for (h = !0; i.length; ) i.shift()(o);
              }
              var i = [],
                h = !1,
                s = {
                  catch: function () {
                    return s;
                  },
                  then: function (o) {
                    return i.push(o), h && setTimeout(r, 1), s;
                  },
                };
              return e(r), s;
            },
          f = !1,
          m = a(null),
          E = a(null),
          v = new u(),
          C = function (e) {
            return e.toLowerCase();
          },
          w =
            ne.create ||
            function e(r) {
              return r ? ((e.prototype = r), new e()) : this;
            },
          b =
            Ye ||
            (Se
              ? function (e, r) {
                  return (e.__proto__ = r), e;
                }
              : Y && Xe
              ? (function () {
                  function e(r, i) {
                    for (var h, s = Y(i), o = 0, l = s.length; o < l; o++)
                      Pe.call(r, (h = s[o])) || Re(r, h, Xe(i, h));
                  }
                  return function (r, i) {
                    do {
                      e(r, i);
                    } while ((i = Ct(i)) && !at.call(i, r));
                    return r;
                  };
                })()
              : function (e, r) {
                  for (var i in r) e[i] = r[i];
                  return e;
                }),
          H = X.MutationObserver || X.WebKitMutationObserver,
          S = X.HTMLAnchorElement,
          P = (X.HTMLElement || X.Element || X.Node).prototype,
          G = !at.call(P, De),
          x = G
            ? function (e, r, i) {
                return (e[r] = i.value), e;
              }
            : Re,
          L = G
            ? function (e) {
                return 1 === e.nodeType;
              }
            : function (e) {
                return at.call(P, e);
              },
          T = G && [],
          Z = P.attachShadow,
          z = P.cloneNode,
          B =
            P.closest ||
            function (e) {
              for (var r = this; r && r.nodeName !== e; ) r = r.parentNode;
              return r;
            },
          $ = P.dispatchEvent,
          R = P.getAttribute,
          Q = P.hasAttribute,
          V = P.removeAttribute,
          K = P.setAttribute,
          N = A.createElement,
          j = A.importNode,
          O = N,
          re = H && {
            attributes: !0,
            characterData: !0,
            attributeOldValue: !0,
          },
          Te =
            H ||
            function (e) {
              (I = !1), De.removeEventListener(Oe, Te);
            },
          F = 0,
          ue = se in A && !/^force-all/.test(oe.type),
          fe = !0,
          W = !1,
          I = !0,
          k = !0,
          n = !0;
        if (
          (H &&
            (((Ce = A.createElement("div")).innerHTML =
              "<div><div></div></div>"),
            new H(function (e, r) {
              if (
                e[0] &&
                "childList" == e[0].type &&
                !e[0].removedNodes[0].childNodes.length
              ) {
                var i = (Ce = Xe(P, "innerHTML")) && Ce.set;
                i &&
                  Re(P, "innerHTML", {
                    set: function (h) {
                      for (; this.lastChild; ) this.removeChild(this.lastChild);
                      i.call(this, h);
                    },
                  });
              }
              r.disconnect(), (Ce = null);
            }).observe(Ce, { childList: !0, subtree: !0 }),
            (Ce.innerHTML = "")),
          ue ||
            (Ye || Se
              ? ((we = function (e, r) {
                  at.call(r, e) || Fe(e, r);
                }),
                (ae = Fe))
              : ((we = function (e, r) {
                  e[de] || ((e[de] = ne(!0)), Fe(e, r));
                }),
                (ae = we)),
            G
              ? ((I = !1),
                (e = Xe(P, be)),
                (r = e.value),
                (i = function (o) {
                  var l = new CustomEvent(Oe, { bubbles: !0 });
                  (l.attrName = o),
                    (l.prevValue = R.call(this, o)),
                    (l.newValue = null),
                    (l[pt] = l.attrChange = 2),
                    V.call(this, o),
                    $.call(this, l);
                }),
                (h = function (o, l) {
                  var d = Q.call(this, o),
                    p = d && R.call(this, o),
                    y = new CustomEvent(Oe, { bubbles: !0 });
                  K.call(this, o, l),
                    (y.attrName = o),
                    (y.prevValue = d ? p : null),
                    (y.newValue = l),
                    d
                      ? (y.MODIFICATION = y.attrChange = 1)
                      : (y[ot] = y.attrChange = 0),
                    $.call(this, y);
                }),
                (s = function (o) {
                  var l,
                    d = o.currentTarget,
                    p = d[de],
                    y = o.propertyName;
                  p.hasOwnProperty(y) &&
                    ((p = p[y]),
                    ((l = new CustomEvent(Oe, { bubbles: !0 })).attrName =
                      p.name),
                    (l.prevValue = p.value || null),
                    (l.newValue = p.value = d[y] || null),
                    null == l.prevValue
                      ? (l[ot] = l.attrChange = 0)
                      : (l.MODIFICATION = l.attrChange = 1),
                    $.call(d, l));
                }),
                (e.value = function (o, l, d) {
                  o === Oe &&
                    this[pe] &&
                    this.setAttribute !== h &&
                    ((this[de] = {
                      className: { name: "class", value: this.className },
                    }),
                    (this.setAttribute = h),
                    (this.removeAttribute = i),
                    r.call(this, "propertychange", s)),
                    r.call(this, o, l, d);
                }),
                Re(P, be, e))
              : H ||
                (De[be](Oe, Te),
                De.setAttribute(de, 1),
                De.removeAttribute(de),
                I &&
                  ((je = function (e) {
                    var r,
                      i,
                      h,
                      s = this;
                    if (s === e.target) {
                      for (h in ((r = s[de]), (s[de] = i = nt(s)), i)) {
                        if (!(h in r)) return Be(0, s, h, r[h], i[h], ot);
                        if (i[h] !== r[h])
                          return Be(1, s, h, r[h], i[h], "MODIFICATION");
                      }
                      for (h in r)
                        if (!(h in i)) return Be(2, s, h, r[h], i[h], pt);
                    }
                  }),
                  (Be = function (e, r, i, h, s, o) {
                    var l = {
                      attrChange: e,
                      currentTarget: r,
                      attrName: i,
                      prevValue: h,
                      newValue: s,
                    };
                    (l[o] = e), Qe(l);
                  }),
                  (nt = function (e) {
                    for (
                      var r, i, h = {}, s = e.attributes, o = 0, l = s.length;
                      o < l;
                      o++
                    )
                      "setAttribute" !== (i = (r = s[o]).name) &&
                        (h[i] = r.value);
                    return h;
                  }))),
            (A[se] = function (e, r) {
              if (
                ((i = e.toUpperCase()),
                fe &&
                  ((fe = !1),
                  H
                    ? ((Ge = (function (p, y) {
                        function _(g, M) {
                          for (var D = 0, q = g.length; D < q; M(g[D++]));
                        }
                        return new H(function (g) {
                          for (
                            var M, D, q, ee = 0, _e = g.length;
                            ee < _e;
                            ee++
                          )
                            "childList" === (M = g[ee]).type
                              ? (_(M.addedNodes, p), _(M.removedNodes, y))
                              : ((D = M.target),
                                n &&
                                  D[pe] &&
                                  "style" !== M.attributeName &&
                                  (q = R.call(D, M.attributeName)) !==
                                    M.oldValue &&
                                  D[pe](M.attributeName, M.oldValue, q));
                        });
                      })(Ve(Le), Ve(me))),
                      (ie = function (p) {
                        return Ge.observe(p, { childList: !0, subtree: !0 }), p;
                      })(A),
                      Z &&
                        (P.attachShadow = function () {
                          return ie(Z.apply(this, arguments));
                        }))
                    : ((Ue = []),
                      A[be]("DOMNodeInserted", et(Le)),
                      A[be]("DOMNodeRemoved", et(me))),
                  A[be](bt, he),
                  A[be]("readystatechange", he),
                  (A.importNode = function (p, y) {
                    switch (p.nodeType) {
                      case 1:
                        return Ze(A, j, [p, !!y]);
                      case 11:
                        for (
                          var _ = A.createDocumentFragment(),
                            g = p.childNodes,
                            M = g.length,
                            D = 0;
                          D < M;
                          D++
                        )
                          _.appendChild(A.importNode(g[D], !!y));
                        return _;
                      default:
                        return z.call(p, !!y);
                    }
                  }),
                  (P.cloneNode = function (p) {
                    return Ze(this, z, [!!p]);
                  })),
                W)
              )
                return (W = !1);
              if (
                (-2 < Ee.call(He, st + i) + Ee.call(He, qe + i) && U(e),
                !Mt.test(i) || -1 < Ee.call(wt, i))
              )
                throw new Error("The type " + e + " is invalid");
              var i,
                h,
                s = function () {
                  return l ? A.createElement(d, i) : A.createElement(d);
                },
                o = r || it,
                l = Pe.call(o, te),
                d = l ? r[te].toUpperCase() : i;
              return (
                l && -1 < Ee.call(He, qe + d) && U(d),
                (h = He.push((l ? st : qe) + i) - 1),
                (le = le.concat(
                  le.length ? "," : "",
                  l ? d + '[is="' + e.toLowerCase() + '"]' : d
                )),
                (s.prototype = We[h] =
                  Pe.call(o, "prototype") ? o.prototype : w(P)),
                le.length && ye(A.querySelectorAll(le), Le),
                s
              );
            }),
            (A.createElement = O =
              function (e, r) {
                var i = yt(r),
                  h = i ? N.call(A, e, C(i)) : N.call(A, e),
                  s = "" + e,
                  o = Ee.call(He, (i ? st : qe) + (i || s).toUpperCase()),
                  l = -1 < o;
                return (
                  i &&
                    (h.setAttribute("is", (i = i.toLowerCase())),
                    l && (l = Je(s.toUpperCase(), i))),
                  (n = !A.createElement.innerHTMLHelper),
                  l && ae(h, We[o]),
                  h
                );
              })),
          addEventListener(
            "beforeunload",
            function () {
              delete A.createElement, delete A.importNode, delete A[se];
            },
            !1
          ),
          (ke.prototype = {
            constructor: ke,
            define: t
              ? function (e, r, i) {
                  if (i) J(e, r, i);
                  else {
                    var h = e.toUpperCase();
                    (m[h] = { constructor: r, create: [h] }),
                      v.set(r, h),
                      Me.define(e, r);
                  }
                }
              : J,
            get: t
              ? function (e) {
                  return Me.get(e) || gt(e);
                }
              : gt,
            whenDefined: t
              ? function (e) {
                  return c.race([Me.whenDefined(e), ut(e)]);
                }
              : ut,
          }),
          !Me || /^force/.test(oe.type))
        )
          ft();
        else if (!oe.noBuiltIn)
          try {
            !(function (e, r, i) {
              var h = new RegExp("^<a\\s+is=('|\")" + i + "\\1></a>$");
              if (
                ((r[te] = "a"),
                ((e.prototype = w(S.prototype)).constructor = e),
                X.customElements.define(i, e, r),
                !h.test(A.createElement("a", { is: i }).outerHTML) ||
                  !h.test(new e().outerHTML))
              )
                throw r;
            })(
              function e() {
                return Reflect.construct(S, [], e);
              },
              {},
              "document-register-element-a" + dt
            );
          } catch {
            ft();
          }
        if (!oe.noBuiltIn)
          try {
            if (N.call(A, "a", "a").outerHTML.indexOf("is") < 0) throw {};
          } catch {
            C = function (r) {
              return { is: r.toLowerCase() };
            };
          }
      })(window);
    },
    583: () => {
      "use strict";
      !(function (t) {
        const a = t.performance;
        function u(I) {
          a && a.mark && a.mark(I);
        }
        function c(I, k) {
          a && a.measure && a.measure(I, k);
        }
        u("Zone");
        const f = t.__Zone_symbol_prefix || "__zone_symbol__";
        function m(I) {
          return f + I;
        }
        const E = !0 === t[m("forceDuplicateZoneCheck")];
        if (t.Zone) {
          if (E || "function" != typeof t.Zone.__symbol__)
            throw new Error("Zone already loaded.");
          return t.Zone;
        }
        let v = (() => {
          class I {
            constructor(n, e) {
              (this._parent = n),
                (this._name = e ? e.name || "unnamed" : "<root>"),
                (this._properties = (e && e.properties) || {}),
                (this._zoneDelegate = new w(
                  this,
                  this._parent && this._parent._zoneDelegate,
                  e
                ));
            }
            static assertZonePatched() {
              if (t.Promise !== re.ZoneAwarePromise)
                throw new Error(
                  "Zone.js has detected that ZoneAwarePromise `(window|global).Promise` has been overwritten.\nMost likely cause is that a Promise polyfill has been loaded after Zone.js (Polyfilling Promise api is not necessary when zone.js is loaded. If you must load one, do so before loading zone.js.)"
                );
            }
            static get root() {
              let n = I.current;
              for (; n.parent; ) n = n.parent;
              return n;
            }
            static get current() {
              return F.zone;
            }
            static get currentTask() {
              return ue;
            }
            static __load_patch(n, e, r = !1) {
              if (re.hasOwnProperty(n)) {
                if (!r && E) throw Error("Already loaded patch: " + n);
              } else if (!t["__Zone_disable_" + n]) {
                const i = "Zone:" + n;
                u(i), (re[n] = e(t, I, Te)), c(i, i);
              }
            }
            get parent() {
              return this._parent;
            }
            get name() {
              return this._name;
            }
            get(n) {
              const e = this.getZoneWith(n);
              if (e) return e._properties[n];
            }
            getZoneWith(n) {
              let e = this;
              for (; e; ) {
                if (e._properties.hasOwnProperty(n)) return e;
                e = e._parent;
              }
              return null;
            }
            fork(n) {
              if (!n) throw new Error("ZoneSpec required!");
              return this._zoneDelegate.fork(this, n);
            }
            wrap(n, e) {
              if ("function" != typeof n)
                throw new Error("Expecting function got: " + n);
              const r = this._zoneDelegate.intercept(this, n, e),
                i = this;
              return function () {
                return i.runGuarded(r, this, arguments, e);
              };
            }
            run(n, e, r, i) {
              F = { parent: F, zone: this };
              try {
                return this._zoneDelegate.invoke(this, n, e, r, i);
              } finally {
                F = F.parent;
              }
            }
            runGuarded(n, e = null, r, i) {
              F = { parent: F, zone: this };
              try {
                try {
                  return this._zoneDelegate.invoke(this, n, e, r, i);
                } catch (h) {
                  if (this._zoneDelegate.handleError(this, h)) throw h;
                }
              } finally {
                F = F.parent;
              }
            }
            runTask(n, e, r) {
              if (n.zone != this)
                throw new Error(
                  "A task can only be run in the zone of creation! (Creation: " +
                    (n.zone || z).name +
                    "; Execution: " +
                    this.name +
                    ")"
                );
              if (n.state === B && (n.type === O || n.type === j)) return;
              const i = n.state != Q;
              i && n._transitionTo(Q, R), n.runCount++;
              const h = ue;
              (ue = n), (F = { parent: F, zone: this });
              try {
                n.type == j &&
                  n.data &&
                  !n.data.isPeriodic &&
                  (n.cancelFn = void 0);
                try {
                  return this._zoneDelegate.invokeTask(this, n, e, r);
                } catch (s) {
                  if (this._zoneDelegate.handleError(this, s)) throw s;
                }
              } finally {
                n.state !== B &&
                  n.state !== K &&
                  (n.type == O || (n.data && n.data.isPeriodic)
                    ? i && n._transitionTo(R, Q)
                    : ((n.runCount = 0),
                      this._updateTaskCount(n, -1),
                      i && n._transitionTo(B, Q, B))),
                  (F = F.parent),
                  (ue = h);
              }
            }
            scheduleTask(n) {
              if (n.zone && n.zone !== this) {
                let r = this;
                for (; r; ) {
                  if (r === n.zone)
                    throw Error(
                      `can not reschedule task to ${this.name} which is descendants of the original zone ${n.zone.name}`
                    );
                  r = r.parent;
                }
              }
              n._transitionTo($, B);
              const e = [];
              (n._zoneDelegates = e), (n._zone = this);
              try {
                n = this._zoneDelegate.scheduleTask(this, n);
              } catch (r) {
                throw (
                  (n._transitionTo(K, $, B),
                  this._zoneDelegate.handleError(this, r),
                  r)
                );
              }
              return (
                n._zoneDelegates === e && this._updateTaskCount(n, 1),
                n.state == $ && n._transitionTo(R, $),
                n
              );
            }
            scheduleMicroTask(n, e, r, i) {
              return this.scheduleTask(new b(N, n, e, r, i, void 0));
            }
            scheduleMacroTask(n, e, r, i, h) {
              return this.scheduleTask(new b(j, n, e, r, i, h));
            }
            scheduleEventTask(n, e, r, i, h) {
              return this.scheduleTask(new b(O, n, e, r, i, h));
            }
            cancelTask(n) {
              if (n.zone != this)
                throw new Error(
                  "A task can only be cancelled in the zone of creation! (Creation: " +
                    (n.zone || z).name +
                    "; Execution: " +
                    this.name +
                    ")"
                );
              n._transitionTo(V, R, Q);
              try {
                this._zoneDelegate.cancelTask(this, n);
              } catch (e) {
                throw (
                  (n._transitionTo(K, V),
                  this._zoneDelegate.handleError(this, e),
                  e)
                );
              }
              return (
                this._updateTaskCount(n, -1),
                n._transitionTo(B, V),
                (n.runCount = 0),
                n
              );
            }
            _updateTaskCount(n, e) {
              const r = n._zoneDelegates;
              -1 == e && (n._zoneDelegates = null);
              for (let i = 0; i < r.length; i++)
                r[i]._updateTaskCount(n.type, e);
            }
          }
          return (I.__symbol__ = m), I;
        })();
        const C = {
          name: "",
          onHasTask: (I, k, n, e) => I.hasTask(n, e),
          onScheduleTask: (I, k, n, e) => I.scheduleTask(n, e),
          onInvokeTask: (I, k, n, e, r, i) => I.invokeTask(n, e, r, i),
          onCancelTask: (I, k, n, e) => I.cancelTask(n, e),
        };
        class w {
          constructor(k, n, e) {
            (this._taskCounts = { microTask: 0, macroTask: 0, eventTask: 0 }),
              (this.zone = k),
              (this._parentDelegate = n),
              (this._forkZS = e && (e && e.onFork ? e : n._forkZS)),
              (this._forkDlgt = e && (e.onFork ? n : n._forkDlgt)),
              (this._forkCurrZone =
                e && (e.onFork ? this.zone : n._forkCurrZone)),
              (this._interceptZS = e && (e.onIntercept ? e : n._interceptZS)),
              (this._interceptDlgt =
                e && (e.onIntercept ? n : n._interceptDlgt)),
              (this._interceptCurrZone =
                e && (e.onIntercept ? this.zone : n._interceptCurrZone)),
              (this._invokeZS = e && (e.onInvoke ? e : n._invokeZS)),
              (this._invokeDlgt = e && (e.onInvoke ? n : n._invokeDlgt)),
              (this._invokeCurrZone =
                e && (e.onInvoke ? this.zone : n._invokeCurrZone)),
              (this._handleErrorZS =
                e && (e.onHandleError ? e : n._handleErrorZS)),
              (this._handleErrorDlgt =
                e && (e.onHandleError ? n : n._handleErrorDlgt)),
              (this._handleErrorCurrZone =
                e && (e.onHandleError ? this.zone : n._handleErrorCurrZone)),
              (this._scheduleTaskZS =
                e && (e.onScheduleTask ? e : n._scheduleTaskZS)),
              (this._scheduleTaskDlgt =
                e && (e.onScheduleTask ? n : n._scheduleTaskDlgt)),
              (this._scheduleTaskCurrZone =
                e && (e.onScheduleTask ? this.zone : n._scheduleTaskCurrZone)),
              (this._invokeTaskZS =
                e && (e.onInvokeTask ? e : n._invokeTaskZS)),
              (this._invokeTaskDlgt =
                e && (e.onInvokeTask ? n : n._invokeTaskDlgt)),
              (this._invokeTaskCurrZone =
                e && (e.onInvokeTask ? this.zone : n._invokeTaskCurrZone)),
              (this._cancelTaskZS =
                e && (e.onCancelTask ? e : n._cancelTaskZS)),
              (this._cancelTaskDlgt =
                e && (e.onCancelTask ? n : n._cancelTaskDlgt)),
              (this._cancelTaskCurrZone =
                e && (e.onCancelTask ? this.zone : n._cancelTaskCurrZone)),
              (this._hasTaskZS = null),
              (this._hasTaskDlgt = null),
              (this._hasTaskDlgtOwner = null),
              (this._hasTaskCurrZone = null);
            const r = e && e.onHasTask;
            (r || (n && n._hasTaskZS)) &&
              ((this._hasTaskZS = r ? e : C),
              (this._hasTaskDlgt = n),
              (this._hasTaskDlgtOwner = this),
              (this._hasTaskCurrZone = k),
              e.onScheduleTask ||
                ((this._scheduleTaskZS = C),
                (this._scheduleTaskDlgt = n),
                (this._scheduleTaskCurrZone = this.zone)),
              e.onInvokeTask ||
                ((this._invokeTaskZS = C),
                (this._invokeTaskDlgt = n),
                (this._invokeTaskCurrZone = this.zone)),
              e.onCancelTask ||
                ((this._cancelTaskZS = C),
                (this._cancelTaskDlgt = n),
                (this._cancelTaskCurrZone = this.zone)));
          }
          fork(k, n) {
            return this._forkZS
              ? this._forkZS.onFork(this._forkDlgt, this.zone, k, n)
              : new v(k, n);
          }
          intercept(k, n, e) {
            return this._interceptZS
              ? this._interceptZS.onIntercept(
                  this._interceptDlgt,
                  this._interceptCurrZone,
                  k,
                  n,
                  e
                )
              : n;
          }
          invoke(k, n, e, r, i) {
            return this._invokeZS
              ? this._invokeZS.onInvoke(
                  this._invokeDlgt,
                  this._invokeCurrZone,
                  k,
                  n,
                  e,
                  r,
                  i
                )
              : n.apply(e, r);
          }
          handleError(k, n) {
            return (
              !this._handleErrorZS ||
              this._handleErrorZS.onHandleError(
                this._handleErrorDlgt,
                this._handleErrorCurrZone,
                k,
                n
              )
            );
          }
          scheduleTask(k, n) {
            let e = n;
            if (this._scheduleTaskZS)
              this._hasTaskZS && e._zoneDelegates.push(this._hasTaskDlgtOwner),
                (e = this._scheduleTaskZS.onScheduleTask(
                  this._scheduleTaskDlgt,
                  this._scheduleTaskCurrZone,
                  k,
                  n
                )),
                e || (e = n);
            else if (n.scheduleFn) n.scheduleFn(n);
            else {
              if (n.type != N) throw new Error("Task is missing scheduleFn.");
              T(n);
            }
            return e;
          }
          invokeTask(k, n, e, r) {
            return this._invokeTaskZS
              ? this._invokeTaskZS.onInvokeTask(
                  this._invokeTaskDlgt,
                  this._invokeTaskCurrZone,
                  k,
                  n,
                  e,
                  r
                )
              : n.callback.apply(e, r);
          }
          cancelTask(k, n) {
            let e;
            if (this._cancelTaskZS)
              e = this._cancelTaskZS.onCancelTask(
                this._cancelTaskDlgt,
                this._cancelTaskCurrZone,
                k,
                n
              );
            else {
              if (!n.cancelFn) throw Error("Task is not cancelable");
              e = n.cancelFn(n);
            }
            return e;
          }
          hasTask(k, n) {
            try {
              this._hasTaskZS &&
                this._hasTaskZS.onHasTask(
                  this._hasTaskDlgt,
                  this._hasTaskCurrZone,
                  k,
                  n
                );
            } catch (e) {
              this.handleError(k, e);
            }
          }
          _updateTaskCount(k, n) {
            const e = this._taskCounts,
              r = e[k],
              i = (e[k] = r + n);
            if (i < 0)
              throw new Error("More tasks executed then were scheduled.");
            (0 != r && 0 != i) ||
              this.hasTask(this.zone, {
                microTask: e.microTask > 0,
                macroTask: e.macroTask > 0,
                eventTask: e.eventTask > 0,
                change: k,
              });
          }
        }
        class b {
          constructor(k, n, e, r, i, h) {
            if (
              ((this._zone = null),
              (this.runCount = 0),
              (this._zoneDelegates = null),
              (this._state = "notScheduled"),
              (this.type = k),
              (this.source = n),
              (this.data = r),
              (this.scheduleFn = i),
              (this.cancelFn = h),
              !e)
            )
              throw new Error("callback is not defined");
            this.callback = e;
            const s = this;
            this.invoke =
              k === O && r && r.useG
                ? b.invokeTask
                : function () {
                    return b.invokeTask.call(t, s, this, arguments);
                  };
          }
          static invokeTask(k, n, e) {
            k || (k = this), fe++;
            try {
              return k.runCount++, k.zone.runTask(k, n, e);
            } finally {
              1 == fe && Z(), fe--;
            }
          }
          get zone() {
            return this._zone;
          }
          get state() {
            return this._state;
          }
          cancelScheduleRequest() {
            this._transitionTo(B, $);
          }
          _transitionTo(k, n, e) {
            if (this._state !== n && this._state !== e)
              throw new Error(
                `${this.type} '${
                  this.source
                }': can not transition to '${k}', expecting state '${n}'${
                  e ? " or '" + e + "'" : ""
                }, was '${this._state}'.`
              );
            (this._state = k), k == B && (this._zoneDelegates = null);
          }
          toString() {
            return this.data && typeof this.data.handleId < "u"
              ? this.data.handleId.toString()
              : Object.prototype.toString.call(this);
          }
          toJSON() {
            return {
              type: this.type,
              state: this.state,
              source: this.source,
              zone: this.zone.name,
              runCount: this.runCount,
            };
          }
        }
        const H = m("setTimeout"),
          S = m("Promise"),
          P = m("then");
        let L,
          G = [],
          x = !1;
        function T(I) {
          if (0 === fe && 0 === G.length)
            if ((L || (t[S] && (L = t[S].resolve(0))), L)) {
              let k = L[P];
              k || (k = L.then), k.call(L, Z);
            } else t[H](Z, 0);
          I && G.push(I);
        }
        function Z() {
          if (!x) {
            for (x = !0; G.length; ) {
              const I = G;
              G = [];
              for (let k = 0; k < I.length; k++) {
                const n = I[k];
                try {
                  n.zone.runTask(n, null, null);
                } catch (e) {
                  Te.onUnhandledError(e);
                }
              }
            }
            Te.microtaskDrainDone(), (x = !1);
          }
        }
        const z = { name: "NO ZONE" },
          B = "notScheduled",
          $ = "scheduling",
          R = "scheduled",
          Q = "running",
          V = "canceling",
          K = "unknown",
          N = "microTask",
          j = "macroTask",
          O = "eventTask",
          re = {},
          Te = {
            symbol: m,
            currentZoneFrame: () => F,
            onUnhandledError: W,
            microtaskDrainDone: W,
            scheduleMicroTask: T,
            showUncaughtError: () => !v[m("ignoreConsoleErrorUncaughtError")],
            patchEventTarget: () => [],
            patchOnProperties: W,
            patchMethod: () => W,
            bindArguments: () => [],
            patchThen: () => W,
            patchMacroTask: () => W,
            patchEventPrototype: () => W,
            isIEOrEdge: () => !1,
            getGlobalObjects: () => {},
            ObjectDefineProperty: () => W,
            ObjectGetOwnPropertyDescriptor: () => {},
            ObjectCreate: () => {},
            ArraySlice: () => [],
            patchClass: () => W,
            wrapWithCurrentZone: () => W,
            filterProperties: () => [],
            attachOriginToPatched: () => W,
            _redefineProperty: () => W,
            patchCallbacks: () => W,
          };
        let F = { parent: null, zone: new v(null, null) },
          ue = null,
          fe = 0;
        function W() {}
        c("Zone", "Zone"), (t.Zone = v);
      })(
        (typeof window < "u" && window) || (typeof self < "u" && self) || global
      );
      const oe = Object.getOwnPropertyDescriptor,
        ge = Object.defineProperty,
        ye = Object.getPrototypeOf,
        _t = Object.create,
        Ve = Array.prototype.slice,
        Ie = "addEventListener",
        Je = "removeEventListener",
        Qe = Zone.__symbol__(Ie),
        et = Zone.__symbol__(Je),
        he = "true",
        ve = "false",
        Ze = Zone.__symbol__("");
      function Fe(t, a) {
        return Zone.current.wrap(t, a);
      }
      function lt(t, a, u, c, f) {
        return Zone.current.scheduleMacroTask(t, a, u, c, f);
      }
      const U = Zone.__symbol__,
        Ae = typeof window < "u",
        ke = Ae ? window : void 0,
        J = (Ae && ke) || ("object" == typeof self && self) || global,
        yt = [null];
      function tt(t, a) {
        for (let u = t.length - 1; u >= 0; u--)
          "function" == typeof t[u] && (t[u] = Fe(t[u], a + "_" + u));
        return t;
      }
      function ft(t) {
        return (
          !t ||
          (!1 !== t.writable &&
            !("function" == typeof t.get && typeof t.set > "u"))
        );
      }
      const A =
          typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope,
        ne =
          !("nw" in J) &&
          typeof J.process < "u" &&
          "[object process]" === {}.toString.call(J.process),
        ht = !ne && !A && !(!Ae || !ke.HTMLElement),
        Ue =
          typeof J.process < "u" &&
          "[object process]" === {}.toString.call(J.process) &&
          !A &&
          !(!Ae || !ke.HTMLElement),
        je = {},
        Be = function (t) {
          if (!(t = t || J.event)) return;
          let a = je[t.type];
          a || (a = je[t.type] = U("ON_PROPERTY" + t.type));
          const u = this || t.target || J,
            c = u[a];
          let f;
          if (ht && u === ke && "error" === t.type) {
            const m = t;
            (f =
              c &&
              c.call(this, m.message, m.filename, m.lineno, m.colno, m.error)),
              !0 === f && t.preventDefault();
          } else
            (f = c && c.apply(this, arguments)),
              null != f && !f && t.preventDefault();
          return f;
        };
      function nt(t, a, u) {
        let c = oe(t, a);
        if (
          (!c && u && oe(u, a) && (c = { enumerable: !0, configurable: !0 }),
          !c || !c.configurable)
        )
          return;
        const f = U("on" + a + "patched");
        if (t.hasOwnProperty(f) && t[f]) return;
        delete c.writable, delete c.value;
        const m = c.get,
          E = c.set,
          v = a.substr(2);
        let C = je[v];
        C || (C = je[v] = U("ON_PROPERTY" + v)),
          (c.set = function (w) {
            let b = this;
            !b && t === J && (b = J),
              b &&
                (b[C] && b.removeEventListener(v, Be),
                E && E.apply(b, yt),
                "function" == typeof w
                  ? ((b[C] = w), b.addEventListener(v, Be, !1))
                  : (b[C] = null));
          }),
          (c.get = function () {
            let w = this;
            if ((!w && t === J && (w = J), !w)) return null;
            const b = w[C];
            if (b) return b;
            if (m) {
              let H = m && m.call(this);
              if (H)
                return (
                  c.set.call(this, H),
                  "function" == typeof w.removeAttribute &&
                    w.removeAttribute(a),
                  H
                );
            }
            return null;
          }),
          ge(t, a, c),
          (t[f] = !0);
      }
      function Ge(t, a, u) {
        if (a) for (let c = 0; c < a.length; c++) nt(t, "on" + a[c], u);
        else {
          const c = [];
          for (const f in t) "on" == f.substr(0, 2) && c.push(f);
          for (let f = 0; f < c.length; f++) nt(t, c[f], u);
        }
      }
      const ie = U("originalInstance");
      function we(t) {
        const a = J[t];
        if (!a) return;
        (J[U(t)] = a),
          (J[t] = function () {
            const f = tt(arguments, t);
            switch (f.length) {
              case 0:
                this[ie] = new a();
                break;
              case 1:
                this[ie] = new a(f[0]);
                break;
              case 2:
                this[ie] = new a(f[0], f[1]);
                break;
              case 3:
                this[ie] = new a(f[0], f[1], f[2]);
                break;
              case 4:
                this[ie] = new a(f[0], f[1], f[2], f[3]);
                break;
              default:
                throw new Error("Arg list too long.");
            }
          }),
          se(J[t], a);
        const u = new a(function () {});
        let c;
        for (c in u)
          ("XMLHttpRequest" === t && "responseBlob" === c) ||
            (function (f) {
              "function" == typeof u[f]
                ? (J[t].prototype[f] = function () {
                    return this[ie][f].apply(this[ie], arguments);
                  })
                : ge(J[t].prototype, f, {
                    set: function (m) {
                      "function" == typeof m
                        ? ((this[ie][f] = Fe(m, t + "." + f)),
                          se(this[ie][f], m))
                        : (this[ie][f] = m);
                    },
                    get: function () {
                      return this[ie][f];
                    },
                  });
            })(c);
        for (c in a)
          "prototype" !== c && a.hasOwnProperty(c) && (J[t][c] = a[c]);
      }
      function ae(t, a, u) {
        let c = t;
        for (; c && !c.hasOwnProperty(a); ) c = ye(c);
        !c && t[a] && (c = t);
        const f = U(a);
        let m = null;
        if (
          c &&
          (!(m = c[f]) || !c.hasOwnProperty(f)) &&
          ((m = c[f] = c[a]), ft(c && oe(c, a)))
        ) {
          const v = u(m, f, a);
          (c[a] = function () {
            return v(this, arguments);
          }),
            se(c[a], m);
        }
        return m;
      }
      function Ce(t, a, u) {
        let c = null;
        function f(m) {
          const E = m.data;
          return (
            (E.args[E.cbIdx] = function () {
              m.invoke.apply(this, arguments);
            }),
            c.apply(E.target, E.args),
            m
          );
        }
        c = ae(
          t,
          a,
          (m) =>
            function (E, v) {
              const C = u(E, v);
              return C.cbIdx >= 0 && "function" == typeof v[C.cbIdx]
                ? lt(C.name, v[C.cbIdx], C, f)
                : m.apply(E, v);
            }
        );
      }
      function se(t, a) {
        t[U("OriginalDelegate")] = a;
      }
      let dt = !1,
        de = !1;
      function Le() {
        if (dt) return de;
        dt = !0;
        try {
          const t = ke.navigator.userAgent;
          (-1 !== t.indexOf("MSIE ") ||
            -1 !== t.indexOf("Trident/") ||
            -1 !== t.indexOf("Edge/")) &&
            (de = !0);
        } catch {}
        return de;
      }
      Zone.__load_patch("ZoneAwarePromise", (t, a, u) => {
        const c = Object.getOwnPropertyDescriptor,
          f = Object.defineProperty,
          E = u.symbol,
          v = [],
          C = !0 === t[E("DISABLE_WRAPPING_UNCAUGHT_PROMISE_REJECTION")],
          w = E("Promise"),
          b = E("then");
        (u.onUnhandledError = (s) => {
          if (u.showUncaughtError()) {
            const o = s && s.rejection;
            o
              ? console.error(
                  "Unhandled Promise rejection:",
                  o instanceof Error ? o.message : o,
                  "; Zone:",
                  s.zone.name,
                  "; Task:",
                  s.task && s.task.source,
                  "; Value:",
                  o,
                  o instanceof Error ? o.stack : void 0
                )
              : console.error(s);
          }
        }),
          (u.microtaskDrainDone = () => {
            for (; v.length; ) {
              const s = v.shift();
              try {
                s.zone.runGuarded(() => {
                  throw s.throwOriginal ? s.rejection : s;
                });
              } catch (o) {
                P(o);
              }
            }
          });
        const S = E("unhandledPromiseRejectionHandler");
        function P(s) {
          u.onUnhandledError(s);
          try {
            const o = a[S];
            "function" == typeof o && o.call(this, s);
          } catch {}
        }
        function G(s) {
          return s && s.then;
        }
        function x(s) {
          return s;
        }
        function L(s) {
          return n.reject(s);
        }
        const T = E("state"),
          Z = E("value"),
          z = E("finally"),
          B = E("parentPromiseValue"),
          $ = E("parentPromiseState"),
          Q = null,
          V = !0,
          K = !1;
        function j(s, o) {
          return (l) => {
            try {
              F(s, o, l);
            } catch (d) {
              F(s, !1, d);
            }
          };
        }
        const Te = E("currentTaskTrace");
        function F(s, o, l) {
          const d = (function () {
            let s = !1;
            return function (l) {
              return function () {
                s || ((s = !0), l.apply(null, arguments));
              };
            };
          })();
          if (s === l) throw new TypeError("Promise resolved with itself");
          if (s[T] === Q) {
            let p = null;
            try {
              ("object" == typeof l || "function" == typeof l) &&
                (p = l && l.then);
            } catch (y) {
              return (
                d(() => {
                  F(s, !1, y);
                })(),
                s
              );
            }
            if (
              o !== K &&
              l instanceof n &&
              l.hasOwnProperty(T) &&
              l.hasOwnProperty(Z) &&
              l[T] !== Q
            )
              fe(l), F(s, l[T], l[Z]);
            else if (o !== K && "function" == typeof p)
              try {
                p.call(l, d(j(s, o)), d(j(s, !1)));
              } catch (y) {
                d(() => {
                  F(s, !1, y);
                })();
              }
            else {
              s[T] = o;
              const y = s[Z];
              if (
                ((s[Z] = l),
                s[z] === z && o === V && ((s[T] = s[$]), (s[Z] = s[B])),
                o === K && l instanceof Error)
              ) {
                const _ =
                  a.currentTask &&
                  a.currentTask.data &&
                  a.currentTask.data.__creationTrace__;
                _ &&
                  f(l, Te, {
                    configurable: !0,
                    enumerable: !1,
                    writable: !0,
                    value: _,
                  });
              }
              for (let _ = 0; _ < y.length; )
                W(s, y[_++], y[_++], y[_++], y[_++]);
              if (0 == y.length && o == K) {
                s[T] = 0;
                let _ = l;
                try {
                  throw new Error(
                    "Uncaught (in promise): " +
                      (function m(s) {
                        return s && s.toString === Object.prototype.toString
                          ? ((s.constructor && s.constructor.name) || "") +
                              ": " +
                              JSON.stringify(s)
                          : s
                          ? s.toString()
                          : Object.prototype.toString.call(s);
                      })(l) +
                      (l && l.stack ? "\n" + l.stack : "")
                  );
                } catch (g) {
                  _ = g;
                }
                C && (_.throwOriginal = !0),
                  (_.rejection = l),
                  (_.promise = s),
                  (_.zone = a.current),
                  (_.task = a.currentTask),
                  v.push(_),
                  u.scheduleMicroTask();
              }
            }
          }
          return s;
        }
        const ue = E("rejectionHandledHandler");
        function fe(s) {
          if (0 === s[T]) {
            try {
              const o = a[ue];
              o &&
                "function" == typeof o &&
                o.call(this, { rejection: s[Z], promise: s });
            } catch {}
            s[T] = K;
            for (let o = 0; o < v.length; o++)
              s === v[o].promise && v.splice(o, 1);
          }
        }
        function W(s, o, l, d, p) {
          fe(s);
          const y = s[T],
            _ = y
              ? "function" == typeof d
                ? d
                : x
              : "function" == typeof p
              ? p
              : L;
          o.scheduleMicroTask(
            "Promise.then",
            () => {
              try {
                const g = s[Z],
                  M = !!l && z === l[z];
                M && ((l[B] = g), (l[$] = y));
                const D = o.run(_, void 0, M && _ !== L && _ !== x ? [] : [g]);
                F(l, !0, D);
              } catch (g) {
                F(l, !1, g);
              }
            },
            l
          );
        }
        const k = function () {};
        class n {
          static toString() {
            return "function ZoneAwarePromise() { [native code] }";
          }
          static resolve(o) {
            return F(new this(null), V, o);
          }
          static reject(o) {
            return F(new this(null), K, o);
          }
          static race(o) {
            let l,
              d,
              p = new this((g, M) => {
                (l = g), (d = M);
              });
            function y(g) {
              l(g);
            }
            function _(g) {
              d(g);
            }
            for (let g of o) G(g) || (g = this.resolve(g)), g.then(y, _);
            return p;
          }
          static all(o) {
            return n.allWithCallback(o);
          }
          static allSettled(o) {
            return (
              this && this.prototype instanceof n ? this : n
            ).allWithCallback(o, {
              thenCallback: (d) => ({ status: "fulfilled", value: d }),
              errorCallback: (d) => ({ status: "rejected", reason: d }),
            });
          }
          static allWithCallback(o, l) {
            let d,
              p,
              y = new this((D, q) => {
                (d = D), (p = q);
              }),
              _ = 2,
              g = 0;
            const M = [];
            for (let D of o) {
              G(D) || (D = this.resolve(D));
              const q = g;
              try {
                D.then(
                  (ee) => {
                    (M[q] = l ? l.thenCallback(ee) : ee), _--, 0 === _ && d(M);
                  },
                  (ee) => {
                    l
                      ? ((M[q] = l.errorCallback(ee)), _--, 0 === _ && d(M))
                      : p(ee);
                  }
                );
              } catch (ee) {
                p(ee);
              }
              _++, g++;
            }
            return (_ -= 2), 0 === _ && d(M), y;
          }
          constructor(o) {
            const l = this;
            if (!(l instanceof n))
              throw new Error("Must be an instanceof Promise.");
            (l[T] = Q), (l[Z] = []);
            try {
              o && o(j(l, V), j(l, K));
            } catch (d) {
              F(l, !1, d);
            }
          }
          get [Symbol.toStringTag]() {
            return "Promise";
          }
          get [Symbol.species]() {
            return n;
          }
          then(o, l) {
            let d = this.constructor[Symbol.species];
            (!d || "function" != typeof d) && (d = this.constructor || n);
            const p = new d(k),
              y = a.current;
            return (
              this[T] == Q ? this[Z].push(y, p, o, l) : W(this, y, p, o, l), p
            );
          }
          catch(o) {
            return this.then(null, o);
          }
          finally(o) {
            let l = this.constructor[Symbol.species];
            (!l || "function" != typeof l) && (l = n);
            const d = new l(k);
            d[z] = z;
            const p = a.current;
            return (
              this[T] == Q ? this[Z].push(p, d, o, o) : W(this, p, d, o, o), d
            );
          }
        }
        (n.resolve = n.resolve),
          (n.reject = n.reject),
          (n.race = n.race),
          (n.all = n.all);
        const e = (t[w] = t.Promise);
        t.Promise = n;
        const r = E("thenPatched");
        function i(s) {
          const o = s.prototype,
            l = c(o, "then");
          if (l && (!1 === l.writable || !l.configurable)) return;
          const d = o.then;
          (o[b] = d),
            (s.prototype.then = function (p, y) {
              return new n((g, M) => {
                d.call(this, g, M);
              }).then(p, y);
            }),
            (s[r] = !0);
        }
        return (
          (u.patchThen = i),
          e &&
            (i(e),
            ae(t, "fetch", (s) =>
              (function h(s) {
                return function (o, l) {
                  let d = s.apply(o, l);
                  if (d instanceof n) return d;
                  let p = d.constructor;
                  return p[r] || i(p), d;
                };
              })(s)
            )),
          (Promise[a.__symbol__("uncaughtPromiseErrors")] = v),
          n
        );
      }),
        Zone.__load_patch("toString", (t) => {
          const a = Function.prototype.toString,
            u = U("OriginalDelegate"),
            c = U("Promise"),
            f = U("Error"),
            m = function () {
              if ("function" == typeof this) {
                const w = this[u];
                if (w)
                  return "function" == typeof w
                    ? a.call(w)
                    : Object.prototype.toString.call(w);
                if (this === Promise) {
                  const b = t[c];
                  if (b) return a.call(b);
                }
                if (this === Error) {
                  const b = t[f];
                  if (b) return a.call(b);
                }
              }
              return a.call(this);
            };
          (m[u] = a), (Function.prototype.toString = m);
          const E = Object.prototype.toString;
          Object.prototype.toString = function () {
            return "function" == typeof Promise && this instanceof Promise
              ? "[object Promise]"
              : E.call(this);
          };
        });
      let ce = !1;
      if (typeof window < "u")
        try {
          const t = Object.defineProperty({}, "passive", {
            get: function () {
              ce = !0;
            },
          });
          window.addEventListener("test", t, t),
            window.removeEventListener("test", t, t);
        } catch {
          ce = !1;
        }
      const me = { useG: !0 },
        te = {},
        pe = {},
        vt = new RegExp("^" + Ze + "(\\w+)(true|false)$"),
        rt = U("propagationStopped");
      function mt(t, a) {
        const u = (a ? a(t) : t) + ve,
          c = (a ? a(t) : t) + he,
          f = Ze + u,
          m = Ze + c;
        (te[t] = {}), (te[t][ve] = f), (te[t][he] = m);
      }
      function ze(t, a, u) {
        const c = (u && u.add) || Ie,
          f = (u && u.rm) || Je,
          m = (u && u.listeners) || "eventListeners",
          E = (u && u.rmAll) || "removeAllListeners",
          v = U(c),
          C = "." + c + ":",
          H = function (L, T, Z) {
            if (L.isRemoved) return;
            const z = L.callback;
            "object" == typeof z &&
              z.handleEvent &&
              ((L.callback = ($) => z.handleEvent($)),
              (L.originalDelegate = z)),
              L.invoke(L, T, [Z]);
            const B = L.options;
            B &&
              "object" == typeof B &&
              B.once &&
              T[f].call(
                T,
                Z.type,
                L.originalDelegate ? L.originalDelegate : L.callback,
                B
              );
          },
          S = function (L) {
            if (!(L = L || t.event)) return;
            const T = this || L.target || t,
              Z = T[te[L.type][ve]];
            if (Z)
              if (1 === Z.length) H(Z[0], T, L);
              else {
                const z = Z.slice();
                for (let B = 0; B < z.length && (!L || !0 !== L[rt]); B++)
                  H(z[B], T, L);
              }
          },
          P = function (L) {
            if (!(L = L || t.event)) return;
            const T = this || L.target || t,
              Z = T[te[L.type][he]];
            if (Z)
              if (1 === Z.length) H(Z[0], T, L);
              else {
                const z = Z.slice();
                for (let B = 0; B < z.length && (!L || !0 !== L[rt]); B++)
                  H(z[B], T, L);
              }
          };
        function G(L, T) {
          if (!L) return !1;
          let Z = !0;
          T && void 0 !== T.useG && (Z = T.useG);
          const z = T && T.vh;
          let B = !0;
          T && void 0 !== T.chkDup && (B = T.chkDup);
          let $ = !1;
          T && void 0 !== T.rt && ($ = T.rt);
          let R = L;
          for (; R && !R.hasOwnProperty(c); ) R = ye(R);
          if ((!R && L[c] && (R = L), !R || R[v])) return !1;
          const Q = T && T.eventNameToString,
            V = {},
            K = (R[v] = R[c]),
            N = (R[U(f)] = R[f]),
            j = (R[U(m)] = R[m]),
            O = (R[U(E)] = R[E]);
          let re;
          function Te(o, l) {
            return !ce && "object" == typeof o && o
              ? !!o.capture
              : ce && l
              ? "boolean" == typeof o
                ? { capture: o, passive: !0 }
                : o
                ? "object" == typeof o && !1 !== o.passive
                  ? Object.assign(Object.assign({}, o), { passive: !0 })
                  : o
                : { passive: !0 }
              : o;
          }
          T && T.prepend && (re = R[U(T.prepend)] = R[T.prepend]);
          const k = Z
              ? function (o) {
                  if (!V.isExisting)
                    return K.call(
                      V.target,
                      V.eventName,
                      V.capture ? P : S,
                      V.options
                    );
                }
              : function (o) {
                  return K.call(V.target, V.eventName, o.invoke, V.options);
                },
            n = Z
              ? function (o) {
                  if (!o.isRemoved) {
                    const l = te[o.eventName];
                    let d;
                    l && (d = l[o.capture ? he : ve]);
                    const p = d && o.target[d];
                    if (p)
                      for (let y = 0; y < p.length; y++)
                        if (p[y] === o) {
                          p.splice(y, 1),
                            (o.isRemoved = !0),
                            0 === p.length &&
                              ((o.allRemoved = !0), (o.target[d] = null));
                          break;
                        }
                  }
                  if (o.allRemoved)
                    return N.call(
                      o.target,
                      o.eventName,
                      o.capture ? P : S,
                      o.options
                    );
                }
              : function (o) {
                  return N.call(o.target, o.eventName, o.invoke, o.options);
                },
            r =
              T && T.diff
                ? T.diff
                : function (o, l) {
                    const d = typeof l;
                    return (
                      ("function" === d && o.callback === l) ||
                      ("object" === d && o.originalDelegate === l)
                    );
                  },
            i = Zone[U("UNPATCHED_EVENTS")],
            h = t[U("PASSIVE_EVENTS")],
            s = function (o, l, d, p, y = !1, _ = !1) {
              return function () {
                const g = this || t;
                let M = arguments[0];
                T && T.transferEventName && (M = T.transferEventName(M));
                let D = arguments[1];
                if (!D) return o.apply(this, arguments);
                if (ne && "uncaughtException" === M)
                  return o.apply(this, arguments);
                let q = !1;
                if ("function" != typeof D) {
                  if (!D.handleEvent) return o.apply(this, arguments);
                  q = !0;
                }
                if (z && !z(o, D, g, arguments)) return;
                const ee = ce && !!h && -1 !== h.indexOf(M),
                  _e = Te(arguments[2], ee);
                if (i)
                  for (let Ke = 0; Ke < i.length; Ke++)
                    if (M === i[Ke])
                      return ee
                        ? o.call(g, M, D, _e)
                        : o.apply(this, arguments);
                const Nt = !!_e && ("boolean" == typeof _e || _e.capture),
                  Ht = !(!_e || "object" != typeof _e) && _e.once,
                  Zt = Zone.current;
                let Ot = te[M];
                Ot || (mt(M, Q), (Ot = te[M]));
                const Dt = Ot[Nt ? he : ve];
                let Lt,
                  ct = g[Dt],
                  Rt = !1;
                if (ct) {
                  if (((Rt = !0), B))
                    for (let Ke = 0; Ke < ct.length; Ke++)
                      if (r(ct[Ke], D)) return;
                } else ct = g[Dt] = [];
                const St = g.constructor.name,
                  It = pe[St];
                It && (Lt = It[M]),
                  Lt || (Lt = St + l + (Q ? Q(M) : M)),
                  (V.options = _e),
                  Ht && (V.options.once = !1),
                  (V.target = g),
                  (V.capture = Nt),
                  (V.eventName = M),
                  (V.isExisting = Rt);
                const Tt = Z ? me : void 0;
                Tt && (Tt.taskData = V);
                const xe = Zt.scheduleEventTask(Lt, D, Tt, d, p);
                return (
                  (V.target = null),
                  Tt && (Tt.taskData = null),
                  Ht && (_e.once = !0),
                  (!ce && "boolean" == typeof xe.options) || (xe.options = _e),
                  (xe.target = g),
                  (xe.capture = Nt),
                  (xe.eventName = M),
                  q && (xe.originalDelegate = D),
                  _ ? ct.unshift(xe) : ct.push(xe),
                  y ? g : void 0
                );
              };
            };
          return (
            (R[c] = s(K, C, k, n, $)),
            re &&
              (R.prependListener = s(
                re,
                ".prependListener:",
                function (o) {
                  return re.call(V.target, V.eventName, o.invoke, V.options);
                },
                n,
                $,
                !0
              )),
            (R[f] = function () {
              const o = this || t;
              let l = arguments[0];
              T && T.transferEventName && (l = T.transferEventName(l));
              const d = arguments[2],
                p = !!d && ("boolean" == typeof d || d.capture),
                y = arguments[1];
              if (!y) return N.apply(this, arguments);
              if (z && !z(N, y, o, arguments)) return;
              const _ = te[l];
              let g;
              _ && (g = _[p ? he : ve]);
              const M = g && o[g];
              if (M)
                for (let D = 0; D < M.length; D++) {
                  const q = M[D];
                  if (r(q, y))
                    return (
                      M.splice(D, 1),
                      (q.isRemoved = !0),
                      0 === M.length &&
                        ((q.allRemoved = !0),
                        (o[g] = null),
                        "string" == typeof l) &&
                        (o[Ze + "ON_PROPERTY" + l] = null),
                      q.zone.cancelTask(q),
                      $ ? o : void 0
                    );
                }
              return N.apply(this, arguments);
            }),
            (R[m] = function () {
              const o = this || t;
              let l = arguments[0];
              T && T.transferEventName && (l = T.transferEventName(l));
              const d = [],
                p = kt(o, Q ? Q(l) : l);
              for (let y = 0; y < p.length; y++) {
                const _ = p[y];
                d.push(_.originalDelegate ? _.originalDelegate : _.callback);
              }
              return d;
            }),
            (R[E] = function () {
              const o = this || t;
              let l = arguments[0];
              if (l) {
                T && T.transferEventName && (l = T.transferEventName(l));
                const d = te[l];
                if (d) {
                  const _ = o[d[ve]],
                    g = o[d[he]];
                  if (_) {
                    const M = _.slice();
                    for (let D = 0; D < M.length; D++) {
                      const q = M[D];
                      this[f].call(
                        this,
                        l,
                        q.originalDelegate ? q.originalDelegate : q.callback,
                        q.options
                      );
                    }
                  }
                  if (g) {
                    const M = g.slice();
                    for (let D = 0; D < M.length; D++) {
                      const q = M[D];
                      this[f].call(
                        this,
                        l,
                        q.originalDelegate ? q.originalDelegate : q.callback,
                        q.options
                      );
                    }
                  }
                }
              } else {
                const d = Object.keys(o);
                for (let p = 0; p < d.length; p++) {
                  const _ = vt.exec(d[p]);
                  let g = _ && _[1];
                  g && "removeListener" !== g && this[E].call(this, g);
                }
                this[E].call(this, "removeListener");
              }
              if ($) return this;
            }),
            se(R[c], K),
            se(R[f], N),
            O && se(R[E], O),
            j && se(R[m], j),
            !0
          );
        }
        let x = [];
        for (let L = 0; L < a.length; L++) x[L] = G(a[L], u);
        return x;
      }
      function kt(t, a) {
        if (!a) {
          const m = [];
          for (let E in t) {
            const v = vt.exec(E);
            let C = v && v[1];
            if (C && (!a || C === a)) {
              const w = t[E];
              if (w) for (let b = 0; b < w.length; b++) m.push(w[b]);
            }
          }
          return m;
        }
        let u = te[a];
        u || (mt(a), (u = te[a]));
        const c = t[u[ve]],
          f = t[u[he]];
        return c ? (f ? c.concat(f) : c.slice()) : f ? f.slice() : [];
      }
      function ot(t, a) {
        const u = t.Event;
        u &&
          u.prototype &&
          a.patchMethod(
            u.prototype,
            "stopImmediatePropagation",
            (c) =>
              function (f, m) {
                (f[rt] = !0), c && c.apply(f, m);
              }
          );
      }
      function pt(t, a, u, c, f) {
        const m = Zone.__symbol__(c);
        if (a[m]) return;
        const E = (a[m] = a[c]);
        (a[c] = function (v, C, w) {
          return (
            C &&
              C.prototype &&
              f.forEach(function (b) {
                const H = `${u}.${c}::` + b,
                  S = C.prototype;
                if (S.hasOwnProperty(b)) {
                  const P = t.ObjectGetOwnPropertyDescriptor(S, b);
                  P && P.value
                    ? ((P.value = t.wrapWithCurrentZone(P.value, H)),
                      t._redefineProperty(C.prototype, b, P))
                    : S[b] && (S[b] = t.wrapWithCurrentZone(S[b], H));
                } else S[b] && (S[b] = t.wrapWithCurrentZone(S[b], H));
              }),
            E.call(a, v, C, w)
          );
        }),
          t.attachOriginToPatched(a[c], E);
      }
      const Et = [
          "absolutedeviceorientation",
          "afterinput",
          "afterprint",
          "appinstalled",
          "beforeinstallprompt",
          "beforeprint",
          "beforeunload",
          "devicelight",
          "devicemotion",
          "deviceorientation",
          "deviceorientationabsolute",
          "deviceproximity",
          "hashchange",
          "languagechange",
          "message",
          "mozbeforepaint",
          "offline",
          "online",
          "paint",
          "pageshow",
          "pagehide",
          "popstate",
          "rejectionhandled",
          "storage",
          "unhandledrejection",
          "unload",
          "userproximity",
          "vrdisplayconnected",
          "vrdisplaydisconnected",
          "vrdisplaypresentchange",
        ],
        st = [
          "encrypted",
          "waitingforkey",
          "msneedkey",
          "mozinterruptbegin",
          "mozinterruptend",
        ],
        le = ["load"],
        De = [
          "blur",
          "error",
          "focus",
          "load",
          "resize",
          "scroll",
          "messageerror",
        ],
        Ee = ["bounce", "finish", "start"],
        it = [
          "loadstart",
          "progress",
          "abort",
          "error",
          "load",
          "progress",
          "timeout",
          "loadend",
          "readystatechange",
        ],
        Pe = [
          "upgradeneeded",
          "complete",
          "abort",
          "success",
          "error",
          "blocked",
          "versionchange",
          "close",
        ],
        at = ["close", "error", "open", "message"],
        Re = ["error", "message"],
        Ne = [
          "abort",
          "animationcancel",
          "animationend",
          "animationiteration",
          "auxclick",
          "beforeinput",
          "blur",
          "cancel",
          "canplay",
          "canplaythrough",
          "change",
          "compositionstart",
          "compositionupdate",
          "compositionend",
          "cuechange",
          "click",
          "close",
          "contextmenu",
          "curechange",
          "dblclick",
          "drag",
          "dragend",
          "dragenter",
          "dragexit",
          "dragleave",
          "dragover",
          "drop",
          "durationchange",
          "emptied",
          "ended",
          "error",
          "focus",
          "focusin",
          "focusout",
          "gotpointercapture",
          "input",
          "invalid",
          "keydown",
          "keypress",
          "keyup",
          "load",
          "loadstart",
          "loadeddata",
          "loadedmetadata",
          "lostpointercapture",
          "mousedown",
          "mouseenter",
          "mouseleave",
          "mousemove",
          "mouseout",
          "mouseover",
          "mouseup",
          "mousewheel",
          "orientationchange",
          "pause",
          "play",
          "playing",
          "pointercancel",
          "pointerdown",
          "pointerenter",
          "pointerleave",
          "pointerlockchange",
          "mozpointerlockchange",
          "webkitpointerlockerchange",
          "pointerlockerror",
          "mozpointerlockerror",
          "webkitpointerlockerror",
          "pointermove",
          "pointout",
          "pointerover",
          "pointerup",
          "progress",
          "ratechange",
          "reset",
          "resize",
          "scroll",
          "seeked",
          "seeking",
          "select",
          "selectionchange",
          "selectstart",
          "show",
          "sort",
          "stalled",
          "submit",
          "suspend",
          "timeupdate",
          "volumechange",
          "touchcancel",
          "touchmove",
          "touchstart",
          "touchend",
          "transitioncancel",
          "transitionend",
          "waiting",
          "wheel",
        ].concat(
          [
            "webglcontextrestored",
            "webglcontextlost",
            "webglcontextcreationerror",
          ],
          ["autocomplete", "autocompleteerror"],
          ["toggle"],
          [
            "afterscriptexecute",
            "beforescriptexecute",
            "DOMContentLoaded",
            "freeze",
            "fullscreenchange",
            "mozfullscreenchange",
            "webkitfullscreenchange",
            "msfullscreenchange",
            "fullscreenerror",
            "mozfullscreenerror",
            "webkitfullscreenerror",
            "msfullscreenerror",
            "readystatechange",
            "visibilitychange",
            "resume",
          ],
          Et,
          [
            "beforecopy",
            "beforecut",
            "beforepaste",
            "copy",
            "cut",
            "paste",
            "dragstart",
            "loadend",
            "animationstart",
            "search",
            "transitionrun",
            "transitionstart",
            "webkitanimationend",
            "webkitanimationiteration",
            "webkitanimationstart",
            "webkittransitionend",
          ],
          [
            "activate",
            "afterupdate",
            "ariarequest",
            "beforeactivate",
            "beforedeactivate",
            "beforeeditfocus",
            "beforeupdate",
            "cellchange",
            "controlselect",
            "dataavailable",
            "datasetchanged",
            "datasetcomplete",
            "errorupdate",
            "filterchange",
            "layoutcomplete",
            "losecapture",
            "move",
            "moveend",
            "movestart",
            "propertychange",
            "resizeend",
            "resizestart",
            "rowenter",
            "rowexit",
            "rowsdelete",
            "rowsinserted",
            "command",
            "compassneedscalibration",
            "deactivate",
            "help",
            "mscontentzoom",
            "msmanipulationstatechanged",
            "msgesturechange",
            "msgesturedoubletap",
            "msgestureend",
            "msgesturehold",
            "msgesturestart",
            "msgesturetap",
            "msgotpointercapture",
            "msinertiastart",
            "mslostpointercapture",
            "mspointercancel",
            "mspointerdown",
            "mspointerenter",
            "mspointerhover",
            "mspointerleave",
            "mspointermove",
            "mspointerout",
            "mspointerover",
            "mspointerup",
            "pointerout",
            "mssitemodejumplistitemremoved",
            "msthumbnailclick",
            "stop",
            "storagecommit",
          ]
        );
      function Xe(t, a, u) {
        if (!u || 0 === u.length) return a;
        const c = u.filter((m) => m.target === t);
        if (!c || 0 === c.length) return a;
        const f = c[0].ignoreProperties;
        return a.filter((m) => -1 === f.indexOf(m));
      }
      function Y(t, a, u, c) {
        t && Ge(t, Xe(t, a, u), c);
      }
      Zone.__load_patch("util", (t, a, u) => {
        (u.patchOnProperties = Ge),
          (u.patchMethod = ae),
          (u.bindArguments = tt),
          (u.patchMacroTask = Ce);
        const c = a.__symbol__("BLACK_LISTED_EVENTS"),
          f = a.__symbol__("UNPATCHED_EVENTS");
        t[f] && (t[c] = t[f]),
          t[c] && (a[c] = a[f] = t[c]),
          (u.patchEventPrototype = ot),
          (u.patchEventTarget = ze),
          (u.isIEOrEdge = Le),
          (u.ObjectDefineProperty = ge),
          (u.ObjectGetOwnPropertyDescriptor = oe),
          (u.ObjectCreate = _t),
          (u.ArraySlice = Ve),
          (u.patchClass = we),
          (u.wrapWithCurrentZone = Fe),
          (u.filterProperties = Xe),
          (u.attachOriginToPatched = se),
          (u._redefineProperty = Object.defineProperty),
          (u.patchCallbacks = pt),
          (u.getGlobalObjects = () => ({
            globalSources: pe,
            zoneSymbolEventNames: te,
            eventNames: Ne,
            isBrowser: ht,
            isMix: Ue,
            isNode: ne,
            TRUE_STR: he,
            FALSE_STR: ve,
            ZONE_SYMBOL_PREFIX: Ze,
            ADD_EVENT_LISTENER_STR: Ie,
            REMOVE_EVENT_LISTENER_STR: Je,
          }));
      });
      const Ye = U("zoneTask");
      function Se(t, a, u, c) {
        let f = null,
          m = null;
        u += c;
        const E = {};
        function v(w) {
          const b = w.data;
          return (
            (b.args[0] = function () {
              return w.invoke.apply(this, arguments);
            }),
            (b.handleId = f.apply(t, b.args)),
            w
          );
        }
        function C(w) {
          return m.call(t, w.data.handleId);
        }
        (f = ae(
          t,
          (a += c),
          (w) =>
            function (b, H) {
              if ("function" == typeof H[0]) {
                const S = {
                    isPeriodic: "Interval" === c,
                    delay:
                      "Timeout" === c || "Interval" === c ? H[1] || 0 : void 0,
                    args: H,
                  },
                  P = H[0];
                H[0] = function () {
                  try {
                    return P.apply(this, arguments);
                  } finally {
                    S.isPeriodic ||
                      ("number" == typeof S.handleId
                        ? delete E[S.handleId]
                        : S.handleId && (S.handleId[Ye] = null));
                  }
                };
                const G = lt(a, H[0], S, v, C);
                if (!G) return G;
                const x = G.data.handleId;
                return (
                  "number" == typeof x ? (E[x] = G) : x && (x[Ye] = G),
                  x &&
                    x.ref &&
                    x.unref &&
                    "function" == typeof x.ref &&
                    "function" == typeof x.unref &&
                    ((G.ref = x.ref.bind(x)), (G.unref = x.unref.bind(x))),
                  "number" == typeof x || x ? x : G
                );
              }
              return w.apply(t, H);
            }
        )),
          (m = ae(
            t,
            u,
            (w) =>
              function (b, H) {
                const S = H[0];
                let P;
                "number" == typeof S
                  ? (P = E[S])
                  : ((P = S && S[Ye]), P || (P = S)),
                  P && "string" == typeof P.type
                    ? "notScheduled" !== P.state &&
                      ((P.cancelFn && P.data.isPeriodic) || 0 === P.runCount) &&
                      ("number" == typeof S ? delete E[S] : S && (S[Ye] = null),
                      P.zone.cancelTask(P))
                    : w.apply(t, H);
              }
          ));
      }
      Zone.__load_patch("legacy", (t) => {
        const a = t[Zone.__symbol__("legacyPatch")];
        a && a();
      }),
        Zone.__load_patch("queueMicrotask", (t, a, u) => {
          u.patchMethod(
            t,
            "queueMicrotask",
            (c) =>
              function (f, m) {
                a.current.scheduleMicroTask("queueMicrotask", m[0]);
              }
          );
        }),
        Zone.__load_patch("timers", (t) => {
          const a = "set",
            u = "clear";
          Se(t, a, u, "Timeout"),
            Se(t, a, u, "Interval"),
            Se(t, a, u, "Immediate");
        }),
        Zone.__load_patch("requestAnimationFrame", (t) => {
          Se(t, "request", "cancel", "AnimationFrame"),
            Se(t, "mozRequest", "mozCancel", "AnimationFrame"),
            Se(t, "webkitRequest", "webkitCancel", "AnimationFrame");
        }),
        Zone.__load_patch("blocking", (t, a) => {
          const u = ["alert", "prompt", "confirm"];
          for (let c = 0; c < u.length; c++)
            ae(
              t,
              u[c],
              (m, E, v) =>
                function (C, w) {
                  return a.current.run(m, t, w, v);
                }
            );
        }),
        Zone.__load_patch("EventTarget", (t, a, u) => {
          (function Me(t, a) {
            a.patchEventPrototype(t, a);
          })(t, u),
            (function $e(t, a) {
              if (Zone[a.symbol("patchEventTarget")]) return;
              const {
                eventNames: u,
                zoneSymbolEventNames: c,
                TRUE_STR: f,
                FALSE_STR: m,
                ZONE_SYMBOL_PREFIX: E,
              } = a.getGlobalObjects();
              for (let C = 0; C < u.length; C++) {
                const w = u[C],
                  S = E + (w + m),
                  P = E + (w + f);
                (c[w] = {}), (c[w][m] = S), (c[w][f] = P);
              }
              const v = t.EventTarget;
              v && v.prototype && a.patchEventTarget(t, [v && v.prototype]);
            })(t, u);
          const c = t.XMLHttpRequestEventTarget;
          c && c.prototype && u.patchEventTarget(t, [c.prototype]);
        }),
        Zone.__load_patch("MutationObserver", (t, a, u) => {
          we("MutationObserver"), we("WebKitMutationObserver");
        }),
        Zone.__load_patch("IntersectionObserver", (t, a, u) => {
          we("IntersectionObserver");
        }),
        Zone.__load_patch("FileReader", (t, a, u) => {
          we("FileReader");
        }),
        Zone.__load_patch("on_property", (t, a, u) => {
          !(function Ct(t, a) {
            if ((ne && !Ue) || Zone[t.symbol("patchEvents")]) return;
            const u = typeof WebSocket < "u",
              c = a.__Zone_ignore_on_properties;
            if (ht) {
              const E = window,
                v = (function be() {
                  try {
                    const t = ke.navigator.userAgent;
                    if (
                      -1 !== t.indexOf("MSIE ") ||
                      -1 !== t.indexOf("Trident/")
                    )
                      return !0;
                  } catch {}
                  return !1;
                })()
                  ? [{ target: E, ignoreProperties: ["error"] }]
                  : [];
              Y(E, Ne.concat(["messageerror"]), c && c.concat(v), ye(E)),
                Y(Document.prototype, Ne, c),
                typeof E.SVGElement < "u" && Y(E.SVGElement.prototype, Ne, c),
                Y(Element.prototype, Ne, c),
                Y(HTMLElement.prototype, Ne, c),
                Y(HTMLMediaElement.prototype, st, c),
                Y(HTMLFrameSetElement.prototype, Et.concat(De), c),
                Y(HTMLBodyElement.prototype, Et.concat(De), c),
                Y(HTMLFrameElement.prototype, le, c),
                Y(HTMLIFrameElement.prototype, le, c);
              const C = E.HTMLMarqueeElement;
              C && Y(C.prototype, Ee, c);
              const w = E.Worker;
              w && Y(w.prototype, Re, c);
            }
            const f = a.XMLHttpRequest;
            f && Y(f.prototype, it, c);
            const m = a.XMLHttpRequestEventTarget;
            m && Y(m && m.prototype, it, c),
              typeof IDBIndex < "u" &&
                (Y(IDBIndex.prototype, Pe, c),
                Y(IDBRequest.prototype, Pe, c),
                Y(IDBOpenDBRequest.prototype, Pe, c),
                Y(IDBDatabase.prototype, Pe, c),
                Y(IDBTransaction.prototype, Pe, c),
                Y(IDBCursor.prototype, Pe, c)),
              u && Y(WebSocket.prototype, at, c);
          })(u, t);
        }),
        Zone.__load_patch("customElements", (t, a, u) => {
          !(function Pt(t, a) {
            const { isBrowser: u, isMix: c } = a.getGlobalObjects();
            (u || c) &&
              t.customElements &&
              "customElements" in t &&
              a.patchCallbacks(
                a,
                t.customElements,
                "customElements",
                "define",
                [
                  "connectedCallback",
                  "disconnectedCallback",
                  "adoptedCallback",
                  "attributeChangedCallback",
                ]
              );
          })(t, u);
        }),
        Zone.__load_patch("XHR", (t, a) => {
          !(function C(w) {
            const b = w.XMLHttpRequest;
            if (!b) return;
            const H = b.prototype;
            let P = H[Qe],
              G = H[et];
            if (!P) {
              const N = w.XMLHttpRequestEventTarget;
              if (N) {
                const j = N.prototype;
                (P = j[Qe]), (G = j[et]);
              }
            }
            const x = "readystatechange",
              L = "scheduled";
            function T(N) {
              const j = N.data,
                O = j.target;
              (O[m] = !1), (O[v] = !1);
              const re = O[f];
              P || ((P = O[Qe]), (G = O[et])), re && G.call(O, x, re);
              const Te = (O[f] = () => {
                if (O.readyState === O.DONE)
                  if (!j.aborted && O[m] && N.state === L) {
                    const ue = O[a.__symbol__("loadfalse")];
                    if (0 !== O.status && ue && ue.length > 0) {
                      const fe = N.invoke;
                      (N.invoke = function () {
                        const W = O[a.__symbol__("loadfalse")];
                        for (let I = 0; I < W.length; I++)
                          W[I] === N && W.splice(I, 1);
                        !j.aborted && N.state === L && fe.call(N);
                      }),
                        ue.push(N);
                    } else N.invoke();
                  } else !j.aborted && !1 === O[m] && (O[v] = !0);
              });
              return (
                P.call(O, x, Te),
                O[u] || (O[u] = N),
                V.apply(O, j.args),
                (O[m] = !0),
                N
              );
            }
            function Z() {}
            function z(N) {
              const j = N.data;
              return (j.aborted = !0), K.apply(j.target, j.args);
            }
            const B = ae(
                H,
                "open",
                () =>
                  function (N, j) {
                    return (N[c] = 0 == j[2]), (N[E] = j[1]), B.apply(N, j);
                  }
              ),
              R = U("fetchTaskAborting"),
              Q = U("fetchTaskScheduling"),
              V = ae(
                H,
                "send",
                () =>
                  function (N, j) {
                    if (!0 === a.current[Q] || N[c]) return V.apply(N, j);
                    {
                      const O = {
                          target: N,
                          url: N[E],
                          isPeriodic: !1,
                          args: j,
                          aborted: !1,
                        },
                        re = lt("XMLHttpRequest.send", Z, O, T, z);
                      N &&
                        !0 === N[v] &&
                        !O.aborted &&
                        re.state === L &&
                        re.invoke();
                    }
                  }
              ),
              K = ae(
                H,
                "abort",
                () =>
                  function (N, j) {
                    const O = (function S(N) {
                      return N[u];
                    })(N);
                    if (O && "string" == typeof O.type) {
                      if (null == O.cancelFn || (O.data && O.data.aborted))
                        return;
                      O.zone.cancelTask(O);
                    } else if (!0 === a.current[R]) return K.apply(N, j);
                  }
              );
          })(t);
          const u = U("xhrTask"),
            c = U("xhrSync"),
            f = U("xhrListener"),
            m = U("xhrScheduled"),
            E = U("xhrURL"),
            v = U("xhrErrorBeforeScheduled");
        }),
        Zone.__load_patch("geolocation", (t) => {
          t.navigator &&
            t.navigator.geolocation &&
            (function ut(t, a) {
              const u = t.constructor.name;
              for (let c = 0; c < a.length; c++) {
                const f = a[c],
                  m = t[f];
                if (m) {
                  if (!ft(oe(t, f))) continue;
                  t[f] = ((v) => {
                    const C = function () {
                      return v.apply(this, tt(arguments, u + "." + f));
                    };
                    return se(C, v), C;
                  })(m);
                }
              }
            })(t.navigator.geolocation, [
              "getCurrentPosition",
              "watchPosition",
            ]);
        }),
        Zone.__load_patch("PromiseRejectionEvent", (t, a) => {
          function u(c) {
            return function (f) {
              kt(t, c).forEach((E) => {
                const v = t.PromiseRejectionEvent;
                if (v) {
                  const C = new v(c, {
                    promise: f.promise,
                    reason: f.rejection,
                  });
                  E.invoke(C);
                }
              });
            };
          }
          t.PromiseRejectionEvent &&
            ((a[U("unhandledPromiseRejectionHandler")] =
              u("unhandledrejection")),
            (a[U("rejectionHandledHandler")] = u("rejectionhandled")));
        });
    },
  },
  (X) => {
    X((X.s = 61));
  },
]);
("use strict");
(self.webpackChunkdotcms_block_editor =
  self.webpackChunkdotcms_block_editor || []).push([
  [179],
  {
    81: () => {
      function Po(n) {
        return "function" == typeof n;
      }
      let ll = !1;
      const Un = {
        Promise: void 0,
        set useDeprecatedSynchronousErrorHandling(n) {
          if (n) {
            const e = new Error();
            console.warn(
              "DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n" +
                e.stack
            );
          } else
            ll &&
              console.log(
                "RxJS: Back to a better error behavior. Thank you. <3"
              );
          ll = n;
        },
        get useDeprecatedSynchronousErrorHandling() {
          return ll;
        },
      };
      function Hr(n) {
        setTimeout(() => {
          throw n;
        }, 0);
      }
      const bu = {
          closed: !0,
          next(n) {},
          error(n) {
            if (Un.useDeprecatedSynchronousErrorHandling) throw n;
            Hr(n);
          },
          complete() {},
        },
        cl = Array.isArray || ((n) => n && "number" == typeof n.length);
      function up(n) {
        return null !== n && "object" == typeof n;
      }
      const Du = (() => {
        function n(e) {
          return (
            Error.call(this),
            (this.message = e
              ? `${e.length} errors occurred during unsubscription:\n${e
                  .map((t, i) => `${i + 1}) ${t.toString()}`)
                  .join("\n  ")}`
              : ""),
            (this.name = "UnsubscriptionError"),
            (this.errors = e),
            this
          );
        }
        return (n.prototype = Object.create(Error.prototype)), n;
      })();
      class Te {
        constructor(e) {
          (this.closed = !1),
            (this._parentOrParents = null),
            (this._subscriptions = null),
            e && ((this._ctorUnsubscribe = !0), (this._unsubscribe = e));
        }
        unsubscribe() {
          let e;
          if (this.closed) return;
          let {
            _parentOrParents: t,
            _ctorUnsubscribe: i,
            _unsubscribe: r,
            _subscriptions: o,
          } = this;
          if (
            ((this.closed = !0),
            (this._parentOrParents = null),
            (this._subscriptions = null),
            t instanceof Te)
          )
            t.remove(this);
          else if (null !== t)
            for (let s = 0; s < t.length; ++s) t[s].remove(this);
          if (Po(r)) {
            i && (this._unsubscribe = void 0);
            try {
              r.call(this);
            } catch (s) {
              e = s instanceof Du ? xb(s.errors) : [s];
            }
          }
          if (cl(o)) {
            let s = -1,
              a = o.length;
            for (; ++s < a; ) {
              const l = o[s];
              if (up(l))
                try {
                  l.unsubscribe();
                } catch (c) {
                  (e = e || []),
                    c instanceof Du ? (e = e.concat(xb(c.errors))) : e.push(c);
                }
            }
          }
          if (e) throw new Du(e);
        }
        add(e) {
          let t = e;
          if (!e) return Te.EMPTY;
          switch (typeof e) {
            case "function":
              t = new Te(e);
            case "object":
              if (t === this || t.closed || "function" != typeof t.unsubscribe)
                return t;
              if (this.closed) return t.unsubscribe(), t;
              if (!(t instanceof Te)) {
                const o = t;
                (t = new Te()), (t._subscriptions = [o]);
              }
              break;
            default:
              throw new Error(
                "unrecognized teardown " + e + " added to Subscription."
              );
          }
          let { _parentOrParents: i } = t;
          if (null === i) t._parentOrParents = this;
          else if (i instanceof Te) {
            if (i === this) return t;
            t._parentOrParents = [i, this];
          } else {
            if (-1 !== i.indexOf(this)) return t;
            i.push(this);
          }
          const r = this._subscriptions;
          return null === r ? (this._subscriptions = [t]) : r.push(t), t;
        }
        remove(e) {
          const t = this._subscriptions;
          if (t) {
            const i = t.indexOf(e);
            -1 !== i && t.splice(i, 1);
          }
        }
      }
      var n;
      function xb(n) {
        return n.reduce((e, t) => e.concat(t instanceof Du ? t.errors : t), []);
      }
      Te.EMPTY = (((n = new Te()).closed = !0), n);
      const Cu =
        "function" == typeof Symbol
          ? Symbol("rxSubscriber")
          : "@@rxSubscriber_" + Math.random();
      class Be extends Te {
        constructor(e, t, i) {
          switch (
            (super(),
            (this.syncErrorValue = null),
            (this.syncErrorThrown = !1),
            (this.syncErrorThrowable = !1),
            (this.isStopped = !1),
            arguments.length)
          ) {
            case 0:
              this.destination = bu;
              break;
            case 1:
              if (!e) {
                this.destination = bu;
                break;
              }
              if ("object" == typeof e) {
                e instanceof Be
                  ? ((this.syncErrorThrowable = e.syncErrorThrowable),
                    (this.destination = e),
                    e.add(this))
                  : ((this.syncErrorThrowable = !0),
                    (this.destination = new Ab(this, e)));
                break;
              }
            default:
              (this.syncErrorThrowable = !0),
                (this.destination = new Ab(this, e, t, i));
          }
        }
        [Cu]() {
          return this;
        }
        static create(e, t, i) {
          const r = new Be(e, t, i);
          return (r.syncErrorThrowable = !1), r;
        }
        next(e) {
          this.isStopped || this._next(e);
        }
        error(e) {
          this.isStopped || ((this.isStopped = !0), this._error(e));
        }
        complete() {
          this.isStopped || ((this.isStopped = !0), this._complete());
        }
        unsubscribe() {
          this.closed || ((this.isStopped = !0), super.unsubscribe());
        }
        _next(e) {
          this.destination.next(e);
        }
        _error(e) {
          this.destination.error(e), this.unsubscribe();
        }
        _complete() {
          this.destination.complete(), this.unsubscribe();
        }
        _unsubscribeAndRecycle() {
          const { _parentOrParents: e } = this;
          return (
            (this._parentOrParents = null),
            this.unsubscribe(),
            (this.closed = !1),
            (this.isStopped = !1),
            (this._parentOrParents = e),
            this
          );
        }
      }
      class Ab extends Be {
        constructor(e, t, i, r) {
          super(), (this._parentSubscriber = e);
          let o,
            s = this;
          Po(t)
            ? (o = t)
            : t &&
              ((o = t.next),
              (i = t.error),
              (r = t.complete),
              t !== bu &&
                ((s = Object.create(t)),
                Po(s.unsubscribe) && this.add(s.unsubscribe.bind(s)),
                (s.unsubscribe = this.unsubscribe.bind(this)))),
            (this._context = s),
            (this._next = o),
            (this._error = i),
            (this._complete = r);
        }
        next(e) {
          if (!this.isStopped && this._next) {
            const { _parentSubscriber: t } = this;
            Un.useDeprecatedSynchronousErrorHandling && t.syncErrorThrowable
              ? this.__tryOrSetError(t, this._next, e) && this.unsubscribe()
              : this.__tryOrUnsub(this._next, e);
          }
        }
        error(e) {
          if (!this.isStopped) {
            const { _parentSubscriber: t } = this,
              { useDeprecatedSynchronousErrorHandling: i } = Un;
            if (this._error)
              i && t.syncErrorThrowable
                ? (this.__tryOrSetError(t, this._error, e), this.unsubscribe())
                : (this.__tryOrUnsub(this._error, e), this.unsubscribe());
            else if (t.syncErrorThrowable)
              i ? ((t.syncErrorValue = e), (t.syncErrorThrown = !0)) : Hr(e),
                this.unsubscribe();
            else {
              if ((this.unsubscribe(), i)) throw e;
              Hr(e);
            }
          }
        }
        complete() {
          if (!this.isStopped) {
            const { _parentSubscriber: e } = this;
            if (this._complete) {
              const t = () => this._complete.call(this._context);
              Un.useDeprecatedSynchronousErrorHandling && e.syncErrorThrowable
                ? (this.__tryOrSetError(e, t), this.unsubscribe())
                : (this.__tryOrUnsub(t), this.unsubscribe());
            } else this.unsubscribe();
          }
        }
        __tryOrUnsub(e, t) {
          try {
            e.call(this._context, t);
          } catch (i) {
            if ((this.unsubscribe(), Un.useDeprecatedSynchronousErrorHandling))
              throw i;
            Hr(i);
          }
        }
        __tryOrSetError(e, t, i) {
          if (!Un.useDeprecatedSynchronousErrorHandling)
            throw new Error("bad call");
          try {
            t.call(this._context, i);
          } catch (r) {
            return Un.useDeprecatedSynchronousErrorHandling
              ? ((e.syncErrorValue = r), (e.syncErrorThrown = !0), !0)
              : (Hr(r), !0);
          }
          return !1;
        }
        _unsubscribe() {
          const { _parentSubscriber: e } = this;
          (this._context = null),
            (this._parentSubscriber = null),
            e.unsubscribe();
        }
      }
      const ul =
        ("function" == typeof Symbol && Symbol.observable) || "@@observable";
      function Eu(n) {
        return n;
      }
      let je = (() => {
        class n {
          constructor(t) {
            (this._isScalar = !1), t && (this._subscribe = t);
          }
          lift(t) {
            const i = new n();
            return (i.source = this), (i.operator = t), i;
          }
          subscribe(t, i, r) {
            const { operator: o } = this,
              s = (function Qk(n, e, t) {
                if (n) {
                  if (n instanceof Be) return n;
                  if (n[Cu]) return n[Cu]();
                }
                return n || e || t ? new Be(n, e, t) : new Be(bu);
              })(t, i, r);
            if (
              (s.add(
                o
                  ? o.call(s, this.source)
                  : this.source ||
                    (Un.useDeprecatedSynchronousErrorHandling &&
                      !s.syncErrorThrowable)
                  ? this._subscribe(s)
                  : this._trySubscribe(s)
              ),
              Un.useDeprecatedSynchronousErrorHandling &&
                s.syncErrorThrowable &&
                ((s.syncErrorThrowable = !1), s.syncErrorThrown))
            )
              throw s.syncErrorValue;
            return s;
          }
          _trySubscribe(t) {
            try {
              return this._subscribe(t);
            } catch (i) {
              Un.useDeprecatedSynchronousErrorHandling &&
                ((t.syncErrorThrown = !0), (t.syncErrorValue = i)),
                (function Zk(n) {
                  for (; n; ) {
                    const { closed: e, destination: t, isStopped: i } = n;
                    if (e || i) return !1;
                    n = t && t instanceof Be ? t : null;
                  }
                  return !0;
                })(t)
                  ? t.error(i)
                  : console.warn(i);
            }
          }
          forEach(t, i) {
            return new (i = kb(i))((r, o) => {
              let s;
              s = this.subscribe(
                (a) => {
                  try {
                    t(a);
                  } catch (l) {
                    o(l), s && s.unsubscribe();
                  }
                },
                o,
                r
              );
            });
          }
          _subscribe(t) {
            const { source: i } = this;
            return i && i.subscribe(t);
          }
          [ul]() {
            return this;
          }
          pipe(...t) {
            return 0 === t.length
              ? this
              : (function Ob(n) {
                  return 0 === n.length
                    ? Eu
                    : 1 === n.length
                    ? n[0]
                    : function (t) {
                        return n.reduce((i, r) => r(i), t);
                      };
                })(t)(this);
          }
          toPromise(t) {
            return new (t = kb(t))((i, r) => {
              let o;
              this.subscribe(
                (s) => (o = s),
                (s) => r(s),
                () => i(o)
              );
            });
          }
        }
        return (n.create = (e) => new n(e)), n;
      })();
      function kb(n) {
        if ((n || (n = Un.Promise || Promise), !n))
          throw new Error("no Promise impl found");
        return n;
      }
      const Fo = (() => {
        function n() {
          return (
            Error.call(this),
            (this.message = "object unsubscribed"),
            (this.name = "ObjectUnsubscribedError"),
            this
          );
        }
        return (n.prototype = Object.create(Error.prototype)), n;
      })();
      class Nb extends Te {
        constructor(e, t) {
          super(),
            (this.subject = e),
            (this.subscriber = t),
            (this.closed = !1);
        }
        unsubscribe() {
          if (this.closed) return;
          this.closed = !0;
          const e = this.subject,
            t = e.observers;
          if (
            ((this.subject = null),
            !t || 0 === t.length || e.isStopped || e.closed)
          )
            return;
          const i = t.indexOf(this.subscriber);
          -1 !== i && t.splice(i, 1);
        }
      }
      class Rb extends Be {
        constructor(e) {
          super(e), (this.destination = e);
        }
      }
      let _e = (() => {
        class n extends je {
          constructor() {
            super(),
              (this.observers = []),
              (this.closed = !1),
              (this.isStopped = !1),
              (this.hasError = !1),
              (this.thrownError = null);
          }
          [Cu]() {
            return new Rb(this);
          }
          lift(t) {
            const i = new Pb(this, this);
            return (i.operator = t), i;
          }
          next(t) {
            if (this.closed) throw new Fo();
            if (!this.isStopped) {
              const { observers: i } = this,
                r = i.length,
                o = i.slice();
              for (let s = 0; s < r; s++) o[s].next(t);
            }
          }
          error(t) {
            if (this.closed) throw new Fo();
            (this.hasError = !0), (this.thrownError = t), (this.isStopped = !0);
            const { observers: i } = this,
              r = i.length,
              o = i.slice();
            for (let s = 0; s < r; s++) o[s].error(t);
            this.observers.length = 0;
          }
          complete() {
            if (this.closed) throw new Fo();
            this.isStopped = !0;
            const { observers: t } = this,
              i = t.length,
              r = t.slice();
            for (let o = 0; o < i; o++) r[o].complete();
            this.observers.length = 0;
          }
          unsubscribe() {
            (this.isStopped = !0), (this.closed = !0), (this.observers = null);
          }
          _trySubscribe(t) {
            if (this.closed) throw new Fo();
            return super._trySubscribe(t);
          }
          _subscribe(t) {
            if (this.closed) throw new Fo();
            return this.hasError
              ? (t.error(this.thrownError), Te.EMPTY)
              : this.isStopped
              ? (t.complete(), Te.EMPTY)
              : (this.observers.push(t), new Nb(this, t));
          }
          asObservable() {
            const t = new je();
            return (t.source = this), t;
          }
        }
        return (n.create = (e, t) => new Pb(e, t)), n;
      })();
      class Pb extends _e {
        constructor(e, t) {
          super(), (this.destination = e), (this.source = t);
        }
        next(e) {
          const { destination: t } = this;
          t && t.next && t.next(e);
        }
        error(e) {
          const { destination: t } = this;
          t && t.error && this.destination.error(e);
        }
        complete() {
          const { destination: e } = this;
          e && e.complete && this.destination.complete();
        }
        _subscribe(e) {
          const { source: t } = this;
          return t ? this.source.subscribe(e) : Te.EMPTY;
        }
      }
      function xs(n) {
        return n && "function" == typeof n.schedule;
      }
      function ye(n, e) {
        return function (i) {
          if ("function" != typeof n)
            throw new TypeError(
              "argument is not a function. Are you looking for `mapTo()`?"
            );
          return i.lift(new Jk(n, e));
        };
      }
      class Jk {
        constructor(e, t) {
          (this.project = e), (this.thisArg = t);
        }
        call(e, t) {
          return t.subscribe(new Xk(e, this.project, this.thisArg));
        }
      }
      class Xk extends Be {
        constructor(e, t, i) {
          super(e),
            (this.project = t),
            (this.count = 0),
            (this.thisArg = i || this);
        }
        _next(e) {
          let t;
          try {
            t = this.project.call(this.thisArg, e, this.count++);
          } catch (i) {
            return void this.destination.error(i);
          }
          this.destination.next(t);
        }
      }
      const Fb = (n) => (e) => {
          for (let t = 0, i = n.length; t < i && !e.closed; t++) e.next(n[t]);
          e.complete();
        },
        wu = (function tN() {
          return "function" == typeof Symbol && Symbol.iterator
            ? Symbol.iterator
            : "@@iterator";
        })(),
        Lb = (n) => n && "number" == typeof n.length && "function" != typeof n;
      function Vb(n) {
        return (
          !!n && "function" != typeof n.subscribe && "function" == typeof n.then
        );
      }
      const dp = (n) => {
        if (n && "function" == typeof n[ul])
          return ((n) => (e) => {
            const t = n[ul]();
            if ("function" != typeof t.subscribe)
              throw new TypeError(
                "Provided object does not correctly implement Symbol.observable"
              );
            return t.subscribe(e);
          })(n);
        if (Lb(n)) return Fb(n);
        if (Vb(n))
          return ((n) => (e) => (
            n
              .then(
                (t) => {
                  e.closed || (e.next(t), e.complete());
                },
                (t) => e.error(t)
              )
              .then(null, Hr),
            e
          ))(n);
        if (n && "function" == typeof n[wu])
          return ((n) => (e) => {
            const t = n[wu]();
            for (;;) {
              let i;
              try {
                i = t.next();
              } catch (r) {
                return e.error(r), e;
              }
              if (i.done) {
                e.complete();
                break;
              }
              if ((e.next(i.value), e.closed)) break;
            }
            return (
              "function" == typeof t.return &&
                e.add(() => {
                  t.return && t.return();
                }),
              e
            );
          })(n);
        {
          const t = `You provided ${
            up(n) ? "an invalid object" : `'${n}'`
          } where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.`;
          throw new TypeError(t);
        }
      };
      function hp(n, e) {
        return new je((t) => {
          const i = new Te();
          let r = 0;
          return (
            i.add(
              e.schedule(function () {
                r !== n.length
                  ? (t.next(n[r++]), t.closed || i.add(this.schedule()))
                  : t.complete();
              })
            ),
            i
          );
        });
      }
      function xt(n, e) {
        return e
          ? (function cN(n, e) {
              if (null != n) {
                if (
                  (function aN(n) {
                    return n && "function" == typeof n[ul];
                  })(n)
                )
                  return (function rN(n, e) {
                    return new je((t) => {
                      const i = new Te();
                      return (
                        i.add(
                          e.schedule(() => {
                            const r = n[ul]();
                            i.add(
                              r.subscribe({
                                next(o) {
                                  i.add(e.schedule(() => t.next(o)));
                                },
                                error(o) {
                                  i.add(e.schedule(() => t.error(o)));
                                },
                                complete() {
                                  i.add(e.schedule(() => t.complete()));
                                },
                              })
                            );
                          })
                        ),
                        i
                      );
                    });
                  })(n, e);
                if (Vb(n))
                  return (function oN(n, e) {
                    return new je((t) => {
                      const i = new Te();
                      return (
                        i.add(
                          e.schedule(() =>
                            n.then(
                              (r) => {
                                i.add(
                                  e.schedule(() => {
                                    t.next(r),
                                      i.add(e.schedule(() => t.complete()));
                                  })
                                );
                              },
                              (r) => {
                                i.add(e.schedule(() => t.error(r)));
                              }
                            )
                          )
                        ),
                        i
                      );
                    });
                  })(n, e);
                if (Lb(n)) return hp(n, e);
                if (
                  (function lN(n) {
                    return n && "function" == typeof n[wu];
                  })(n) ||
                  "string" == typeof n
                )
                  return (function sN(n, e) {
                    if (!n) throw new Error("Iterable cannot be null");
                    return new je((t) => {
                      const i = new Te();
                      let r;
                      return (
                        i.add(() => {
                          r && "function" == typeof r.return && r.return();
                        }),
                        i.add(
                          e.schedule(() => {
                            (r = n[wu]()),
                              i.add(
                                e.schedule(function () {
                                  if (t.closed) return;
                                  let o, s;
                                  try {
                                    const a = r.next();
                                    (o = a.value), (s = a.done);
                                  } catch (a) {
                                    return void t.error(a);
                                  }
                                  s
                                    ? t.complete()
                                    : (t.next(o), this.schedule());
                                })
                              );
                          })
                        ),
                        i
                      );
                    });
                  })(n, e);
              }
              throw new TypeError(
                ((null !== n && typeof n) || n) + " is not observable"
              );
            })(n, e)
          : n instanceof je
          ? n
          : new je(dp(n));
      }
      class dl extends Be {
        constructor(e) {
          super(), (this.parent = e);
        }
        _next(e) {
          this.parent.notifyNext(e);
        }
        _error(e) {
          this.parent.notifyError(e), this.unsubscribe();
        }
        _complete() {
          this.parent.notifyComplete(), this.unsubscribe();
        }
      }
      class hl extends Be {
        notifyNext(e) {
          this.destination.next(e);
        }
        notifyError(e) {
          this.destination.error(e);
        }
        notifyComplete() {
          this.destination.complete();
        }
      }
      function fl(n, e) {
        if (e.closed) return;
        if (n instanceof je) return n.subscribe(e);
        let t;
        try {
          t = dp(n)(e);
        } catch (i) {
          e.error(i);
        }
        return t;
      }
      function zt(n, e, t = Number.POSITIVE_INFINITY) {
        return "function" == typeof e
          ? (i) =>
              i.pipe(
                zt((r, o) => xt(n(r, o)).pipe(ye((s, a) => e(r, s, o, a))), t)
              )
          : ("number" == typeof e && (t = e), (i) => i.lift(new uN(n, t)));
      }
      class uN {
        constructor(e, t = Number.POSITIVE_INFINITY) {
          (this.project = e), (this.concurrent = t);
        }
        call(e, t) {
          return t.subscribe(new dN(e, this.project, this.concurrent));
        }
      }
      class dN extends hl {
        constructor(e, t, i = Number.POSITIVE_INFINITY) {
          super(e),
            (this.project = t),
            (this.concurrent = i),
            (this.hasCompleted = !1),
            (this.buffer = []),
            (this.active = 0),
            (this.index = 0);
        }
        _next(e) {
          this.active < this.concurrent
            ? this._tryNext(e)
            : this.buffer.push(e);
        }
        _tryNext(e) {
          let t;
          const i = this.index++;
          try {
            t = this.project(e, i);
          } catch (r) {
            return void this.destination.error(r);
          }
          this.active++, this._innerSub(t);
        }
        _innerSub(e) {
          const t = new dl(this),
            i = this.destination;
          i.add(t);
          const r = fl(e, t);
          r !== t && i.add(r);
        }
        _complete() {
          (this.hasCompleted = !0),
            0 === this.active &&
              0 === this.buffer.length &&
              this.destination.complete(),
            this.unsubscribe();
        }
        notifyNext(e) {
          this.destination.next(e);
        }
        notifyComplete() {
          const e = this.buffer;
          this.active--,
            e.length > 0
              ? this._next(e.shift())
              : 0 === this.active &&
                this.hasCompleted &&
                this.destination.complete();
        }
      }
      function As(n = Number.POSITIVE_INFINITY) {
        return zt(Eu, n);
      }
      function fp(n, e) {
        return e ? hp(n, e) : new je(Fb(n));
      }
      function pp(...n) {
        let e = Number.POSITIVE_INFINITY,
          t = null,
          i = n[n.length - 1];
        return (
          xs(i)
            ? ((t = n.pop()),
              n.length > 1 &&
                "number" == typeof n[n.length - 1] &&
                (e = n.pop()))
            : "number" == typeof i && (e = n.pop()),
          null === t && 1 === n.length && n[0] instanceof je
            ? n[0]
            : As(e)(fp(n, t))
        );
      }
      function Su() {
        return function (e) {
          return e.lift(new hN(e));
        };
      }
      class hN {
        constructor(e) {
          this.connectable = e;
        }
        call(e, t) {
          const { connectable: i } = this;
          i._refCount++;
          const r = new fN(e, i),
            o = t.subscribe(r);
          return r.closed || (r.connection = i.connect()), o;
        }
      }
      class fN extends Be {
        constructor(e, t) {
          super(e), (this.connectable = t);
        }
        _unsubscribe() {
          const { connectable: e } = this;
          if (!e) return void (this.connection = null);
          this.connectable = null;
          const t = e._refCount;
          if (t <= 0) return void (this.connection = null);
          if (((e._refCount = t - 1), t > 1))
            return void (this.connection = null);
          const { connection: i } = this,
            r = e._connection;
          (this.connection = null), r && (!i || r === i) && r.unsubscribe();
        }
      }
      class gp extends je {
        constructor(e, t) {
          super(),
            (this.source = e),
            (this.subjectFactory = t),
            (this._refCount = 0),
            (this._isComplete = !1);
        }
        _subscribe(e) {
          return this.getSubject().subscribe(e);
        }
        getSubject() {
          const e = this._subject;
          return (
            (!e || e.isStopped) && (this._subject = this.subjectFactory()),
            this._subject
          );
        }
        connect() {
          let e = this._connection;
          return (
            e ||
              ((this._isComplete = !1),
              (e = this._connection = new Te()),
              e.add(this.source.subscribe(new gN(this.getSubject(), this))),
              e.closed && ((this._connection = null), (e = Te.EMPTY))),
            e
          );
        }
        refCount() {
          return Su()(this);
        }
      }
      const pN = (() => {
        const n = gp.prototype;
        return {
          operator: { value: null },
          _refCount: { value: 0, writable: !0 },
          _subject: { value: null, writable: !0 },
          _connection: { value: null, writable: !0 },
          _subscribe: { value: n._subscribe },
          _isComplete: { value: n._isComplete, writable: !0 },
          getSubject: { value: n.getSubject },
          connect: { value: n.connect },
          refCount: { value: n.refCount },
        };
      })();
      class gN extends Rb {
        constructor(e, t) {
          super(e), (this.connectable = t);
        }
        _error(e) {
          this._unsubscribe(), super._error(e);
        }
        _complete() {
          (this.connectable._isComplete = !0),
            this._unsubscribe(),
            super._complete();
        }
        _unsubscribe() {
          const e = this.connectable;
          if (e) {
            this.connectable = null;
            const t = e._connection;
            (e._refCount = 0),
              (e._subject = null),
              (e._connection = null),
              t && t.unsubscribe();
          }
        }
      }
      class vN {
        constructor(e, t) {
          (this.subjectFactory = e), (this.selector = t);
        }
        call(e, t) {
          const { selector: i } = this,
            r = this.subjectFactory(),
            o = i(r).subscribe(e);
          return o.add(t.subscribe(r)), o;
        }
      }
      function _N() {
        return new _e();
      }
      function Fe(n) {
        for (let e in n) if (n[e] === Fe) return e;
        throw Error("Could not find renamed property on target object.");
      }
      function mp(n, e) {
        for (const t in e)
          e.hasOwnProperty(t) && !n.hasOwnProperty(t) && (n[t] = e[t]);
      }
      function Le(n) {
        if ("string" == typeof n) return n;
        if (Array.isArray(n)) return "[" + n.map(Le).join(", ") + "]";
        if (null == n) return "" + n;
        if (n.overriddenName) return `${n.overriddenName}`;
        if (n.name) return `${n.name}`;
        const e = n.toString();
        if (null == e) return "" + e;
        const t = e.indexOf("\n");
        return -1 === t ? e : e.substring(0, t);
      }
      function yp(n, e) {
        return null == n || "" === n
          ? null === e
            ? ""
            : e
          : null == e || "" === e
          ? n
          : n + " " + e;
      }
      const DN = Fe({ __forward_ref__: Fe });
      function Ne(n) {
        return (
          (n.__forward_ref__ = Ne),
          (n.toString = function () {
            return Le(this());
          }),
          n
        );
      }
      function J(n) {
        return vp(n) ? n() : n;
      }
      function vp(n) {
        return (
          "function" == typeof n &&
          n.hasOwnProperty(DN) &&
          n.__forward_ref__ === Ne
        );
      }
      class W extends Error {
        constructor(e, t) {
          super(
            (function Mu(n, e) {
              return `NG0${Math.abs(n)}${e ? ": " + e.trim() : ""}`;
            })(e, t)
          ),
            (this.code = e);
        }
      }
      function ie(n) {
        return "string" == typeof n ? n : null == n ? "" : String(n);
      }
      function Iu(n, e) {
        throw new W(-201, !1);
      }
      function xn(n, e) {
        null == n &&
          (function xe(n, e, t, i) {
            throw new Error(
              `ASSERTION ERROR: ${n}` +
                (null == i ? "" : ` [Expected=> ${t} ${i} ${e} <=Actual]`)
            );
          })(e, n, null, "!=");
      }
      function j(n) {
        return {
          token: n.token,
          providedIn: n.providedIn || null,
          factory: n.factory,
          value: void 0,
        };
      }
      function Xe(n) {
        return { providers: n.providers || [], imports: n.imports || [] };
      }
      function _p(n) {
        return Bb(n, Tu) || Bb(n, Hb);
      }
      function Bb(n, e) {
        return n.hasOwnProperty(e) ? n[e] : null;
      }
      function jb(n) {
        return n && (n.hasOwnProperty(bp) || n.hasOwnProperty(xN))
          ? n[bp]
          : null;
      }
      const Tu = Fe({ ɵprov: Fe }),
        bp = Fe({ ɵinj: Fe }),
        Hb = Fe({ ngInjectableDef: Fe }),
        xN = Fe({ ngInjectorDef: Fe });
      var G = (() => (
        ((G = G || {})[(G.Default = 0)] = "Default"),
        (G[(G.Host = 1)] = "Host"),
        (G[(G.Self = 2)] = "Self"),
        (G[(G.SkipSelf = 4)] = "SkipSelf"),
        (G[(G.Optional = 8)] = "Optional"),
        G
      ))();
      let Dp;
      function ki(n) {
        const e = Dp;
        return (Dp = n), e;
      }
      function Ub(n, e, t) {
        const i = _p(n);
        return i && "root" == i.providedIn
          ? void 0 === i.value
            ? (i.value = i.factory())
            : i.value
          : t & G.Optional
          ? null
          : void 0 !== e
          ? e
          : void Iu(Le(n));
      }
      function Ur(n) {
        return { toString: n }.toString();
      }
      var ci = (() => (
          ((ci = ci || {})[(ci.OnPush = 0)] = "OnPush"),
          (ci[(ci.Default = 1)] = "Default"),
          ci
        ))(),
        Ni = (() => (
          (function (n) {
            (n[(n.Emulated = 0)] = "Emulated"),
              (n[(n.None = 2)] = "None"),
              (n[(n.ShadowDom = 3)] = "ShadowDom");
          })(Ni || (Ni = {})),
          Ni
        ))();
      const Re = (() =>
          (typeof globalThis < "u" && globalThis) ||
          (typeof global < "u" && global) ||
          (typeof window < "u" && window) ||
          (typeof self < "u" &&
            typeof WorkerGlobalScope < "u" &&
            self instanceof WorkerGlobalScope &&
            self))(),
        Os = {},
        Me = [],
        xu = Fe({ ɵcmp: Fe }),
        Cp = Fe({ ɵdir: Fe }),
        Ep = Fe({ ɵpipe: Fe }),
        zb = Fe({ ɵmod: Fe }),
        pr = Fe({ ɵfac: Fe }),
        pl = Fe({ __NG_ELEMENT_ID__: Fe });
      let ON = 0;
      function ht(n) {
        return Ur(() => {
          const t = !0 === n.standalone,
            i = {},
            r = {
              type: n.type,
              providersResolver: null,
              decls: n.decls,
              vars: n.vars,
              factory: null,
              template: n.template || null,
              consts: n.consts || null,
              ngContentSelectors: n.ngContentSelectors,
              hostBindings: n.hostBindings || null,
              hostVars: n.hostVars || 0,
              hostAttrs: n.hostAttrs || null,
              contentQueries: n.contentQueries || null,
              declaredInputs: i,
              inputs: null,
              outputs: null,
              exportAs: n.exportAs || null,
              onPush: n.changeDetection === ci.OnPush,
              directiveDefs: null,
              pipeDefs: null,
              standalone: t,
              dependencies: (t && n.dependencies) || null,
              getStandaloneInjector: null,
              selectors: n.selectors || Me,
              viewQuery: n.viewQuery || null,
              features: n.features || null,
              data: n.data || {},
              encapsulation: n.encapsulation || Ni.Emulated,
              id: "c" + ON++,
              styles: n.styles || Me,
              _: null,
              setInput: null,
              schemas: n.schemas || null,
              tView: null,
            },
            o = n.dependencies,
            s = n.features;
          return (
            (r.inputs = Gb(n.inputs, i)),
            (r.outputs = Gb(n.outputs)),
            s && s.forEach((a) => a(r)),
            (r.directiveDefs = o
              ? () => ("function" == typeof o ? o() : o).map($b).filter(Wb)
              : null),
            (r.pipeDefs = o
              ? () => ("function" == typeof o ? o() : o).map(on).filter(Wb)
              : null),
            r
          );
        });
      }
      function $b(n) {
        return Ve(n) || rn(n);
      }
      function Wb(n) {
        return null !== n;
      }
      const NN = {};
      function rt(n) {
        return Ur(() => {
          const e = {
            type: n.type,
            bootstrap: n.bootstrap || Me,
            declarations: n.declarations || Me,
            imports: n.imports || Me,
            exports: n.exports || Me,
            transitiveCompileScopes: null,
            schemas: n.schemas || null,
            id: n.id || null,
          };
          return null != n.id && (NN[n.id] = n.type), e;
        });
      }
      function Gb(n, e) {
        if (null == n) return Os;
        const t = {};
        for (const i in n)
          if (n.hasOwnProperty(i)) {
            let r = n[i],
              o = r;
            Array.isArray(r) && ((o = r[1]), (r = r[0])),
              (t[r] = i),
              e && (e[r] = o);
          }
        return t;
      }
      const q = ht;
      function nn(n) {
        return {
          type: n.type,
          name: n.name,
          factory: null,
          pure: !1 !== n.pure,
          standalone: !0 === n.standalone,
          onDestroy: n.type.prototype.ngOnDestroy || null,
        };
      }
      function Ve(n) {
        return n[xu] || null;
      }
      function rn(n) {
        return n[Cp] || null;
      }
      function on(n) {
        return n[Ep] || null;
      }
      function An(n, e) {
        const t = n[zb] || null;
        if (!t && !0 === e)
          throw new Error(`Type ${Le(n)} does not have '\u0275mod' property.`);
        return t;
      }
      function yn(n) {
        return Array.isArray(n) && "object" == typeof n[1];
      }
      function di(n) {
        return Array.isArray(n) && !0 === n[1];
      }
      function Mp(n) {
        return 0 != (8 & n.flags);
      }
      function Nu(n) {
        return 2 == (2 & n.flags);
      }
      function Ru(n) {
        return 1 == (1 & n.flags);
      }
      function hi(n) {
        return null !== n.template;
      }
      function VN(n) {
        return 0 != (256 & n[2]);
      }
      function Ho(n, e) {
        return n.hasOwnProperty(pr) ? n[pr] : null;
      }
      class Yb {
        constructor(e, t, i) {
          (this.previousValue = e),
            (this.currentValue = t),
            (this.firstChange = i);
        }
        isFirstChange() {
          return this.firstChange;
        }
      }
      function $n() {
        return Zb;
      }
      function Zb(n) {
        return n.type.prototype.ngOnChanges && (n.setInput = UN), HN;
      }
      function HN() {
        const n = Jb(this),
          e = n?.current;
        if (e) {
          const t = n.previous;
          if (t === Os) n.previous = e;
          else for (let i in e) t[i] = e[i];
          (n.current = null), this.ngOnChanges(e);
        }
      }
      function UN(n, e, t, i) {
        const r =
            Jb(n) ||
            (function zN(n, e) {
              return (n[Qb] = e);
            })(n, { previous: Os, current: null }),
          o = r.current || (r.current = {}),
          s = r.previous,
          a = this.declaredInputs[t],
          l = s[a];
        (o[a] = new Yb(l && l.currentValue, e, s === Os)), (n[i] = e);
      }
      $n.ngInherit = !0;
      const Qb = "__ngSimpleChanges__";
      function Jb(n) {
        return n[Qb] || null;
      }
      let Op;
      function kp() {
        return void 0 !== Op ? Op : typeof document < "u" ? document : void 0;
      }
      function ot(n) {
        return !!n.listen;
      }
      const eD = {
        createRenderer: (n, e) => {
          throw new Error("Renderer3 disabled");
        },
      };
      function ft(n) {
        for (; Array.isArray(n); ) n = n[0];
        return n;
      }
      function Pu(n, e) {
        return ft(e[n]);
      }
      function Gn(n, e) {
        return ft(e[n.index]);
      }
      function Np(n, e) {
        return n.data[e];
      }
      function Fs(n, e) {
        return n[e];
      }
      function kn(n, e) {
        const t = e[n];
        return yn(t) ? t : t[0];
      }
      function tD(n) {
        return 4 == (4 & n[2]);
      }
      function Rp(n) {
        return 64 == (64 & n[2]);
      }
      function zr(n, e) {
        return null == e ? null : n[e];
      }
      function nD(n) {
        n[18] = 0;
      }
      function Pp(n, e) {
        n[5] += e;
        let t = n,
          i = n[3];
        for (
          ;
          null !== i && ((1 === e && 1 === t[5]) || (-1 === e && 0 === t[5]));

        )
          (i[5] += e), (t = i), (i = i[3]);
      }
      const te = { lFrame: dD(null), bindingsEnabled: !0 };
      function rD() {
        return te.bindingsEnabled;
      }
      function M() {
        return te.lFrame.lView;
      }
      function be() {
        return te.lFrame.tView;
      }
      function Ot(n) {
        return (te.lFrame.contextLView = n), n[8];
      }
      function kt(n) {
        return (te.lFrame.contextLView = null), n;
      }
      function Ct() {
        let n = oD();
        for (; null !== n && 64 === n.type; ) n = n.parent;
        return n;
      }
      function oD() {
        return te.lFrame.currentTNode;
      }
      function Ri(n, e) {
        const t = te.lFrame;
        (t.currentTNode = n), (t.isParent = e);
      }
      function Fp() {
        return te.lFrame.isParent;
      }
      function Lp() {
        te.lFrame.isParent = !1;
      }
      function sn() {
        const n = te.lFrame;
        let e = n.bindingRootIndex;
        return (
          -1 === e && (e = n.bindingRootIndex = n.tView.bindingStartIndex), e
        );
      }
      function Ls() {
        return te.lFrame.bindingIndex++;
      }
      function mr(n) {
        const e = te.lFrame,
          t = e.bindingIndex;
        return (e.bindingIndex = e.bindingIndex + n), t;
      }
      function aR(n, e) {
        const t = te.lFrame;
        (t.bindingIndex = t.bindingRootIndex = n), Vp(e);
      }
      function Vp(n) {
        te.lFrame.currentDirectiveIndex = n;
      }
      function lD() {
        return te.lFrame.currentQueryIndex;
      }
      function jp(n) {
        te.lFrame.currentQueryIndex = n;
      }
      function cR(n) {
        const e = n[1];
        return 2 === e.type ? e.declTNode : 1 === e.type ? n[6] : null;
      }
      function cD(n, e, t) {
        if (t & G.SkipSelf) {
          let r = e,
            o = n;
          for (
            ;
            !((r = r.parent),
            null !== r ||
              t & G.Host ||
              ((r = cR(o)), null === r || ((o = o[15]), 10 & r.type)));

          );
          if (null === r) return !1;
          (e = r), (n = o);
        }
        const i = (te.lFrame = uD());
        return (i.currentTNode = e), (i.lView = n), !0;
      }
      function Lu(n) {
        const e = uD(),
          t = n[1];
        (te.lFrame = e),
          (e.currentTNode = t.firstChild),
          (e.lView = n),
          (e.tView = t),
          (e.contextLView = n),
          (e.bindingIndex = t.bindingStartIndex),
          (e.inI18n = !1);
      }
      function uD() {
        const n = te.lFrame,
          e = null === n ? null : n.child;
        return null === e ? dD(n) : e;
      }
      function dD(n) {
        const e = {
          currentTNode: null,
          isParent: !0,
          lView: null,
          tView: null,
          selectedIndex: -1,
          contextLView: null,
          elementDepthCount: 0,
          currentNamespace: null,
          currentDirectiveIndex: -1,
          bindingRootIndex: -1,
          bindingIndex: -1,
          currentQueryIndex: 0,
          parent: n,
          child: null,
          inI18n: !1,
        };
        return null !== n && (n.child = e), e;
      }
      function hD() {
        const n = te.lFrame;
        return (
          (te.lFrame = n.parent), (n.currentTNode = null), (n.lView = null), n
        );
      }
      const fD = hD;
      function Vu() {
        const n = hD();
        (n.isParent = !0),
          (n.tView = null),
          (n.selectedIndex = -1),
          (n.contextLView = null),
          (n.elementDepthCount = 0),
          (n.currentDirectiveIndex = -1),
          (n.currentNamespace = null),
          (n.bindingRootIndex = -1),
          (n.bindingIndex = -1),
          (n.currentQueryIndex = 0);
      }
      function an() {
        return te.lFrame.selectedIndex;
      }
      function $r(n) {
        te.lFrame.selectedIndex = n;
      }
      function st() {
        const n = te.lFrame;
        return Np(n.tView, n.selectedIndex);
      }
      function Bu(n, e) {
        for (let t = e.directiveStart, i = e.directiveEnd; t < i; t++) {
          const o = n.data[t].type.prototype,
            {
              ngAfterContentInit: s,
              ngAfterContentChecked: a,
              ngAfterViewInit: l,
              ngAfterViewChecked: c,
              ngOnDestroy: u,
            } = o;
          s && (n.contentHooks || (n.contentHooks = [])).push(-t, s),
            a &&
              ((n.contentHooks || (n.contentHooks = [])).push(t, a),
              (n.contentCheckHooks || (n.contentCheckHooks = [])).push(t, a)),
            l && (n.viewHooks || (n.viewHooks = [])).push(-t, l),
            c &&
              ((n.viewHooks || (n.viewHooks = [])).push(t, c),
              (n.viewCheckHooks || (n.viewCheckHooks = [])).push(t, c)),
            null != u && (n.destroyHooks || (n.destroyHooks = [])).push(t, u);
        }
      }
      function ju(n, e, t) {
        pD(n, e, 3, t);
      }
      function Hu(n, e, t, i) {
        (3 & n[2]) === t && pD(n, e, t, i);
      }
      function Hp(n, e) {
        let t = n[2];
        (3 & t) === e && ((t &= 2047), (t += 1), (n[2] = t));
      }
      function pD(n, e, t, i) {
        const o = i ?? -1,
          s = e.length - 1;
        let a = 0;
        for (let l = void 0 !== i ? 65535 & n[18] : 0; l < s; l++)
          if ("number" == typeof e[l + 1]) {
            if (((a = e[l]), null != i && a >= i)) break;
          } else
            e[l] < 0 && (n[18] += 65536),
              (a < o || -1 == o) &&
                (vR(n, t, e, l), (n[18] = (4294901760 & n[18]) + l + 2)),
              l++;
      }
      function vR(n, e, t, i) {
        const r = t[i] < 0,
          o = t[i + 1],
          a = n[r ? -t[i] : t[i]];
        if (r) {
          if (n[2] >> 11 < n[18] >> 16 && (3 & n[2]) === e) {
            n[2] += 2048;
            try {
              o.call(a);
            } finally {
            }
          }
        } else
          try {
            o.call(a);
          } finally {
          }
      }
      class _l {
        constructor(e, t, i) {
          (this.factory = e),
            (this.resolving = !1),
            (this.canSeeViewProviders = t),
            (this.injectImpl = i);
        }
      }
      function Uu(n, e, t) {
        const i = ot(n);
        let r = 0;
        for (; r < t.length; ) {
          const o = t[r];
          if ("number" == typeof o) {
            if (0 !== o) break;
            r++;
            const s = t[r++],
              a = t[r++],
              l = t[r++];
            i ? n.setAttribute(e, a, l, s) : e.setAttributeNS(s, a, l);
          } else {
            const s = o,
              a = t[++r];
            zp(s)
              ? i && n.setProperty(e, s, a)
              : i
              ? n.setAttribute(e, s, a)
              : e.setAttribute(s, a),
              r++;
          }
        }
        return r;
      }
      function gD(n) {
        return 3 === n || 4 === n || 6 === n;
      }
      function zp(n) {
        return 64 === n.charCodeAt(0);
      }
      function zu(n, e) {
        if (null !== e && 0 !== e.length)
          if (null === n || 0 === n.length) n = e.slice();
          else {
            let t = -1;
            for (let i = 0; i < e.length; i++) {
              const r = e[i];
              "number" == typeof r
                ? (t = r)
                : 0 === t ||
                  mD(n, t, r, null, -1 === t || 2 === t ? e[++i] : null);
            }
          }
        return n;
      }
      function mD(n, e, t, i, r) {
        let o = 0,
          s = n.length;
        if (-1 === e) s = -1;
        else
          for (; o < n.length; ) {
            const a = n[o++];
            if ("number" == typeof a) {
              if (a === e) {
                s = -1;
                break;
              }
              if (a > e) {
                s = o - 1;
                break;
              }
            }
          }
        for (; o < n.length; ) {
          const a = n[o];
          if ("number" == typeof a) break;
          if (a === t) {
            if (null === i) return void (null !== r && (n[o + 1] = r));
            if (i === n[o + 1]) return void (n[o + 2] = r);
          }
          o++, null !== i && o++, null !== r && o++;
        }
        -1 !== s && (n.splice(s, 0, e), (o = s + 1)),
          n.splice(o++, 0, t),
          null !== i && n.splice(o++, 0, i),
          null !== r && n.splice(o++, 0, r);
      }
      function yD(n) {
        return -1 !== n;
      }
      function Vs(n) {
        return 32767 & n;
      }
      function Bs(n, e) {
        let t = (function ER(n) {
            return n >> 16;
          })(n),
          i = e;
        for (; t > 0; ) (i = i[15]), t--;
        return i;
      }
      let $p = !0;
      function $u(n) {
        const e = $p;
        return ($p = n), e;
      }
      let wR = 0;
      const Pi = {};
      function Dl(n, e) {
        const t = Gp(n, e);
        if (-1 !== t) return t;
        const i = e[1];
        i.firstCreatePass &&
          ((n.injectorIndex = e.length),
          Wp(i.data, n),
          Wp(e, null),
          Wp(i.blueprint, null));
        const r = Wu(n, e),
          o = n.injectorIndex;
        if (yD(r)) {
          const s = Vs(r),
            a = Bs(r, e),
            l = a[1].data;
          for (let c = 0; c < 8; c++) e[o + c] = a[s + c] | l[s + c];
        }
        return (e[o + 8] = r), o;
      }
      function Wp(n, e) {
        n.push(0, 0, 0, 0, 0, 0, 0, 0, e);
      }
      function Gp(n, e) {
        return -1 === n.injectorIndex ||
          (n.parent && n.parent.injectorIndex === n.injectorIndex) ||
          null === e[n.injectorIndex + 8]
          ? -1
          : n.injectorIndex;
      }
      function Wu(n, e) {
        if (n.parent && -1 !== n.parent.injectorIndex)
          return n.parent.injectorIndex;
        let t = 0,
          i = null,
          r = e;
        for (; null !== r; ) {
          if (((i = MD(r)), null === i)) return -1;
          if ((t++, (r = r[15]), -1 !== i.injectorIndex))
            return i.injectorIndex | (t << 16);
        }
        return -1;
      }
      function Gu(n, e, t) {
        !(function SR(n, e, t) {
          let i;
          "string" == typeof t
            ? (i = t.charCodeAt(0) || 0)
            : t.hasOwnProperty(pl) && (i = t[pl]),
            null == i && (i = t[pl] = wR++);
          const r = 255 & i;
          e.data[n + (r >> 5)] |= 1 << r;
        })(n, e, t);
      }
      function bD(n, e, t) {
        if (t & G.Optional) return n;
        Iu();
      }
      function DD(n, e, t, i) {
        if (
          (t & G.Optional && void 0 === i && (i = null),
          0 == (t & (G.Self | G.Host)))
        ) {
          const r = n[9],
            o = ki(void 0);
          try {
            return r ? r.get(e, i, t & G.Optional) : Ub(e, i, t & G.Optional);
          } finally {
            ki(o);
          }
        }
        return bD(i, 0, t);
      }
      function CD(n, e, t, i = G.Default, r) {
        if (null !== n) {
          if (1024 & e[2]) {
            const s = (function AR(n, e, t, i, r) {
              let o = n,
                s = e;
              for (
                ;
                null !== o && null !== s && 1024 & s[2] && !(256 & s[2]);

              ) {
                const a = ED(o, s, t, i | G.Self, Pi);
                if (a !== Pi) return a;
                let l = o.parent;
                if (!l) {
                  const c = s[21];
                  if (c) {
                    const u = c.get(t, Pi, i);
                    if (u !== Pi) return u;
                  }
                  (l = MD(s)), (s = s[15]);
                }
                o = l;
              }
              return r;
            })(n, e, t, i, Pi);
            if (s !== Pi) return s;
          }
          const o = ED(n, e, t, i, Pi);
          if (o !== Pi) return o;
        }
        return DD(e, t, i, r);
      }
      function ED(n, e, t, i, r) {
        const o = (function TR(n) {
          if ("string" == typeof n) return n.charCodeAt(0) || 0;
          const e = n.hasOwnProperty(pl) ? n[pl] : void 0;
          return "number" == typeof e ? (e >= 0 ? 255 & e : xR) : e;
        })(t);
        if ("function" == typeof o) {
          if (!cD(e, n, i)) return i & G.Host ? bD(r, 0, i) : DD(e, t, i, r);
          try {
            const s = o(i);
            if (null != s || i & G.Optional) return s;
            Iu();
          } finally {
            fD();
          }
        } else if ("number" == typeof o) {
          let s = null,
            a = Gp(n, e),
            l = -1,
            c = i & G.Host ? e[16][6] : null;
          for (
            (-1 === a || i & G.SkipSelf) &&
            ((l = -1 === a ? Wu(n, e) : e[a + 8]),
            -1 !== l && SD(i, !1)
              ? ((s = e[1]), (a = Vs(l)), (e = Bs(l, e)))
              : (a = -1));
            -1 !== a;

          ) {
            const u = e[1];
            if (wD(o, a, u.data)) {
              const d = IR(a, e, t, s, i, c);
              if (d !== Pi) return d;
            }
            (l = e[a + 8]),
              -1 !== l && SD(i, e[1].data[a + 8] === c) && wD(o, a, e)
                ? ((s = u), (a = Vs(l)), (e = Bs(l, e)))
                : (a = -1);
          }
        }
        return r;
      }
      function IR(n, e, t, i, r, o) {
        const s = e[1],
          a = s.data[n + 8],
          u = qu(
            a,
            s,
            t,
            null == i ? Nu(a) && $p : i != s && 0 != (3 & a.type),
            r & G.Host && o === a
          );
        return null !== u ? Cl(e, s, u, a) : Pi;
      }
      function qu(n, e, t, i, r) {
        const o = n.providerIndexes,
          s = e.data,
          a = 1048575 & o,
          l = n.directiveStart,
          u = o >> 20,
          h = r ? a + u : n.directiveEnd;
        for (let f = i ? a : a + u; f < h; f++) {
          const p = s[f];
          if ((f < l && t === p) || (f >= l && p.type === t)) return f;
        }
        if (r) {
          const f = s[l];
          if (f && hi(f) && f.type === t) return l;
        }
        return null;
      }
      function Cl(n, e, t, i) {
        let r = n[t];
        const o = e.data;
        if (
          (function _R(n) {
            return n instanceof _l;
          })(r)
        ) {
          const s = r;
          s.resolving &&
            (function CN(n, e) {
              const t = e ? `. Dependency path: ${e.join(" > ")} > ${n}` : "";
              throw new W(
                -200,
                `Circular dependency in DI detected for ${n}${t}`
              );
            })(
              (function Se(n) {
                return "function" == typeof n
                  ? n.name || n.toString()
                  : "object" == typeof n &&
                    null != n &&
                    "function" == typeof n.type
                  ? n.type.name || n.type.toString()
                  : ie(n);
              })(o[t])
            );
          const a = $u(s.canSeeViewProviders);
          s.resolving = !0;
          const l = s.injectImpl ? ki(s.injectImpl) : null;
          cD(n, i, G.Default);
          try {
            (r = n[t] = s.factory(void 0, o, n, i)),
              e.firstCreatePass &&
                t >= i.directiveStart &&
                (function yR(n, e, t) {
                  const {
                    ngOnChanges: i,
                    ngOnInit: r,
                    ngDoCheck: o,
                  } = e.type.prototype;
                  if (i) {
                    const s = Zb(e);
                    (t.preOrderHooks || (t.preOrderHooks = [])).push(n, s),
                      (
                        t.preOrderCheckHooks || (t.preOrderCheckHooks = [])
                      ).push(n, s);
                  }
                  r &&
                    (t.preOrderHooks || (t.preOrderHooks = [])).push(0 - n, r),
                    o &&
                      ((t.preOrderHooks || (t.preOrderHooks = [])).push(n, o),
                      (
                        t.preOrderCheckHooks || (t.preOrderCheckHooks = [])
                      ).push(n, o));
                })(t, o[t], e);
          } finally {
            null !== l && ki(l), $u(a), (s.resolving = !1), fD();
          }
        }
        return r;
      }
      function wD(n, e, t) {
        return !!(t[e + (n >> 5)] & (1 << n));
      }
      function SD(n, e) {
        return !(n & G.Self || (n & G.Host && e));
      }
      class js {
        constructor(e, t) {
          (this._tNode = e), (this._lView = t);
        }
        get(e, t, i) {
          return CD(this._tNode, this._lView, e, i, t);
        }
      }
      function xR() {
        return new js(Ct(), M());
      }
      function Nt(n) {
        return Ur(() => {
          const e = n.prototype.constructor,
            t = e[pr] || qp(e),
            i = Object.prototype;
          let r = Object.getPrototypeOf(n.prototype).constructor;
          for (; r && r !== i; ) {
            const o = r[pr] || qp(r);
            if (o && o !== t) return o;
            r = Object.getPrototypeOf(r);
          }
          return (o) => new o();
        });
      }
      function qp(n) {
        return vp(n)
          ? () => {
              const e = qp(J(n));
              return e && e();
            }
          : Ho(n);
      }
      function MD(n) {
        const e = n[1],
          t = e.type;
        return 2 === t ? e.declTNode : 1 === t ? n[6] : null;
      }
      const Us = "__parameters__";
      function $s(n, e, t) {
        return Ur(() => {
          const i = (function Kp(n) {
            return function (...t) {
              if (n) {
                const i = n(...t);
                for (const r in i) this[r] = i[r];
              }
            };
          })(e);
          function r(...o) {
            if (this instanceof r) return i.apply(this, o), this;
            const s = new r(...o);
            return (a.annotation = s), a;
            function a(l, c, u) {
              const d = l.hasOwnProperty(Us)
                ? l[Us]
                : Object.defineProperty(l, Us, { value: [] })[Us];
              for (; d.length <= u; ) d.push(null);
              return (d[u] = d[u] || []).push(s), l;
            }
          }
          return (
            t && (r.prototype = Object.create(t.prototype)),
            (r.prototype.ngMetadataName = n),
            (r.annotationCls = r),
            r
          );
        });
      }
      class F {
        constructor(e, t) {
          (this._desc = e),
            (this.ngMetadataName = "InjectionToken"),
            (this.ɵprov = void 0),
            "number" == typeof t
              ? (this.__NG_ELEMENT_ID__ = t)
              : void 0 !== t &&
                (this.ɵprov = j({
                  token: this,
                  providedIn: t.providedIn || "root",
                  factory: t.factory,
                }));
        }
        get multi() {
          return this;
        }
        toString() {
          return `InjectionToken ${this._desc}`;
        }
      }
      const kR = new F("AnalyzeForEntryComponents");
      function Nn(n, e) {
        void 0 === e && (e = n);
        for (let t = 0; t < n.length; t++) {
          let i = n[t];
          Array.isArray(i)
            ? (e === n && (e = n.slice(0, t)), Nn(i, e))
            : e !== n && e.push(i);
        }
        return e;
      }
      function yr(n, e) {
        n.forEach((t) => (Array.isArray(t) ? yr(t, e) : e(t)));
      }
      function TD(n, e, t) {
        e >= n.length ? n.push(t) : n.splice(e, 0, t);
      }
      function Ku(n, e) {
        return e >= n.length - 1 ? n.pop() : n.splice(e, 1)[0];
      }
      function Ml(n, e) {
        const t = [];
        for (let i = 0; i < n; i++) t.push(e);
        return t;
      }
      function Rn(n, e, t) {
        let i = Ws(n, e);
        return (
          i >= 0
            ? (n[1 | i] = t)
            : ((i = ~i),
              (function PR(n, e, t, i) {
                let r = n.length;
                if (r == e) n.push(t, i);
                else if (1 === r) n.push(i, n[0]), (n[0] = t);
                else {
                  for (r--, n.push(n[r - 1], n[r]); r > e; )
                    (n[r] = n[r - 2]), r--;
                  (n[e] = t), (n[e + 1] = i);
                }
              })(n, i, e, t)),
          i
        );
      }
      function Zp(n, e) {
        const t = Ws(n, e);
        if (t >= 0) return n[1 | t];
      }
      function Ws(n, e) {
        return (function OD(n, e, t) {
          let i = 0,
            r = n.length >> t;
          for (; r !== i; ) {
            const o = i + ((r - i) >> 1),
              s = n[o << t];
            if (e === s) return o << t;
            s > e ? (r = o) : (i = o + 1);
          }
          return ~(r << t);
        })(n, e, 1);
      }
      const Il = {},
        Jp = "__NG_DI_FLAG__",
        Zu = "ngTempTokenPath",
        zR = /\n/gm,
        kD = "__source";
      let Tl;
      function Qu(n) {
        const e = Tl;
        return (Tl = n), e;
      }
      function WR(n, e = G.Default) {
        if (void 0 === Tl) throw new W(-203, !1);
        return null === Tl
          ? Ub(n, void 0, e)
          : Tl.get(n, e & G.Optional ? null : void 0, e);
      }
      function T(n, e = G.Default) {
        return (
          (function AN() {
            return Dp;
          })() || WR
        )(J(n), e);
      }
      function Uo(n, e = G.Default) {
        return T(n, e);
      }
      function Xp(n) {
        const e = [];
        for (let t = 0; t < n.length; t++) {
          const i = J(n[t]);
          if (Array.isArray(i)) {
            if (0 === i.length) throw new W(900, !1);
            let r,
              o = G.Default;
            for (let s = 0; s < i.length; s++) {
              const a = i[s],
                l = GR(a);
              "number" == typeof l
                ? -1 === l
                  ? (r = a.token)
                  : (o |= l)
                : (r = a);
            }
            e.push(T(r, o));
          } else e.push(T(i));
        }
        return e;
      }
      function xl(n, e) {
        return (n[Jp] = e), (n.prototype[Jp] = e), n;
      }
      function GR(n) {
        return n[Jp];
      }
      const Ju = xl(
          $s("Inject", (n) => ({ token: n })),
          -1
        ),
        Gr = xl($s("Optional"), 8),
        Al = xl($s("SkipSelf"), 4);
      let td, nd;
      function qs(n) {
        return (
          (function eg() {
            if (void 0 === td && ((td = null), Re.trustedTypes))
              try {
                td = Re.trustedTypes.createPolicy("angular", {
                  createHTML: (n) => n,
                  createScript: (n) => n,
                  createScriptURL: (n) => n,
                });
              } catch {}
            return td;
          })()?.createHTML(n) || n
        );
      }
      function HD(n) {
        return (
          (function tg() {
            if (void 0 === nd && ((nd = null), Re.trustedTypes))
              try {
                nd = Re.trustedTypes.createPolicy("angular#unsafe-bypass", {
                  createHTML: (n) => n,
                  createScript: (n) => n,
                  createScriptURL: (n) => n,
                });
              } catch {}
            return nd;
          })()?.createHTML(n) || n
        );
      }
      class zo {
        constructor(e) {
          this.changingThisBreaksApplicationSecurity = e;
        }
        toString() {
          return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see https://g.co/ng/security#xss)`;
        }
      }
      class sP extends zo {
        getTypeName() {
          return "HTML";
        }
      }
      class aP extends zo {
        getTypeName() {
          return "Style";
        }
      }
      class lP extends zo {
        getTypeName() {
          return "Script";
        }
      }
      class cP extends zo {
        getTypeName() {
          return "URL";
        }
      }
      class uP extends zo {
        getTypeName() {
          return "ResourceURL";
        }
      }
      function Pn(n) {
        return n instanceof zo ? n.changingThisBreaksApplicationSecurity : n;
      }
      function Fi(n, e) {
        const t = (function dP(n) {
          return (n instanceof zo && n.getTypeName()) || null;
        })(n);
        if (null != t && t !== e) {
          if ("ResourceURL" === t && "URL" === e) return !0;
          throw new Error(
            `Required a safe ${e}, got a ${t} (see https://g.co/ng/security#xss)`
          );
        }
        return t === e;
      }
      class yP {
        constructor(e) {
          this.inertDocumentHelper = e;
        }
        getInertBodyElement(e) {
          e = "<body><remove></remove>" + e;
          try {
            const t = new window.DOMParser().parseFromString(
              qs(e),
              "text/html"
            ).body;
            return null === t
              ? this.inertDocumentHelper.getInertBodyElement(e)
              : (t.removeChild(t.firstChild), t);
          } catch {
            return null;
          }
        }
      }
      class vP {
        constructor(e) {
          if (
            ((this.defaultDoc = e),
            (this.inertDocument =
              this.defaultDoc.implementation.createHTMLDocument(
                "sanitization-inert"
              )),
            null == this.inertDocument.body)
          ) {
            const t = this.inertDocument.createElement("html");
            this.inertDocument.appendChild(t);
            const i = this.inertDocument.createElement("body");
            t.appendChild(i);
          }
        }
        getInertBodyElement(e) {
          const t = this.inertDocument.createElement("template");
          if ("content" in t) return (t.innerHTML = qs(e)), t;
          const i = this.inertDocument.createElement("body");
          return (
            (i.innerHTML = qs(e)),
            this.defaultDoc.documentMode && this.stripCustomNsAttrs(i),
            i
          );
        }
        stripCustomNsAttrs(e) {
          const t = e.attributes;
          for (let r = t.length - 1; 0 < r; r--) {
            const s = t.item(r).name;
            ("xmlns:ns1" === s || 0 === s.indexOf("ns1:")) &&
              e.removeAttribute(s);
          }
          let i = e.firstChild;
          for (; i; )
            i.nodeType === Node.ELEMENT_NODE && this.stripCustomNsAttrs(i),
              (i = i.nextSibling);
        }
      }
      const bP =
          /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^&:/?#]*(?:[/?#]|$))/gi,
        DP =
          /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+\/]+=*$/i;
      function Nl(n) {
        return (n = String(n)).match(bP) || n.match(DP) ? n : "unsafe:" + n;
      }
      function WD(n) {
        return (n = String(n))
          .split(",")
          .map((e) => Nl(e.trim()))
          .join(", ");
      }
      function Li(n) {
        const e = {};
        for (const t of n.split(",")) e[t] = !0;
        return e;
      }
      function Rl(...n) {
        const e = {};
        for (const t of n)
          for (const i in t) t.hasOwnProperty(i) && (e[i] = !0);
        return e;
      }
      const GD = Li("area,br,col,hr,img,wbr"),
        qD = Li("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"),
        KD = Li("rp,rt"),
        ng = Rl(
          GD,
          Rl(
            qD,
            Li(
              "address,article,aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul"
            )
          ),
          Rl(
            KD,
            Li(
              "a,abbr,acronym,audio,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video"
            )
          ),
          Rl(KD, qD)
        ),
        ig = Li("background,cite,href,itemtype,longdesc,poster,src,xlink:href"),
        rg = Li("srcset"),
        YD = Rl(
          ig,
          rg,
          Li(
            "abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,scope,scrolling,shape,size,sizes,span,srclang,start,summary,tabindex,target,title,translate,type,usemap,valign,value,vspace,width"
          ),
          Li(
            "aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext"
          )
        ),
        CP = Li("script,style,template");
      class EP {
        constructor() {
          (this.sanitizedSomething = !1), (this.buf = []);
        }
        sanitizeChildren(e) {
          let t = e.firstChild,
            i = !0;
          for (; t; )
            if (
              (t.nodeType === Node.ELEMENT_NODE
                ? (i = this.startElement(t))
                : t.nodeType === Node.TEXT_NODE
                ? this.chars(t.nodeValue)
                : (this.sanitizedSomething = !0),
              i && t.firstChild)
            )
              t = t.firstChild;
            else
              for (; t; ) {
                t.nodeType === Node.ELEMENT_NODE && this.endElement(t);
                let r = this.checkClobberedElement(t, t.nextSibling);
                if (r) {
                  t = r;
                  break;
                }
                t = this.checkClobberedElement(t, t.parentNode);
              }
          return this.buf.join("");
        }
        startElement(e) {
          const t = e.nodeName.toLowerCase();
          if (!ng.hasOwnProperty(t))
            return (this.sanitizedSomething = !0), !CP.hasOwnProperty(t);
          this.buf.push("<"), this.buf.push(t);
          const i = e.attributes;
          for (let r = 0; r < i.length; r++) {
            const o = i.item(r),
              s = o.name,
              a = s.toLowerCase();
            if (!YD.hasOwnProperty(a)) {
              this.sanitizedSomething = !0;
              continue;
            }
            let l = o.value;
            ig[a] && (l = Nl(l)),
              rg[a] && (l = WD(l)),
              this.buf.push(" ", s, '="', ZD(l), '"');
          }
          return this.buf.push(">"), !0;
        }
        endElement(e) {
          const t = e.nodeName.toLowerCase();
          ng.hasOwnProperty(t) &&
            !GD.hasOwnProperty(t) &&
            (this.buf.push("</"), this.buf.push(t), this.buf.push(">"));
        }
        chars(e) {
          this.buf.push(ZD(e));
        }
        checkClobberedElement(e, t) {
          if (
            t &&
            (e.compareDocumentPosition(t) &
              Node.DOCUMENT_POSITION_CONTAINED_BY) ===
              Node.DOCUMENT_POSITION_CONTAINED_BY
          )
            throw new Error(
              `Failed to sanitize html because the element is clobbered: ${e.outerHTML}`
            );
          return t;
        }
      }
      const wP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
        SP = /([^\#-~ |!])/g;
      function ZD(n) {
        return n
          .replace(/&/g, "&amp;")
          .replace(wP, function (e) {
            return (
              "&#" +
              (1024 * (e.charCodeAt(0) - 55296) +
                (e.charCodeAt(1) - 56320) +
                65536) +
              ";"
            );
          })
          .replace(SP, function (e) {
            return "&#" + e.charCodeAt(0) + ";";
          })
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;");
      }
      let id;
      function QD(n, e) {
        let t = null;
        try {
          id =
            id ||
            (function $D(n) {
              const e = new vP(n);
              return (function _P() {
                try {
                  return !!new window.DOMParser().parseFromString(
                    qs(""),
                    "text/html"
                  );
                } catch {
                  return !1;
                }
              })()
                ? new yP(e)
                : e;
            })(n);
          let i = e ? String(e) : "";
          t = id.getInertBodyElement(i);
          let r = 5,
            o = i;
          do {
            if (0 === r)
              throw new Error(
                "Failed to sanitize html because the input is unstable"
              );
            r--, (i = o), (o = t.innerHTML), (t = id.getInertBodyElement(i));
          } while (i !== o);
          return qs(new EP().sanitizeChildren(og(t) || t));
        } finally {
          if (t) {
            const i = og(t) || t;
            for (; i.firstChild; ) i.removeChild(i.firstChild);
          }
        }
      }
      function og(n) {
        return "content" in n &&
          (function MP(n) {
            return (
              n.nodeType === Node.ELEMENT_NODE && "TEMPLATE" === n.nodeName
            );
          })(n)
          ? n.content
          : null;
      }
      var Ue = (() => (
        ((Ue = Ue || {})[(Ue.NONE = 0)] = "NONE"),
        (Ue[(Ue.HTML = 1)] = "HTML"),
        (Ue[(Ue.STYLE = 2)] = "STYLE"),
        (Ue[(Ue.SCRIPT = 3)] = "SCRIPT"),
        (Ue[(Ue.URL = 4)] = "URL"),
        (Ue[(Ue.RESOURCE_URL = 5)] = "RESOURCE_URL"),
        Ue
      ))();
      function sg(n) {
        const e = Pl();
        return e
          ? HD(e.sanitize(Ue.HTML, n) || "")
          : Fi(n, "HTML")
          ? HD(Pn(n))
          : QD(kp(), ie(n));
      }
      function qr(n) {
        const e = Pl();
        return e
          ? e.sanitize(Ue.URL, n) || ""
          : Fi(n, "URL")
          ? Pn(n)
          : Nl(ie(n));
      }
      function Pl() {
        const n = M();
        return n && n[12];
      }
      function lg(n) {
        return n.ngOriginalError;
      }
      class Ks {
        constructor() {
          this._console = console;
        }
        handleError(e) {
          const t = this._findOriginalError(e);
          this._console.error("ERROR", e),
            t && this._console.error("ORIGINAL ERROR", t);
        }
        _findOriginalError(e) {
          let t = e && lg(e);
          for (; t && lg(t); ) t = lg(t);
          return t || null;
        }
      }
      const cg = new Map();
      let HP = 0;
      const dg = "__ngContext__";
      function Gt(n, e) {
        yn(e)
          ? ((n[dg] = e[20]),
            (function zP(n) {
              cg.set(n[20], n);
            })(e))
          : (n[dg] = e);
      }
      function Fl(n) {
        const e = n[dg];
        return "number" == typeof e
          ? (function eC(n) {
              return cg.get(n) || null;
            })(e)
          : e || null;
      }
      function hg(n) {
        const e = Fl(n);
        return e ? (yn(e) ? e : e.lView) : null;
      }
      const JP = (() =>
        (
          (typeof requestAnimationFrame < "u" && requestAnimationFrame) ||
          setTimeout
        ).bind(Re))();
      function vr(n) {
        return n instanceof Function ? n() : n;
      }
      var vn = (() => (
        ((vn = vn || {})[(vn.Important = 1)] = "Important"),
        (vn[(vn.DashCase = 2)] = "DashCase"),
        vn
      ))();
      function pg(n, e) {
        return undefined(n, e);
      }
      function Ll(n) {
        const e = n[3];
        return di(e) ? e[3] : e;
      }
      function gg(n) {
        return cC(n[13]);
      }
      function mg(n) {
        return cC(n[4]);
      }
      function cC(n) {
        for (; null !== n && !di(n); ) n = n[4];
        return n;
      }
      function Zs(n, e, t, i, r) {
        if (null != i) {
          let o,
            s = !1;
          di(i) ? (o = i) : yn(i) && ((s = !0), (i = i[0]));
          const a = ft(i);
          0 === n && null !== t
            ? null == r
              ? gC(e, t, a)
              : $o(e, t, a, r || null, !0)
            : 1 === n && null !== t
            ? $o(e, t, a, r || null, !0)
            : 2 === n
            ? (function EC(n, e, t) {
                const i = rd(n, e);
                i &&
                  (function fF(n, e, t, i) {
                    ot(n) ? n.removeChild(e, t, i) : e.removeChild(t);
                  })(n, i, e, t);
              })(e, a, s)
            : 3 === n && e.destroyNode(a),
            null != o &&
              (function mF(n, e, t, i, r) {
                const o = t[7];
                o !== ft(t) && Zs(e, n, i, o, r);
                for (let a = 10; a < t.length; a++) {
                  const l = t[a];
                  Vl(l[1], l, n, e, i, o);
                }
              })(e, n, o, t, r);
        }
      }
      function vg(n, e, t) {
        if (ot(n)) return n.createElement(e, t);
        {
          const i =
            null !== t
              ? (function qN(n) {
                  const e = n.toLowerCase();
                  return "svg" === e
                    ? "http://www.w3.org/2000/svg"
                    : "math" === e
                    ? "http://www.w3.org/1998/MathML/"
                    : null;
                })(t)
              : null;
          return null === i ? n.createElement(e) : n.createElementNS(i, e);
        }
      }
      function dC(n, e) {
        const t = n[9],
          i = t.indexOf(e),
          r = e[3];
        512 & e[2] && ((e[2] &= -513), Pp(r, -1)), t.splice(i, 1);
      }
      function _g(n, e) {
        if (n.length <= 10) return;
        const t = 10 + e,
          i = n[t];
        if (i) {
          const r = i[17];
          null !== r && r !== n && dC(r, i), e > 0 && (n[t - 1][4] = i[4]);
          const o = Ku(n, 10 + e);
          !(function oF(n, e) {
            Vl(n, e, e[11], 2, null, null), (e[0] = null), (e[6] = null);
          })(i[1], i);
          const s = o[19];
          null !== s && s.detachView(o[1]),
            (i[3] = null),
            (i[4] = null),
            (i[2] &= -65);
        }
        return i;
      }
      function hC(n, e) {
        if (!(128 & e[2])) {
          const t = e[11];
          ot(t) && t.destroyNode && Vl(n, e, t, 3, null, null),
            (function lF(n) {
              let e = n[13];
              if (!e) return bg(n[1], n);
              for (; e; ) {
                let t = null;
                if (yn(e)) t = e[13];
                else {
                  const i = e[10];
                  i && (t = i);
                }
                if (!t) {
                  for (; e && !e[4] && e !== n; )
                    yn(e) && bg(e[1], e), (e = e[3]);
                  null === e && (e = n), yn(e) && bg(e[1], e), (t = e && e[4]);
                }
                e = t;
              }
            })(e);
        }
      }
      function bg(n, e) {
        if (!(128 & e[2])) {
          (e[2] &= -65),
            (e[2] |= 128),
            (function hF(n, e) {
              let t;
              if (null != n && null != (t = n.destroyHooks))
                for (let i = 0; i < t.length; i += 2) {
                  const r = e[t[i]];
                  if (!(r instanceof _l)) {
                    const o = t[i + 1];
                    if (Array.isArray(o))
                      for (let s = 0; s < o.length; s += 2) {
                        const a = r[o[s]],
                          l = o[s + 1];
                        try {
                          l.call(a);
                        } finally {
                        }
                      }
                    else
                      try {
                        o.call(r);
                      } finally {
                      }
                  }
                }
            })(n, e),
            (function dF(n, e) {
              const t = n.cleanup,
                i = e[7];
              let r = -1;
              if (null !== t)
                for (let o = 0; o < t.length - 1; o += 2)
                  if ("string" == typeof t[o]) {
                    const s = t[o + 1],
                      a = "function" == typeof s ? s(e) : ft(e[s]),
                      l = i[(r = t[o + 2])],
                      c = t[o + 3];
                    "boolean" == typeof c
                      ? a.removeEventListener(t[o], l, c)
                      : c >= 0
                      ? i[(r = c)]()
                      : i[(r = -c)].unsubscribe(),
                      (o += 2);
                  } else {
                    const s = i[(r = t[o + 1])];
                    t[o].call(s);
                  }
              if (null !== i) {
                for (let o = r + 1; o < i.length; o++) i[o]();
                e[7] = null;
              }
            })(n, e),
            1 === e[1].type && ot(e[11]) && e[11].destroy();
          const t = e[17];
          if (null !== t && di(e[3])) {
            t !== e[3] && dC(t, e);
            const i = e[19];
            null !== i && i.detachView(n);
          }
          !(function $P(n) {
            cg.delete(n[20]);
          })(e);
        }
      }
      function fC(n, e, t) {
        return (function pC(n, e, t) {
          let i = e;
          for (; null !== i && 40 & i.type; ) i = (e = i).parent;
          if (null === i) return t[0];
          if (2 & i.flags) {
            const r = n.data[i.directiveStart].encapsulation;
            if (r === Ni.None || r === Ni.Emulated) return null;
          }
          return Gn(i, t);
        })(n, e.parent, t);
      }
      function $o(n, e, t, i, r) {
        ot(n)
          ? n.insertBefore(e, t, i, r)
          : (yC(e) ? e.content : e).insertBefore(t, i, r);
      }
      function gC(n, e, t) {
        ot(n) ? n.appendChild(e, t) : (yC(e) ? e.content : e).appendChild(t);
      }
      function mC(n, e, t, i, r) {
        null !== i ? $o(n, e, t, i, r) : gC(n, e, t);
      }
      function yC(n) {
        return "TEMPLATE" === n.tagName && void 0 !== n.content;
      }
      function rd(n, e) {
        return ot(n) ? n.parentNode(e) : e.parentNode;
      }
      function vC(n, e, t) {
        return bC(n, e, t);
      }
      let bC = function _C(n, e, t) {
        return 40 & n.type ? Gn(n, t) : null;
      };
      function od(n, e, t, i) {
        const r = fC(n, i, e),
          o = e[11],
          a = vC(i.parent || e[6], i, e);
        if (null != r)
          if (Array.isArray(t))
            for (let l = 0; l < t.length; l++) mC(o, r, t[l], a, !1);
          else mC(o, r, t, a, !1);
      }
      function sd(n, e) {
        if (null !== e) {
          const t = e.type;
          if (3 & t) return Gn(e, n);
          if (4 & t) return Cg(-1, n[e.index]);
          if (8 & t) {
            const i = e.child;
            if (null !== i) return sd(n, i);
            {
              const r = n[e.index];
              return di(r) ? Cg(-1, r) : ft(r);
            }
          }
          if (32 & t) return pg(e, n)() || ft(n[e.index]);
          {
            const i = CC(n, e);
            return null !== i
              ? Array.isArray(i)
                ? i[0]
                : sd(Ll(n[16]), i)
              : sd(n, e.next);
          }
        }
        return null;
      }
      function CC(n, e) {
        return null !== e ? n[16][6].projection[e.projection] : null;
      }
      function Cg(n, e) {
        const t = 10 + n + 1;
        if (t < e.length) {
          const i = e[t],
            r = i[1].firstChild;
          if (null !== r) return sd(i, r);
        }
        return e[7];
      }
      function Eg(n, e, t, i, r, o, s) {
        for (; null != t; ) {
          const a = i[t.index],
            l = t.type;
          if (
            (s && 0 === e && (a && Gt(ft(a), i), (t.flags |= 4)),
            64 != (64 & t.flags))
          )
            if (8 & l) Eg(n, e, t.child, i, r, o, !1), Zs(e, n, r, a, o);
            else if (32 & l) {
              const c = pg(t, i);
              let u;
              for (; (u = c()); ) Zs(e, n, r, u, o);
              Zs(e, n, r, a, o);
            } else 16 & l ? wC(n, e, i, t, r, o) : Zs(e, n, r, a, o);
          t = s ? t.projectionNext : t.next;
        }
      }
      function Vl(n, e, t, i, r, o) {
        Eg(t, i, n.firstChild, e, r, o, !1);
      }
      function wC(n, e, t, i, r, o) {
        const s = t[16],
          l = s[6].projection[i.projection];
        if (Array.isArray(l))
          for (let c = 0; c < l.length; c++) Zs(e, n, r, l[c], o);
        else Eg(n, e, l, s[3], r, o, !0);
      }
      function SC(n, e, t) {
        ot(n) ? n.setAttribute(e, "style", t) : (e.style.cssText = t);
      }
      function wg(n, e, t) {
        ot(n)
          ? "" === t
            ? n.removeAttribute(e, "class")
            : n.setAttribute(e, "class", t)
          : (e.className = t);
      }
      function MC(n, e, t) {
        let i = n.length;
        for (;;) {
          const r = n.indexOf(e, t);
          if (-1 === r) return r;
          if (0 === r || n.charCodeAt(r - 1) <= 32) {
            const o = e.length;
            if (r + o === i || n.charCodeAt(r + o) <= 32) return r;
          }
          t = r + 1;
        }
      }
      const IC = "ng-template";
      function vF(n, e, t) {
        let i = 0;
        for (; i < n.length; ) {
          let r = n[i++];
          if (t && "class" === r) {
            if (((r = n[i]), -1 !== MC(r.toLowerCase(), e, 0))) return !0;
          } else if (1 === r) {
            for (; i < n.length && "string" == typeof (r = n[i++]); )
              if (r.toLowerCase() === e) return !0;
            return !1;
          }
        }
        return !1;
      }
      function TC(n) {
        return 4 === n.type && n.value !== IC;
      }
      function _F(n, e, t) {
        return e === (4 !== n.type || t ? n.value : IC);
      }
      function bF(n, e, t) {
        let i = 4;
        const r = n.attrs || [],
          o = (function EF(n) {
            for (let e = 0; e < n.length; e++) if (gD(n[e])) return e;
            return n.length;
          })(r);
        let s = !1;
        for (let a = 0; a < e.length; a++) {
          const l = e[a];
          if ("number" != typeof l) {
            if (!s)
              if (4 & i) {
                if (
                  ((i = 2 | (1 & i)),
                  ("" !== l && !_F(n, l, t)) || ("" === l && 1 === e.length))
                ) {
                  if (fi(i)) return !1;
                  s = !0;
                }
              } else {
                const c = 8 & i ? l : e[++a];
                if (8 & i && null !== n.attrs) {
                  if (!vF(n.attrs, c, t)) {
                    if (fi(i)) return !1;
                    s = !0;
                  }
                  continue;
                }
                const d = DF(8 & i ? "class" : l, r, TC(n), t);
                if (-1 === d) {
                  if (fi(i)) return !1;
                  s = !0;
                  continue;
                }
                if ("" !== c) {
                  let h;
                  h = d > o ? "" : r[d + 1].toLowerCase();
                  const f = 8 & i ? h : null;
                  if ((f && -1 !== MC(f, c, 0)) || (2 & i && c !== h)) {
                    if (fi(i)) return !1;
                    s = !0;
                  }
                }
              }
          } else {
            if (!s && !fi(i) && !fi(l)) return !1;
            if (s && fi(l)) continue;
            (s = !1), (i = l | (1 & i));
          }
        }
        return fi(i) || s;
      }
      function fi(n) {
        return 0 == (1 & n);
      }
      function DF(n, e, t, i) {
        if (null === e) return -1;
        let r = 0;
        if (i || !t) {
          let o = !1;
          for (; r < e.length; ) {
            const s = e[r];
            if (s === n) return r;
            if (3 === s || 6 === s) o = !0;
            else {
              if (1 === s || 2 === s) {
                let a = e[++r];
                for (; "string" == typeof a; ) a = e[++r];
                continue;
              }
              if (4 === s) break;
              if (0 === s) {
                r += 4;
                continue;
              }
            }
            r += o ? 1 : 2;
          }
          return -1;
        }
        return (function wF(n, e) {
          let t = n.indexOf(4);
          if (t > -1)
            for (t++; t < n.length; ) {
              const i = n[t];
              if ("number" == typeof i) return -1;
              if (i === e) return t;
              t++;
            }
          return -1;
        })(e, n);
      }
      function xC(n, e, t = !1) {
        for (let i = 0; i < e.length; i++) if (bF(n, e[i], t)) return !0;
        return !1;
      }
      function SF(n, e) {
        e: for (let t = 0; t < e.length; t++) {
          const i = e[t];
          if (n.length === i.length) {
            for (let r = 0; r < n.length; r++) if (n[r] !== i[r]) continue e;
            return !0;
          }
        }
        return !1;
      }
      function AC(n, e) {
        return n ? ":not(" + e.trim() + ")" : e;
      }
      function MF(n) {
        let e = n[0],
          t = 1,
          i = 2,
          r = "",
          o = !1;
        for (; t < n.length; ) {
          let s = n[t];
          if ("string" == typeof s)
            if (2 & i) {
              const a = n[++t];
              r += "[" + s + (a.length > 0 ? '="' + a + '"' : "") + "]";
            } else 8 & i ? (r += "." + s) : 4 & i && (r += " " + s);
          else
            "" !== r && !fi(s) && ((e += AC(o, r)), (r = "")),
              (i = s),
              (o = o || !fi(i));
          t++;
        }
        return "" !== r && (e += AC(o, r)), e;
      }
      const re = {};
      function O(n) {
        OC(be(), M(), an() + n, !1);
      }
      function OC(n, e, t, i) {
        if (!i)
          if (3 == (3 & e[2])) {
            const o = n.preOrderCheckHooks;
            null !== o && ju(e, o, t);
          } else {
            const o = n.preOrderHooks;
            null !== o && Hu(e, o, 0, t);
          }
        $r(t);
      }
      const Sg = new F("ENVIRONMENT_INITIALIZER"),
        PC = new F("INJECTOR_DEF_TYPES");
      function RF(...n) {
        return { ɵproviders: FC(0, n) };
      }
      function FC(n, ...e) {
        const t = [],
          i = new Set();
        let r;
        return (
          yr(e, (o) => {
            const s = o;
            Mg(s, t, [], i) && (r || (r = []), r.push(s));
          }),
          void 0 !== r && LC(r, t),
          t
        );
      }
      function LC(n, e) {
        for (let t = 0; t < n.length; t++) {
          const { providers: r } = n[t];
          yr(r, (o) => {
            e.push(o);
          });
        }
      }
      function Mg(n, e, t, i) {
        if (!(n = J(n))) return !1;
        let r = null,
          o = jb(n);
        const s = !o && Ve(n);
        if (o || s) {
          if (s && !s.standalone) return !1;
          r = n;
        } else {
          const l = n.ngModule;
          if (((o = jb(l)), !o)) return !1;
          r = l;
        }
        const a = i.has(r);
        if (s) {
          if (a) return !1;
          if ((i.add(r), s.dependencies)) {
            const l =
              "function" == typeof s.dependencies
                ? s.dependencies()
                : s.dependencies;
            for (const c of l) Mg(c, e, t, i);
          }
        } else {
          if (!o) return !1;
          {
            if (null != o.imports && !a) {
              let c;
              i.add(r);
              try {
                yr(o.imports, (u) => {
                  Mg(u, e, t, i) && (c || (c = []), c.push(u));
                });
              } finally {
              }
              void 0 !== c && LC(c, e);
            }
            if (!a) {
              const c = Ho(r) || (() => new r());
              e.push(
                { provide: r, useFactory: c, deps: Me },
                { provide: PC, useValue: r, multi: !0 },
                { provide: Sg, useValue: () => T(r), multi: !0 }
              );
            }
            const l = o.providers;
            null == l ||
              a ||
              yr(l, (u) => {
                e.push(u);
              });
          }
        }
        return r !== n && void 0 !== n.providers;
      }
      const PF = Fe({ provide: String, useValue: Fe });
      function Ig(n) {
        return null !== n && "object" == typeof n && PF in n;
      }
      function Wo(n) {
        return "function" == typeof n;
      }
      const Tg = new F("INJECTOR", -1);
      class jC {
        get(e, t = Il) {
          if (t === Il) {
            const i = new Error(`NullInjectorError: No provider for ${Le(e)}!`);
            throw ((i.name = "NullInjectorError"), i);
          }
          return t;
        }
      }
      const xg = new F("Set Injector scope."),
        ad = {},
        LF = {};
      let Ag;
      function Og() {
        return void 0 === Ag && (Ag = new jC()), Ag;
      }
      class Go {}
      class HC extends Go {
        constructor(e, t, i, r) {
          super(),
            (this.parent = t),
            (this.source = i),
            (this.scopes = r),
            (this.records = new Map()),
            (this._ngOnDestroyHooks = new Set()),
            (this._onDestroyHooks = []),
            (this._destroyed = !1),
            Ng(e, (s) => this.processProvider(s)),
            this.records.set(Tg, Qs(void 0, this)),
            r.has("environment") && this.records.set(Go, Qs(void 0, this));
          const o = this.records.get(xg);
          null != o && "string" == typeof o.value && this.scopes.add(o.value),
            (this.injectorDefTypes = new Set(this.get(PC.multi, Me, G.Self)));
        }
        get destroyed() {
          return this._destroyed;
        }
        destroy() {
          this.assertNotDestroyed(), (this._destroyed = !0);
          try {
            for (const e of this._ngOnDestroyHooks) e.ngOnDestroy();
            for (const e of this._onDestroyHooks) e();
          } finally {
            this.records.clear(),
              this._ngOnDestroyHooks.clear(),
              this.injectorDefTypes.clear(),
              (this._onDestroyHooks.length = 0);
          }
        }
        onDestroy(e) {
          this._onDestroyHooks.push(e);
        }
        get(e, t = Il, i = G.Default) {
          this.assertNotDestroyed();
          const r = Qu(this),
            o = ki(void 0);
          try {
            if (!(i & G.SkipSelf)) {
              let a = this.records.get(e);
              if (void 0 === a) {
                const l =
                  (function UF(n) {
                    return (
                      "function" == typeof n ||
                      ("object" == typeof n && n instanceof F)
                    );
                  })(e) && _p(e);
                (a = l && this.injectableDefInScope(l) ? Qs(kg(e), ad) : null),
                  this.records.set(e, a);
              }
              if (null != a) return this.hydrate(e, a);
            }
            return (i & G.Self ? Og() : this.parent).get(
              e,
              (t = i & G.Optional && t === Il ? null : t)
            );
          } catch (s) {
            if ("NullInjectorError" === s.name) {
              if (((s[Zu] = s[Zu] || []).unshift(Le(e)), r)) throw s;
              return (function qR(n, e, t, i) {
                const r = n[Zu];
                throw (
                  (e[kD] && r.unshift(e[kD]),
                  (n.message = (function KR(n, e, t, i = null) {
                    n =
                      n && "\n" === n.charAt(0) && "\u0275" == n.charAt(1)
                        ? n.slice(2)
                        : n;
                    let r = Le(e);
                    if (Array.isArray(e)) r = e.map(Le).join(" -> ");
                    else if ("object" == typeof e) {
                      let o = [];
                      for (let s in e)
                        if (e.hasOwnProperty(s)) {
                          let a = e[s];
                          o.push(
                            s +
                              ":" +
                              ("string" == typeof a ? JSON.stringify(a) : Le(a))
                          );
                        }
                      r = `{${o.join(", ")}}`;
                    }
                    return `${t}${i ? "(" + i + ")" : ""}[${r}]: ${n.replace(
                      zR,
                      "\n  "
                    )}`;
                  })("\n" + n.message, r, t, i)),
                  (n.ngTokenPath = r),
                  (n[Zu] = null),
                  n)
                );
              })(s, e, "R3InjectorError", this.source);
            }
            throw s;
          } finally {
            ki(o), Qu(r);
          }
        }
        resolveInjectorInitializers() {
          const e = Qu(this),
            t = ki(void 0);
          try {
            const i = this.get(Sg.multi, Me, G.Self);
            for (const r of i) r();
          } finally {
            Qu(e), ki(t);
          }
        }
        toString() {
          const e = [],
            t = this.records;
          for (const i of t.keys()) e.push(Le(i));
          return `R3Injector[${e.join(", ")}]`;
        }
        assertNotDestroyed() {
          if (this._destroyed) throw new W(205, !1);
        }
        processProvider(e) {
          let t = Wo((e = J(e))) ? e : J(e && e.provide);
          const i = (function BF(n) {
            return Ig(n) ? Qs(void 0, n.useValue) : Qs(UC(n), ad);
          })(e);
          if (Wo(e) || !0 !== e.multi) this.records.get(t);
          else {
            let r = this.records.get(t);
            r ||
              ((r = Qs(void 0, ad, !0)),
              (r.factory = () => Xp(r.multi)),
              this.records.set(t, r)),
              (t = e),
              r.multi.push(e);
          }
          this.records.set(t, i);
        }
        hydrate(e, t) {
          return (
            t.value === ad && ((t.value = LF), (t.value = t.factory())),
            "object" == typeof t.value &&
              t.value &&
              (function HF(n) {
                return (
                  null !== n &&
                  "object" == typeof n &&
                  "function" == typeof n.ngOnDestroy
                );
              })(t.value) &&
              this._ngOnDestroyHooks.add(t.value),
            t.value
          );
        }
        injectableDefInScope(e) {
          if (!e.providedIn) return !1;
          const t = J(e.providedIn);
          return "string" == typeof t
            ? "any" === t || this.scopes.has(t)
            : this.injectorDefTypes.has(t);
        }
      }
      function kg(n) {
        const e = _p(n),
          t = null !== e ? e.factory : Ho(n);
        if (null !== t) return t;
        if (n instanceof F) throw new W(204, !1);
        if (n instanceof Function)
          return (function VF(n) {
            const e = n.length;
            if (e > 0) throw (Ml(e, "?"), new W(204, !1));
            const t = (function IN(n) {
              const e = n && (n[Tu] || n[Hb]);
              if (e) {
                const t = (function TN(n) {
                  if (n.hasOwnProperty("name")) return n.name;
                  const e = ("" + n).match(/^function\s*([^\s(]+)/);
                  return null === e ? "" : e[1];
                })(n);
                return (
                  console.warn(
                    `DEPRECATED: DI is instantiating a token "${t}" that inherits its @Injectable decorator but does not provide one itself.\nThis will become an error in a future version of Angular. Please add @Injectable() to the "${t}" class.`
                  ),
                  e
                );
              }
              return null;
            })(n);
            return null !== t ? () => t.factory(n) : () => new n();
          })(n);
        throw new W(204, !1);
      }
      function UC(n, e, t) {
        let i;
        if (Wo(n)) {
          const r = J(n);
          return Ho(r) || kg(r);
        }
        if (Ig(n)) i = () => J(n.useValue);
        else if (
          (function BC(n) {
            return !(!n || !n.useFactory);
          })(n)
        )
          i = () => n.useFactory(...Xp(n.deps || []));
        else if (
          (function VC(n) {
            return !(!n || !n.useExisting);
          })(n)
        )
          i = () => T(J(n.useExisting));
        else {
          const r = J(n && (n.useClass || n.provide));
          if (
            !(function jF(n) {
              return !!n.deps;
            })(n)
          )
            return Ho(r) || kg(r);
          i = () => new r(...Xp(n.deps));
        }
        return i;
      }
      function Qs(n, e, t = !1) {
        return { factory: n, value: e, multi: t ? [] : void 0 };
      }
      function zF(n) {
        return !!n.ɵproviders;
      }
      function Ng(n, e) {
        for (const t of n)
          Array.isArray(t) ? Ng(t, e) : zF(t) ? Ng(t.ɵproviders, e) : e(t);
      }
      function zC(n, e = null, t = null, i) {
        const r = $C(n, e, t, i);
        return r.resolveInjectorInitializers(), r;
      }
      function $C(n, e = null, t = null, i, r = new Set()) {
        const o = [t || Me, RF(n)];
        return (
          (i = i || ("object" == typeof n ? void 0 : Le(n))),
          new HC(o, e || Og(), i || null, r)
        );
      }
      let pt = (() => {
        class n {
          static create(t, i) {
            if (Array.isArray(t)) return zC({ name: "" }, i, t, "");
            {
              const r = t.name ?? "";
              return zC({ name: r }, t.parent, t.providers, r);
            }
          }
        }
        return (
          (n.THROW_IF_NOT_FOUND = Il),
          (n.NULL = new jC()),
          (n.ɵprov = j({ token: n, providedIn: "any", factory: () => T(Tg) })),
          (n.__NG_ELEMENT_ID__ = -1),
          n
        );
      })();
      function w(n, e = G.Default) {
        const t = M();
        return null === t ? T(n, e) : CD(Ct(), t, J(n), e);
      }
      function Vg() {
        throw new Error("invalid");
      }
      function cd(n, e) {
        return (n << 17) | (e << 2);
      }
      function pi(n) {
        return (n >> 17) & 32767;
      }
      function Ug(n) {
        return 2 | n;
      }
      function _r(n) {
        return (131068 & n) >> 2;
      }
      function zg(n, e) {
        return (-131069 & n) | (e << 2);
      }
      function $g(n) {
        return 1 | n;
      }
      function d0(n, e) {
        const t = n.contentQueries;
        if (null !== t)
          for (let i = 0; i < t.length; i += 2) {
            const r = t[i],
              o = t[i + 1];
            if (-1 !== o) {
              const s = n.data[o];
              jp(r), s.contentQueries(2, e[o], o);
            }
          }
      }
      function Bl(n, e, t, i, r, o, s, a, l, c, u) {
        const d = e.blueprint.slice();
        return (
          (d[0] = r),
          (d[2] = 76 | i),
          (null !== u || (n && 1024 & n[2])) && (d[2] |= 1024),
          nD(d),
          (d[3] = d[15] = n),
          (d[8] = t),
          (d[10] = s || (n && n[10])),
          (d[11] = a || (n && n[11])),
          (d[12] = l || (n && n[12]) || null),
          (d[9] = c || (n && n[9]) || null),
          (d[6] = o),
          (d[20] = (function UP() {
            return HP++;
          })()),
          (d[21] = u),
          (d[16] = 2 == e.type ? n[16] : d),
          d
        );
      }
      function Xs(n, e, t, i, r) {
        let o = n.data[e];
        if (null === o)
          (o = (function Xg(n, e, t, i, r) {
            const o = oD(),
              s = Fp(),
              l = (n.data[e] = (function DL(n, e, t, i, r, o) {
                return {
                  type: t,
                  index: i,
                  insertBeforeIndex: null,
                  injectorIndex: e ? e.injectorIndex : -1,
                  directiveStart: -1,
                  directiveEnd: -1,
                  directiveStylingLast: -1,
                  propertyBindings: null,
                  flags: 0,
                  providerIndexes: 0,
                  value: r,
                  attrs: o,
                  mergedAttrs: null,
                  localNames: null,
                  initialInputs: void 0,
                  inputs: null,
                  outputs: null,
                  tViews: null,
                  next: null,
                  projectionNext: null,
                  child: null,
                  parent: e,
                  projection: null,
                  styles: null,
                  stylesWithoutHost: null,
                  residualStyles: void 0,
                  classes: null,
                  classesWithoutHost: null,
                  residualClasses: void 0,
                  classBindings: 0,
                  styleBindings: 0,
                };
              })(0, s ? o : o && o.parent, t, e, i, r));
            return (
              null === n.firstChild && (n.firstChild = l),
              null !== o &&
                (s
                  ? null == o.child && null !== l.parent && (o.child = l)
                  : null === o.next && (o.next = l)),
              l
            );
          })(n, e, t, i, r)),
            (function sR() {
              return te.lFrame.inI18n;
            })() && (o.flags |= 64);
        else if (64 & o.type) {
          (o.type = t), (o.value = i), (o.attrs = r);
          const s = (function vl() {
            const n = te.lFrame,
              e = n.currentTNode;
            return n.isParent ? e : e.parent;
          })();
          o.injectorIndex = null === s ? -1 : s.injectorIndex;
        }
        return Ri(o, !0), o;
      }
      function ea(n, e, t, i) {
        if (0 === t) return -1;
        const r = e.length;
        for (let o = 0; o < t; o++)
          e.push(i), n.blueprint.push(i), n.data.push(null);
        return r;
      }
      function jl(n, e, t) {
        Lu(e);
        try {
          const i = n.viewQuery;
          null !== i && lm(1, i, t);
          const r = n.template;
          null !== r && h0(n, e, r, 1, t),
            n.firstCreatePass && (n.firstCreatePass = !1),
            n.staticContentQueries && d0(n, e),
            n.staticViewQueries && lm(2, n.viewQuery, t);
          const o = n.components;
          null !== o &&
            (function vL(n, e) {
              for (let t = 0; t < e.length; t++) BL(n, e[t]);
            })(e, o);
        } catch (i) {
          throw (
            (n.firstCreatePass &&
              ((n.incompleteFirstPass = !0), (n.firstCreatePass = !1)),
            i)
          );
        } finally {
          (e[2] &= -5), Vu();
        }
      }
      function ta(n, e, t, i) {
        const r = e[2];
        if (128 != (128 & r)) {
          Lu(e);
          try {
            nD(e),
              (function sD(n) {
                return (te.lFrame.bindingIndex = n);
              })(n.bindingStartIndex),
              null !== t && h0(n, e, t, 2, i);
            const s = 3 == (3 & r);
            if (s) {
              const c = n.preOrderCheckHooks;
              null !== c && ju(e, c, null);
            } else {
              const c = n.preOrderHooks;
              null !== c && Hu(e, c, 0, null), Hp(e, 0);
            }
            if (
              ((function LL(n) {
                for (let e = gg(n); null !== e; e = mg(e)) {
                  if (!e[2]) continue;
                  const t = e[9];
                  for (let i = 0; i < t.length; i++) {
                    const r = t[i],
                      o = r[3];
                    0 == (512 & r[2]) && Pp(o, 1), (r[2] |= 512);
                  }
                }
              })(e),
              (function FL(n) {
                for (let e = gg(n); null !== e; e = mg(e))
                  for (let t = 10; t < e.length; t++) {
                    const i = e[t],
                      r = i[1];
                    Rp(i) && ta(r, i, r.template, i[8]);
                  }
              })(e),
              null !== n.contentQueries && d0(n, e),
              s)
            ) {
              const c = n.contentCheckHooks;
              null !== c && ju(e, c);
            } else {
              const c = n.contentHooks;
              null !== c && Hu(e, c, 1), Hp(e, 1);
            }
            !(function mL(n, e) {
              const t = n.hostBindingOpCodes;
              if (null !== t)
                try {
                  for (let i = 0; i < t.length; i++) {
                    const r = t[i];
                    if (r < 0) $r(~r);
                    else {
                      const o = r,
                        s = t[++i],
                        a = t[++i];
                      aR(s, o), a(2, e[o]);
                    }
                  }
                } finally {
                  $r(-1);
                }
            })(n, e);
            const a = n.components;
            null !== a &&
              (function yL(n, e) {
                for (let t = 0; t < e.length; t++) VL(n, e[t]);
              })(e, a);
            const l = n.viewQuery;
            if ((null !== l && lm(2, l, i), s)) {
              const c = n.viewCheckHooks;
              null !== c && ju(e, c);
            } else {
              const c = n.viewHooks;
              null !== c && Hu(e, c, 2), Hp(e, 2);
            }
            !0 === n.firstUpdatePass && (n.firstUpdatePass = !1),
              (e[2] &= -41),
              512 & e[2] && ((e[2] &= -513), Pp(e[3], -1));
          } finally {
            Vu();
          }
        }
      }
      function _L(n, e, t, i) {
        const r = e[10],
          s = tD(e);
        try {
          !s && r.begin && r.begin(), s && jl(n, e, i), ta(n, e, t, i);
        } finally {
          !s && r.end && r.end();
        }
      }
      function h0(n, e, t, i, r) {
        const o = an(),
          s = 2 & i;
        try {
          $r(-1), s && e.length > 22 && OC(n, e, 22, !1), t(i, r);
        } finally {
          $r(o);
        }
      }
      function f0(n, e, t) {
        if (Mp(e)) {
          const r = e.directiveEnd;
          for (let o = e.directiveStart; o < r; o++) {
            const s = n.data[o];
            s.contentQueries && s.contentQueries(1, t[o], o);
          }
        }
      }
      function em(n, e, t) {
        !rD() ||
          ((function TL(n, e, t, i) {
            const r = t.directiveStart,
              o = t.directiveEnd;
            n.firstCreatePass || Dl(t, e), Gt(i, e);
            const s = t.initialInputs;
            for (let a = r; a < o; a++) {
              const l = n.data[a],
                c = hi(l);
              c && NL(e, t, l);
              const u = Cl(e, n, a, t);
              Gt(u, e),
                null !== s && RL(0, a - r, u, l, 0, s),
                c && (kn(t.index, e)[8] = u);
            }
          })(n, e, t, Gn(t, e)),
          128 == (128 & t.flags) &&
            (function xL(n, e, t) {
              const i = t.directiveStart,
                r = t.directiveEnd,
                o = t.index,
                s = (function lR() {
                  return te.lFrame.currentDirectiveIndex;
                })();
              try {
                $r(o);
                for (let a = i; a < r; a++) {
                  const l = n.data[a],
                    c = e[a];
                  Vp(a),
                    (null !== l.hostBindings ||
                      0 !== l.hostVars ||
                      null !== l.hostAttrs) &&
                      b0(l, c);
                }
              } finally {
                $r(-1), Vp(s);
              }
            })(n, e, t));
      }
      function tm(n, e, t = Gn) {
        const i = e.localNames;
        if (null !== i) {
          let r = e.index + 1;
          for (let o = 0; o < i.length; o += 2) {
            const s = i[o + 1],
              a = -1 === s ? t(e, n) : n[s];
            n[r++] = a;
          }
        }
      }
      function p0(n) {
        const e = n.tView;
        return null === e || e.incompleteFirstPass
          ? (n.tView = hd(
              1,
              null,
              n.template,
              n.decls,
              n.vars,
              n.directiveDefs,
              n.pipeDefs,
              n.viewQuery,
              n.schemas,
              n.consts
            ))
          : e;
      }
      function hd(n, e, t, i, r, o, s, a, l, c) {
        const u = 22 + i,
          d = u + r,
          h = (function bL(n, e) {
            const t = [];
            for (let i = 0; i < e; i++) t.push(i < n ? null : re);
            return t;
          })(u, d),
          f = "function" == typeof c ? c() : c;
        return (h[1] = {
          type: n,
          blueprint: h,
          template: t,
          queries: null,
          viewQuery: a,
          declTNode: e,
          data: h.slice().fill(null, u),
          bindingStartIndex: u,
          expandoStartIndex: d,
          hostBindingOpCodes: null,
          firstCreatePass: !0,
          firstUpdatePass: !0,
          staticViewQueries: !1,
          staticContentQueries: !1,
          preOrderHooks: null,
          preOrderCheckHooks: null,
          contentHooks: null,
          contentCheckHooks: null,
          viewHooks: null,
          viewCheckHooks: null,
          destroyHooks: null,
          cleanup: null,
          contentQueries: null,
          components: null,
          directiveRegistry: "function" == typeof o ? o() : o,
          pipeRegistry: "function" == typeof s ? s() : s,
          firstChild: null,
          schemas: l,
          consts: f,
          incompleteFirstPass: !1,
        });
      }
      function y0(n, e, t, i) {
        const r = M0(e);
        null === t
          ? r.push(i)
          : (r.push(t), n.firstCreatePass && I0(n).push(i, r.length - 1));
      }
      function v0(n, e, t) {
        for (let i in n)
          if (n.hasOwnProperty(i)) {
            const r = n[i];
            (t = null === t ? {} : t).hasOwnProperty(i)
              ? t[i].push(e, r)
              : (t[i] = [e, r]);
          }
        return t;
      }
      function nm(n, e, t, i) {
        let r = !1;
        if (rD()) {
          const o = (function AL(n, e, t) {
              const i = n.directiveRegistry;
              let r = null;
              if (i)
                for (let o = 0; o < i.length; o++) {
                  const s = i[o];
                  xC(t, s.selectors, !1) &&
                    (r || (r = []),
                    Gu(Dl(t, e), n, s.type),
                    hi(s) ? (D0(n, t), r.unshift(s)) : r.push(s));
                }
              return r;
            })(n, e, t),
            s = null === i ? null : { "": -1 };
          if (null !== o) {
            (r = !0), C0(t, n.data.length, o.length);
            for (let u = 0; u < o.length; u++) {
              const d = o[u];
              d.providersResolver && d.providersResolver(d);
            }
            let a = !1,
              l = !1,
              c = ea(n, e, o.length, null);
            for (let u = 0; u < o.length; u++) {
              const d = o[u];
              (t.mergedAttrs = zu(t.mergedAttrs, d.hostAttrs)),
                E0(n, t, e, c, d),
                kL(c, d, s),
                null !== d.contentQueries && (t.flags |= 8),
                (null !== d.hostBindings ||
                  null !== d.hostAttrs ||
                  0 !== d.hostVars) &&
                  (t.flags |= 128);
              const h = d.type.prototype;
              !a &&
                (h.ngOnChanges || h.ngOnInit || h.ngDoCheck) &&
                ((n.preOrderHooks || (n.preOrderHooks = [])).push(t.index),
                (a = !0)),
                !l &&
                  (h.ngOnChanges || h.ngDoCheck) &&
                  ((n.preOrderCheckHooks || (n.preOrderCheckHooks = [])).push(
                    t.index
                  ),
                  (l = !0)),
                c++;
            }
            !(function CL(n, e) {
              const i = e.directiveEnd,
                r = n.data,
                o = e.attrs,
                s = [];
              let a = null,
                l = null;
              for (let c = e.directiveStart; c < i; c++) {
                const u = r[c],
                  d = u.inputs,
                  h = null === o || TC(e) ? null : PL(d, o);
                s.push(h), (a = v0(d, c, a)), (l = v0(u.outputs, c, l));
              }
              null !== a &&
                (a.hasOwnProperty("class") && (e.flags |= 16),
                a.hasOwnProperty("style") && (e.flags |= 32)),
                (e.initialInputs = s),
                (e.inputs = a),
                (e.outputs = l);
            })(n, t);
          }
          s &&
            (function OL(n, e, t) {
              if (e) {
                const i = (n.localNames = []);
                for (let r = 0; r < e.length; r += 2) {
                  const o = t[e[r + 1]];
                  if (null == o) throw new W(-301, !1);
                  i.push(e[r], o);
                }
              }
            })(t, i, s);
        }
        return (t.mergedAttrs = zu(t.mergedAttrs, t.attrs)), r;
      }
      function _0(n, e, t, i, r, o) {
        const s = o.hostBindings;
        if (s) {
          let a = n.hostBindingOpCodes;
          null === a && (a = n.hostBindingOpCodes = []);
          const l = ~e.index;
          (function IL(n) {
            let e = n.length;
            for (; e > 0; ) {
              const t = n[--e];
              if ("number" == typeof t && t < 0) return t;
            }
            return 0;
          })(a) != l && a.push(l),
            a.push(i, r, s);
        }
      }
      function b0(n, e) {
        null !== n.hostBindings && n.hostBindings(1, e);
      }
      function D0(n, e) {
        (e.flags |= 2), (n.components || (n.components = [])).push(e.index);
      }
      function kL(n, e, t) {
        if (t) {
          if (e.exportAs)
            for (let i = 0; i < e.exportAs.length; i++) t[e.exportAs[i]] = n;
          hi(e) && (t[""] = n);
        }
      }
      function C0(n, e, t) {
        (n.flags |= 1),
          (n.directiveStart = e),
          (n.directiveEnd = e + t),
          (n.providerIndexes = e);
      }
      function E0(n, e, t, i, r) {
        n.data[i] = r;
        const o = r.factory || (r.factory = Ho(r.type)),
          s = new _l(o, hi(r), w);
        (n.blueprint[i] = s),
          (t[i] = s),
          _0(n, e, 0, i, ea(n, t, r.hostVars, re), r);
      }
      function NL(n, e, t) {
        const i = Gn(e, n),
          r = p0(t),
          o = n[10],
          s = fd(
            n,
            Bl(
              n,
              r,
              null,
              t.onPush ? 32 : 16,
              i,
              e,
              o,
              o.createRenderer(i, t),
              null,
              null,
              null
            )
          );
        n[e.index] = s;
      }
      function Vi(n, e, t, i, r, o) {
        const s = Gn(n, e);
        !(function im(n, e, t, i, r, o, s) {
          if (null == o)
            ot(n) ? n.removeAttribute(e, r, t) : e.removeAttribute(r);
          else {
            const a = null == s ? ie(o) : s(o, i || "", r);
            ot(n)
              ? n.setAttribute(e, r, a, t)
              : t
              ? e.setAttributeNS(t, r, a)
              : e.setAttribute(r, a);
          }
        })(e[11], s, o, n.value, t, i, r);
      }
      function RL(n, e, t, i, r, o) {
        const s = o[e];
        if (null !== s) {
          const a = i.setInput;
          for (let l = 0; l < s.length; ) {
            const c = s[l++],
              u = s[l++],
              d = s[l++];
            null !== a ? i.setInput(t, d, c, u) : (t[u] = d);
          }
        }
      }
      function PL(n, e) {
        let t = null,
          i = 0;
        for (; i < e.length; ) {
          const r = e[i];
          if (0 !== r)
            if (5 !== r) {
              if ("number" == typeof r) break;
              n.hasOwnProperty(r) &&
                (null === t && (t = []), t.push(r, n[r], e[i + 1])),
                (i += 2);
            } else i += 2;
          else i += 4;
        }
        return t;
      }
      function w0(n, e, t, i) {
        return new Array(n, !0, !1, e, null, 0, i, t, null, null);
      }
      function VL(n, e) {
        const t = kn(e, n);
        if (Rp(t)) {
          const i = t[1];
          48 & t[2] ? ta(i, t, i.template, t[8]) : t[5] > 0 && rm(t);
        }
      }
      function rm(n) {
        for (let i = gg(n); null !== i; i = mg(i))
          for (let r = 10; r < i.length; r++) {
            const o = i[r];
            if (512 & o[2]) {
              const s = o[1];
              ta(s, o, s.template, o[8]);
            } else o[5] > 0 && rm(o);
          }
        const t = n[1].components;
        if (null !== t)
          for (let i = 0; i < t.length; i++) {
            const r = kn(t[i], n);
            Rp(r) && r[5] > 0 && rm(r);
          }
      }
      function BL(n, e) {
        const t = kn(e, n),
          i = t[1];
        (function jL(n, e) {
          for (let t = e.length; t < n.blueprint.length; t++)
            e.push(n.blueprint[t]);
        })(i, t),
          jl(i, t, t[8]);
      }
      function fd(n, e) {
        return n[13] ? (n[14][4] = e) : (n[13] = e), (n[14] = e), e;
      }
      function om(n) {
        for (; n; ) {
          n[2] |= 32;
          const e = Ll(n);
          if (VN(n) && !e) return n;
          n = e;
        }
        return null;
      }
      function S0(n) {
        !(function sm(n) {
          for (let e = 0; e < n.components.length; e++) {
            const t = n.components[e],
              i = hg(t);
            if (null !== i) {
              const r = i[1];
              _L(r, i, r.template, t);
            }
          }
        })(n[8]);
      }
      function lm(n, e, t) {
        jp(0), e(n, t);
      }
      const UL = (() => Promise.resolve(null))();
      function M0(n) {
        return n[7] || (n[7] = []);
      }
      function I0(n) {
        return n.cleanup || (n.cleanup = []);
      }
      function x0(n, e) {
        const t = n[9],
          i = t ? t.get(Ks, null) : null;
        i && i.handleError(e);
      }
      function A0(n, e, t, i, r) {
        for (let o = 0; o < t.length; ) {
          const s = t[o++],
            a = t[o++],
            l = e[s],
            c = n.data[s];
          null !== c.setInput ? c.setInput(l, r, i, a) : (l[a] = r);
        }
      }
      function br(n, e, t) {
        const i = Pu(e, n);
        !(function uC(n, e, t) {
          ot(n) ? n.setValue(e, t) : (e.textContent = t);
        })(n[11], i, t);
      }
      function pd(n, e, t) {
        let i = t ? n.styles : null,
          r = t ? n.classes : null,
          o = 0;
        if (null !== e)
          for (let s = 0; s < e.length; s++) {
            const a = e[s];
            "number" == typeof a
              ? (o = a)
              : 1 == o
              ? (r = yp(r, a))
              : 2 == o && (i = yp(i, a + ": " + e[++s] + ";"));
          }
        t ? (n.styles = i) : (n.stylesWithoutHost = i),
          t ? (n.classes = r) : (n.classesWithoutHost = r);
      }
      function XL() {
        const n = Ct();
        Bu(M()[1], n);
      }
      function we(n) {
        let e = (function U0(n) {
            return Object.getPrototypeOf(n.prototype).constructor;
          })(n.type),
          t = !0;
        const i = [n];
        for (; e; ) {
          let r;
          if (hi(n)) r = e.ɵcmp || e.ɵdir;
          else {
            if (e.ɵcmp) throw new W(903, !1);
            r = e.ɵdir;
          }
          if (r) {
            if (t) {
              i.push(r);
              const s = n;
              (s.inputs = um(n.inputs)),
                (s.declaredInputs = um(n.declaredInputs)),
                (s.outputs = um(n.outputs));
              const a = r.hostBindings;
              a && iV(n, a);
              const l = r.viewQuery,
                c = r.contentQueries;
              if (
                (l && tV(n, l),
                c && nV(n, c),
                mp(n.inputs, r.inputs),
                mp(n.declaredInputs, r.declaredInputs),
                mp(n.outputs, r.outputs),
                hi(r) && r.data.animation)
              ) {
                const u = n.data;
                u.animation = (u.animation || []).concat(r.data.animation);
              }
            }
            const o = r.features;
            if (o)
              for (let s = 0; s < o.length; s++) {
                const a = o[s];
                a && a.ngInherit && a(n), a === we && (t = !1);
              }
          }
          e = Object.getPrototypeOf(e);
        }
        !(function eV(n) {
          let e = 0,
            t = null;
          for (let i = n.length - 1; i >= 0; i--) {
            const r = n[i];
            (r.hostVars = e += r.hostVars),
              (r.hostAttrs = zu(r.hostAttrs, (t = zu(t, r.hostAttrs))));
          }
        })(i);
      }
      function um(n) {
        return n === Os ? {} : n === Me ? [] : n;
      }
      function tV(n, e) {
        const t = n.viewQuery;
        n.viewQuery = t
          ? (i, r) => {
              e(i, r), t(i, r);
            }
          : e;
      }
      function nV(n, e) {
        const t = n.contentQueries;
        n.contentQueries = t
          ? (i, r, o) => {
              e(i, r, o), t(i, r, o);
            }
          : e;
      }
      function iV(n, e) {
        const t = n.hostBindings;
        n.hostBindings = t
          ? (i, r) => {
              e(i, r), t(i, r);
            }
          : e;
      }
      let gd = null;
      function qo() {
        if (!gd) {
          const n = Re.Symbol;
          if (n && n.iterator) gd = n.iterator;
          else {
            const e = Object.getOwnPropertyNames(Map.prototype);
            for (let t = 0; t < e.length; ++t) {
              const i = e[t];
              "entries" !== i &&
                "size" !== i &&
                Map.prototype[i] === Map.prototype.entries &&
                (gd = i);
            }
          }
        }
        return gd;
      }
      function Hl(n) {
        return (
          !!dm(n) && (Array.isArray(n) || (!(n instanceof Map) && qo() in n))
        );
      }
      function dm(n) {
        return null !== n && ("function" == typeof n || "object" == typeof n);
      }
      function Bi(n, e, t) {
        return (n[e] = t);
      }
      function qt(n, e, t) {
        return !Object.is(n[e], t) && ((n[e] = t), !0);
      }
      function Ko(n, e, t, i) {
        const r = qt(n, e, t);
        return qt(n, e + 1, i) || r;
      }
      function Ln(n, e, t, i) {
        const r = M();
        return qt(r, Ls(), e) && (be(), Vi(st(), r, n, e, t, i)), Ln;
      }
      function U(n, e, t, i, r, o, s, a) {
        const l = M(),
          c = be(),
          u = n + 22,
          d = c.firstCreatePass
            ? (function uV(n, e, t, i, r, o, s, a, l) {
                const c = e.consts,
                  u = Xs(e, n, 4, s || null, zr(c, a));
                nm(e, t, u, zr(c, l)), Bu(e, u);
                const d = (u.tViews = hd(
                  2,
                  u,
                  i,
                  r,
                  o,
                  e.directiveRegistry,
                  e.pipeRegistry,
                  null,
                  e.schemas,
                  c
                ));
                return (
                  null !== e.queries &&
                    (e.queries.template(e, u),
                    (d.queries = e.queries.embeddedTView(u))),
                  u
                );
              })(u, c, l, e, t, i, r, o, s)
            : c.data[u];
        Ri(d, !1);
        const h = l[11].createComment("");
        od(c, l, h, d),
          Gt(h, l),
          fd(l, (l[u] = w0(h, l, h, d))),
          Ru(d) && em(c, l, d),
          null != s && tm(l, d, a);
      }
      function Dr(n) {
        return Fs(
          (function oR() {
            return te.lFrame.contextLView;
          })(),
          22 + n
        );
      }
      function A(n, e, t) {
        const i = M();
        return (
          qt(i, Ls(), e) &&
            (function Fn(n, e, t, i, r, o, s, a) {
              const l = Gn(e, t);
              let u,
                c = e.inputs;
              !a && null != c && (u = c[i])
                ? (A0(n, t, u, i, r),
                  Nu(e) &&
                    (function wL(n, e) {
                      const t = kn(e, n);
                      16 & t[2] || (t[2] |= 32);
                    })(t, e.index))
                : 3 & e.type &&
                  ((i = (function EL(n) {
                    return "class" === n
                      ? "className"
                      : "for" === n
                      ? "htmlFor"
                      : "formaction" === n
                      ? "formAction"
                      : "innerHtml" === n
                      ? "innerHTML"
                      : "readonly" === n
                      ? "readOnly"
                      : "tabindex" === n
                      ? "tabIndex"
                      : n;
                  })(i)),
                  (r = null != s ? s(r, e.value || "", i) : r),
                  ot(o)
                    ? o.setProperty(l, i, r)
                    : zp(i) ||
                      (l.setProperty ? l.setProperty(i, r) : (l[i] = r)));
            })(be(), st(), i, n, e, i[11], t, !1),
          A
        );
      }
      function hm(n, e, t, i, r) {
        const s = r ? "class" : "style";
        A0(n, t, e.inputs[s], s, i);
      }
      function H(n, e, t, i) {
        const r = M(),
          o = be(),
          s = 22 + n,
          a = r[11],
          l = (r[s] = vg(
            a,
            e,
            (function mR() {
              return te.lFrame.currentNamespace;
            })()
          )),
          c = o.firstCreatePass
            ? (function hV(n, e, t, i, r, o, s) {
                const a = e.consts,
                  c = Xs(e, n, 2, r, zr(a, o));
                return (
                  nm(e, t, c, zr(a, s)),
                  null !== c.attrs && pd(c, c.attrs, !1),
                  null !== c.mergedAttrs && pd(c, c.mergedAttrs, !0),
                  null !== e.queries && e.queries.elementStart(e, c),
                  c
                );
              })(s, o, r, 0, e, t, i)
            : o.data[s];
        Ri(c, !0);
        const u = c.mergedAttrs;
        null !== u && Uu(a, l, u);
        const d = c.classes;
        null !== d && wg(a, l, d);
        const h = c.styles;
        return (
          null !== h && SC(a, l, h),
          64 != (64 & c.flags) && od(o, r, l, c),
          0 ===
            (function eR() {
              return te.lFrame.elementDepthCount;
            })() && Gt(l, r),
          (function tR() {
            te.lFrame.elementDepthCount++;
          })(),
          Ru(c) && (em(o, r, c), f0(o, c, r)),
          null !== i && tm(r, c),
          H
        );
      }
      function z() {
        let n = Ct();
        Fp() ? Lp() : ((n = n.parent), Ri(n, !1));
        const e = n;
        !(function nR() {
          te.lFrame.elementDepthCount--;
        })();
        const t = be();
        return (
          t.firstCreatePass && (Bu(t, n), Mp(n) && t.queries.elementEnd(n)),
          null != e.classesWithoutHost &&
            (function DR(n) {
              return 0 != (16 & n.flags);
            })(e) &&
            hm(t, e, M(), e.classesWithoutHost, !0),
          null != e.stylesWithoutHost &&
            (function CR(n) {
              return 0 != (32 & n.flags);
            })(e) &&
            hm(t, e, M(), e.stylesWithoutHost, !1),
          z
        );
      }
      function Lt(n, e, t, i) {
        return H(n, e, t, i), z(), Lt;
      }
      function ji(n, e, t) {
        const i = M(),
          r = be(),
          o = n + 22,
          s = r.firstCreatePass
            ? (function fV(n, e, t, i, r) {
                const o = e.consts,
                  s = zr(o, i),
                  a = Xs(e, n, 8, "ng-container", s);
                return (
                  null !== s && pd(a, s, !0),
                  nm(e, t, a, zr(o, r)),
                  null !== e.queries && e.queries.elementStart(e, a),
                  a
                );
              })(o, r, i, e, t)
            : r.data[o];
        Ri(s, !0);
        const a = (i[o] = i[11].createComment(""));
        return (
          od(r, i, a, s),
          Gt(a, i),
          Ru(s) && (em(r, i, s), f0(r, s, i)),
          null != t && tm(i, s),
          ji
        );
      }
      function Hi() {
        let n = Ct();
        const e = be();
        return (
          Fp() ? Lp() : ((n = n.parent), Ri(n, !1)),
          e.firstCreatePass && (Bu(e, n), Mp(n) && e.queries.elementEnd(n)),
          Hi
        );
      }
      function Kt(n, e, t) {
        return ji(n, e, t), Hi(), Kt;
      }
      function Ui() {
        return M();
      }
      function zl(n) {
        return !!n && "function" == typeof n.then;
      }
      const fm = function J0(n) {
        return !!n && "function" == typeof n.subscribe;
      };
      function Oe(n, e, t, i) {
        const r = M(),
          o = be(),
          s = Ct();
        return (
          (function eE(n, e, t, i, r, o, s, a) {
            const l = Ru(i),
              u = n.firstCreatePass && I0(n),
              d = e[8],
              h = M0(e);
            let f = !0;
            if (3 & i.type || a) {
              const m = Gn(i, e),
                v = a ? a(m) : m,
                _ = h.length,
                b = a ? (y) => a(ft(y[i.index])) : i.index;
              if (ot(t)) {
                let y = null;
                if (
                  (!a &&
                    l &&
                    (y = (function pV(n, e, t, i) {
                      const r = n.cleanup;
                      if (null != r)
                        for (let o = 0; o < r.length - 1; o += 2) {
                          const s = r[o];
                          if (s === t && r[o + 1] === i) {
                            const a = e[7],
                              l = r[o + 2];
                            return a.length > l ? a[l] : null;
                          }
                          "string" == typeof s && (o += 2);
                        }
                      return null;
                    })(n, e, r, i.index)),
                  null !== y)
                )
                  ((y.__ngLastListenerFn__ || y).__ngNextListenerFn__ = o),
                    (y.__ngLastListenerFn__ = o),
                    (f = !1);
                else {
                  o = pm(i, e, d, o, !1);
                  const D = t.listen(v, r, o);
                  h.push(o, D), u && u.push(r, b, _, _ + 1);
                }
              } else
                (o = pm(i, e, d, o, !0)),
                  v.addEventListener(r, o, s),
                  h.push(o),
                  u && u.push(r, b, _, s);
            } else o = pm(i, e, d, o, !1);
            const p = i.outputs;
            let g;
            if (f && null !== p && (g = p[r])) {
              const m = g.length;
              if (m)
                for (let v = 0; v < m; v += 2) {
                  const C = e[g[v]][g[v + 1]].subscribe(o),
                    R = h.length;
                  h.push(o, C), u && u.push(r, i.index, R, -(R + 1));
                }
            }
          })(o, r, r[11], s, n, e, !!t, i),
          Oe
        );
      }
      function tE(n, e, t, i) {
        try {
          return !1 !== t(i);
        } catch (r) {
          return x0(n, r), !1;
        }
      }
      function pm(n, e, t, i, r) {
        return function o(s) {
          if (s === Function) return i;
          om(2 & n.flags ? kn(n.index, e) : e);
          let l = tE(e, 0, i, s),
            c = o.__ngNextListenerFn__;
          for (; c; ) (l = tE(e, 0, c, s) && l), (c = c.__ngNextListenerFn__);
          return r && !1 === l && (s.preventDefault(), (s.returnValue = !1)), l;
        };
      }
      function V(n = 1) {
        return (function uR(n) {
          return (te.lFrame.contextLView = (function dR(n, e) {
            for (; n > 0; ) (e = e[15]), n--;
            return e;
          })(n, te.lFrame.contextLView))[8];
        })(n);
      }
      function gV(n, e) {
        let t = null;
        const i = (function CF(n) {
          const e = n.attrs;
          if (null != e) {
            const t = e.indexOf(5);
            if (0 == (1 & t)) return e[t + 1];
          }
          return null;
        })(n);
        for (let r = 0; r < e.length; r++) {
          const o = e[r];
          if ("*" !== o) {
            if (null === i ? xC(n, o, !0) : SF(i, o)) return r;
          } else t = r;
        }
        return t;
      }
      function da(n) {
        const e = M()[16][6];
        if (!e.projection) {
          const i = (e.projection = Ml(n ? n.length : 1, null)),
            r = i.slice();
          let o = e.child;
          for (; null !== o; ) {
            const s = n ? gV(o, n) : 0;
            null !== s &&
              (r[s] ? (r[s].projectionNext = o) : (i[s] = o), (r[s] = o)),
              (o = o.next);
          }
        }
      }
      function Cr(n, e = 0, t) {
        const i = M(),
          r = be(),
          o = Xs(r, 22 + n, 16, null, t || null);
        null === o.projection && (o.projection = e),
          Lp(),
          64 != (64 & o.flags) &&
            (function gF(n, e, t) {
              wC(e[11], 0, e, t, fC(n, t, e), vC(t.parent || e[6], t, e));
            })(r, i, o);
      }
      function dE(n, e, t, i, r) {
        const o = n[t + 1],
          s = null === e;
        let a = i ? pi(o) : _r(o),
          l = !1;
        for (; 0 !== a && (!1 === l || s); ) {
          const u = n[a + 1];
          vV(n[a], e) && ((l = !0), (n[a + 1] = i ? $g(u) : Ug(u))),
            (a = i ? pi(u) : _r(u));
        }
        l && (n[t + 1] = i ? Ug(o) : $g(o));
      }
      function vV(n, e) {
        return (
          null === n ||
          null == e ||
          (Array.isArray(n) ? n[1] : n) === e ||
          (!(!Array.isArray(n) || "string" != typeof e) && Ws(n, e) >= 0)
        );
      }
      const wt = { textEnd: 0, key: 0, keyEnd: 0, value: 0, valueEnd: 0 };
      function hE(n) {
        return n.substring(wt.key, wt.keyEnd);
      }
      function fE(n, e) {
        const t = wt.textEnd;
        return t === e
          ? -1
          : ((e = wt.keyEnd =
              (function CV(n, e, t) {
                for (; e < t && n.charCodeAt(e) > 32; ) e++;
                return e;
              })(n, (wt.key = e), t)),
            ha(n, e, t));
      }
      function ha(n, e, t) {
        for (; e < t && n.charCodeAt(e) <= 32; ) e++;
        return e;
      }
      function $l(n, e) {
        return (
          (function mi(n, e, t, i) {
            const r = M(),
              o = be(),
              s = mr(2);
            o.firstUpdatePass && bE(o, n, s, i),
              e !== re &&
                qt(r, s, e) &&
                CE(
                  o,
                  o.data[an()],
                  r,
                  r[11],
                  n,
                  (r[s + 1] = (function kV(n, e) {
                    return (
                      null == n ||
                        ("string" == typeof e
                          ? (n += e)
                          : "object" == typeof n && (n = Le(Pn(n)))),
                      n
                    );
                  })(e, t)),
                  i,
                  s
                );
          })(n, e, null, !0),
          $l
        );
      }
      function yd(n) {
        !(function yi(n, e, t, i) {
          const r = be(),
            o = mr(2);
          r.firstUpdatePass && bE(r, null, o, i);
          const s = M();
          if (t !== re && qt(s, o, t)) {
            const a = r.data[an()];
            if (wE(a, i) && !_E(r, o)) {
              let l = i ? a.classesWithoutHost : a.stylesWithoutHost;
              null !== l && (t = yp(l, t || "")), hm(r, a, s, t, i);
            } else
              !(function OV(n, e, t, i, r, o, s, a) {
                r === re && (r = Me);
                let l = 0,
                  c = 0,
                  u = 0 < r.length ? r[0] : null,
                  d = 0 < o.length ? o[0] : null;
                for (; null !== u || null !== d; ) {
                  const h = l < r.length ? r[l + 1] : void 0,
                    f = c < o.length ? o[c + 1] : void 0;
                  let g,
                    p = null;
                  u === d
                    ? ((l += 2), (c += 2), h !== f && ((p = d), (g = f)))
                    : null === d || (null !== u && u < d)
                    ? ((l += 2), (p = u))
                    : ((c += 2), (p = d), (g = f)),
                    null !== p && CE(n, e, t, i, p, g, s, a),
                    (u = l < r.length ? r[l] : null),
                    (d = c < o.length ? o[c] : null);
                }
              })(
                r,
                a,
                s,
                s[11],
                s[o + 1],
                (s[o + 1] = (function AV(n, e, t) {
                  if (null == t || "" === t) return Me;
                  const i = [],
                    r = Pn(t);
                  if (Array.isArray(r))
                    for (let o = 0; o < r.length; o++) n(i, r[o], !0);
                  else if ("object" == typeof r)
                    for (const o in r) r.hasOwnProperty(o) && n(i, o, r[o]);
                  else "string" == typeof r && e(i, r);
                  return i;
                })(n, e, t)),
                i,
                o
              );
          }
        })(Rn, $i, n, !0);
      }
      function $i(n, e) {
        for (
          let t = (function bV(n) {
            return (
              (function gE(n) {
                (wt.key = 0),
                  (wt.keyEnd = 0),
                  (wt.value = 0),
                  (wt.valueEnd = 0),
                  (wt.textEnd = n.length);
              })(n),
              fE(n, ha(n, 0, wt.textEnd))
            );
          })(e);
          t >= 0;
          t = fE(e, t)
        )
          Rn(n, hE(e), !0);
      }
      function _E(n, e) {
        return e >= n.expandoStartIndex;
      }
      function bE(n, e, t, i) {
        const r = n.data;
        if (null === r[t + 1]) {
          const o = r[an()],
            s = _E(n, t);
          wE(o, i) && null === e && !s && (e = !1),
            (e = (function MV(n, e, t, i) {
              const r = (function Bp(n) {
                const e = te.lFrame.currentDirectiveIndex;
                return -1 === e ? null : n[e];
              })(n);
              let o = i ? e.residualClasses : e.residualStyles;
              if (null === r)
                0 === (i ? e.classBindings : e.styleBindings) &&
                  ((t = Wl((t = mm(null, n, e, t, i)), e.attrs, i)),
                  (o = null));
              else {
                const s = e.directiveStylingLast;
                if (-1 === s || n[s] !== r)
                  if (((t = mm(r, n, e, t, i)), null === o)) {
                    let l = (function IV(n, e, t) {
                      const i = t ? e.classBindings : e.styleBindings;
                      if (0 !== _r(i)) return n[pi(i)];
                    })(n, e, i);
                    void 0 !== l &&
                      Array.isArray(l) &&
                      ((l = mm(null, n, e, l[1], i)),
                      (l = Wl(l, e.attrs, i)),
                      (function TV(n, e, t, i) {
                        n[pi(t ? e.classBindings : e.styleBindings)] = i;
                      })(n, e, i, l));
                  } else
                    o = (function xV(n, e, t) {
                      let i;
                      const r = e.directiveEnd;
                      for (let o = 1 + e.directiveStylingLast; o < r; o++)
                        i = Wl(i, n[o].hostAttrs, t);
                      return Wl(i, e.attrs, t);
                    })(n, e, i);
              }
              return (
                void 0 !== o &&
                  (i ? (e.residualClasses = o) : (e.residualStyles = o)),
                t
              );
            })(r, o, e, i)),
            (function mV(n, e, t, i, r, o) {
              let s = o ? e.classBindings : e.styleBindings,
                a = pi(s),
                l = _r(s);
              n[i] = t;
              let u,
                c = !1;
              if (Array.isArray(t)) {
                const d = t;
                (u = d[1]), (null === u || Ws(d, u) > 0) && (c = !0);
              } else u = t;
              if (r)
                if (0 !== l) {
                  const h = pi(n[a + 1]);
                  (n[i + 1] = cd(h, a)),
                    0 !== h && (n[h + 1] = zg(n[h + 1], i)),
                    (n[a + 1] = (function sL(n, e) {
                      return (131071 & n) | (e << 17);
                    })(n[a + 1], i));
                } else
                  (n[i + 1] = cd(a, 0)),
                    0 !== a && (n[a + 1] = zg(n[a + 1], i)),
                    (a = i);
              else
                (n[i + 1] = cd(l, 0)),
                  0 === a ? (a = i) : (n[l + 1] = zg(n[l + 1], i)),
                  (l = i);
              c && (n[i + 1] = Ug(n[i + 1])),
                dE(n, u, i, !0),
                dE(n, u, i, !1),
                (function yV(n, e, t, i, r) {
                  const o = r ? n.residualClasses : n.residualStyles;
                  null != o &&
                    "string" == typeof e &&
                    Ws(o, e) >= 0 &&
                    (t[i + 1] = $g(t[i + 1]));
                })(e, u, n, i, o),
                (s = cd(a, l)),
                o ? (e.classBindings = s) : (e.styleBindings = s);
            })(r, o, e, t, s, i);
        }
      }
      function mm(n, e, t, i, r) {
        let o = null;
        const s = t.directiveEnd;
        let a = t.directiveStylingLast;
        for (
          -1 === a ? (a = t.directiveStart) : a++;
          a < s && ((o = e[a]), (i = Wl(i, o.hostAttrs, r)), o !== n);

        )
          a++;
        return null !== n && (t.directiveStylingLast = a), i;
      }
      function Wl(n, e, t) {
        const i = t ? 1 : 2;
        let r = -1;
        if (null !== e)
          for (let o = 0; o < e.length; o++) {
            const s = e[o];
            "number" == typeof s
              ? (r = s)
              : r === i &&
                (Array.isArray(n) || (n = void 0 === n ? [] : ["", n]),
                Rn(n, s, !!t || e[++o]));
          }
        return void 0 === n ? null : n;
      }
      function CE(n, e, t, i, r, o, s, a) {
        if (!(3 & e.type)) return;
        const l = n.data,
          c = l[a + 1];
        vd(
          (function n0(n) {
            return 1 == (1 & n);
          })(c)
            ? EE(l, e, t, r, _r(c), s)
            : void 0
        ) ||
          (vd(o) ||
            ((function t0(n) {
              return 2 == (2 & n);
            })(c) &&
              (o = EE(l, null, t, r, a, s))),
          (function yF(n, e, t, i, r) {
            const o = ot(n);
            if (e)
              r
                ? o
                  ? n.addClass(t, i)
                  : t.classList.add(i)
                : o
                ? n.removeClass(t, i)
                : t.classList.remove(i);
            else {
              let s = -1 === i.indexOf("-") ? void 0 : vn.DashCase;
              if (null == r)
                o ? n.removeStyle(t, i, s) : t.style.removeProperty(i);
              else {
                const a = "string" == typeof r && r.endsWith("!important");
                a && ((r = r.slice(0, -10)), (s |= vn.Important)),
                  o
                    ? n.setStyle(t, i, r, s)
                    : t.style.setProperty(i, r, a ? "important" : "");
              }
            }
          })(i, s, Pu(an(), t), r, o));
      }
      function EE(n, e, t, i, r, o) {
        const s = null === e;
        let a;
        for (; r > 0; ) {
          const l = n[r],
            c = Array.isArray(l),
            u = c ? l[1] : l,
            d = null === u;
          let h = t[r + 1];
          h === re && (h = d ? Me : void 0);
          let f = d ? Zp(h, i) : u === i ? h : void 0;
          if ((c && !vd(f) && (f = Zp(l, i)), vd(f) && ((a = f), s))) return a;
          const p = n[r + 1];
          r = s ? pi(p) : _r(p);
        }
        if (null !== e) {
          let l = o ? e.residualClasses : e.residualStyles;
          null != l && (a = Zp(l, i));
        }
        return a;
      }
      function vd(n) {
        return void 0 !== n;
      }
      function wE(n, e) {
        return 0 != (n.flags & (e ? 16 : 32));
      }
      function ze(n, e = "") {
        const t = M(),
          i = be(),
          r = n + 22,
          o = i.firstCreatePass ? Xs(i, r, 1, e, null) : i.data[r],
          s = (t[r] = (function yg(n, e) {
            return ot(n) ? n.createText(e) : n.createTextNode(e);
          })(t[11], e));
        od(i, t, s, o), Ri(o, !1);
      }
      function _n(n) {
        return Zr("", n, ""), _n;
      }
      function Zr(n, e, t) {
        const i = M(),
          r = (function ia(n, e, t, i) {
            return qt(n, Ls(), t) ? e + ie(t) + i : re;
          })(i, n, e, t);
        return r !== re && br(i, an(), r), Zr;
      }
      const pa = "en-US";
      let GE = pa;
      function _m(n, e, t, i, r) {
        if (((n = J(n)), Array.isArray(n)))
          for (let o = 0; o < n.length; o++) _m(n[o], e, t, i, r);
        else {
          const o = be(),
            s = M();
          let a = Wo(n) ? n : J(n.provide),
            l = UC(n);
          const c = Ct(),
            u = 1048575 & c.providerIndexes,
            d = c.directiveStart,
            h = c.providerIndexes >> 20;
          if (Wo(n) || !n.multi) {
            const f = new _l(l, r, w),
              p = Dm(a, e, r ? u : u + h, d);
            -1 === p
              ? (Gu(Dl(c, s), o, a),
                bm(o, n, e.length),
                e.push(a),
                c.directiveStart++,
                c.directiveEnd++,
                r && (c.providerIndexes += 1048576),
                t.push(f),
                s.push(f))
              : ((t[p] = f), (s[p] = f));
          } else {
            const f = Dm(a, e, u + h, d),
              p = Dm(a, e, u, u + h),
              g = f >= 0 && t[f],
              m = p >= 0 && t[p];
            if ((r && !m) || (!r && !g)) {
              Gu(Dl(c, s), o, a);
              const v = (function ZB(n, e, t, i, r) {
                const o = new _l(n, t, w);
                return (
                  (o.multi = []),
                  (o.index = e),
                  (o.componentProviders = 0),
                  yw(o, r, i && !t),
                  o
                );
              })(r ? YB : KB, t.length, r, i, l);
              !r && m && (t[p].providerFactory = v),
                bm(o, n, e.length, 0),
                e.push(a),
                c.directiveStart++,
                c.directiveEnd++,
                r && (c.providerIndexes += 1048576),
                t.push(v),
                s.push(v);
            } else bm(o, n, f > -1 ? f : p, yw(t[r ? p : f], l, !r && i));
            !r && i && m && t[p].componentProviders++;
          }
        }
      }
      function bm(n, e, t, i) {
        const r = Wo(e),
          o = (function FF(n) {
            return !!n.useClass;
          })(e);
        if (r || o) {
          const l = (o ? J(e.useClass) : e).prototype.ngOnDestroy;
          if (l) {
            const c = n.destroyHooks || (n.destroyHooks = []);
            if (!r && e.multi) {
              const u = c.indexOf(t);
              -1 === u ? c.push(t, [i, l]) : c[u + 1].push(i, l);
            } else c.push(t, l);
          }
        }
      }
      function yw(n, e, t) {
        return t && n.componentProviders++, n.multi.push(e) - 1;
      }
      function Dm(n, e, t, i) {
        for (let r = t; r < i; r++) if (e[r] === n) return r;
        return -1;
      }
      function KB(n, e, t, i) {
        return Cm(this.multi, []);
      }
      function YB(n, e, t, i) {
        const r = this.multi;
        let o;
        if (this.providerFactory) {
          const s = this.providerFactory.componentProviders,
            a = Cl(t, t[1], this.providerFactory.index, i);
          (o = a.slice(0, s)), Cm(r, o);
          for (let l = s; l < a.length; l++) o.push(a[l]);
        } else (o = []), Cm(r, o);
        return o;
      }
      function Cm(n, e) {
        for (let t = 0; t < n.length; t++) e.push((0, n[t])());
        return e;
      }
      function $e(n, e = []) {
        return (t) => {
          t.providersResolver = (i, r) =>
            (function qB(n, e, t) {
              const i = be();
              if (i.firstCreatePass) {
                const r = hi(n);
                _m(t, i.data, i.blueprint, r, !0),
                  _m(e, i.data, i.blueprint, r, !1);
              }
            })(i, r ? r(n) : n, e);
        };
      }
      class JB {
        resolveComponentFactory(e) {
          throw (function QB(n) {
            const e = Error(
              `No component factory found for ${Le(
                n
              )}. Did you add it to @NgModule.entryComponents?`
            );
            return (e.ngComponent = n), e;
          })(e);
        }
      }
      let Qr = (() => {
        class n {}
        return (n.NULL = new JB()), n;
      })();
      class Jr {}
      class _w {}
      class bw {}
      function ej() {
        return ma(Ct(), M());
      }
      function ma(n, e) {
        return new ut(Gn(n, e));
      }
      let ut = (() => {
        class n {
          constructor(t) {
            this.nativeElement = t;
          }
        }
        return (n.__NG_ELEMENT_ID__ = ej), n;
      })();
      function tj(n) {
        return n instanceof ut ? n.nativeElement : n;
      }
      class Dw {}
      let Wi = (() => {
          class n {}
          return (
            (n.__NG_ELEMENT_ID__ = () =>
              (function ij() {
                const n = M(),
                  t = kn(Ct().index, n);
                return (function nj(n) {
                  return n[11];
                })(yn(t) ? t : n);
              })()),
            n
          );
        })(),
        rj = (() => {
          class n {}
          return (
            (n.ɵprov = j({
              token: n,
              providedIn: "root",
              factory: () => null,
            })),
            n
          );
        })();
      class ya {
        constructor(e) {
          (this.full = e),
            (this.major = e.split(".")[0]),
            (this.minor = e.split(".")[1]),
            (this.patch = e.split(".").slice(2).join("."));
        }
      }
      const oj = new ya("14.0.4"),
        Em = {};
      function Ed(n, e, t, i, r = !1) {
        for (; null !== t; ) {
          const o = e[t.index];
          if ((null !== o && i.push(ft(o)), di(o)))
            for (let a = 10; a < o.length; a++) {
              const l = o[a],
                c = l[1].firstChild;
              null !== c && Ed(l[1], l, c, i);
            }
          const s = t.type;
          if (8 & s) Ed(n, e, t.child, i);
          else if (32 & s) {
            const a = pg(t, e);
            let l;
            for (; (l = a()); ) i.push(l);
          } else if (16 & s) {
            const a = CC(e, t);
            if (Array.isArray(a)) i.push(...a);
            else {
              const l = Ll(e[16]);
              Ed(l[1], l, a, i, !0);
            }
          }
          t = r ? t.projectionNext : t.next;
        }
        return i;
      }
      class Zl {
        constructor(e, t) {
          (this._lView = e),
            (this._cdRefInjectingView = t),
            (this._appRef = null),
            (this._attachedToViewContainer = !1);
        }
        get rootNodes() {
          const e = this._lView,
            t = e[1];
          return Ed(t, e, t.firstChild, []);
        }
        get context() {
          return this._lView[8];
        }
        set context(e) {
          this._lView[8] = e;
        }
        get destroyed() {
          return 128 == (128 & this._lView[2]);
        }
        destroy() {
          if (this._appRef) this._appRef.detachView(this);
          else if (this._attachedToViewContainer) {
            const e = this._lView[3];
            if (di(e)) {
              const t = e[8],
                i = t ? t.indexOf(this) : -1;
              i > -1 && (_g(e, i), Ku(t, i));
            }
            this._attachedToViewContainer = !1;
          }
          hC(this._lView[1], this._lView);
        }
        onDestroy(e) {
          y0(this._lView[1], this._lView, null, e);
        }
        markForCheck() {
          om(this._cdRefInjectingView || this._lView);
        }
        detach() {
          this._lView[2] &= -65;
        }
        reattach() {
          this._lView[2] |= 64;
        }
        detectChanges() {
          !(function am(n, e, t) {
            const i = e[10];
            i.begin && i.begin();
            try {
              ta(n, e, n.template, t);
            } catch (r) {
              throw (x0(e, r), r);
            } finally {
              i.end && i.end();
            }
          })(this._lView[1], this._lView, this.context);
        }
        checkNoChanges() {}
        attachToViewContainerRef() {
          if (this._appRef) throw new W(902, !1);
          this._attachedToViewContainer = !0;
        }
        detachFromAppRef() {
          (this._appRef = null),
            (function aF(n, e) {
              Vl(n, e, e[11], 2, null, null);
            })(this._lView[1], this._lView);
        }
        attachToAppRef(e) {
          if (this._attachedToViewContainer) throw new W(902, !1);
          this._appRef = e;
        }
      }
      class sj extends Zl {
        constructor(e) {
          super(e), (this._view = e);
        }
        detectChanges() {
          S0(this._view);
        }
        checkNoChanges() {}
        get context() {
          return null;
        }
      }
      class wm extends Qr {
        constructor(e) {
          super(), (this.ngModule = e);
        }
        resolveComponentFactory(e) {
          const t = Ve(e);
          return new Sm(t, this.ngModule);
        }
      }
      function Cw(n) {
        const e = [];
        for (let t in n)
          n.hasOwnProperty(t) && e.push({ propName: n[t], templateName: t });
        return e;
      }
      class lj {
        constructor(e, t) {
          (this.injector = e), (this.parentInjector = t);
        }
        get(e, t, i) {
          const r = this.injector.get(e, Em, i);
          return r !== Em || t === Em ? r : this.parentInjector.get(e, t, i);
        }
      }
      class Sm extends bw {
        constructor(e, t) {
          super(),
            (this.componentDef = e),
            (this.ngModule = t),
            (this.componentType = e.type),
            (this.selector = (function IF(n) {
              return n.map(MF).join(",");
            })(e.selectors)),
            (this.ngContentSelectors = e.ngContentSelectors
              ? e.ngContentSelectors
              : []),
            (this.isBoundToModule = !!t);
        }
        get inputs() {
          return Cw(this.componentDef.inputs);
        }
        get outputs() {
          return Cw(this.componentDef.outputs);
        }
        create(e, t, i, r) {
          let o = (r = r || this.ngModule) instanceof Go ? r : r?.injector;
          o &&
            null !== this.componentDef.getStandaloneInjector &&
            (o = this.componentDef.getStandaloneInjector(o) || o);
          const s = o ? new lj(e, o) : e,
            a = s.get(Dw, eD),
            l = s.get(rj, null),
            c = a.createRenderer(null, this.componentDef),
            u = this.componentDef.selectors[0][0] || "div",
            d = i
              ? (function m0(n, e, t) {
                  if (ot(n)) return n.selectRootElement(e, t === Ni.ShadowDom);
                  let i = "string" == typeof e ? n.querySelector(e) : e;
                  return (i.textContent = ""), i;
                })(c, i, this.componentDef.encapsulation)
              : vg(
                  a.createRenderer(null, this.componentDef),
                  u,
                  (function aj(n) {
                    const e = n.toLowerCase();
                    return "svg" === e ? "svg" : "math" === e ? "math" : null;
                  })(u)
                ),
            h = this.componentDef.onPush ? 288 : 272,
            f = (function H0(n, e) {
              return {
                components: [],
                scheduler: n || JP,
                clean: UL,
                playerHandler: e || null,
                flags: 0,
              };
            })(),
            p = hd(0, null, null, 1, 0, null, null, null, null, null),
            g = Bl(null, p, f, h, null, null, a, c, l, s, null);
          let m, v;
          Lu(g);
          try {
            const _ = (function B0(n, e, t, i, r, o) {
              const s = t[1];
              t[22] = n;
              const l = Xs(s, 22, 2, "#host", null),
                c = (l.mergedAttrs = e.hostAttrs);
              null !== c &&
                (pd(l, c, !0),
                null !== n &&
                  (Uu(r, n, c),
                  null !== l.classes && wg(r, n, l.classes),
                  null !== l.styles && SC(r, n, l.styles)));
              const u = i.createRenderer(n, e),
                d = Bl(
                  t,
                  p0(e),
                  null,
                  e.onPush ? 32 : 16,
                  t[22],
                  l,
                  i,
                  u,
                  o || null,
                  null,
                  null
                );
              return (
                s.firstCreatePass &&
                  (Gu(Dl(l, t), s, e.type), D0(s, l), C0(l, t.length, 1)),
                fd(t, d),
                (t[22] = d)
              );
            })(d, this.componentDef, g, a, c);
            if (d)
              if (i) Uu(c, d, ["ng-version", oj.full]);
              else {
                const { attrs: b, classes: y } = (function TF(n) {
                  const e = [],
                    t = [];
                  let i = 1,
                    r = 2;
                  for (; i < n.length; ) {
                    let o = n[i];
                    if ("string" == typeof o)
                      2 === r
                        ? "" !== o && e.push(o, n[++i])
                        : 8 === r && t.push(o);
                    else {
                      if (!fi(r)) break;
                      r = o;
                    }
                    i++;
                  }
                  return { attrs: e, classes: t };
                })(this.componentDef.selectors[0]);
                b && Uu(c, d, b), y && y.length > 0 && wg(c, d, y.join(" "));
              }
            if (((v = Np(p, 22)), void 0 !== t)) {
              const b = (v.projection = []);
              for (let y = 0; y < this.ngContentSelectors.length; y++) {
                const D = t[y];
                b.push(null != D ? Array.from(D) : null);
              }
            }
            (m = (function j0(n, e, t, i, r) {
              const o = t[1],
                s = (function ML(n, e, t) {
                  const i = Ct();
                  n.firstCreatePass &&
                    (t.providersResolver && t.providersResolver(t),
                    E0(n, i, e, ea(n, e, 1, null), t));
                  const r = Cl(e, n, i.directiveStart, i);
                  Gt(r, e);
                  const o = Gn(i, e);
                  return o && Gt(o, e), r;
                })(o, t, e);
              if ((i.components.push(s), (n[8] = s), null !== r))
                for (const l of r) l(s, e);
              if (e.contentQueries) {
                const l = Ct();
                e.contentQueries(1, s, l.directiveStart);
              }
              const a = Ct();
              return (
                !o.firstCreatePass ||
                  (null === e.hostBindings && null === e.hostAttrs) ||
                  ($r(a.index),
                  _0(t[1], a, 0, a.directiveStart, a.directiveEnd, e),
                  b0(e, s)),
                s
              );
            })(_, this.componentDef, g, f, [XL])),
              jl(p, g, null);
          } finally {
            Vu();
          }
          return new uj(this.componentType, m, ma(v, g), g, v);
        }
      }
      class uj extends class XB {} {
        constructor(e, t, i, r, o) {
          super(),
            (this.location = i),
            (this._rootLView = r),
            (this._tNode = o),
            (this.instance = t),
            (this.hostView = this.changeDetectorRef = new sj(r)),
            (this.componentType = e);
        }
        get injector() {
          return new js(this._tNode, this._rootLView);
        }
        destroy() {
          this.hostView.destroy();
        }
        onDestroy(e) {
          this.hostView.onDestroy(e);
        }
      }
      class Ew extends Jr {
        constructor(e, t) {
          super(),
            (this._parent = t),
            (this._bootstrapComponents = []),
            (this.injector = this),
            (this.destroyCbs = []),
            (this.componentFactoryResolver = new wm(this));
          const i = An(e);
          (this._bootstrapComponents = vr(i.bootstrap)),
            (this._r3Injector = $C(
              e,
              t,
              [
                { provide: Jr, useValue: this },
                { provide: Qr, useValue: this.componentFactoryResolver },
              ],
              Le(e),
              new Set(["environment"])
            )),
            this._r3Injector.resolveInjectorInitializers(),
            (this.instance = this.get(e));
        }
        get(e, t = pt.THROW_IF_NOT_FOUND, i = G.Default) {
          return e === pt || e === Jr || e === Tg
            ? this
            : this._r3Injector.get(e, t, i);
        }
        destroy() {
          const e = this._r3Injector;
          !e.destroyed && e.destroy(),
            this.destroyCbs.forEach((t) => t()),
            (this.destroyCbs = null);
        }
        onDestroy(e) {
          this.destroyCbs.push(e);
        }
      }
      class Mm extends _w {
        constructor(e) {
          super(), (this.moduleType = e);
        }
        create(e) {
          return new Ew(this.moduleType, e);
        }
      }
      class hj extends Jr {
        constructor(e, t, i) {
          super(),
            (this.componentFactoryResolver = new wm(this)),
            (this.instance = null);
          const r = new HC(
            [
              ...e,
              { provide: Jr, useValue: this },
              { provide: Qr, useValue: this.componentFactoryResolver },
            ],
            t || Og(),
            i,
            new Set(["environment"])
          );
          (this.injector = r), r.resolveInjectorInitializers();
        }
        destroy() {
          this.injector.destroy();
        }
        onDestroy(e) {
          this.injector.onDestroy(e);
        }
      }
      function wd(n, e = null, t = null) {
        return new hj(n, e, t).injector;
      }
      function Kn(n, e, t, i) {
        return Sw(M(), sn(), n, e, t, i);
      }
      function Im(n, e, t, i, r) {
        return (function Mw(n, e, t, i, r, o, s) {
          const a = e + t;
          return Ko(n, a, r, o)
            ? Bi(n, a + 2, s ? i.call(s, r, o) : i(r, o))
            : Ql(n, a + 2);
        })(M(), sn(), n, e, t, i, r);
      }
      function Ql(n, e) {
        const t = n[e];
        return t === re ? void 0 : t;
      }
      function Sw(n, e, t, i, r, o) {
        const s = e + t;
        return qt(n, s, r)
          ? Bi(n, s + 1, o ? i.call(o, r) : i(r))
          : Ql(n, s + 1);
      }
      function Iw(n, e, t, i, r, o, s, a) {
        const l = e + t;
        return (function md(n, e, t, i, r) {
          const o = Ko(n, e, t, i);
          return qt(n, e + 2, r) || o;
        })(n, l, r, o, s)
          ? Bi(n, l + 3, a ? i.call(a, r, o, s) : i(r, o, s))
          : Ql(n, l + 3);
      }
      function Sd(n, e) {
        const t = be();
        let i;
        const r = n + 22;
        t.firstCreatePass
          ? ((i = (function Ej(n, e) {
              if (e)
                for (let t = e.length - 1; t >= 0; t--) {
                  const i = e[t];
                  if (n === i.name) return i;
                }
            })(e, t.pipeRegistry)),
            (t.data[r] = i),
            i.onDestroy &&
              (t.destroyHooks || (t.destroyHooks = [])).push(r, i.onDestroy))
          : (i = t.data[r]);
        const o = i.factory || (i.factory = Ho(i.type)),
          s = ki(w);
        try {
          const a = $u(!1),
            l = o();
          return (
            $u(a),
            (function dV(n, e, t, i) {
              t >= n.data.length &&
                ((n.data[t] = null), (n.blueprint[t] = null)),
                (e[t] = i);
            })(t, M(), r, l),
            l
          );
        } finally {
          ki(s);
        }
      }
      function Tm(n, e, t) {
        const i = n + 22,
          r = M(),
          o = Fs(r, i);
        return Jl(r, i) ? Sw(r, sn(), e, o.transform, t, o) : o.transform(t);
      }
      function Jl(n, e) {
        return n[1].data[e].pure;
      }
      function xm(n) {
        return (e) => {
          setTimeout(n, void 0, e);
        };
      }
      const Ie = class Ij extends _e {
        constructor(e = !1) {
          super(), (this.__isAsync = e);
        }
        emit(e) {
          super.next(e);
        }
        subscribe(e, t, i) {
          let r = e,
            o = t || (() => null),
            s = i;
          if (e && "object" == typeof e) {
            const l = e;
            (r = l.next?.bind(l)),
              (o = l.error?.bind(l)),
              (s = l.complete?.bind(l));
          }
          this.__isAsync && ((o = xm(o)), r && (r = xm(r)), s && (s = xm(s)));
          const a = super.subscribe({ next: r, error: o, complete: s });
          return e instanceof Te && e.add(a), a;
        }
      };
      function Tj() {
        return this._results[qo()]();
      }
      class Xl {
        constructor(e = !1) {
          (this._emitDistinctChangesOnly = e),
            (this.dirty = !0),
            (this._results = []),
            (this._changesDetected = !1),
            (this._changes = null),
            (this.length = 0),
            (this.first = void 0),
            (this.last = void 0);
          const t = qo(),
            i = Xl.prototype;
          i[t] || (i[t] = Tj);
        }
        get changes() {
          return this._changes || (this._changes = new Ie());
        }
        get(e) {
          return this._results[e];
        }
        map(e) {
          return this._results.map(e);
        }
        filter(e) {
          return this._results.filter(e);
        }
        find(e) {
          return this._results.find(e);
        }
        reduce(e, t) {
          return this._results.reduce(e, t);
        }
        forEach(e) {
          this._results.forEach(e);
        }
        some(e) {
          return this._results.some(e);
        }
        toArray() {
          return this._results.slice();
        }
        toString() {
          return this._results.toString();
        }
        reset(e, t) {
          const i = this;
          i.dirty = !1;
          const r = Nn(e);
          (this._changesDetected = !(function NR(n, e, t) {
            if (n.length !== e.length) return !1;
            for (let i = 0; i < n.length; i++) {
              let r = n[i],
                o = e[i];
              if ((t && ((r = t(r)), (o = t(o))), o !== r)) return !1;
            }
            return !0;
          })(i._results, r, t)) &&
            ((i._results = r),
            (i.length = r.length),
            (i.last = r[this.length - 1]),
            (i.first = r[0]));
        }
        notifyOnChanges() {
          this._changes &&
            (this._changesDetected || !this._emitDistinctChangesOnly) &&
            this._changes.emit(this);
        }
        setDirty() {
          this.dirty = !0;
        }
        destroy() {
          this.changes.complete(), this.changes.unsubscribe();
        }
      }
      let Gi = (() => {
        class n {}
        return (n.__NG_ELEMENT_ID__ = Oj), n;
      })();
      const xj = Gi,
        Aj = class extends xj {
          constructor(e, t, i) {
            super(),
              (this._declarationLView = e),
              (this._declarationTContainer = t),
              (this.elementRef = i);
          }
          createEmbeddedView(e, t) {
            const i = this._declarationTContainer.tViews,
              r = Bl(
                this._declarationLView,
                i,
                e,
                16,
                null,
                i.declTNode,
                null,
                null,
                null,
                null,
                t || null
              );
            r[17] = this._declarationLView[this._declarationTContainer.index];
            const s = this._declarationLView[19];
            return (
              null !== s && (r[19] = s.createEmbeddedView(i)),
              jl(i, r, e),
              new Zl(r)
            );
          }
        };
      function Oj() {
        return Md(Ct(), M());
      }
      function Md(n, e) {
        return 4 & n.type ? new Aj(e, n, ma(n, e)) : null;
      }
      let Yn = (() => {
        class n {}
        return (n.__NG_ELEMENT_ID__ = kj), n;
      })();
      function kj() {
        return Nw(Ct(), M());
      }
      const Nj = Yn,
        Ow = class extends Nj {
          constructor(e, t, i) {
            super(),
              (this._lContainer = e),
              (this._hostTNode = t),
              (this._hostLView = i);
          }
          get element() {
            return ma(this._hostTNode, this._hostLView);
          }
          get injector() {
            return new js(this._hostTNode, this._hostLView);
          }
          get parentInjector() {
            const e = Wu(this._hostTNode, this._hostLView);
            if (yD(e)) {
              const t = Bs(e, this._hostLView),
                i = Vs(e);
              return new js(t[1].data[i + 8], t);
            }
            return new js(null, this._hostLView);
          }
          clear() {
            for (; this.length > 0; ) this.remove(this.length - 1);
          }
          get(e) {
            const t = kw(this._lContainer);
            return (null !== t && t[e]) || null;
          }
          get length() {
            return this._lContainer.length - 10;
          }
          createEmbeddedView(e, t, i) {
            let r, o;
            "number" == typeof i
              ? (r = i)
              : null != i && ((r = i.index), (o = i.injector));
            const s = e.createEmbeddedView(t || {}, o);
            return this.insert(s, r), s;
          }
          createComponent(e, t, i, r, o) {
            const s =
              e &&
              !(function Sl(n) {
                return "function" == typeof n;
              })(e);
            let a;
            if (s) a = t;
            else {
              const d = t || {};
              (a = d.index),
                (i = d.injector),
                (r = d.projectableNodes),
                (o = d.environmentInjector || d.ngModuleRef);
            }
            const l = s ? e : new Sm(Ve(e)),
              c = i || this.parentInjector;
            if (!o && null == l.ngModule) {
              const h = (s ? c : this.parentInjector).get(Go, null);
              h && (o = h);
            }
            const u = l.create(c, r, void 0, o);
            return this.insert(u.hostView, a), u;
          }
          insert(e, t) {
            const i = e._lView,
              r = i[1];
            if (
              (function XN(n) {
                return di(n[3]);
              })(i)
            ) {
              const u = this.indexOf(e);
              if (-1 !== u) this.detach(u);
              else {
                const d = i[3],
                  h = new Ow(d, d[6], d[3]);
                h.detach(h.indexOf(e));
              }
            }
            const o = this._adjustIndex(t),
              s = this._lContainer;
            !(function cF(n, e, t, i) {
              const r = 10 + i,
                o = t.length;
              i > 0 && (t[r - 1][4] = e),
                i < o - 10
                  ? ((e[4] = t[r]), TD(t, 10 + i, e))
                  : (t.push(e), (e[4] = null)),
                (e[3] = t);
              const s = e[17];
              null !== s &&
                t !== s &&
                (function uF(n, e) {
                  const t = n[9];
                  e[16] !== e[3][3][16] && (n[2] = !0),
                    null === t ? (n[9] = [e]) : t.push(e);
                })(s, e);
              const a = e[19];
              null !== a && a.insertView(n), (e[2] |= 64);
            })(r, i, s, o);
            const a = Cg(o, s),
              l = i[11],
              c = rd(l, s[7]);
            return (
              null !== c &&
                (function sF(n, e, t, i, r, o) {
                  (i[0] = r), (i[6] = e), Vl(n, i, t, 1, r, o);
                })(r, s[6], l, i, c, a),
              e.attachToViewContainerRef(),
              TD(Am(s), o, e),
              e
            );
          }
          move(e, t) {
            return this.insert(e, t);
          }
          indexOf(e) {
            const t = kw(this._lContainer);
            return null !== t ? t.indexOf(e) : -1;
          }
          remove(e) {
            const t = this._adjustIndex(e, -1),
              i = _g(this._lContainer, t);
            i && (Ku(Am(this._lContainer), t), hC(i[1], i));
          }
          detach(e) {
            const t = this._adjustIndex(e, -1),
              i = _g(this._lContainer, t);
            return i && null != Ku(Am(this._lContainer), t) ? new Zl(i) : null;
          }
          _adjustIndex(e, t = 0) {
            return e ?? this.length + t;
          }
        };
      function kw(n) {
        return n[8];
      }
      function Am(n) {
        return n[8] || (n[8] = []);
      }
      function Nw(n, e) {
        let t;
        const i = e[n.index];
        if (di(i)) t = i;
        else {
          let r;
          if (8 & n.type) r = ft(i);
          else {
            const o = e[11];
            r = o.createComment("");
            const s = Gn(n, e);
            $o(
              o,
              rd(o, s),
              r,
              (function pF(n, e) {
                return ot(n) ? n.nextSibling(e) : e.nextSibling;
              })(o, s),
              !1
            );
          }
          (e[n.index] = t = w0(i, e, r, n)), fd(e, t);
        }
        return new Ow(t, n, e);
      }
      class Om {
        constructor(e) {
          (this.queryList = e), (this.matches = null);
        }
        clone() {
          return new Om(this.queryList);
        }
        setDirty() {
          this.queryList.setDirty();
        }
      }
      class km {
        constructor(e = []) {
          this.queries = e;
        }
        createEmbeddedView(e) {
          const t = e.queries;
          if (null !== t) {
            const i =
                null !== e.contentQueries ? e.contentQueries[0] : t.length,
              r = [];
            for (let o = 0; o < i; o++) {
              const s = t.getByIndex(o);
              r.push(this.queries[s.indexInDeclarationView].clone());
            }
            return new km(r);
          }
          return null;
        }
        insertView(e) {
          this.dirtyQueriesWithMatches(e);
        }
        detachView(e) {
          this.dirtyQueriesWithMatches(e);
        }
        dirtyQueriesWithMatches(e) {
          for (let t = 0; t < this.queries.length; t++)
            null !== Vw(e, t).matches && this.queries[t].setDirty();
        }
      }
      class Rw {
        constructor(e, t, i = null) {
          (this.predicate = e), (this.flags = t), (this.read = i);
        }
      }
      class Nm {
        constructor(e = []) {
          this.queries = e;
        }
        elementStart(e, t) {
          for (let i = 0; i < this.queries.length; i++)
            this.queries[i].elementStart(e, t);
        }
        elementEnd(e) {
          for (let t = 0; t < this.queries.length; t++)
            this.queries[t].elementEnd(e);
        }
        embeddedTView(e) {
          let t = null;
          for (let i = 0; i < this.length; i++) {
            const r = null !== t ? t.length : 0,
              o = this.getByIndex(i).embeddedTView(e, r);
            o &&
              ((o.indexInDeclarationView = i),
              null !== t ? t.push(o) : (t = [o]));
          }
          return null !== t ? new Nm(t) : null;
        }
        template(e, t) {
          for (let i = 0; i < this.queries.length; i++)
            this.queries[i].template(e, t);
        }
        getByIndex(e) {
          return this.queries[e];
        }
        get length() {
          return this.queries.length;
        }
        track(e) {
          this.queries.push(e);
        }
      }
      class Rm {
        constructor(e, t = -1) {
          (this.metadata = e),
            (this.matches = null),
            (this.indexInDeclarationView = -1),
            (this.crossesNgTemplate = !1),
            (this._appliesToNextNode = !0),
            (this._declarationNodeIndex = t);
        }
        elementStart(e, t) {
          this.isApplyingToNode(t) && this.matchTNode(e, t);
        }
        elementEnd(e) {
          this._declarationNodeIndex === e.index &&
            (this._appliesToNextNode = !1);
        }
        template(e, t) {
          this.elementStart(e, t);
        }
        embeddedTView(e, t) {
          return this.isApplyingToNode(e)
            ? ((this.crossesNgTemplate = !0),
              this.addMatch(-e.index, t),
              new Rm(this.metadata))
            : null;
        }
        isApplyingToNode(e) {
          if (this._appliesToNextNode && 1 != (1 & this.metadata.flags)) {
            const t = this._declarationNodeIndex;
            let i = e.parent;
            for (; null !== i && 8 & i.type && i.index !== t; ) i = i.parent;
            return t === (null !== i ? i.index : -1);
          }
          return this._appliesToNextNode;
        }
        matchTNode(e, t) {
          const i = this.metadata.predicate;
          if (Array.isArray(i))
            for (let r = 0; r < i.length; r++) {
              const o = i[r];
              this.matchTNodeWithReadOption(e, t, Fj(t, o)),
                this.matchTNodeWithReadOption(e, t, qu(t, e, o, !1, !1));
            }
          else
            i === Gi
              ? 4 & t.type && this.matchTNodeWithReadOption(e, t, -1)
              : this.matchTNodeWithReadOption(e, t, qu(t, e, i, !1, !1));
        }
        matchTNodeWithReadOption(e, t, i) {
          if (null !== i) {
            const r = this.metadata.read;
            if (null !== r)
              if (r === ut || r === Yn || (r === Gi && 4 & t.type))
                this.addMatch(t.index, -2);
              else {
                const o = qu(t, e, r, !1, !1);
                null !== o && this.addMatch(t.index, o);
              }
            else this.addMatch(t.index, i);
          }
        }
        addMatch(e, t) {
          null === this.matches
            ? (this.matches = [e, t])
            : this.matches.push(e, t);
        }
      }
      function Fj(n, e) {
        const t = n.localNames;
        if (null !== t)
          for (let i = 0; i < t.length; i += 2) if (t[i] === e) return t[i + 1];
        return null;
      }
      function Vj(n, e, t, i) {
        return -1 === t
          ? (function Lj(n, e) {
              return 11 & n.type ? ma(n, e) : 4 & n.type ? Md(n, e) : null;
            })(e, n)
          : -2 === t
          ? (function Bj(n, e, t) {
              return t === ut
                ? ma(e, n)
                : t === Gi
                ? Md(e, n)
                : t === Yn
                ? Nw(e, n)
                : void 0;
            })(n, e, i)
          : Cl(n, n[1], t, e);
      }
      function Pw(n, e, t, i) {
        const r = e[19].queries[i];
        if (null === r.matches) {
          const o = n.data,
            s = t.matches,
            a = [];
          for (let l = 0; l < s.length; l += 2) {
            const c = s[l];
            a.push(c < 0 ? null : Vj(e, o[c], s[l + 1], t.metadata.read));
          }
          r.matches = a;
        }
        return r.matches;
      }
      function Pm(n, e, t, i) {
        const r = n.queries.getByIndex(t),
          o = r.matches;
        if (null !== o) {
          const s = Pw(n, e, r, t);
          for (let a = 0; a < o.length; a += 2) {
            const l = o[a];
            if (l > 0) i.push(s[a / 2]);
            else {
              const c = o[a + 1],
                u = e[-l];
              for (let d = 10; d < u.length; d++) {
                const h = u[d];
                h[17] === h[3] && Pm(h[1], h, c, i);
              }
              if (null !== u[9]) {
                const d = u[9];
                for (let h = 0; h < d.length; h++) {
                  const f = d[h];
                  Pm(f[1], f, c, i);
                }
              }
            }
          }
        }
        return i;
      }
      function bn(n) {
        const e = M(),
          t = be(),
          i = lD();
        jp(i + 1);
        const r = Vw(t, i);
        if (n.dirty && tD(e) === (2 == (2 & r.metadata.flags))) {
          if (null === r.matches) n.reset([]);
          else {
            const o = r.crossesNgTemplate ? Pm(t, e, i, []) : Pw(t, e, r, i);
            n.reset(o, tj), n.notifyOnChanges();
          }
          return !0;
        }
        return !1;
      }
      function ec(n, e, t) {
        const i = be();
        i.firstCreatePass &&
          (Lw(i, new Rw(n, e, t), -1),
          2 == (2 & e) && (i.staticViewQueries = !0)),
          Fw(i, M(), e);
      }
      function qi(n, e, t, i) {
        const r = be();
        if (r.firstCreatePass) {
          const o = Ct();
          Lw(r, new Rw(e, t, i), o.index),
            (function Hj(n, e) {
              const t = n.contentQueries || (n.contentQueries = []);
              e !== (t.length ? t[t.length - 1] : -1) &&
                t.push(n.queries.length - 1, e);
            })(r, n),
            2 == (2 & t) && (r.staticContentQueries = !0);
        }
        Fw(r, M(), t);
      }
      function Dn() {
        return (function jj(n, e) {
          return n[19].queries[e].queryList;
        })(M(), lD());
      }
      function Fw(n, e, t) {
        const i = new Xl(4 == (4 & t));
        y0(n, e, i, i.destroy),
          null === e[19] && (e[19] = new km()),
          e[19].queries.push(new Om(i));
      }
      function Lw(n, e, t) {
        null === n.queries && (n.queries = new Nm()),
          n.queries.track(new Rm(e, t));
      }
      function Vw(n, e) {
        return n.queries.getByIndex(e);
      }
      function Xr(n, e) {
        return Md(n, e);
      }
      function Td(...n) {}
      const xd = new F("Application Initializer");
      let Ad = (() => {
        class n {
          constructor(t) {
            (this.appInits = t),
              (this.resolve = Td),
              (this.reject = Td),
              (this.initialized = !1),
              (this.done = !1),
              (this.donePromise = new Promise((i, r) => {
                (this.resolve = i), (this.reject = r);
              }));
          }
          runInitializers() {
            if (this.initialized) return;
            const t = [],
              i = () => {
                (this.done = !0), this.resolve();
              };
            if (this.appInits)
              for (let r = 0; r < this.appInits.length; r++) {
                const o = this.appInits[r]();
                if (zl(o)) t.push(o);
                else if (fm(o)) {
                  const s = new Promise((a, l) => {
                    o.subscribe({ complete: a, error: l });
                  });
                  t.push(s);
                }
              }
            Promise.all(t)
              .then(() => {
                i();
              })
              .catch((r) => {
                this.reject(r);
              }),
              0 === t.length && i(),
              (this.initialized = !0);
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(T(xd, 8));
          }),
          (n.ɵprov = j({ token: n, factory: n.ɵfac, providedIn: "root" })),
          n
        );
      })();
      const nc = new F("AppId", {
        providedIn: "root",
        factory: function iS() {
          return `${jm()}${jm()}${jm()}`;
        },
      });
      function jm() {
        return String.fromCharCode(97 + Math.floor(25 * Math.random()));
      }
      const rS = new F("Platform Initializer"),
        Od = new F("Platform ID", {
          providedIn: "platform",
          factory: () => "unknown",
        }),
        oS = new F("appBootstrapListener");
      let l2 = (() => {
        class n {
          log(t) {
            console.log(t);
          }
          warn(t) {
            console.warn(t);
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)();
          }),
          (n.ɵprov = j({ token: n, factory: n.ɵfac, providedIn: "platform" })),
          n
        );
      })();
      const Er = new F("LocaleId", {
        providedIn: "root",
        factory: () =>
          Uo(Er, G.Optional | G.SkipSelf) ||
          (function c2() {
            return (typeof $localize < "u" && $localize.locale) || pa;
          })(),
      });
      class d2 {
        constructor(e, t) {
          (this.ngModuleFactory = e), (this.componentFactories = t);
        }
      }
      let Hm = (() => {
        class n {
          compileModuleSync(t) {
            return new Mm(t);
          }
          compileModuleAsync(t) {
            return Promise.resolve(this.compileModuleSync(t));
          }
          compileModuleAndAllComponentsSync(t) {
            const i = this.compileModuleSync(t),
              o = vr(An(t).declarations).reduce((s, a) => {
                const l = Ve(a);
                return l && s.push(new Sm(l)), s;
              }, []);
            return new d2(i, o);
          }
          compileModuleAndAllComponentsAsync(t) {
            return Promise.resolve(this.compileModuleAndAllComponentsSync(t));
          }
          clearCache() {}
          clearCacheFor(t) {}
          getModuleId(t) {}
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)();
          }),
          (n.ɵprov = j({ token: n, factory: n.ɵfac, providedIn: "root" })),
          n
        );
      })();
      const f2 = (() => Promise.resolve(0))();
      function Um(n) {
        typeof Zone > "u"
          ? f2.then(() => {
              n && n.apply(null, null);
            })
          : Zone.current.scheduleMicroTask("scheduleMicrotask", n);
      }
      class Ke {
        constructor({
          enableLongStackTrace: e = !1,
          shouldCoalesceEventChangeDetection: t = !1,
          shouldCoalesceRunChangeDetection: i = !1,
        }) {
          if (
            ((this.hasPendingMacrotasks = !1),
            (this.hasPendingMicrotasks = !1),
            (this.isStable = !0),
            (this.onUnstable = new Ie(!1)),
            (this.onMicrotaskEmpty = new Ie(!1)),
            (this.onStable = new Ie(!1)),
            (this.onError = new Ie(!1)),
            typeof Zone > "u")
          )
            throw new W(908, !1);
          Zone.assertZonePatched();
          const r = this;
          (r._nesting = 0),
            (r._outer = r._inner = Zone.current),
            Zone.TaskTrackingZoneSpec &&
              (r._inner = r._inner.fork(new Zone.TaskTrackingZoneSpec())),
            e &&
              Zone.longStackTraceZoneSpec &&
              (r._inner = r._inner.fork(Zone.longStackTraceZoneSpec)),
            (r.shouldCoalesceEventChangeDetection = !i && t),
            (r.shouldCoalesceRunChangeDetection = i),
            (r.lastRequestAnimationFrameId = -1),
            (r.nativeRequestAnimationFrame = (function p2() {
              let n = Re.requestAnimationFrame,
                e = Re.cancelAnimationFrame;
              if (typeof Zone < "u" && n && e) {
                const t = n[Zone.__symbol__("OriginalDelegate")];
                t && (n = t);
                const i = e[Zone.__symbol__("OriginalDelegate")];
                i && (e = i);
              }
              return {
                nativeRequestAnimationFrame: n,
                nativeCancelAnimationFrame: e,
              };
            })().nativeRequestAnimationFrame),
            (function y2(n) {
              const e = () => {
                !(function m2(n) {
                  n.isCheckStableRunning ||
                    -1 !== n.lastRequestAnimationFrameId ||
                    ((n.lastRequestAnimationFrameId =
                      n.nativeRequestAnimationFrame.call(Re, () => {
                        n.fakeTopEventTask ||
                          (n.fakeTopEventTask = Zone.root.scheduleEventTask(
                            "fakeTopEventTask",
                            () => {
                              (n.lastRequestAnimationFrameId = -1),
                                $m(n),
                                (n.isCheckStableRunning = !0),
                                zm(n),
                                (n.isCheckStableRunning = !1);
                            },
                            void 0,
                            () => {},
                            () => {}
                          )),
                          n.fakeTopEventTask.invoke();
                      })),
                    $m(n));
                })(n);
              };
              n._inner = n._inner.fork({
                name: "angular",
                properties: { isAngularZone: !0 },
                onInvokeTask: (t, i, r, o, s, a) => {
                  try {
                    return sS(n), t.invokeTask(r, o, s, a);
                  } finally {
                    ((n.shouldCoalesceEventChangeDetection &&
                      "eventTask" === o.type) ||
                      n.shouldCoalesceRunChangeDetection) &&
                      e(),
                      aS(n);
                  }
                },
                onInvoke: (t, i, r, o, s, a, l) => {
                  try {
                    return sS(n), t.invoke(r, o, s, a, l);
                  } finally {
                    n.shouldCoalesceRunChangeDetection && e(), aS(n);
                  }
                },
                onHasTask: (t, i, r, o) => {
                  t.hasTask(r, o),
                    i === r &&
                      ("microTask" == o.change
                        ? ((n._hasPendingMicrotasks = o.microTask),
                          $m(n),
                          zm(n))
                        : "macroTask" == o.change &&
                          (n.hasPendingMacrotasks = o.macroTask));
                },
                onHandleError: (t, i, r, o) => (
                  t.handleError(r, o),
                  n.runOutsideAngular(() => n.onError.emit(o)),
                  !1
                ),
              });
            })(r);
        }
        static isInAngularZone() {
          return typeof Zone < "u" && !0 === Zone.current.get("isAngularZone");
        }
        static assertInAngularZone() {
          if (!Ke.isInAngularZone()) throw new W(909, !1);
        }
        static assertNotInAngularZone() {
          if (Ke.isInAngularZone()) throw new W(909, !1);
        }
        run(e, t, i) {
          return this._inner.run(e, t, i);
        }
        runTask(e, t, i, r) {
          const o = this._inner,
            s = o.scheduleEventTask("NgZoneEvent: " + r, e, g2, Td, Td);
          try {
            return o.runTask(s, t, i);
          } finally {
            o.cancelTask(s);
          }
        }
        runGuarded(e, t, i) {
          return this._inner.runGuarded(e, t, i);
        }
        runOutsideAngular(e) {
          return this._outer.run(e);
        }
      }
      const g2 = {};
      function zm(n) {
        if (0 == n._nesting && !n.hasPendingMicrotasks && !n.isStable)
          try {
            n._nesting++, n.onMicrotaskEmpty.emit(null);
          } finally {
            if ((n._nesting--, !n.hasPendingMicrotasks))
              try {
                n.runOutsideAngular(() => n.onStable.emit(null));
              } finally {
                n.isStable = !0;
              }
          }
      }
      function $m(n) {
        n.hasPendingMicrotasks = !!(
          n._hasPendingMicrotasks ||
          ((n.shouldCoalesceEventChangeDetection ||
            n.shouldCoalesceRunChangeDetection) &&
            -1 !== n.lastRequestAnimationFrameId)
        );
      }
      function sS(n) {
        n._nesting++,
          n.isStable && ((n.isStable = !1), n.onUnstable.emit(null));
      }
      function aS(n) {
        n._nesting--, zm(n);
      }
      class v2 {
        constructor() {
          (this.hasPendingMicrotasks = !1),
            (this.hasPendingMacrotasks = !1),
            (this.isStable = !0),
            (this.onUnstable = new Ie()),
            (this.onMicrotaskEmpty = new Ie()),
            (this.onStable = new Ie()),
            (this.onError = new Ie());
        }
        run(e, t, i) {
          return e.apply(t, i);
        }
        runGuarded(e, t, i) {
          return e.apply(t, i);
        }
        runOutsideAngular(e) {
          return e();
        }
        runTask(e, t, i, r) {
          return e.apply(t, i);
        }
      }
      const lS = new F(""),
        kd = new F("");
      let qm,
        Wm = (() => {
          class n {
            constructor(t, i, r) {
              (this._ngZone = t),
                (this.registry = i),
                (this._pendingCount = 0),
                (this._isZoneStable = !0),
                (this._didWork = !1),
                (this._callbacks = []),
                (this.taskTrackingZone = null),
                qm ||
                  ((function _2(n) {
                    qm = n;
                  })(r),
                  r.addToWindow(i)),
                this._watchAngularEvents(),
                t.run(() => {
                  this.taskTrackingZone =
                    typeof Zone > "u"
                      ? null
                      : Zone.current.get("TaskTrackingZone");
                });
            }
            _watchAngularEvents() {
              this._ngZone.onUnstable.subscribe({
                next: () => {
                  (this._didWork = !0), (this._isZoneStable = !1);
                },
              }),
                this._ngZone.runOutsideAngular(() => {
                  this._ngZone.onStable.subscribe({
                    next: () => {
                      Ke.assertNotInAngularZone(),
                        Um(() => {
                          (this._isZoneStable = !0),
                            this._runCallbacksIfReady();
                        });
                    },
                  });
                });
            }
            increasePendingRequestCount() {
              return (
                (this._pendingCount += 1),
                (this._didWork = !0),
                this._pendingCount
              );
            }
            decreasePendingRequestCount() {
              if (((this._pendingCount -= 1), this._pendingCount < 0))
                throw new Error("pending async requests below zero");
              return this._runCallbacksIfReady(), this._pendingCount;
            }
            isStable() {
              return (
                this._isZoneStable &&
                0 === this._pendingCount &&
                !this._ngZone.hasPendingMacrotasks
              );
            }
            _runCallbacksIfReady() {
              if (this.isStable())
                Um(() => {
                  for (; 0 !== this._callbacks.length; ) {
                    let t = this._callbacks.pop();
                    clearTimeout(t.timeoutId), t.doneCb(this._didWork);
                  }
                  this._didWork = !1;
                });
              else {
                let t = this.getPendingTasks();
                (this._callbacks = this._callbacks.filter(
                  (i) =>
                    !i.updateCb ||
                    !i.updateCb(t) ||
                    (clearTimeout(i.timeoutId), !1)
                )),
                  (this._didWork = !0);
              }
            }
            getPendingTasks() {
              return this.taskTrackingZone
                ? this.taskTrackingZone.macroTasks.map((t) => ({
                    source: t.source,
                    creationLocation: t.creationLocation,
                    data: t.data,
                  }))
                : [];
            }
            addCallback(t, i, r) {
              let o = -1;
              i &&
                i > 0 &&
                (o = setTimeout(() => {
                  (this._callbacks = this._callbacks.filter(
                    (s) => s.timeoutId !== o
                  )),
                    t(this._didWork, this.getPendingTasks());
                }, i)),
                this._callbacks.push({ doneCb: t, timeoutId: o, updateCb: r });
            }
            whenStable(t, i, r) {
              if (r && !this.taskTrackingZone)
                throw new Error(
                  'Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?'
                );
              this.addCallback(t, i, r), this._runCallbacksIfReady();
            }
            getPendingRequestCount() {
              return this._pendingCount;
            }
            registerApplication(t) {
              this.registry.registerApplication(t, this);
            }
            unregisterApplication(t) {
              this.registry.unregisterApplication(t);
            }
            findProviders(t, i, r) {
              return [];
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(T(Ke), T(Gm), T(kd));
            }),
            (n.ɵprov = j({ token: n, factory: n.ɵfac })),
            n
          );
        })(),
        Gm = (() => {
          class n {
            constructor() {
              this._applications = new Map();
            }
            registerApplication(t, i) {
              this._applications.set(t, i);
            }
            unregisterApplication(t) {
              this._applications.delete(t);
            }
            unregisterAllApplications() {
              this._applications.clear();
            }
            getTestability(t) {
              return this._applications.get(t) || null;
            }
            getAllTestabilities() {
              return Array.from(this._applications.values());
            }
            getAllRootElements() {
              return Array.from(this._applications.keys());
            }
            findTestabilityInTree(t, i = !0) {
              return qm?.findTestabilityInTree(this, t, i) ?? null;
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵprov = j({
              token: n,
              factory: n.ɵfac,
              providedIn: "platform",
            })),
            n
          );
        })(),
        eo = null;
      const cS = new F("AllowMultipleToken"),
        Km = new F("PlatformDestroyListeners");
      class uS {
        constructor(e, t) {
          (this.name = e), (this.token = t);
        }
      }
      function hS(n, e, t = []) {
        const i = `Platform: ${e}`,
          r = new F(i);
        return (o = []) => {
          let s = Ym();
          if (!s || s.injector.get(cS, !1)) {
            const a = [...t, ...o, { provide: r, useValue: !0 }];
            n
              ? n(a)
              : (function C2(n) {
                  if (eo && !eo.get(cS, !1)) throw new W(400, !1);
                  eo = n;
                  const e = n.get(pS);
                  (function dS(n) {
                    const e = n.get(rS, null);
                    e && e.forEach((t) => t());
                  })(n);
                })(
                  (function fS(n = [], e) {
                    return pt.create({
                      name: e,
                      providers: [
                        { provide: xg, useValue: "platform" },
                        { provide: Km, useValue: new Set([() => (eo = null)]) },
                        ...n,
                      ],
                    });
                  })(a, i)
                );
          }
          return (function w2(n) {
            const e = Ym();
            if (!e) throw new W(401, !1);
            return e;
          })();
        };
      }
      function Ym() {
        return eo?.get(pS) ?? null;
      }
      let pS = (() => {
        class n {
          constructor(t) {
            (this._injector = t),
              (this._modules = []),
              (this._destroyListeners = []),
              (this._destroyed = !1);
          }
          bootstrapModuleFactory(t, i) {
            const r = (function S2(n, e) {
                let t;
                return (
                  (t =
                    "noop" === n
                      ? new v2()
                      : ("zone.js" === n ? void 0 : n) || new Ke(e)),
                  t
                );
              })(
                i?.ngZone,
                (function gS(n) {
                  return {
                    enableLongStackTrace: !1,
                    shouldCoalesceEventChangeDetection:
                      !(!n || !n.ngZoneEventCoalescing) || !1,
                    shouldCoalesceRunChangeDetection:
                      !(!n || !n.ngZoneRunCoalescing) || !1,
                  };
                })(i)
              ),
              o = [{ provide: Ke, useValue: r }];
            return r.run(() => {
              const s = pt.create({
                  providers: o,
                  parent: this.injector,
                  name: t.moduleType.name,
                }),
                a = t.create(s),
                l = a.injector.get(Ks, null);
              if (!l) throw new W(402, !1);
              return (
                r.runOutsideAngular(() => {
                  const c = r.onError.subscribe({
                    next: (u) => {
                      l.handleError(u);
                    },
                  });
                  a.onDestroy(() => {
                    Nd(this._modules, a), c.unsubscribe();
                  });
                }),
                (function mS(n, e, t) {
                  try {
                    const i = t();
                    return zl(i)
                      ? i.catch((r) => {
                          throw (
                            (e.runOutsideAngular(() => n.handleError(r)), r)
                          );
                        })
                      : i;
                  } catch (i) {
                    throw (e.runOutsideAngular(() => n.handleError(i)), i);
                  }
                })(l, r, () => {
                  const c = a.injector.get(Ad);
                  return (
                    c.runInitializers(),
                    c.donePromise.then(
                      () => (
                        (function qE(n) {
                          xn(n, "Expected localeId to be defined"),
                            "string" == typeof n &&
                              (GE = n.toLowerCase().replace(/_/g, "-"));
                        })(a.injector.get(Er, pa) || pa),
                        this._moduleDoBootstrap(a),
                        a
                      )
                    )
                  );
                })
              );
            });
          }
          bootstrapModule(t, i = []) {
            const r = yS({}, i);
            return (function b2(n, e, t) {
              const i = new Mm(t);
              return Promise.resolve(i);
            })(0, 0, t).then((o) => this.bootstrapModuleFactory(o, r));
          }
          _moduleDoBootstrap(t) {
            const i = t.injector.get(Da);
            if (t._bootstrapComponents.length > 0)
              t._bootstrapComponents.forEach((r) => i.bootstrap(r));
            else {
              if (!t.instance.ngDoBootstrap) throw new W(403, !1);
              t.instance.ngDoBootstrap(i);
            }
            this._modules.push(t);
          }
          onDestroy(t) {
            this._destroyListeners.push(t);
          }
          get injector() {
            return this._injector;
          }
          destroy() {
            if (this._destroyed) throw new W(404, !1);
            this._modules.slice().forEach((i) => i.destroy()),
              this._destroyListeners.forEach((i) => i());
            const t = this._injector.get(Km, null);
            t && (t.forEach((i) => i()), t.clear()), (this._destroyed = !0);
          }
          get destroyed() {
            return this._destroyed;
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(T(pt));
          }),
          (n.ɵprov = j({ token: n, factory: n.ɵfac, providedIn: "platform" })),
          n
        );
      })();
      function yS(n, e) {
        return Array.isArray(e) ? e.reduce(yS, n) : { ...n, ...e };
      }
      let Da = (() => {
        class n {
          constructor(t, i, r) {
            (this._zone = t),
              (this._injector = i),
              (this._exceptionHandler = r),
              (this._bootstrapListeners = []),
              (this._views = []),
              (this._runningTick = !1),
              (this._stable = !0),
              (this._destroyed = !1),
              (this._destroyListeners = []),
              (this.componentTypes = []),
              (this.components = []),
              (this._onMicrotaskEmptySubscription =
                this._zone.onMicrotaskEmpty.subscribe({
                  next: () => {
                    this._zone.run(() => {
                      this.tick();
                    });
                  },
                }));
            const o = new je((a) => {
                (this._stable =
                  this._zone.isStable &&
                  !this._zone.hasPendingMacrotasks &&
                  !this._zone.hasPendingMicrotasks),
                  this._zone.runOutsideAngular(() => {
                    a.next(this._stable), a.complete();
                  });
              }),
              s = new je((a) => {
                let l;
                this._zone.runOutsideAngular(() => {
                  l = this._zone.onStable.subscribe(() => {
                    Ke.assertNotInAngularZone(),
                      Um(() => {
                        !this._stable &&
                          !this._zone.hasPendingMacrotasks &&
                          !this._zone.hasPendingMicrotasks &&
                          ((this._stable = !0), a.next(!0));
                      });
                  });
                });
                const c = this._zone.onUnstable.subscribe(() => {
                  Ke.assertInAngularZone(),
                    this._stable &&
                      ((this._stable = !1),
                      this._zone.runOutsideAngular(() => {
                        a.next(!1);
                      }));
                });
                return () => {
                  l.unsubscribe(), c.unsubscribe();
                };
              });
            this.isStable = pp(
              o,
              s.pipe(
                (function bN() {
                  return (n) =>
                    Su()(
                      (function yN(n, e) {
                        return function (i) {
                          let r;
                          if (
                            ((r =
                              "function" == typeof n
                                ? n
                                : function () {
                                    return n;
                                  }),
                            "function" == typeof e)
                          )
                            return i.lift(new vN(r, e));
                          const o = Object.create(i, pN);
                          return (o.source = i), (o.subjectFactory = r), o;
                        };
                      })(_N)(n)
                    );
                })()
              )
            );
          }
          get destroyed() {
            return this._destroyed;
          }
          get injector() {
            return this._injector;
          }
          bootstrap(t, i) {
            const r = t instanceof bw;
            if (!this._injector.get(Ad).done)
              throw (
                (!r &&
                  (function _a(n) {
                    const e = Ve(n) || rn(n) || on(n);
                    return null !== e && e.standalone;
                  })(t),
                new W(405, false))
              );
            let s;
            (s = r ? t : this._injector.get(Qr).resolveComponentFactory(t)),
              this.componentTypes.push(s.componentType);
            const a = (function D2(n) {
                return n.isBoundToModule;
              })(s)
                ? void 0
                : this._injector.get(Jr),
              c = s.create(pt.NULL, [], i || s.selector, a),
              u = c.location.nativeElement,
              d = c.injector.get(lS, null);
            return (
              d?.registerApplication(u),
              c.onDestroy(() => {
                this.detachView(c.hostView),
                  Nd(this.components, c),
                  d?.unregisterApplication(u);
              }),
              this._loadComponent(c),
              c
            );
          }
          tick() {
            if (this._runningTick) throw new W(101, !1);
            try {
              this._runningTick = !0;
              for (let t of this._views) t.detectChanges();
            } catch (t) {
              this._zone.runOutsideAngular(() =>
                this._exceptionHandler.handleError(t)
              );
            } finally {
              this._runningTick = !1;
            }
          }
          attachView(t) {
            const i = t;
            this._views.push(i), i.attachToAppRef(this);
          }
          detachView(t) {
            const i = t;
            Nd(this._views, i), i.detachFromAppRef();
          }
          _loadComponent(t) {
            this.attachView(t.hostView),
              this.tick(),
              this.components.push(t),
              this._injector
                .get(oS, [])
                .concat(this._bootstrapListeners)
                .forEach((r) => r(t));
          }
          ngOnDestroy() {
            if (!this._destroyed)
              try {
                this._destroyListeners.forEach((t) => t()),
                  this._views.slice().forEach((t) => t.destroy()),
                  this._onMicrotaskEmptySubscription.unsubscribe();
              } finally {
                (this._destroyed = !0),
                  (this._views = []),
                  (this._bootstrapListeners = []),
                  (this._destroyListeners = []);
              }
          }
          onDestroy(t) {
            return (
              this._destroyListeners.push(t),
              () => Nd(this._destroyListeners, t)
            );
          }
          destroy() {
            if (this._destroyed) throw new W(406, !1);
            const t = this._injector;
            t.destroy && !t.destroyed && t.destroy();
          }
          get viewCount() {
            return this._views.length;
          }
          warnIfDestroyed() {}
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(T(Ke), T(pt), T(Ks));
          }),
          (n.ɵprov = j({ token: n, factory: n.ɵfac, providedIn: "root" })),
          n
        );
      })();
      function Nd(n, e) {
        const t = n.indexOf(e);
        t > -1 && n.splice(t, 1);
      }
      let _S = !0,
        Zo = (() => {
          class n {}
          return (n.__NG_ELEMENT_ID__ = T2), n;
        })();
      function T2(n) {
        return (function x2(n, e, t) {
          if (Nu(n) && !t) {
            const i = kn(n.index, e);
            return new Zl(i, i);
          }
          return 47 & n.type ? new Zl(e[16], e) : null;
        })(Ct(), M(), 16 == (16 & n));
      }
      class wS {
        constructor() {}
        supports(e) {
          return Hl(e);
        }
        create(e) {
          return new P2(e);
        }
      }
      const R2 = (n, e) => e;
      class P2 {
        constructor(e) {
          (this.length = 0),
            (this._linkedRecords = null),
            (this._unlinkedRecords = null),
            (this._previousItHead = null),
            (this._itHead = null),
            (this._itTail = null),
            (this._additionsHead = null),
            (this._additionsTail = null),
            (this._movesHead = null),
            (this._movesTail = null),
            (this._removalsHead = null),
            (this._removalsTail = null),
            (this._identityChangesHead = null),
            (this._identityChangesTail = null),
            (this._trackByFn = e || R2);
        }
        forEachItem(e) {
          let t;
          for (t = this._itHead; null !== t; t = t._next) e(t);
        }
        forEachOperation(e) {
          let t = this._itHead,
            i = this._removalsHead,
            r = 0,
            o = null;
          for (; t || i; ) {
            const s = !i || (t && t.currentIndex < MS(i, r, o)) ? t : i,
              a = MS(s, r, o),
              l = s.currentIndex;
            if (s === i) r--, (i = i._nextRemoved);
            else if (((t = t._next), null == s.previousIndex)) r++;
            else {
              o || (o = []);
              const c = a - r,
                u = l - r;
              if (c != u) {
                for (let h = 0; h < c; h++) {
                  const f = h < o.length ? o[h] : (o[h] = 0),
                    p = f + h;
                  u <= p && p < c && (o[h] = f + 1);
                }
                o[s.previousIndex] = u - c;
              }
            }
            a !== l && e(s, a, l);
          }
        }
        forEachPreviousItem(e) {
          let t;
          for (t = this._previousItHead; null !== t; t = t._nextPrevious) e(t);
        }
        forEachAddedItem(e) {
          let t;
          for (t = this._additionsHead; null !== t; t = t._nextAdded) e(t);
        }
        forEachMovedItem(e) {
          let t;
          for (t = this._movesHead; null !== t; t = t._nextMoved) e(t);
        }
        forEachRemovedItem(e) {
          let t;
          for (t = this._removalsHead; null !== t; t = t._nextRemoved) e(t);
        }
        forEachIdentityChange(e) {
          let t;
          for (
            t = this._identityChangesHead;
            null !== t;
            t = t._nextIdentityChange
          )
            e(t);
        }
        diff(e) {
          if ((null == e && (e = []), !Hl(e))) throw new W(900, !1);
          return this.check(e) ? this : null;
        }
        onDestroy() {}
        check(e) {
          this._reset();
          let r,
            o,
            s,
            t = this._itHead,
            i = !1;
          if (Array.isArray(e)) {
            this.length = e.length;
            for (let a = 0; a < this.length; a++)
              (o = e[a]),
                (s = this._trackByFn(a, o)),
                null !== t && Object.is(t.trackById, s)
                  ? (i && (t = this._verifyReinsertion(t, o, s, a)),
                    Object.is(t.item, o) || this._addIdentityChange(t, o))
                  : ((t = this._mismatch(t, o, s, a)), (i = !0)),
                (t = t._next);
          } else
            (r = 0),
              (function lV(n, e) {
                if (Array.isArray(n))
                  for (let t = 0; t < n.length; t++) e(n[t]);
                else {
                  const t = n[qo()]();
                  let i;
                  for (; !(i = t.next()).done; ) e(i.value);
                }
              })(e, (a) => {
                (s = this._trackByFn(r, a)),
                  null !== t && Object.is(t.trackById, s)
                    ? (i && (t = this._verifyReinsertion(t, a, s, r)),
                      Object.is(t.item, a) || this._addIdentityChange(t, a))
                    : ((t = this._mismatch(t, a, s, r)), (i = !0)),
                  (t = t._next),
                  r++;
              }),
              (this.length = r);
          return this._truncate(t), (this.collection = e), this.isDirty;
        }
        get isDirty() {
          return (
            null !== this._additionsHead ||
            null !== this._movesHead ||
            null !== this._removalsHead ||
            null !== this._identityChangesHead
          );
        }
        _reset() {
          if (this.isDirty) {
            let e;
            for (
              e = this._previousItHead = this._itHead;
              null !== e;
              e = e._next
            )
              e._nextPrevious = e._next;
            for (e = this._additionsHead; null !== e; e = e._nextAdded)
              e.previousIndex = e.currentIndex;
            for (
              this._additionsHead = this._additionsTail = null,
                e = this._movesHead;
              null !== e;
              e = e._nextMoved
            )
              e.previousIndex = e.currentIndex;
            (this._movesHead = this._movesTail = null),
              (this._removalsHead = this._removalsTail = null),
              (this._identityChangesHead = this._identityChangesTail = null);
          }
        }
        _mismatch(e, t, i, r) {
          let o;
          return (
            null === e ? (o = this._itTail) : ((o = e._prev), this._remove(e)),
            null !==
            (e =
              null === this._unlinkedRecords
                ? null
                : this._unlinkedRecords.get(i, null))
              ? (Object.is(e.item, t) || this._addIdentityChange(e, t),
                this._reinsertAfter(e, o, r))
              : null !==
                (e =
                  null === this._linkedRecords
                    ? null
                    : this._linkedRecords.get(i, r))
              ? (Object.is(e.item, t) || this._addIdentityChange(e, t),
                this._moveAfter(e, o, r))
              : (e = this._addAfter(new F2(t, i), o, r)),
            e
          );
        }
        _verifyReinsertion(e, t, i, r) {
          let o =
            null === this._unlinkedRecords
              ? null
              : this._unlinkedRecords.get(i, null);
          return (
            null !== o
              ? (e = this._reinsertAfter(o, e._prev, r))
              : e.currentIndex != r &&
                ((e.currentIndex = r), this._addToMoves(e, r)),
            e
          );
        }
        _truncate(e) {
          for (; null !== e; ) {
            const t = e._next;
            this._addToRemovals(this._unlink(e)), (e = t);
          }
          null !== this._unlinkedRecords && this._unlinkedRecords.clear(),
            null !== this._additionsTail &&
              (this._additionsTail._nextAdded = null),
            null !== this._movesTail && (this._movesTail._nextMoved = null),
            null !== this._itTail && (this._itTail._next = null),
            null !== this._removalsTail &&
              (this._removalsTail._nextRemoved = null),
            null !== this._identityChangesTail &&
              (this._identityChangesTail._nextIdentityChange = null);
        }
        _reinsertAfter(e, t, i) {
          null !== this._unlinkedRecords && this._unlinkedRecords.remove(e);
          const r = e._prevRemoved,
            o = e._nextRemoved;
          return (
            null === r ? (this._removalsHead = o) : (r._nextRemoved = o),
            null === o ? (this._removalsTail = r) : (o._prevRemoved = r),
            this._insertAfter(e, t, i),
            this._addToMoves(e, i),
            e
          );
        }
        _moveAfter(e, t, i) {
          return (
            this._unlink(e),
            this._insertAfter(e, t, i),
            this._addToMoves(e, i),
            e
          );
        }
        _addAfter(e, t, i) {
          return (
            this._insertAfter(e, t, i),
            (this._additionsTail =
              null === this._additionsTail
                ? (this._additionsHead = e)
                : (this._additionsTail._nextAdded = e)),
            e
          );
        }
        _insertAfter(e, t, i) {
          const r = null === t ? this._itHead : t._next;
          return (
            (e._next = r),
            (e._prev = t),
            null === r ? (this._itTail = e) : (r._prev = e),
            null === t ? (this._itHead = e) : (t._next = e),
            null === this._linkedRecords && (this._linkedRecords = new SS()),
            this._linkedRecords.put(e),
            (e.currentIndex = i),
            e
          );
        }
        _remove(e) {
          return this._addToRemovals(this._unlink(e));
        }
        _unlink(e) {
          null !== this._linkedRecords && this._linkedRecords.remove(e);
          const t = e._prev,
            i = e._next;
          return (
            null === t ? (this._itHead = i) : (t._next = i),
            null === i ? (this._itTail = t) : (i._prev = t),
            e
          );
        }
        _addToMoves(e, t) {
          return (
            e.previousIndex === t ||
              (this._movesTail =
                null === this._movesTail
                  ? (this._movesHead = e)
                  : (this._movesTail._nextMoved = e)),
            e
          );
        }
        _addToRemovals(e) {
          return (
            null === this._unlinkedRecords &&
              (this._unlinkedRecords = new SS()),
            this._unlinkedRecords.put(e),
            (e.currentIndex = null),
            (e._nextRemoved = null),
            null === this._removalsTail
              ? ((this._removalsTail = this._removalsHead = e),
                (e._prevRemoved = null))
              : ((e._prevRemoved = this._removalsTail),
                (this._removalsTail = this._removalsTail._nextRemoved = e)),
            e
          );
        }
        _addIdentityChange(e, t) {
          return (
            (e.item = t),
            (this._identityChangesTail =
              null === this._identityChangesTail
                ? (this._identityChangesHead = e)
                : (this._identityChangesTail._nextIdentityChange = e)),
            e
          );
        }
      }
      class F2 {
        constructor(e, t) {
          (this.item = e),
            (this.trackById = t),
            (this.currentIndex = null),
            (this.previousIndex = null),
            (this._nextPrevious = null),
            (this._prev = null),
            (this._next = null),
            (this._prevDup = null),
            (this._nextDup = null),
            (this._prevRemoved = null),
            (this._nextRemoved = null),
            (this._nextAdded = null),
            (this._nextMoved = null),
            (this._nextIdentityChange = null);
        }
      }
      class L2 {
        constructor() {
          (this._head = null), (this._tail = null);
        }
        add(e) {
          null === this._head
            ? ((this._head = this._tail = e),
              (e._nextDup = null),
              (e._prevDup = null))
            : ((this._tail._nextDup = e),
              (e._prevDup = this._tail),
              (e._nextDup = null),
              (this._tail = e));
        }
        get(e, t) {
          let i;
          for (i = this._head; null !== i; i = i._nextDup)
            if (
              (null === t || t <= i.currentIndex) &&
              Object.is(i.trackById, e)
            )
              return i;
          return null;
        }
        remove(e) {
          const t = e._prevDup,
            i = e._nextDup;
          return (
            null === t ? (this._head = i) : (t._nextDup = i),
            null === i ? (this._tail = t) : (i._prevDup = t),
            null === this._head
          );
        }
      }
      class SS {
        constructor() {
          this.map = new Map();
        }
        put(e) {
          const t = e.trackById;
          let i = this.map.get(t);
          i || ((i = new L2()), this.map.set(t, i)), i.add(e);
        }
        get(e, t) {
          const r = this.map.get(e);
          return r ? r.get(e, t) : null;
        }
        remove(e) {
          const t = e.trackById;
          return this.map.get(t).remove(e) && this.map.delete(t), e;
        }
        get isEmpty() {
          return 0 === this.map.size;
        }
        clear() {
          this.map.clear();
        }
      }
      function MS(n, e, t) {
        const i = n.previousIndex;
        if (null === i) return i;
        let r = 0;
        return t && i < t.length && (r = t[i]), i + e + r;
      }
      class IS {
        constructor() {}
        supports(e) {
          return e instanceof Map || dm(e);
        }
        create() {
          return new V2();
        }
      }
      class V2 {
        constructor() {
          (this._records = new Map()),
            (this._mapHead = null),
            (this._appendAfter = null),
            (this._previousMapHead = null),
            (this._changesHead = null),
            (this._changesTail = null),
            (this._additionsHead = null),
            (this._additionsTail = null),
            (this._removalsHead = null),
            (this._removalsTail = null);
        }
        get isDirty() {
          return (
            null !== this._additionsHead ||
            null !== this._changesHead ||
            null !== this._removalsHead
          );
        }
        forEachItem(e) {
          let t;
          for (t = this._mapHead; null !== t; t = t._next) e(t);
        }
        forEachPreviousItem(e) {
          let t;
          for (t = this._previousMapHead; null !== t; t = t._nextPrevious) e(t);
        }
        forEachChangedItem(e) {
          let t;
          for (t = this._changesHead; null !== t; t = t._nextChanged) e(t);
        }
        forEachAddedItem(e) {
          let t;
          for (t = this._additionsHead; null !== t; t = t._nextAdded) e(t);
        }
        forEachRemovedItem(e) {
          let t;
          for (t = this._removalsHead; null !== t; t = t._nextRemoved) e(t);
        }
        diff(e) {
          if (e) {
            if (!(e instanceof Map || dm(e))) throw new W(900, !1);
          } else e = new Map();
          return this.check(e) ? this : null;
        }
        onDestroy() {}
        check(e) {
          this._reset();
          let t = this._mapHead;
          if (
            ((this._appendAfter = null),
            this._forEach(e, (i, r) => {
              if (t && t.key === r)
                this._maybeAddToChanges(t, i),
                  (this._appendAfter = t),
                  (t = t._next);
              else {
                const o = this._getOrCreateRecordForKey(r, i);
                t = this._insertBeforeOrAppend(t, o);
              }
            }),
            t)
          ) {
            t._prev && (t._prev._next = null), (this._removalsHead = t);
            for (let i = t; null !== i; i = i._nextRemoved)
              i === this._mapHead && (this._mapHead = null),
                this._records.delete(i.key),
                (i._nextRemoved = i._next),
                (i.previousValue = i.currentValue),
                (i.currentValue = null),
                (i._prev = null),
                (i._next = null);
          }
          return (
            this._changesTail && (this._changesTail._nextChanged = null),
            this._additionsTail && (this._additionsTail._nextAdded = null),
            this.isDirty
          );
        }
        _insertBeforeOrAppend(e, t) {
          if (e) {
            const i = e._prev;
            return (
              (t._next = e),
              (t._prev = i),
              (e._prev = t),
              i && (i._next = t),
              e === this._mapHead && (this._mapHead = t),
              (this._appendAfter = e),
              e
            );
          }
          return (
            this._appendAfter
              ? ((this._appendAfter._next = t), (t._prev = this._appendAfter))
              : (this._mapHead = t),
            (this._appendAfter = t),
            null
          );
        }
        _getOrCreateRecordForKey(e, t) {
          if (this._records.has(e)) {
            const r = this._records.get(e);
            this._maybeAddToChanges(r, t);
            const o = r._prev,
              s = r._next;
            return (
              o && (o._next = s),
              s && (s._prev = o),
              (r._next = null),
              (r._prev = null),
              r
            );
          }
          const i = new B2(e);
          return (
            this._records.set(e, i),
            (i.currentValue = t),
            this._addToAdditions(i),
            i
          );
        }
        _reset() {
          if (this.isDirty) {
            let e;
            for (
              this._previousMapHead = this._mapHead, e = this._previousMapHead;
              null !== e;
              e = e._next
            )
              e._nextPrevious = e._next;
            for (e = this._changesHead; null !== e; e = e._nextChanged)
              e.previousValue = e.currentValue;
            for (e = this._additionsHead; null != e; e = e._nextAdded)
              e.previousValue = e.currentValue;
            (this._changesHead = this._changesTail = null),
              (this._additionsHead = this._additionsTail = null),
              (this._removalsHead = null);
          }
        }
        _maybeAddToChanges(e, t) {
          Object.is(t, e.currentValue) ||
            ((e.previousValue = e.currentValue),
            (e.currentValue = t),
            this._addToChanges(e));
        }
        _addToAdditions(e) {
          null === this._additionsHead
            ? (this._additionsHead = this._additionsTail = e)
            : ((this._additionsTail._nextAdded = e), (this._additionsTail = e));
        }
        _addToChanges(e) {
          null === this._changesHead
            ? (this._changesHead = this._changesTail = e)
            : ((this._changesTail._nextChanged = e), (this._changesTail = e));
        }
        _forEach(e, t) {
          e instanceof Map
            ? e.forEach(t)
            : Object.keys(e).forEach((i) => t(e[i], i));
        }
      }
      class B2 {
        constructor(e) {
          (this.key = e),
            (this.previousValue = null),
            (this.currentValue = null),
            (this._nextPrevious = null),
            (this._next = null),
            (this._prev = null),
            (this._nextAdded = null),
            (this._nextRemoved = null),
            (this._nextChanged = null);
        }
      }
      function TS() {
        return new Fd([new wS()]);
      }
      let Fd = (() => {
        class n {
          constructor(t) {
            this.factories = t;
          }
          static create(t, i) {
            if (null != i) {
              const r = i.factories.slice();
              t = t.concat(r);
            }
            return new n(t);
          }
          static extend(t) {
            return {
              provide: n,
              useFactory: (i) => n.create(t, i || TS()),
              deps: [[n, new Al(), new Gr()]],
            };
          }
          find(t) {
            const i = this.factories.find((r) => r.supports(t));
            if (null != i) return i;
            throw new W(901, !1);
          }
        }
        return (n.ɵprov = j({ token: n, providedIn: "root", factory: TS })), n;
      })();
      function xS() {
        return new ic([new IS()]);
      }
      let ic = (() => {
        class n {
          constructor(t) {
            this.factories = t;
          }
          static create(t, i) {
            if (i) {
              const r = i.factories.slice();
              t = t.concat(r);
            }
            return new n(t);
          }
          static extend(t) {
            return {
              provide: n,
              useFactory: (i) => n.create(t, i || xS()),
              deps: [[n, new Al(), new Gr()]],
            };
          }
          find(t) {
            const i = this.factories.find((r) => r.supports(t));
            if (i) return i;
            throw new W(901, !1);
          }
        }
        return (n.ɵprov = j({ token: n, providedIn: "root", factory: xS })), n;
      })();
      const U2 = hS(null, "core", []);
      let z2 = (() => {
        class n {
          constructor(t) {}
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(T(Da));
          }),
          (n.ɵmod = rt({ type: n })),
          (n.ɵinj = Xe({})),
          n
        );
      })();
      let Ld = null;
      function Ki() {
        return Ld;
      }
      const gt = new F("DocumentToken");
      let Vd = (() => {
        class n {
          historyGo(t) {
            throw new Error("Not implemented");
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)();
          }),
          (n.ɵprov = j({
            token: n,
            factory: function () {
              return (function q2() {
                return T(AS);
              })();
            },
            providedIn: "platform",
          })),
          n
        );
      })();
      const K2 = new F("Location Initialized");
      let AS = (() => {
        class n extends Vd {
          constructor(t) {
            super(), (this._doc = t), this._init();
          }
          _init() {
            (this.location = window.location), (this._history = window.history);
          }
          getBaseHrefFromDOM() {
            return Ki().getBaseHref(this._doc);
          }
          onPopState(t) {
            const i = Ki().getGlobalEventTarget(this._doc, "window");
            return (
              i.addEventListener("popstate", t, !1),
              () => i.removeEventListener("popstate", t)
            );
          }
          onHashChange(t) {
            const i = Ki().getGlobalEventTarget(this._doc, "window");
            return (
              i.addEventListener("hashchange", t, !1),
              () => i.removeEventListener("hashchange", t)
            );
          }
          get href() {
            return this.location.href;
          }
          get protocol() {
            return this.location.protocol;
          }
          get hostname() {
            return this.location.hostname;
          }
          get port() {
            return this.location.port;
          }
          get pathname() {
            return this.location.pathname;
          }
          get search() {
            return this.location.search;
          }
          get hash() {
            return this.location.hash;
          }
          set pathname(t) {
            this.location.pathname = t;
          }
          pushState(t, i, r) {
            OS() ? this._history.pushState(t, i, r) : (this.location.hash = r);
          }
          replaceState(t, i, r) {
            OS()
              ? this._history.replaceState(t, i, r)
              : (this.location.hash = r);
          }
          forward() {
            this._history.forward();
          }
          back() {
            this._history.back();
          }
          historyGo(t = 0) {
            this._history.go(t);
          }
          getState() {
            return this._history.state;
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(T(gt));
          }),
          (n.ɵprov = j({
            token: n,
            factory: function () {
              return (function Y2() {
                return new AS(T(gt));
              })();
            },
            providedIn: "platform",
          })),
          n
        );
      })();
      function OS() {
        return !!window.history.pushState;
      }
      function ey(n, e) {
        if (0 == n.length) return e;
        if (0 == e.length) return n;
        let t = 0;
        return (
          n.endsWith("/") && t++,
          e.startsWith("/") && t++,
          2 == t ? n + e.substring(1) : 1 == t ? n + e : n + "/" + e
        );
      }
      function kS(n) {
        const e = n.match(/#|\?|$/),
          t = (e && e.index) || n.length;
        return n.slice(0, t - ("/" === n[t - 1] ? 1 : 0)) + n.slice(t);
      }
      function Mr(n) {
        return n && "?" !== n[0] ? "?" + n : n;
      }
      let Jo = (() => {
        class n {
          historyGo(t) {
            throw new Error("Not implemented");
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)();
          }),
          (n.ɵprov = j({
            token: n,
            factory: function () {
              return (function Z2() {
                const n = T(gt).location;
                return new RS(T(Vd), (n && n.origin) || "");
              })();
            },
            providedIn: "root",
          })),
          n
        );
      })();
      const NS = new F("appBaseHref");
      let RS = (() => {
          class n extends Jo {
            constructor(t, i) {
              if (
                (super(),
                (this._platformLocation = t),
                (this._removeListenerFns = []),
                null == i && (i = this._platformLocation.getBaseHrefFromDOM()),
                null == i)
              )
                throw new Error(
                  "No base href set. Please provide a value for the APP_BASE_HREF token or add a base element to the document."
                );
              this._baseHref = i;
            }
            ngOnDestroy() {
              for (; this._removeListenerFns.length; )
                this._removeListenerFns.pop()();
            }
            onPopState(t) {
              this._removeListenerFns.push(
                this._platformLocation.onPopState(t),
                this._platformLocation.onHashChange(t)
              );
            }
            getBaseHref() {
              return this._baseHref;
            }
            prepareExternalUrl(t) {
              return ey(this._baseHref, t);
            }
            path(t = !1) {
              const i =
                  this._platformLocation.pathname +
                  Mr(this._platformLocation.search),
                r = this._platformLocation.hash;
              return r && t ? `${i}${r}` : i;
            }
            pushState(t, i, r, o) {
              const s = this.prepareExternalUrl(r + Mr(o));
              this._platformLocation.pushState(t, i, s);
            }
            replaceState(t, i, r, o) {
              const s = this.prepareExternalUrl(r + Mr(o));
              this._platformLocation.replaceState(t, i, s);
            }
            forward() {
              this._platformLocation.forward();
            }
            back() {
              this._platformLocation.back();
            }
            getState() {
              return this._platformLocation.getState();
            }
            historyGo(t = 0) {
              this._platformLocation.historyGo?.(t);
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(T(Vd), T(NS, 8));
            }),
            (n.ɵprov = j({ token: n, factory: n.ɵfac })),
            n
          );
        })(),
        Q2 = (() => {
          class n extends Jo {
            constructor(t, i) {
              super(),
                (this._platformLocation = t),
                (this._baseHref = ""),
                (this._removeListenerFns = []),
                null != i && (this._baseHref = i);
            }
            ngOnDestroy() {
              for (; this._removeListenerFns.length; )
                this._removeListenerFns.pop()();
            }
            onPopState(t) {
              this._removeListenerFns.push(
                this._platformLocation.onPopState(t),
                this._platformLocation.onHashChange(t)
              );
            }
            getBaseHref() {
              return this._baseHref;
            }
            path(t = !1) {
              let i = this._platformLocation.hash;
              return null == i && (i = "#"), i.length > 0 ? i.substring(1) : i;
            }
            prepareExternalUrl(t) {
              const i = ey(this._baseHref, t);
              return i.length > 0 ? "#" + i : i;
            }
            pushState(t, i, r, o) {
              let s = this.prepareExternalUrl(r + Mr(o));
              0 == s.length && (s = this._platformLocation.pathname),
                this._platformLocation.pushState(t, i, s);
            }
            replaceState(t, i, r, o) {
              let s = this.prepareExternalUrl(r + Mr(o));
              0 == s.length && (s = this._platformLocation.pathname),
                this._platformLocation.replaceState(t, i, s);
            }
            forward() {
              this._platformLocation.forward();
            }
            back() {
              this._platformLocation.back();
            }
            getState() {
              return this._platformLocation.getState();
            }
            historyGo(t = 0) {
              this._platformLocation.historyGo?.(t);
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(T(Vd), T(NS, 8));
            }),
            (n.ɵprov = j({ token: n, factory: n.ɵfac })),
            n
          );
        })(),
        ty = (() => {
          class n {
            constructor(t) {
              (this._subject = new Ie()),
                (this._urlChangeListeners = []),
                (this._urlChangeSubscription = null),
                (this._locationStrategy = t);
              const i = this._locationStrategy.getBaseHref();
              (this._baseHref = kS(PS(i))),
                this._locationStrategy.onPopState((r) => {
                  this._subject.emit({
                    url: this.path(!0),
                    pop: !0,
                    state: r.state,
                    type: r.type,
                  });
                });
            }
            ngOnDestroy() {
              this._urlChangeSubscription?.unsubscribe(),
                (this._urlChangeListeners = []);
            }
            path(t = !1) {
              return this.normalize(this._locationStrategy.path(t));
            }
            getState() {
              return this._locationStrategy.getState();
            }
            isCurrentPathEqualTo(t, i = "") {
              return this.path() == this.normalize(t + Mr(i));
            }
            normalize(t) {
              return n.stripTrailingSlash(
                (function X2(n, e) {
                  return n && e.startsWith(n) ? e.substring(n.length) : e;
                })(this._baseHref, PS(t))
              );
            }
            prepareExternalUrl(t) {
              return (
                t && "/" !== t[0] && (t = "/" + t),
                this._locationStrategy.prepareExternalUrl(t)
              );
            }
            go(t, i = "", r = null) {
              this._locationStrategy.pushState(r, "", t, i),
                this._notifyUrlChangeListeners(
                  this.prepareExternalUrl(t + Mr(i)),
                  r
                );
            }
            replaceState(t, i = "", r = null) {
              this._locationStrategy.replaceState(r, "", t, i),
                this._notifyUrlChangeListeners(
                  this.prepareExternalUrl(t + Mr(i)),
                  r
                );
            }
            forward() {
              this._locationStrategy.forward();
            }
            back() {
              this._locationStrategy.back();
            }
            historyGo(t = 0) {
              this._locationStrategy.historyGo?.(t);
            }
            onUrlChange(t) {
              return (
                this._urlChangeListeners.push(t),
                this._urlChangeSubscription ||
                  (this._urlChangeSubscription = this.subscribe((i) => {
                    this._notifyUrlChangeListeners(i.url, i.state);
                  })),
                () => {
                  const i = this._urlChangeListeners.indexOf(t);
                  this._urlChangeListeners.splice(i, 1),
                    0 === this._urlChangeListeners.length &&
                      (this._urlChangeSubscription?.unsubscribe(),
                      (this._urlChangeSubscription = null));
                }
              );
            }
            _notifyUrlChangeListeners(t = "", i) {
              this._urlChangeListeners.forEach((r) => r(t, i));
            }
            subscribe(t, i, r) {
              return this._subject.subscribe({
                next: t,
                error: i,
                complete: r,
              });
            }
          }
          return (
            (n.normalizeQueryParams = Mr),
            (n.joinWithSlash = ey),
            (n.stripTrailingSlash = kS),
            (n.ɵfac = function (t) {
              return new (t || n)(T(Jo));
            }),
            (n.ɵprov = j({
              token: n,
              factory: function () {
                return (function J2() {
                  return new ty(T(Jo));
                })();
              },
              providedIn: "root",
            })),
            n
          );
        })();
      function PS(n) {
        return n.replace(/\/index.html$/, "");
      }
      function $S(n, e) {
        e = encodeURIComponent(e);
        for (const t of n.split(";")) {
          const i = t.indexOf("="),
            [r, o] = -1 == i ? [t, ""] : [t.slice(0, i), t.slice(i + 1)];
          if (r.trim() === e) return decodeURIComponent(o);
        }
        return null;
      }
      let sc = (() => {
        class n {
          constructor(t, i, r, o) {
            (this._iterableDiffers = t),
              (this._keyValueDiffers = i),
              (this._ngEl = r),
              (this._renderer = o),
              (this._iterableDiffer = null),
              (this._keyValueDiffer = null),
              (this._initialClasses = []),
              (this._rawClass = null);
          }
          set klass(t) {
            this._removeClasses(this._initialClasses),
              (this._initialClasses =
                "string" == typeof t ? t.split(/\s+/) : []),
              this._applyClasses(this._initialClasses),
              this._applyClasses(this._rawClass);
          }
          set ngClass(t) {
            this._removeClasses(this._rawClass),
              this._applyClasses(this._initialClasses),
              (this._iterableDiffer = null),
              (this._keyValueDiffer = null),
              (this._rawClass = "string" == typeof t ? t.split(/\s+/) : t),
              this._rawClass &&
                (Hl(this._rawClass)
                  ? (this._iterableDiffer = this._iterableDiffers
                      .find(this._rawClass)
                      .create())
                  : (this._keyValueDiffer = this._keyValueDiffers
                      .find(this._rawClass)
                      .create()));
          }
          ngDoCheck() {
            if (this._iterableDiffer) {
              const t = this._iterableDiffer.diff(this._rawClass);
              t && this._applyIterableChanges(t);
            } else if (this._keyValueDiffer) {
              const t = this._keyValueDiffer.diff(this._rawClass);
              t && this._applyKeyValueChanges(t);
            }
          }
          _applyKeyValueChanges(t) {
            t.forEachAddedItem((i) => this._toggleClass(i.key, i.currentValue)),
              t.forEachChangedItem((i) =>
                this._toggleClass(i.key, i.currentValue)
              ),
              t.forEachRemovedItem((i) => {
                i.previousValue && this._toggleClass(i.key, !1);
              });
          }
          _applyIterableChanges(t) {
            t.forEachAddedItem((i) => {
              if ("string" != typeof i.item)
                throw new Error(
                  `NgClass can only toggle CSS classes expressed as strings, got ${Le(
                    i.item
                  )}`
                );
              this._toggleClass(i.item, !0);
            }),
              t.forEachRemovedItem((i) => this._toggleClass(i.item, !1));
          }
          _applyClasses(t) {
            t &&
              (Array.isArray(t) || t instanceof Set
                ? t.forEach((i) => this._toggleClass(i, !0))
                : Object.keys(t).forEach((i) => this._toggleClass(i, !!t[i])));
          }
          _removeClasses(t) {
            t &&
              (Array.isArray(t) || t instanceof Set
                ? t.forEach((i) => this._toggleClass(i, !1))
                : Object.keys(t).forEach((i) => this._toggleClass(i, !1)));
          }
          _toggleClass(t, i) {
            (t = t.trim()) &&
              t.split(/\s+/g).forEach((r) => {
                i
                  ? this._renderer.addClass(this._ngEl.nativeElement, r)
                  : this._renderer.removeClass(this._ngEl.nativeElement, r);
              });
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(w(Fd), w(ic), w(ut), w(Wi));
          }),
          (n.ɵdir = q({
            type: n,
            selectors: [["", "ngClass", ""]],
            inputs: { klass: ["class", "klass"], ngClass: "ngClass" },
          })),
          n
        );
      })();
      class LH {
        constructor(e, t, i, r) {
          (this.$implicit = e),
            (this.ngForOf = t),
            (this.index = i),
            (this.count = r);
        }
        get first() {
          return 0 === this.index;
        }
        get last() {
          return this.index === this.count - 1;
        }
        get even() {
          return this.index % 2 == 0;
        }
        get odd() {
          return !this.even;
        }
      }
      let Kd = (() => {
        class n {
          constructor(t, i, r) {
            (this._viewContainer = t),
              (this._template = i),
              (this._differs = r),
              (this._ngForOf = null),
              (this._ngForOfDirty = !0),
              (this._differ = null);
          }
          set ngForOf(t) {
            (this._ngForOf = t), (this._ngForOfDirty = !0);
          }
          set ngForTrackBy(t) {
            this._trackByFn = t;
          }
          get ngForTrackBy() {
            return this._trackByFn;
          }
          set ngForTemplate(t) {
            t && (this._template = t);
          }
          ngDoCheck() {
            if (this._ngForOfDirty) {
              this._ngForOfDirty = !1;
              const t = this._ngForOf;
              !this._differ &&
                t &&
                (this._differ = this._differs
                  .find(t)
                  .create(this.ngForTrackBy));
            }
            if (this._differ) {
              const t = this._differ.diff(this._ngForOf);
              t && this._applyChanges(t);
            }
          }
          _applyChanges(t) {
            const i = this._viewContainer;
            t.forEachOperation((r, o, s) => {
              if (null == r.previousIndex)
                i.createEmbeddedView(
                  this._template,
                  new LH(r.item, this._ngForOf, -1, -1),
                  null === s ? void 0 : s
                );
              else if (null == s) i.remove(null === o ? void 0 : o);
              else if (null !== o) {
                const a = i.get(o);
                i.move(a, s), qS(a, r);
              }
            });
            for (let r = 0, o = i.length; r < o; r++) {
              const a = i.get(r).context;
              (a.index = r), (a.count = o), (a.ngForOf = this._ngForOf);
            }
            t.forEachIdentityChange((r) => {
              qS(i.get(r.currentIndex), r);
            });
          }
          static ngTemplateContextGuard(t, i) {
            return !0;
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(w(Yn), w(Gi), w(Fd));
          }),
          (n.ɵdir = q({
            type: n,
            selectors: [["", "ngFor", "", "ngForOf", ""]],
            inputs: {
              ngForOf: "ngForOf",
              ngForTrackBy: "ngForTrackBy",
              ngForTemplate: "ngForTemplate",
            },
          })),
          n
        );
      })();
      function qS(n, e) {
        n.context.$implicit = e.item;
      }
      let to = (() => {
        class n {
          constructor(t, i) {
            (this._viewContainer = t),
              (this._context = new BH()),
              (this._thenTemplateRef = null),
              (this._elseTemplateRef = null),
              (this._thenViewRef = null),
              (this._elseViewRef = null),
              (this._thenTemplateRef = i);
          }
          set ngIf(t) {
            (this._context.$implicit = this._context.ngIf = t),
              this._updateView();
          }
          set ngIfThen(t) {
            KS("ngIfThen", t),
              (this._thenTemplateRef = t),
              (this._thenViewRef = null),
              this._updateView();
          }
          set ngIfElse(t) {
            KS("ngIfElse", t),
              (this._elseTemplateRef = t),
              (this._elseViewRef = null),
              this._updateView();
          }
          _updateView() {
            this._context.$implicit
              ? this._thenViewRef ||
                (this._viewContainer.clear(),
                (this._elseViewRef = null),
                this._thenTemplateRef &&
                  (this._thenViewRef = this._viewContainer.createEmbeddedView(
                    this._thenTemplateRef,
                    this._context
                  )))
              : this._elseViewRef ||
                (this._viewContainer.clear(),
                (this._thenViewRef = null),
                this._elseTemplateRef &&
                  (this._elseViewRef = this._viewContainer.createEmbeddedView(
                    this._elseTemplateRef,
                    this._context
                  )));
          }
          static ngTemplateContextGuard(t, i) {
            return !0;
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(w(Yn), w(Gi));
          }),
          (n.ɵdir = q({
            type: n,
            selectors: [["", "ngIf", ""]],
            inputs: {
              ngIf: "ngIf",
              ngIfThen: "ngIfThen",
              ngIfElse: "ngIfElse",
            },
          })),
          n
        );
      })();
      class BH {
        constructor() {
          (this.$implicit = null), (this.ngIf = null);
        }
      }
      function KS(n, e) {
        if (e && !e.createEmbeddedView)
          throw new Error(
            `${n} must be a TemplateRef, but received '${Le(e)}'.`
          );
      }
      let fy = (() => {
          class n {
            constructor(t, i, r) {
              (this._ngEl = t),
                (this._differs = i),
                (this._renderer = r),
                (this._ngStyle = null),
                (this._differ = null);
            }
            set ngStyle(t) {
              (this._ngStyle = t),
                !this._differ &&
                  t &&
                  (this._differ = this._differs.find(t).create());
            }
            ngDoCheck() {
              if (this._differ) {
                const t = this._differ.diff(this._ngStyle);
                t && this._applyChanges(t);
              }
            }
            _setStyle(t, i) {
              const [r, o] = t.split("."),
                s = -1 === r.indexOf("-") ? void 0 : vn.DashCase;
              null != i
                ? this._renderer.setStyle(
                    this._ngEl.nativeElement,
                    r,
                    o ? `${i}${o}` : i,
                    s
                  )
                : this._renderer.removeStyle(this._ngEl.nativeElement, r, s);
            }
            _applyChanges(t) {
              t.forEachRemovedItem((i) => this._setStyle(i.key, null)),
                t.forEachAddedItem((i) =>
                  this._setStyle(i.key, i.currentValue)
                ),
                t.forEachChangedItem((i) =>
                  this._setStyle(i.key, i.currentValue)
                );
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(w(ut), w(ic), w(Wi));
            }),
            (n.ɵdir = q({
              type: n,
              selectors: [["", "ngStyle", ""]],
              inputs: { ngStyle: "ngStyle" },
            })),
            n
          );
        })(),
        py = (() => {
          class n {
            constructor(t) {
              (this._viewContainerRef = t),
                (this._viewRef = null),
                (this.ngTemplateOutletContext = null),
                (this.ngTemplateOutlet = null),
                (this.ngTemplateOutletInjector = null);
            }
            ngOnChanges(t) {
              if (t.ngTemplateOutlet || t.ngTemplateOutletInjector) {
                const i = this._viewContainerRef;
                if (
                  (this._viewRef && i.remove(i.indexOf(this._viewRef)),
                  this.ngTemplateOutlet)
                ) {
                  const {
                    ngTemplateOutlet: r,
                    ngTemplateOutletContext: o,
                    ngTemplateOutletInjector: s,
                  } = this;
                  this._viewRef = i.createEmbeddedView(
                    r,
                    o,
                    s ? { injector: s } : void 0
                  );
                } else this._viewRef = null;
              } else
                this._viewRef &&
                  t.ngTemplateOutletContext &&
                  this.ngTemplateOutletContext &&
                  (this._viewRef.context = this.ngTemplateOutletContext);
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(w(Yn));
            }),
            (n.ɵdir = q({
              type: n,
              selectors: [["", "ngTemplateOutlet", ""]],
              inputs: {
                ngTemplateOutletContext: "ngTemplateOutletContext",
                ngTemplateOutlet: "ngTemplateOutlet",
                ngTemplateOutletInjector: "ngTemplateOutletInjector",
              },
              features: [$n],
            })),
            n
          );
        })();
      function _i(n, e) {
        return new W(2100, !1);
      }
      let ZS = (() => {
          class n {
            transform(t) {
              if (null == t) return null;
              if ("string" != typeof t) throw _i();
              return t.toLowerCase();
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵpipe = nn({ name: "lowercase", type: n, pure: !0 })),
            n
          );
        })(),
        JS = (() => {
          class n {
            transform(t, i, r) {
              if (null == t) return null;
              if (!this.supports(t)) throw _i();
              return t.slice(i, r);
            }
            supports(t) {
              return "string" == typeof t || Array.isArray(t);
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵpipe = nn({ name: "slice", type: n, pure: !1 })),
            n
          );
        })(),
        bi = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = rt({ type: n })),
            (n.ɵinj = Xe({})),
            n
          );
        })();
      const XS = "browser";
      let hU = (() => {
        class n {}
        return (
          (n.ɵprov = j({
            token: n,
            providedIn: "root",
            factory: () => new fU(T(gt), window),
          })),
          n
        );
      })();
      class fU {
        constructor(e, t) {
          (this.document = e), (this.window = t), (this.offset = () => [0, 0]);
        }
        setOffset(e) {
          this.offset = Array.isArray(e) ? () => e : e;
        }
        getScrollPosition() {
          return this.supportsScrolling()
            ? [this.window.pageXOffset, this.window.pageYOffset]
            : [0, 0];
        }
        scrollToPosition(e) {
          this.supportsScrolling() && this.window.scrollTo(e[0], e[1]);
        }
        scrollToAnchor(e) {
          if (!this.supportsScrolling()) return;
          const t = (function pU(n, e) {
            const t = n.getElementById(e) || n.getElementsByName(e)[0];
            if (t) return t;
            if (
              "function" == typeof n.createTreeWalker &&
              n.body &&
              (n.body.createShadowRoot || n.body.attachShadow)
            ) {
              const i = n.createTreeWalker(n.body, NodeFilter.SHOW_ELEMENT);
              let r = i.currentNode;
              for (; r; ) {
                const o = r.shadowRoot;
                if (o) {
                  const s =
                    o.getElementById(e) || o.querySelector(`[name="${e}"]`);
                  if (s) return s;
                }
                r = i.nextNode();
              }
            }
            return null;
          })(this.document, e);
          t && (this.scrollToElement(t), t.focus());
        }
        setHistoryScrollRestoration(e) {
          if (this.supportScrollRestoration()) {
            const t = this.window.history;
            t && t.scrollRestoration && (t.scrollRestoration = e);
          }
        }
        scrollToElement(e) {
          const t = e.getBoundingClientRect(),
            i = t.left + this.window.pageXOffset,
            r = t.top + this.window.pageYOffset,
            o = this.offset();
          this.window.scrollTo(i - o[0], r - o[1]);
        }
        supportScrollRestoration() {
          try {
            if (!this.supportsScrolling()) return !1;
            const e =
              eM(this.window.history) ||
              eM(Object.getPrototypeOf(this.window.history));
            return !(!e || (!e.writable && !e.set));
          } catch {
            return !1;
          }
        }
        supportsScrolling() {
          try {
            return (
              !!this.window &&
              !!this.window.scrollTo &&
              "pageXOffset" in this.window
            );
          } catch {
            return !1;
          }
        }
      }
      function eM(n) {
        return Object.getOwnPropertyDescriptor(n, "scrollRestoration");
      }
      class tM {}
      class yy extends class gU extends class G2 {} {
        constructor() {
          super(...arguments), (this.supportsDOMEvents = !0);
        }
      } {
        static makeCurrent() {
          !(function W2(n) {
            Ld || (Ld = n);
          })(new yy());
        }
        onAndCancel(e, t, i) {
          return (
            e.addEventListener(t, i, !1),
            () => {
              e.removeEventListener(t, i, !1);
            }
          );
        }
        dispatchEvent(e, t) {
          e.dispatchEvent(t);
        }
        remove(e) {
          e.parentNode && e.parentNode.removeChild(e);
        }
        createElement(e, t) {
          return (t = t || this.getDefaultDocument()).createElement(e);
        }
        createHtmlDocument() {
          return document.implementation.createHTMLDocument("fakeTitle");
        }
        getDefaultDocument() {
          return document;
        }
        isElementNode(e) {
          return e.nodeType === Node.ELEMENT_NODE;
        }
        isShadowRoot(e) {
          return e instanceof DocumentFragment;
        }
        getGlobalEventTarget(e, t) {
          return "window" === t
            ? window
            : "document" === t
            ? e
            : "body" === t
            ? e.body
            : null;
        }
        getBaseHref(e) {
          const t = (function mU() {
            return (
              (ac = ac || document.querySelector("base")),
              ac ? ac.getAttribute("href") : null
            );
          })();
          return null == t
            ? null
            : (function yU(n) {
                (Yd = Yd || document.createElement("a")),
                  Yd.setAttribute("href", n);
                const e = Yd.pathname;
                return "/" === e.charAt(0) ? e : `/${e}`;
              })(t);
        }
        resetBaseElement() {
          ac = null;
        }
        getUserAgent() {
          return window.navigator.userAgent;
        }
        getCookie(e) {
          return $S(document.cookie, e);
        }
      }
      let Yd,
        ac = null;
      const nM = new F("TRANSITION_ID"),
        _U = [
          {
            provide: xd,
            useFactory: function vU(n, e, t) {
              return () => {
                t.get(Ad).donePromise.then(() => {
                  const i = Ki(),
                    r = e.querySelectorAll(`style[ng-transition="${n}"]`);
                  for (let o = 0; o < r.length; o++) i.remove(r[o]);
                });
              };
            },
            deps: [nM, gt, pt],
            multi: !0,
          },
        ];
      let DU = (() => {
        class n {
          build() {
            return new XMLHttpRequest();
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)();
          }),
          (n.ɵprov = j({ token: n, factory: n.ɵfac })),
          n
        );
      })();
      const Zd = new F("EventManagerPlugins");
      let Qd = (() => {
        class n {
          constructor(t, i) {
            (this._zone = i),
              (this._eventNameToPlugin = new Map()),
              t.forEach((r) => (r.manager = this)),
              (this._plugins = t.slice().reverse());
          }
          addEventListener(t, i, r) {
            return this._findPluginFor(i).addEventListener(t, i, r);
          }
          addGlobalEventListener(t, i, r) {
            return this._findPluginFor(i).addGlobalEventListener(t, i, r);
          }
          getZone() {
            return this._zone;
          }
          _findPluginFor(t) {
            const i = this._eventNameToPlugin.get(t);
            if (i) return i;
            const r = this._plugins;
            for (let o = 0; o < r.length; o++) {
              const s = r[o];
              if (s.supports(t)) return this._eventNameToPlugin.set(t, s), s;
            }
            throw new Error(`No event manager plugin found for event ${t}`);
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(T(Zd), T(Ke));
          }),
          (n.ɵprov = j({ token: n, factory: n.ɵfac })),
          n
        );
      })();
      class iM {
        constructor(e) {
          this._doc = e;
        }
        addGlobalEventListener(e, t, i) {
          const r = Ki().getGlobalEventTarget(this._doc, e);
          if (!r)
            throw new Error(`Unsupported event target ${r} for event ${t}`);
          return this.addEventListener(r, t, i);
        }
      }
      let rM = (() => {
          class n {
            constructor() {
              this._stylesSet = new Set();
            }
            addStyles(t) {
              const i = new Set();
              t.forEach((r) => {
                this._stylesSet.has(r) || (this._stylesSet.add(r), i.add(r));
              }),
                this.onStylesAdded(i);
            }
            onStylesAdded(t) {}
            getAllStyles() {
              return Array.from(this._stylesSet);
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵprov = j({ token: n, factory: n.ɵfac })),
            n
          );
        })(),
        lc = (() => {
          class n extends rM {
            constructor(t) {
              super(),
                (this._doc = t),
                (this._hostNodes = new Map()),
                this._hostNodes.set(t.head, []);
            }
            _addStylesToHost(t, i, r) {
              t.forEach((o) => {
                const s = this._doc.createElement("style");
                (s.textContent = o), r.push(i.appendChild(s));
              });
            }
            addHost(t) {
              const i = [];
              this._addStylesToHost(this._stylesSet, t, i),
                this._hostNodes.set(t, i);
            }
            removeHost(t) {
              const i = this._hostNodes.get(t);
              i && i.forEach(oM), this._hostNodes.delete(t);
            }
            onStylesAdded(t) {
              this._hostNodes.forEach((i, r) => {
                this._addStylesToHost(t, r, i);
              });
            }
            ngOnDestroy() {
              this._hostNodes.forEach((t) => t.forEach(oM));
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(T(gt));
            }),
            (n.ɵprov = j({ token: n, factory: n.ɵfac })),
            n
          );
        })();
      function oM(n) {
        Ki().remove(n);
      }
      const vy = {
          svg: "http://www.w3.org/2000/svg",
          xhtml: "http://www.w3.org/1999/xhtml",
          xlink: "http://www.w3.org/1999/xlink",
          xml: "http://www.w3.org/XML/1998/namespace",
          xmlns: "http://www.w3.org/2000/xmlns/",
          math: "http://www.w3.org/1998/MathML/",
        },
        _y = /%COMP%/g;
      function Jd(n, e, t) {
        for (let i = 0; i < e.length; i++) {
          let r = e[i];
          Array.isArray(r) ? Jd(n, r, t) : ((r = r.replace(_y, n)), t.push(r));
        }
        return t;
      }
      function lM(n) {
        return (e) => {
          if ("__ngUnwrap__" === e) return n;
          !1 === n(e) && (e.preventDefault(), (e.returnValue = !1));
        };
      }
      let by = (() => {
        class n {
          constructor(t, i, r) {
            (this.eventManager = t),
              (this.sharedStylesHost = i),
              (this.appId = r),
              (this.rendererByCompId = new Map()),
              (this.defaultRenderer = new Dy(t));
          }
          createRenderer(t, i) {
            if (!t || !i) return this.defaultRenderer;
            switch (i.encapsulation) {
              case Ni.Emulated: {
                let r = this.rendererByCompId.get(i.id);
                return (
                  r ||
                    ((r = new IU(
                      this.eventManager,
                      this.sharedStylesHost,
                      i,
                      this.appId
                    )),
                    this.rendererByCompId.set(i.id, r)),
                  r.applyToHost(t),
                  r
                );
              }
              case 1:
              case Ni.ShadowDom:
                return new TU(this.eventManager, this.sharedStylesHost, t, i);
              default:
                if (!this.rendererByCompId.has(i.id)) {
                  const r = Jd(i.id, i.styles, []);
                  this.sharedStylesHost.addStyles(r),
                    this.rendererByCompId.set(i.id, this.defaultRenderer);
                }
                return this.defaultRenderer;
            }
          }
          begin() {}
          end() {}
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(T(Qd), T(lc), T(nc));
          }),
          (n.ɵprov = j({ token: n, factory: n.ɵfac })),
          n
        );
      })();
      class Dy {
        constructor(e) {
          (this.eventManager = e),
            (this.data = Object.create(null)),
            (this.destroyNode = null);
        }
        destroy() {}
        createElement(e, t) {
          return t
            ? document.createElementNS(vy[t] || t, e)
            : document.createElement(e);
        }
        createComment(e) {
          return document.createComment(e);
        }
        createText(e) {
          return document.createTextNode(e);
        }
        appendChild(e, t) {
          (uM(e) ? e.content : e).appendChild(t);
        }
        insertBefore(e, t, i) {
          e && (uM(e) ? e.content : e).insertBefore(t, i);
        }
        removeChild(e, t) {
          e && e.removeChild(t);
        }
        selectRootElement(e, t) {
          let i = "string" == typeof e ? document.querySelector(e) : e;
          if (!i)
            throw new Error(`The selector "${e}" did not match any elements`);
          return t || (i.textContent = ""), i;
        }
        parentNode(e) {
          return e.parentNode;
        }
        nextSibling(e) {
          return e.nextSibling;
        }
        setAttribute(e, t, i, r) {
          if (r) {
            t = r + ":" + t;
            const o = vy[r];
            o ? e.setAttributeNS(o, t, i) : e.setAttribute(t, i);
          } else e.setAttribute(t, i);
        }
        removeAttribute(e, t, i) {
          if (i) {
            const r = vy[i];
            r ? e.removeAttributeNS(r, t) : e.removeAttribute(`${i}:${t}`);
          } else e.removeAttribute(t);
        }
        addClass(e, t) {
          e.classList.add(t);
        }
        removeClass(e, t) {
          e.classList.remove(t);
        }
        setStyle(e, t, i, r) {
          r & (vn.DashCase | vn.Important)
            ? e.style.setProperty(t, i, r & vn.Important ? "important" : "")
            : (e.style[t] = i);
        }
        removeStyle(e, t, i) {
          i & vn.DashCase ? e.style.removeProperty(t) : (e.style[t] = "");
        }
        setProperty(e, t, i) {
          e[t] = i;
        }
        setValue(e, t) {
          e.nodeValue = t;
        }
        listen(e, t, i) {
          return "string" == typeof e
            ? this.eventManager.addGlobalEventListener(e, t, lM(i))
            : this.eventManager.addEventListener(e, t, lM(i));
        }
      }
      function uM(n) {
        return "TEMPLATE" === n.tagName && void 0 !== n.content;
      }
      class IU extends Dy {
        constructor(e, t, i, r) {
          super(e), (this.component = i);
          const o = Jd(r + "-" + i.id, i.styles, []);
          t.addStyles(o),
            (this.contentAttr = (function wU(n) {
              return "_ngcontent-%COMP%".replace(_y, n);
            })(r + "-" + i.id)),
            (this.hostAttr = (function SU(n) {
              return "_nghost-%COMP%".replace(_y, n);
            })(r + "-" + i.id));
        }
        applyToHost(e) {
          super.setAttribute(e, this.hostAttr, "");
        }
        createElement(e, t) {
          const i = super.createElement(e, t);
          return super.setAttribute(i, this.contentAttr, ""), i;
        }
      }
      class TU extends Dy {
        constructor(e, t, i, r) {
          super(e),
            (this.sharedStylesHost = t),
            (this.hostEl = i),
            (this.shadowRoot = i.attachShadow({ mode: "open" })),
            this.sharedStylesHost.addHost(this.shadowRoot);
          const o = Jd(r.id, r.styles, []);
          for (let s = 0; s < o.length; s++) {
            const a = document.createElement("style");
            (a.textContent = o[s]), this.shadowRoot.appendChild(a);
          }
        }
        nodeOrShadowRoot(e) {
          return e === this.hostEl ? this.shadowRoot : e;
        }
        destroy() {
          this.sharedStylesHost.removeHost(this.shadowRoot);
        }
        appendChild(e, t) {
          return super.appendChild(this.nodeOrShadowRoot(e), t);
        }
        insertBefore(e, t, i) {
          return super.insertBefore(this.nodeOrShadowRoot(e), t, i);
        }
        removeChild(e, t) {
          return super.removeChild(this.nodeOrShadowRoot(e), t);
        }
        parentNode(e) {
          return this.nodeOrShadowRoot(
            super.parentNode(this.nodeOrShadowRoot(e))
          );
        }
      }
      let xU = (() => {
        class n extends iM {
          constructor(t) {
            super(t);
          }
          supports(t) {
            return !0;
          }
          addEventListener(t, i, r) {
            return (
              t.addEventListener(i, r, !1),
              () => this.removeEventListener(t, i, r)
            );
          }
          removeEventListener(t, i, r) {
            return t.removeEventListener(i, r);
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(T(gt));
          }),
          (n.ɵprov = j({ token: n, factory: n.ɵfac })),
          n
        );
      })();
      const dM = ["alt", "control", "meta", "shift"],
        OU = {
          "\b": "Backspace",
          "\t": "Tab",
          "\x7f": "Delete",
          "\x1b": "Escape",
          Del: "Delete",
          Esc: "Escape",
          Left: "ArrowLeft",
          Right: "ArrowRight",
          Up: "ArrowUp",
          Down: "ArrowDown",
          Menu: "ContextMenu",
          Scroll: "ScrollLock",
          Win: "OS",
        },
        hM = {
          A: "1",
          B: "2",
          C: "3",
          D: "4",
          E: "5",
          F: "6",
          G: "7",
          H: "8",
          I: "9",
          J: "*",
          K: "+",
          M: "-",
          N: ".",
          O: "/",
          "`": "0",
          "\x90": "NumLock",
        },
        kU = {
          alt: (n) => n.altKey,
          control: (n) => n.ctrlKey,
          meta: (n) => n.metaKey,
          shift: (n) => n.shiftKey,
        };
      let NU = (() => {
        class n extends iM {
          constructor(t) {
            super(t);
          }
          supports(t) {
            return null != n.parseEventName(t);
          }
          addEventListener(t, i, r) {
            const o = n.parseEventName(i),
              s = n.eventCallback(o.fullKey, r, this.manager.getZone());
            return this.manager
              .getZone()
              .runOutsideAngular(() => Ki().onAndCancel(t, o.domEventName, s));
          }
          static parseEventName(t) {
            const i = t.toLowerCase().split("."),
              r = i.shift();
            if (0 === i.length || ("keydown" !== r && "keyup" !== r))
              return null;
            const o = n._normalizeKey(i.pop());
            let s = "";
            if (
              (dM.forEach((l) => {
                const c = i.indexOf(l);
                c > -1 && (i.splice(c, 1), (s += l + "."));
              }),
              (s += o),
              0 != i.length || 0 === o.length)
            )
              return null;
            const a = {};
            return (a.domEventName = r), (a.fullKey = s), a;
          }
          static getEventFullKey(t) {
            let i = "",
              r = (function RU(n) {
                let e = n.key;
                if (null == e) {
                  if (((e = n.keyIdentifier), null == e)) return "Unidentified";
                  e.startsWith("U+") &&
                    ((e = String.fromCharCode(parseInt(e.substring(2), 16))),
                    3 === n.location && hM.hasOwnProperty(e) && (e = hM[e]));
                }
                return OU[e] || e;
              })(t);
            return (
              (r = r.toLowerCase()),
              " " === r ? (r = "space") : "." === r && (r = "dot"),
              dM.forEach((o) => {
                o != r && kU[o](t) && (i += o + ".");
              }),
              (i += r),
              i
            );
          }
          static eventCallback(t, i, r) {
            return (o) => {
              n.getEventFullKey(o) === t && r.runGuarded(() => i(o));
            };
          }
          static _normalizeKey(t) {
            return "esc" === t ? "escape" : t;
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(T(gt));
          }),
          (n.ɵprov = j({ token: n, factory: n.ɵfac })),
          n
        );
      })();
      const fM = [
          { provide: Od, useValue: XS },
          {
            provide: rS,
            useValue: function PU() {
              yy.makeCurrent();
            },
            multi: !0,
          },
          {
            provide: gt,
            useFactory: function LU() {
              return (
                (function KN(n) {
                  Op = n;
                })(document),
                document
              );
            },
            deps: [],
          },
        ],
        VU = hS(U2, "browser", fM),
        pM = new F(""),
        gM = [
          {
            provide: kd,
            useClass: class bU {
              addToWindow(e) {
                (Re.getAngularTestability = (i, r = !0) => {
                  const o = e.findTestabilityInTree(i, r);
                  if (null == o)
                    throw new Error("Could not find testability for element.");
                  return o;
                }),
                  (Re.getAllAngularTestabilities = () =>
                    e.getAllTestabilities()),
                  (Re.getAllAngularRootElements = () => e.getAllRootElements()),
                  Re.frameworkStabilizers || (Re.frameworkStabilizers = []),
                  Re.frameworkStabilizers.push((i) => {
                    const r = Re.getAllAngularTestabilities();
                    let o = r.length,
                      s = !1;
                    const a = function (l) {
                      (s = s || l), o--, 0 == o && i(s);
                    };
                    r.forEach(function (l) {
                      l.whenStable(a);
                    });
                  });
              }
              findTestabilityInTree(e, t, i) {
                return null == t
                  ? null
                  : e.getTestability(t) ??
                      (i
                        ? Ki().isShadowRoot(t)
                          ? this.findTestabilityInTree(e, t.host, !0)
                          : this.findTestabilityInTree(e, t.parentElement, !0)
                        : null);
              }
            },
            deps: [],
          },
          { provide: lS, useClass: Wm, deps: [Ke, Gm, kd] },
          { provide: Wm, useClass: Wm, deps: [Ke, Gm, kd] },
        ],
        mM = [
          { provide: xg, useValue: "root" },
          {
            provide: Ks,
            useFactory: function FU() {
              return new Ks();
            },
            deps: [],
          },
          { provide: Zd, useClass: xU, multi: !0, deps: [gt, Ke, Od] },
          { provide: Zd, useClass: NU, multi: !0, deps: [gt] },
          { provide: by, useClass: by, deps: [Qd, lc, nc] },
          { provide: Dw, useExisting: by },
          { provide: rM, useExisting: lc },
          { provide: lc, useClass: lc, deps: [gt] },
          { provide: Qd, useClass: Qd, deps: [Zd, Ke] },
          { provide: tM, useClass: DU, deps: [] },
          [],
        ];
      let BU = (() => {
          class n {
            constructor(t) {}
            static withServerTransition(t) {
              return {
                ngModule: n,
                providers: [
                  { provide: nc, useValue: t.appId },
                  { provide: nM, useExisting: nc },
                  _U,
                ],
              };
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(T(pM, 12));
            }),
            (n.ɵmod = rt({ type: n })),
            (n.ɵinj = Xe({ providers: [...mM, ...gM], imports: [bi, z2] })),
            n
          );
        })(),
        yM = (() => {
          class n {
            constructor(t) {
              this._doc = t;
            }
            getTitle() {
              return this._doc.title;
            }
            setTitle(t) {
              this._doc.title = t || "";
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(T(gt));
            }),
            (n.ɵprov = j({
              token: n,
              factory: function (t) {
                let i = null;
                return (
                  (i = t
                    ? new t()
                    : (function HU() {
                        return new yM(T(gt));
                      })()),
                  i
                );
              },
              providedIn: "root",
            })),
            n
          );
        })();
      typeof window < "u" && window;
      let YU = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵprov = j({
              token: n,
              factory: function (t) {
                let i = null;
                return (i = t ? new (t || n)() : T(wy)), i;
              },
              providedIn: "root",
            })),
            n
          );
        })(),
        wy = (() => {
          class n extends YU {
            constructor(t) {
              super(), (this._doc = t);
            }
            sanitize(t, i) {
              if (null == i) return null;
              switch (t) {
                case Ue.NONE:
                  return i;
                case Ue.HTML:
                  return Fi(i, "HTML")
                    ? Pn(i)
                    : QD(this._doc, String(i)).toString();
                case Ue.STYLE:
                  return Fi(i, "Style") ? Pn(i) : i;
                case Ue.SCRIPT:
                  if (Fi(i, "Script")) return Pn(i);
                  throw new Error("unsafe value used in a script context");
                case Ue.URL:
                  return Fi(i, "URL") ? Pn(i) : Nl(String(i));
                case Ue.RESOURCE_URL:
                  if (Fi(i, "ResourceURL")) return Pn(i);
                  throw new Error(
                    "unsafe value used in a resource URL context (see https://g.co/ng/security#xss)"
                  );
                default:
                  throw new Error(
                    `Unexpected SecurityContext ${t} (see https://g.co/ng/security#xss)`
                  );
              }
            }
            bypassSecurityTrustHtml(t) {
              return (function hP(n) {
                return new sP(n);
              })(t);
            }
            bypassSecurityTrustStyle(t) {
              return (function fP(n) {
                return new aP(n);
              })(t);
            }
            bypassSecurityTrustScript(t) {
              return (function pP(n) {
                return new lP(n);
              })(t);
            }
            bypassSecurityTrustUrl(t) {
              return (function gP(n) {
                return new cP(n);
              })(t);
            }
            bypassSecurityTrustResourceUrl(t) {
              return (function mP(n) {
                return new uP(n);
              })(t);
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(T(gt));
            }),
            (n.ɵprov = j({
              token: n,
              factory: function (t) {
                let i = null;
                return (
                  (i = t
                    ? new t()
                    : (function ZU(n) {
                        return new wy(n.get(gt));
                      })(T(pt))),
                  i
                );
              },
              providedIn: "root",
            })),
            n
          );
        })();
      function Xd(n, e) {
        return new je((t) => {
          const i = n.length;
          if (0 === i) return void t.complete();
          const r = new Array(i);
          let o = 0,
            s = 0;
          for (let a = 0; a < i; a++) {
            const l = xt(n[a]);
            let c = !1;
            t.add(
              l.subscribe({
                next: (u) => {
                  c || ((c = !0), s++), (r[a] = u);
                },
                error: (u) => t.error(u),
                complete: () => {
                  o++,
                    (o === i || !c) &&
                      (s === i &&
                        t.next(
                          e ? e.reduce((u, d, h) => ((u[d] = r[h]), u), {}) : r
                        ),
                      t.complete());
                },
              })
            );
          }
        });
      }
      let bM = (() => {
          class n {
            constructor(t, i) {
              (this._renderer = t),
                (this._elementRef = i),
                (this.onChange = (r) => {}),
                (this.onTouched = () => {});
            }
            setProperty(t, i) {
              this._renderer.setProperty(this._elementRef.nativeElement, t, i);
            }
            registerOnTouched(t) {
              this.onTouched = t;
            }
            registerOnChange(t) {
              this.onChange = t;
            }
            setDisabledState(t) {
              this.setProperty("disabled", t);
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(w(Wi), w(ut));
            }),
            (n.ɵdir = q({ type: n })),
            n
          );
        })(),
        Xo = (() => {
          class n extends bM {}
          return (
            (n.ɵfac = (function () {
              let e;
              return function (i) {
                return (e || (e = Nt(n)))(i || n);
              };
            })()),
            (n.ɵdir = q({ type: n, features: [we] })),
            n
          );
        })();
      const Jn = new F("NgValueAccessor"),
        XU = { provide: Jn, useExisting: Ne(() => eh), multi: !0 },
        t3 = new F("CompositionEventMode");
      let eh = (() => {
        class n extends bM {
          constructor(t, i, r) {
            super(t, i),
              (this._compositionMode = r),
              (this._composing = !1),
              null == this._compositionMode &&
                (this._compositionMode = !(function e3() {
                  const n = Ki() ? Ki().getUserAgent() : "";
                  return /android (\d+)/.test(n.toLowerCase());
                })());
          }
          writeValue(t) {
            this.setProperty("value", t ?? "");
          }
          _handleInput(t) {
            (!this._compositionMode ||
              (this._compositionMode && !this._composing)) &&
              this.onChange(t);
          }
          _compositionStart() {
            this._composing = !0;
          }
          _compositionEnd(t) {
            (this._composing = !1), this._compositionMode && this.onChange(t);
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(w(Wi), w(ut), w(t3, 8));
          }),
          (n.ɵdir = q({
            type: n,
            selectors: [
              ["input", "formControlName", "", 3, "type", "checkbox"],
              ["textarea", "formControlName", ""],
              ["input", "formControl", "", 3, "type", "checkbox"],
              ["textarea", "formControl", ""],
              ["input", "ngModel", "", 3, "type", "checkbox"],
              ["textarea", "ngModel", ""],
              ["", "ngDefaultControl", ""],
            ],
            hostBindings: function (t, i) {
              1 & t &&
                Oe("input", function (o) {
                  return i._handleInput(o.target.value);
                })("blur", function () {
                  return i.onTouched();
                })("compositionstart", function () {
                  return i._compositionStart();
                })("compositionend", function (o) {
                  return i._compositionEnd(o.target.value);
                });
            },
            features: [$e([XU]), we],
          })),
          n
        );
      })();
      const Yt = new F("NgValidators"),
        ro = new F("NgAsyncValidators");
      function OM(n) {
        return null != n;
      }
      function kM(n) {
        return zl(n) ? xt(n) : n;
      }
      function NM(n) {
        let e = {};
        return (
          n.forEach((t) => {
            e = null != t ? { ...e, ...t } : e;
          }),
          0 === Object.keys(e).length ? null : e
        );
      }
      function RM(n, e) {
        return e.map((t) => t(n));
      }
      function PM(n) {
        return n.map((e) =>
          (function o3(n) {
            return !n.validate;
          })(e)
            ? e
            : (t) => e.validate(t)
        );
      }
      function Sy(n) {
        return null != n
          ? (function FM(n) {
              if (!n) return null;
              const e = n.filter(OM);
              return 0 == e.length
                ? null
                : function (t) {
                    return NM(RM(t, e));
                  };
            })(PM(n))
          : null;
      }
      function My(n) {
        return null != n
          ? (function LM(n) {
              if (!n) return null;
              const e = n.filter(OM);
              return 0 == e.length
                ? null
                : function (t) {
                    return (function QU(...n) {
                      if (1 === n.length) {
                        const e = n[0];
                        if (cl(e)) return Xd(e, null);
                        if (
                          up(e) &&
                          Object.getPrototypeOf(e) === Object.prototype
                        ) {
                          const t = Object.keys(e);
                          return Xd(
                            t.map((i) => e[i]),
                            t
                          );
                        }
                      }
                      if ("function" == typeof n[n.length - 1]) {
                        const e = n.pop();
                        return Xd(
                          (n = 1 === n.length && cl(n[0]) ? n[0] : n),
                          null
                        ).pipe(ye((t) => e(...t)));
                      }
                      return Xd(n, null);
                    })(RM(t, e).map(kM)).pipe(ye(NM));
                  };
            })(PM(n))
          : null;
      }
      function VM(n, e) {
        return null === n ? [e] : Array.isArray(n) ? [...n, e] : [n, e];
      }
      function Iy(n) {
        return n ? (Array.isArray(n) ? n : [n]) : [];
      }
      function nh(n, e) {
        return Array.isArray(n) ? n.includes(e) : n === e;
      }
      function HM(n, e) {
        const t = Iy(e);
        return (
          Iy(n).forEach((r) => {
            nh(t, r) || t.push(r);
          }),
          t
        );
      }
      function UM(n, e) {
        return Iy(e).filter((t) => !nh(n, t));
      }
      class zM {
        constructor() {
          (this._rawValidators = []),
            (this._rawAsyncValidators = []),
            (this._onDestroyCallbacks = []);
        }
        get value() {
          return this.control ? this.control.value : null;
        }
        get valid() {
          return this.control ? this.control.valid : null;
        }
        get invalid() {
          return this.control ? this.control.invalid : null;
        }
        get pending() {
          return this.control ? this.control.pending : null;
        }
        get disabled() {
          return this.control ? this.control.disabled : null;
        }
        get enabled() {
          return this.control ? this.control.enabled : null;
        }
        get errors() {
          return this.control ? this.control.errors : null;
        }
        get pristine() {
          return this.control ? this.control.pristine : null;
        }
        get dirty() {
          return this.control ? this.control.dirty : null;
        }
        get touched() {
          return this.control ? this.control.touched : null;
        }
        get status() {
          return this.control ? this.control.status : null;
        }
        get untouched() {
          return this.control ? this.control.untouched : null;
        }
        get statusChanges() {
          return this.control ? this.control.statusChanges : null;
        }
        get valueChanges() {
          return this.control ? this.control.valueChanges : null;
        }
        get path() {
          return null;
        }
        _setValidators(e) {
          (this._rawValidators = e || []),
            (this._composedValidatorFn = Sy(this._rawValidators));
        }
        _setAsyncValidators(e) {
          (this._rawAsyncValidators = e || []),
            (this._composedAsyncValidatorFn = My(this._rawAsyncValidators));
        }
        get validator() {
          return this._composedValidatorFn || null;
        }
        get asyncValidator() {
          return this._composedAsyncValidatorFn || null;
        }
        _registerOnDestroy(e) {
          this._onDestroyCallbacks.push(e);
        }
        _invokeOnDestroyCallbacks() {
          this._onDestroyCallbacks.forEach((e) => e()),
            (this._onDestroyCallbacks = []);
        }
        reset(e) {
          this.control && this.control.reset(e);
        }
        hasError(e, t) {
          return !!this.control && this.control.hasError(e, t);
        }
        getError(e, t) {
          return this.control ? this.control.getError(e, t) : null;
        }
      }
      class dn extends zM {
        get formDirective() {
          return null;
        }
        get path() {
          return null;
        }
      }
      class oo extends zM {
        constructor() {
          super(...arguments),
            (this._parent = null),
            (this.name = null),
            (this.valueAccessor = null);
        }
      }
      class $M {
        constructor(e) {
          this._cd = e;
        }
        get isTouched() {
          return !!this._cd?.control?.touched;
        }
        get isUntouched() {
          return !!this._cd?.control?.untouched;
        }
        get isPristine() {
          return !!this._cd?.control?.pristine;
        }
        get isDirty() {
          return !!this._cd?.control?.dirty;
        }
        get isValid() {
          return !!this._cd?.control?.valid;
        }
        get isInvalid() {
          return !!this._cd?.control?.invalid;
        }
        get isPending() {
          return !!this._cd?.control?.pending;
        }
        get isSubmitted() {
          return !!this._cd?.submitted;
        }
      }
      let Ty = (() => {
          class n extends $M {
            constructor(t) {
              super(t);
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(w(oo, 2));
            }),
            (n.ɵdir = q({
              type: n,
              selectors: [
                ["", "formControlName", ""],
                ["", "ngModel", ""],
                ["", "formControl", ""],
              ],
              hostVars: 14,
              hostBindings: function (t, i) {
                2 & t &&
                  $l("ng-untouched", i.isUntouched)("ng-touched", i.isTouched)(
                    "ng-pristine",
                    i.isPristine
                  )("ng-dirty", i.isDirty)("ng-valid", i.isValid)(
                    "ng-invalid",
                    i.isInvalid
                  )("ng-pending", i.isPending);
              },
              features: [we],
            })),
            n
          );
        })(),
        WM = (() => {
          class n extends $M {
            constructor(t) {
              super(t);
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(w(dn, 10));
            }),
            (n.ɵdir = q({
              type: n,
              selectors: [
                ["", "formGroupName", ""],
                ["", "formArrayName", ""],
                ["", "ngModelGroup", ""],
                ["", "formGroup", ""],
                ["form", 3, "ngNoForm", ""],
                ["", "ngForm", ""],
              ],
              hostVars: 16,
              hostBindings: function (t, i) {
                2 & t &&
                  $l("ng-untouched", i.isUntouched)("ng-touched", i.isTouched)(
                    "ng-pristine",
                    i.isPristine
                  )("ng-dirty", i.isDirty)("ng-valid", i.isValid)(
                    "ng-invalid",
                    i.isInvalid
                  )("ng-pending", i.isPending)("ng-submitted", i.isSubmitted);
              },
              features: [we],
            })),
            n
          );
        })();
      const cc = "VALID",
        rh = "INVALID",
        Ca = "PENDING",
        uc = "DISABLED";
      function ky(n) {
        return (oh(n) ? n.validators : n) || null;
      }
      function qM(n) {
        return Array.isArray(n) ? Sy(n) : n || null;
      }
      function Ny(n, e) {
        return (oh(e) ? e.asyncValidators : n) || null;
      }
      function KM(n) {
        return Array.isArray(n) ? My(n) : n || null;
      }
      function oh(n) {
        return null != n && !Array.isArray(n) && "object" == typeof n;
      }
      class QM {
        constructor(e, t) {
          (this._pendingDirty = !1),
            (this._hasOwnPendingAsyncValidator = !1),
            (this._pendingTouched = !1),
            (this._onCollectionChange = () => {}),
            (this._parent = null),
            (this.pristine = !0),
            (this.touched = !1),
            (this._onDisabledChange = []),
            (this._rawValidators = e),
            (this._rawAsyncValidators = t),
            (this._composedValidatorFn = qM(this._rawValidators)),
            (this._composedAsyncValidatorFn = KM(this._rawAsyncValidators));
        }
        get validator() {
          return this._composedValidatorFn;
        }
        set validator(e) {
          this._rawValidators = this._composedValidatorFn = e;
        }
        get asyncValidator() {
          return this._composedAsyncValidatorFn;
        }
        set asyncValidator(e) {
          this._rawAsyncValidators = this._composedAsyncValidatorFn = e;
        }
        get parent() {
          return this._parent;
        }
        get valid() {
          return this.status === cc;
        }
        get invalid() {
          return this.status === rh;
        }
        get pending() {
          return this.status == Ca;
        }
        get disabled() {
          return this.status === uc;
        }
        get enabled() {
          return this.status !== uc;
        }
        get dirty() {
          return !this.pristine;
        }
        get untouched() {
          return !this.touched;
        }
        get updateOn() {
          return this._updateOn
            ? this._updateOn
            : this.parent
            ? this.parent.updateOn
            : "change";
        }
        setValidators(e) {
          (this._rawValidators = e), (this._composedValidatorFn = qM(e));
        }
        setAsyncValidators(e) {
          (this._rawAsyncValidators = e),
            (this._composedAsyncValidatorFn = KM(e));
        }
        addValidators(e) {
          this.setValidators(HM(e, this._rawValidators));
        }
        addAsyncValidators(e) {
          this.setAsyncValidators(HM(e, this._rawAsyncValidators));
        }
        removeValidators(e) {
          this.setValidators(UM(e, this._rawValidators));
        }
        removeAsyncValidators(e) {
          this.setAsyncValidators(UM(e, this._rawAsyncValidators));
        }
        hasValidator(e) {
          return nh(this._rawValidators, e);
        }
        hasAsyncValidator(e) {
          return nh(this._rawAsyncValidators, e);
        }
        clearValidators() {
          this.validator = null;
        }
        clearAsyncValidators() {
          this.asyncValidator = null;
        }
        markAsTouched(e = {}) {
          (this.touched = !0),
            this._parent && !e.onlySelf && this._parent.markAsTouched(e);
        }
        markAllAsTouched() {
          this.markAsTouched({ onlySelf: !0 }),
            this._forEachChild((e) => e.markAllAsTouched());
        }
        markAsUntouched(e = {}) {
          (this.touched = !1),
            (this._pendingTouched = !1),
            this._forEachChild((t) => {
              t.markAsUntouched({ onlySelf: !0 });
            }),
            this._parent && !e.onlySelf && this._parent._updateTouched(e);
        }
        markAsDirty(e = {}) {
          (this.pristine = !1),
            this._parent && !e.onlySelf && this._parent.markAsDirty(e);
        }
        markAsPristine(e = {}) {
          (this.pristine = !0),
            (this._pendingDirty = !1),
            this._forEachChild((t) => {
              t.markAsPristine({ onlySelf: !0 });
            }),
            this._parent && !e.onlySelf && this._parent._updatePristine(e);
        }
        markAsPending(e = {}) {
          (this.status = Ca),
            !1 !== e.emitEvent && this.statusChanges.emit(this.status),
            this._parent && !e.onlySelf && this._parent.markAsPending(e);
        }
        disable(e = {}) {
          const t = this._parentMarkedDirty(e.onlySelf);
          (this.status = uc),
            (this.errors = null),
            this._forEachChild((i) => {
              i.disable({ ...e, onlySelf: !0 });
            }),
            this._updateValue(),
            !1 !== e.emitEvent &&
              (this.valueChanges.emit(this.value),
              this.statusChanges.emit(this.status)),
            this._updateAncestors({ ...e, skipPristineCheck: t }),
            this._onDisabledChange.forEach((i) => i(!0));
        }
        enable(e = {}) {
          const t = this._parentMarkedDirty(e.onlySelf);
          (this.status = cc),
            this._forEachChild((i) => {
              i.enable({ ...e, onlySelf: !0 });
            }),
            this.updateValueAndValidity({
              onlySelf: !0,
              emitEvent: e.emitEvent,
            }),
            this._updateAncestors({ ...e, skipPristineCheck: t }),
            this._onDisabledChange.forEach((i) => i(!1));
        }
        _updateAncestors(e) {
          this._parent &&
            !e.onlySelf &&
            (this._parent.updateValueAndValidity(e),
            e.skipPristineCheck || this._parent._updatePristine(),
            this._parent._updateTouched());
        }
        setParent(e) {
          this._parent = e;
        }
        getRawValue() {
          return this.value;
        }
        updateValueAndValidity(e = {}) {
          this._setInitialStatus(),
            this._updateValue(),
            this.enabled &&
              (this._cancelExistingSubscription(),
              (this.errors = this._runValidator()),
              (this.status = this._calculateStatus()),
              (this.status === cc || this.status === Ca) &&
                this._runAsyncValidator(e.emitEvent)),
            !1 !== e.emitEvent &&
              (this.valueChanges.emit(this.value),
              this.statusChanges.emit(this.status)),
            this._parent &&
              !e.onlySelf &&
              this._parent.updateValueAndValidity(e);
        }
        _updateTreeValidity(e = { emitEvent: !0 }) {
          this._forEachChild((t) => t._updateTreeValidity(e)),
            this.updateValueAndValidity({
              onlySelf: !0,
              emitEvent: e.emitEvent,
            });
        }
        _setInitialStatus() {
          this.status = this._allControlsDisabled() ? uc : cc;
        }
        _runValidator() {
          return this.validator ? this.validator(this) : null;
        }
        _runAsyncValidator(e) {
          if (this.asyncValidator) {
            (this.status = Ca), (this._hasOwnPendingAsyncValidator = !0);
            const t = kM(this.asyncValidator(this));
            this._asyncValidationSubscription = t.subscribe((i) => {
              (this._hasOwnPendingAsyncValidator = !1),
                this.setErrors(i, { emitEvent: e });
            });
          }
        }
        _cancelExistingSubscription() {
          this._asyncValidationSubscription &&
            (this._asyncValidationSubscription.unsubscribe(),
            (this._hasOwnPendingAsyncValidator = !1));
        }
        setErrors(e, t = {}) {
          (this.errors = e), this._updateControlsErrors(!1 !== t.emitEvent);
        }
        get(e) {
          let t = e;
          return null == t ||
            (Array.isArray(t) || (t = t.split(".")), 0 === t.length)
            ? null
            : t.reduce((i, r) => i && i._find(r), this);
        }
        getError(e, t) {
          const i = t ? this.get(t) : this;
          return i && i.errors ? i.errors[e] : null;
        }
        hasError(e, t) {
          return !!this.getError(e, t);
        }
        get root() {
          let e = this;
          for (; e._parent; ) e = e._parent;
          return e;
        }
        _updateControlsErrors(e) {
          (this.status = this._calculateStatus()),
            e && this.statusChanges.emit(this.status),
            this._parent && this._parent._updateControlsErrors(e);
        }
        _initObservables() {
          (this.valueChanges = new Ie()), (this.statusChanges = new Ie());
        }
        _calculateStatus() {
          return this._allControlsDisabled()
            ? uc
            : this.errors
            ? rh
            : this._hasOwnPendingAsyncValidator ||
              this._anyControlsHaveStatus(Ca)
            ? Ca
            : this._anyControlsHaveStatus(rh)
            ? rh
            : cc;
        }
        _anyControlsHaveStatus(e) {
          return this._anyControls((t) => t.status === e);
        }
        _anyControlsDirty() {
          return this._anyControls((e) => e.dirty);
        }
        _anyControlsTouched() {
          return this._anyControls((e) => e.touched);
        }
        _updatePristine(e = {}) {
          (this.pristine = !this._anyControlsDirty()),
            this._parent && !e.onlySelf && this._parent._updatePristine(e);
        }
        _updateTouched(e = {}) {
          (this.touched = this._anyControlsTouched()),
            this._parent && !e.onlySelf && this._parent._updateTouched(e);
        }
        _registerOnCollectionChange(e) {
          this._onCollectionChange = e;
        }
        _setUpdateStrategy(e) {
          oh(e) && null != e.updateOn && (this._updateOn = e.updateOn);
        }
        _parentMarkedDirty(e) {
          return (
            !e &&
            !(!this._parent || !this._parent.dirty) &&
            !this._parent._anyControlsDirty()
          );
        }
        _find(e) {
          return null;
        }
      }
      class Ry extends QM {
        constructor(e, t, i) {
          super(ky(t), Ny(i, t)),
            (this.controls = e),
            this._initObservables(),
            this._setUpdateStrategy(t),
            this._setUpControls(),
            this.updateValueAndValidity({
              onlySelf: !0,
              emitEvent: !!this.asyncValidator,
            });
        }
        registerControl(e, t) {
          return this.controls[e]
            ? this.controls[e]
            : ((this.controls[e] = t),
              t.setParent(this),
              t._registerOnCollectionChange(this._onCollectionChange),
              t);
        }
        addControl(e, t, i = {}) {
          this.registerControl(e, t),
            this.updateValueAndValidity({ emitEvent: i.emitEvent }),
            this._onCollectionChange();
        }
        removeControl(e, t = {}) {
          this.controls[e] &&
            this.controls[e]._registerOnCollectionChange(() => {}),
            delete this.controls[e],
            this.updateValueAndValidity({ emitEvent: t.emitEvent }),
            this._onCollectionChange();
        }
        setControl(e, t, i = {}) {
          this.controls[e] &&
            this.controls[e]._registerOnCollectionChange(() => {}),
            delete this.controls[e],
            t && this.registerControl(e, t),
            this.updateValueAndValidity({ emitEvent: i.emitEvent }),
            this._onCollectionChange();
        }
        contains(e) {
          return this.controls.hasOwnProperty(e) && this.controls[e].enabled;
        }
        setValue(e, t = {}) {
          (function ZM(n, e, t) {
            n._forEachChild((i, r) => {
              if (void 0 === t[r]) throw new W(1002, "");
            });
          })(this, 0, e),
            Object.keys(e).forEach((i) => {
              (function YM(n, e, t) {
                const i = n.controls;
                if (!(e ? Object.keys(i) : i).length) throw new W(1e3, "");
                if (!i[t]) throw new W(1001, "");
              })(this, !0, i),
                this.controls[i].setValue(e[i], {
                  onlySelf: !0,
                  emitEvent: t.emitEvent,
                });
            }),
            this.updateValueAndValidity(t);
        }
        patchValue(e, t = {}) {
          null != e &&
            (Object.keys(e).forEach((i) => {
              const r = this.controls[i];
              r && r.patchValue(e[i], { onlySelf: !0, emitEvent: t.emitEvent });
            }),
            this.updateValueAndValidity(t));
        }
        reset(e = {}, t = {}) {
          this._forEachChild((i, r) => {
            i.reset(e[r], { onlySelf: !0, emitEvent: t.emitEvent });
          }),
            this._updatePristine(t),
            this._updateTouched(t),
            this.updateValueAndValidity(t);
        }
        getRawValue() {
          return this._reduceChildren(
            {},
            (e, t, i) => ((e[i] = t.getRawValue()), e)
          );
        }
        _syncPendingControls() {
          let e = this._reduceChildren(
            !1,
            (t, i) => !!i._syncPendingControls() || t
          );
          return e && this.updateValueAndValidity({ onlySelf: !0 }), e;
        }
        _forEachChild(e) {
          Object.keys(this.controls).forEach((t) => {
            const i = this.controls[t];
            i && e(i, t);
          });
        }
        _setUpControls() {
          this._forEachChild((e) => {
            e.setParent(this),
              e._registerOnCollectionChange(this._onCollectionChange);
          });
        }
        _updateValue() {
          this.value = this._reduceValue();
        }
        _anyControls(e) {
          for (const [t, i] of Object.entries(this.controls))
            if (this.contains(t) && e(i)) return !0;
          return !1;
        }
        _reduceValue() {
          return this._reduceChildren(
            {},
            (t, i, r) => ((i.enabled || this.disabled) && (t[r] = i.value), t)
          );
        }
        _reduceChildren(e, t) {
          let i = e;
          return (
            this._forEachChild((r, o) => {
              i = t(i, r, o);
            }),
            i
          );
        }
        _allControlsDisabled() {
          for (const e of Object.keys(this.controls))
            if (this.controls[e].enabled) return !1;
          return Object.keys(this.controls).length > 0 || this.disabled;
        }
        _find(e) {
          return this.controls.hasOwnProperty(e) ? this.controls[e] : null;
        }
      }
      function dc(n, e) {
        Py(n, e),
          e.valueAccessor.writeValue(n.value),
          n.disabled && e.valueAccessor.setDisabledState?.(!0),
          (function p3(n, e) {
            e.valueAccessor.registerOnChange((t) => {
              (n._pendingValue = t),
                (n._pendingChange = !0),
                (n._pendingDirty = !0),
                "change" === n.updateOn && JM(n, e);
            });
          })(n, e),
          (function m3(n, e) {
            const t = (i, r) => {
              e.valueAccessor.writeValue(i), r && e.viewToModelUpdate(i);
            };
            n.registerOnChange(t),
              e._registerOnDestroy(() => {
                n._unregisterOnChange(t);
              });
          })(n, e),
          (function g3(n, e) {
            e.valueAccessor.registerOnTouched(() => {
              (n._pendingTouched = !0),
                "blur" === n.updateOn && n._pendingChange && JM(n, e),
                "submit" !== n.updateOn && n.markAsTouched();
            });
          })(n, e),
          (function f3(n, e) {
            if (e.valueAccessor.setDisabledState) {
              const t = (i) => {
                e.valueAccessor.setDisabledState(i);
              };
              n.registerOnDisabledChange(t),
                e._registerOnDestroy(() => {
                  n._unregisterOnDisabledChange(t);
                });
            }
          })(n, e);
      }
      function lh(n, e) {
        n.forEach((t) => {
          t.registerOnValidatorChange && t.registerOnValidatorChange(e);
        });
      }
      function Py(n, e) {
        const t = (function BM(n) {
          return n._rawValidators;
        })(n);
        null !== e.validator
          ? n.setValidators(VM(t, e.validator))
          : "function" == typeof t && n.setValidators([t]);
        const i = (function jM(n) {
          return n._rawAsyncValidators;
        })(n);
        null !== e.asyncValidator
          ? n.setAsyncValidators(VM(i, e.asyncValidator))
          : "function" == typeof i && n.setAsyncValidators([i]);
        const r = () => n.updateValueAndValidity();
        lh(e._rawValidators, r), lh(e._rawAsyncValidators, r);
      }
      function JM(n, e) {
        n._pendingDirty && n.markAsDirty(),
          n.setValue(n._pendingValue, { emitModelToViewChange: !1 }),
          e.viewToModelUpdate(n._pendingValue),
          (n._pendingChange = !1);
      }
      const D3 = { provide: dn, useExisting: Ne(() => uh) },
        hc = (() => Promise.resolve(null))();
      let uh = (() => {
        class n extends dn {
          constructor(t, i) {
            super(),
              (this.submitted = !1),
              (this._directives = new Set()),
              (this.ngSubmit = new Ie()),
              (this.form = new Ry({}, Sy(t), My(i)));
          }
          ngAfterViewInit() {
            this._setUpdateStrategy();
          }
          get formDirective() {
            return this;
          }
          get control() {
            return this.form;
          }
          get path() {
            return [];
          }
          get controls() {
            return this.form.controls;
          }
          addControl(t) {
            hc.then(() => {
              const i = this._findContainer(t.path);
              (t.control = i.registerControl(t.name, t.control)),
                dc(t.control, t),
                t.control.updateValueAndValidity({ emitEvent: !1 }),
                this._directives.add(t);
            });
          }
          getControl(t) {
            return this.form.get(t.path);
          }
          removeControl(t) {
            hc.then(() => {
              const i = this._findContainer(t.path);
              i && i.removeControl(t.name), this._directives.delete(t);
            });
          }
          addFormGroup(t) {
            hc.then(() => {
              const i = this._findContainer(t.path),
                r = new Ry({});
              (function XM(n, e) {
                Py(n, e);
              })(r, t),
                i.registerControl(t.name, r),
                r.updateValueAndValidity({ emitEvent: !1 });
            });
          }
          removeFormGroup(t) {
            hc.then(() => {
              const i = this._findContainer(t.path);
              i && i.removeControl(t.name);
            });
          }
          getFormGroup(t) {
            return this.form.get(t.path);
          }
          updateModel(t, i) {
            hc.then(() => {
              this.form.get(t.path).setValue(i);
            });
          }
          setValue(t) {
            this.control.setValue(t);
          }
          onSubmit(t) {
            return (
              (this.submitted = !0),
              (function tI(n, e) {
                n._syncPendingControls(),
                  e.forEach((t) => {
                    const i = t.control;
                    "submit" === i.updateOn &&
                      i._pendingChange &&
                      (t.viewToModelUpdate(i._pendingValue),
                      (i._pendingChange = !1));
                  });
              })(this.form, this._directives),
              this.ngSubmit.emit(t),
              !1
            );
          }
          onReset() {
            this.resetForm();
          }
          resetForm(t) {
            this.form.reset(t), (this.submitted = !1);
          }
          _setUpdateStrategy() {
            this.options &&
              null != this.options.updateOn &&
              (this.form._updateOn = this.options.updateOn);
          }
          _findContainer(t) {
            return t.pop(), t.length ? this.form.get(t) : this.form;
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(w(Yt, 10), w(ro, 10));
          }),
          (n.ɵdir = q({
            type: n,
            selectors: [
              ["form", 3, "ngNoForm", "", 3, "formGroup", ""],
              ["ng-form"],
              ["", "ngForm", ""],
            ],
            hostBindings: function (t, i) {
              1 & t &&
                Oe("submit", function (o) {
                  return i.onSubmit(o);
                })("reset", function () {
                  return i.onReset();
                });
            },
            inputs: { options: ["ngFormOptions", "options"] },
            outputs: { ngSubmit: "ngSubmit" },
            exportAs: ["ngForm"],
            features: [$e([D3]), we],
          })),
          n
        );
      })();
      function nI(n, e) {
        const t = n.indexOf(e);
        t > -1 && n.splice(t, 1);
      }
      function iI(n) {
        return (
          "object" == typeof n &&
          null !== n &&
          2 === Object.keys(n).length &&
          "value" in n &&
          "disabled" in n
        );
      }
      const rI = class extends QM {
          constructor(e = null, t, i) {
            super(ky(t), Ny(i, t)),
              (this.defaultValue = null),
              (this._onChange = []),
              (this._pendingChange = !1),
              this._applyFormState(e),
              this._setUpdateStrategy(t),
              this._initObservables(),
              this.updateValueAndValidity({
                onlySelf: !0,
                emitEvent: !!this.asyncValidator,
              }),
              oh(t) &&
                (t.nonNullable || t.initialValueIsDefault) &&
                (this.defaultValue = iI(e) ? e.value : e);
          }
          setValue(e, t = {}) {
            (this.value = this._pendingValue = e),
              this._onChange.length &&
                !1 !== t.emitModelToViewChange &&
                this._onChange.forEach((i) =>
                  i(this.value, !1 !== t.emitViewToModelChange)
                ),
              this.updateValueAndValidity(t);
          }
          patchValue(e, t = {}) {
            this.setValue(e, t);
          }
          reset(e = this.defaultValue, t = {}) {
            this._applyFormState(e),
              this.markAsPristine(t),
              this.markAsUntouched(t),
              this.setValue(this.value, t),
              (this._pendingChange = !1);
          }
          _updateValue() {}
          _anyControls(e) {
            return !1;
          }
          _allControlsDisabled() {
            return this.disabled;
          }
          registerOnChange(e) {
            this._onChange.push(e);
          }
          _unregisterOnChange(e) {
            nI(this._onChange, e);
          }
          registerOnDisabledChange(e) {
            this._onDisabledChange.push(e);
          }
          _unregisterOnDisabledChange(e) {
            nI(this._onDisabledChange, e);
          }
          _forEachChild(e) {}
          _syncPendingControls() {
            return !(
              "submit" !== this.updateOn ||
              (this._pendingDirty && this.markAsDirty(),
              this._pendingTouched && this.markAsTouched(),
              !this._pendingChange) ||
              (this.setValue(this._pendingValue, {
                onlySelf: !0,
                emitModelToViewChange: !1,
              }),
              0)
            );
          }
          _applyFormState(e) {
            iI(e)
              ? ((this.value = this._pendingValue = e.value),
                e.disabled
                  ? this.disable({ onlySelf: !0, emitEvent: !1 })
                  : this.enable({ onlySelf: !0, emitEvent: !1 }))
              : (this.value = this._pendingValue = e);
          }
        },
        w3 = { provide: oo, useExisting: Ne(() => dh) },
        aI = (() => Promise.resolve(null))();
      let dh = (() => {
          class n extends oo {
            constructor(t, i, r, o, s) {
              super(),
                (this._changeDetectorRef = s),
                (this.control = new rI()),
                (this._registered = !1),
                (this.update = new Ie()),
                (this._parent = t),
                this._setValidators(i),
                this._setAsyncValidators(r),
                (this.valueAccessor = (function Ly(n, e) {
                  if (!e) return null;
                  let t, i, r;
                  return (
                    Array.isArray(e),
                    e.forEach((o) => {
                      o.constructor === eh
                        ? (t = o)
                        : (function _3(n) {
                            return Object.getPrototypeOf(n.constructor) === Xo;
                          })(o)
                        ? (i = o)
                        : (r = o);
                    }),
                    r || i || t || null
                  );
                })(0, o));
            }
            ngOnChanges(t) {
              if ((this._checkForErrors(), !this._registered || "name" in t)) {
                if (
                  this._registered &&
                  (this._checkName(), this.formDirective)
                ) {
                  const i = t.name.previousValue;
                  this.formDirective.removeControl({
                    name: i,
                    path: this._getPath(i),
                  });
                }
                this._setUpControl();
              }
              "isDisabled" in t && this._updateDisabled(t),
                (function Fy(n, e) {
                  if (!n.hasOwnProperty("model")) return !1;
                  const t = n.model;
                  return !!t.isFirstChange() || !Object.is(e, t.currentValue);
                })(t, this.viewModel) &&
                  (this._updateValue(this.model),
                  (this.viewModel = this.model));
            }
            ngOnDestroy() {
              this.formDirective && this.formDirective.removeControl(this);
            }
            get path() {
              return this._getPath(this.name);
            }
            get formDirective() {
              return this._parent ? this._parent.formDirective : null;
            }
            viewToModelUpdate(t) {
              (this.viewModel = t), this.update.emit(t);
            }
            _setUpControl() {
              this._setUpdateStrategy(),
                this._isStandalone()
                  ? this._setUpStandalone()
                  : this.formDirective.addControl(this),
                (this._registered = !0);
            }
            _setUpdateStrategy() {
              this.options &&
                null != this.options.updateOn &&
                (this.control._updateOn = this.options.updateOn);
            }
            _isStandalone() {
              return (
                !this._parent || !(!this.options || !this.options.standalone)
              );
            }
            _setUpStandalone() {
              dc(this.control, this),
                this.control.updateValueAndValidity({ emitEvent: !1 });
            }
            _checkForErrors() {
              this._isStandalone() || this._checkParentType(),
                this._checkName();
            }
            _checkParentType() {}
            _checkName() {
              this.options &&
                this.options.name &&
                (this.name = this.options.name),
                this._isStandalone();
            }
            _updateValue(t) {
              aI.then(() => {
                this.control.setValue(t, { emitViewToModelChange: !1 }),
                  this._changeDetectorRef?.markForCheck();
              });
            }
            _updateDisabled(t) {
              const i = t.isDisabled.currentValue,
                r =
                  0 !== i &&
                  (function Sr(n) {
                    return "boolean" == typeof n
                      ? n
                      : null != n && "false" !== n;
                  })(i);
              aI.then(() => {
                r && !this.control.disabled
                  ? this.control.disable()
                  : !r && this.control.disabled && this.control.enable(),
                  this._changeDetectorRef?.markForCheck();
              });
            }
            _getPath(t) {
              return this._parent
                ? (function sh(n, e) {
                    return [...e.path, n];
                  })(t, this._parent)
                : [t];
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(
                w(dn, 9),
                w(Yt, 10),
                w(ro, 10),
                w(Jn, 10),
                w(Zo, 8)
              );
            }),
            (n.ɵdir = q({
              type: n,
              selectors: [
                [
                  "",
                  "ngModel",
                  "",
                  3,
                  "formControlName",
                  "",
                  3,
                  "formControl",
                  "",
                ],
              ],
              inputs: {
                name: "name",
                isDisabled: ["disabled", "isDisabled"],
                model: ["ngModel", "model"],
                options: ["ngModelOptions", "options"],
              },
              outputs: { update: "ngModelChange" },
              exportAs: ["ngModel"],
              features: [$e([w3]), we, $n],
            })),
            n
          );
        })(),
        lI = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵdir = q({
              type: n,
              selectors: [
                ["form", 3, "ngNoForm", "", 3, "ngNativeValidate", ""],
              ],
              hostAttrs: ["novalidate", ""],
            })),
            n
          );
        })(),
        uI = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = rt({ type: n })),
            (n.ɵinj = Xe({})),
            n
          );
        })(),
        K3 = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = rt({ type: n })),
            (n.ɵinj = Xe({ imports: [uI] })),
            n
          );
        })(),
        TI = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = rt({ type: n })),
            (n.ɵinj = Xe({ imports: [K3] })),
            n
          );
        })(),
        Mt = (() => {
          class n {
            static addClass(t, i) {
              t.classList ? t.classList.add(i) : (t.className += " " + i);
            }
            static addMultipleClasses(t, i) {
              if (t.classList) {
                let r = i.trim().split(" ");
                for (let o = 0; o < r.length; o++) t.classList.add(r[o]);
              } else {
                let r = i.split(" ");
                for (let o = 0; o < r.length; o++) t.className += " " + r[o];
              }
            }
            static removeClass(t, i) {
              t.classList
                ? t.classList.remove(i)
                : (t.className = t.className.replace(
                    new RegExp(
                      "(^|\\b)" + i.split(" ").join("|") + "(\\b|$)",
                      "gi"
                    ),
                    " "
                  ));
            }
            static hasClass(t, i) {
              return t.classList
                ? t.classList.contains(i)
                : new RegExp("(^| )" + i + "( |$)", "gi").test(t.className);
            }
            static siblings(t) {
              return Array.prototype.filter.call(
                t.parentNode.children,
                function (i) {
                  return i !== t;
                }
              );
            }
            static find(t, i) {
              return Array.from(t.querySelectorAll(i));
            }
            static findSingle(t, i) {
              return t ? t.querySelector(i) : null;
            }
            static index(t) {
              let i = t.parentNode.childNodes,
                r = 0;
              for (var o = 0; o < i.length; o++) {
                if (i[o] == t) return r;
                1 == i[o].nodeType && r++;
              }
              return -1;
            }
            static indexWithinGroup(t, i) {
              let r = t.parentNode ? t.parentNode.childNodes : [],
                o = 0;
              for (var s = 0; s < r.length; s++) {
                if (r[s] == t) return o;
                r[s].attributes &&
                  r[s].attributes[i] &&
                  1 == r[s].nodeType &&
                  o++;
              }
              return -1;
            }
            static relativePosition(t, i) {
              let r = t.offsetParent
                ? { width: t.offsetWidth, height: t.offsetHeight }
                : this.getHiddenElementDimensions(t);
              const o = i.offsetHeight,
                s = i.getBoundingClientRect(),
                a = this.getViewport();
              let l, c;
              s.top + o + r.height > a.height
                ? ((l = -1 * r.height),
                  (t.style.transformOrigin = "bottom"),
                  s.top + l < 0 && (l = -1 * s.top))
                : ((l = o), (t.style.transformOrigin = "top")),
                (c =
                  r.width > a.width
                    ? -1 * s.left
                    : s.left + r.width > a.width
                    ? -1 * (s.left + r.width - a.width)
                    : 0),
                (t.style.top = l + "px"),
                (t.style.left = c + "px");
            }
            static absolutePosition(t, i) {
              let f,
                p,
                r = t.offsetParent
                  ? { width: t.offsetWidth, height: t.offsetHeight }
                  : this.getHiddenElementDimensions(t),
                o = r.height,
                s = r.width,
                a = i.offsetHeight,
                l = i.offsetWidth,
                c = i.getBoundingClientRect(),
                u = this.getWindowScrollTop(),
                d = this.getWindowScrollLeft(),
                h = this.getViewport();
              c.top + a + o > h.height
                ? ((f = c.top + u - o),
                  (t.style.transformOrigin = "bottom"),
                  f < 0 && (f = u))
                : ((f = a + c.top + u), (t.style.transformOrigin = "top")),
                (p =
                  c.left + s > h.width
                    ? Math.max(0, c.left + d + l - s)
                    : c.left + d),
                (t.style.top = f + "px"),
                (t.style.left = p + "px");
            }
            static getParents(t, i = []) {
              return null === t.parentNode
                ? i
                : this.getParents(t.parentNode, i.concat([t.parentNode]));
            }
            static getScrollableParents(t) {
              let i = [];
              if (t) {
                let r = this.getParents(t);
                const o = /(auto|scroll)/,
                  s = (a) => {
                    let l = window.getComputedStyle(a, null);
                    return (
                      o.test(l.getPropertyValue("overflow")) ||
                      o.test(l.getPropertyValue("overflowX")) ||
                      o.test(l.getPropertyValue("overflowY"))
                    );
                  };
                for (let a of r) {
                  let l = 1 === a.nodeType && a.dataset.scrollselectors;
                  if (l) {
                    let c = l.split(",");
                    for (let u of c) {
                      let d = this.findSingle(a, u);
                      d && s(d) && i.push(d);
                    }
                  }
                  9 !== a.nodeType && s(a) && i.push(a);
                }
              }
              return i;
            }
            static getHiddenElementOuterHeight(t) {
              (t.style.visibility = "hidden"), (t.style.display = "block");
              let i = t.offsetHeight;
              return (
                (t.style.display = "none"), (t.style.visibility = "visible"), i
              );
            }
            static getHiddenElementOuterWidth(t) {
              (t.style.visibility = "hidden"), (t.style.display = "block");
              let i = t.offsetWidth;
              return (
                (t.style.display = "none"), (t.style.visibility = "visible"), i
              );
            }
            static getHiddenElementDimensions(t) {
              let i = {};
              return (
                (t.style.visibility = "hidden"),
                (t.style.display = "block"),
                (i.width = t.offsetWidth),
                (i.height = t.offsetHeight),
                (t.style.display = "none"),
                (t.style.visibility = "visible"),
                i
              );
            }
            static scrollInView(t, i) {
              let r = getComputedStyle(t).getPropertyValue("borderTopWidth"),
                o = r ? parseFloat(r) : 0,
                s = getComputedStyle(t).getPropertyValue("paddingTop"),
                a = s ? parseFloat(s) : 0,
                l = t.getBoundingClientRect(),
                u =
                  i.getBoundingClientRect().top +
                  document.body.scrollTop -
                  (l.top + document.body.scrollTop) -
                  o -
                  a,
                d = t.scrollTop,
                h = t.clientHeight,
                f = this.getOuterHeight(i);
              u < 0
                ? (t.scrollTop = d + u)
                : u + f > h && (t.scrollTop = d + u - h + f);
            }
            static fadeIn(t, i) {
              t.style.opacity = 0;
              let r = +new Date(),
                o = 0,
                s = function () {
                  (o =
                    +t.style.opacity.replace(",", ".") +
                    (new Date().getTime() - r) / i),
                    (t.style.opacity = o),
                    (r = +new Date()),
                    +o < 1 &&
                      ((window.requestAnimationFrame &&
                        requestAnimationFrame(s)) ||
                        setTimeout(s, 16));
                };
              s();
            }
            static fadeOut(t, i) {
              var r = 1,
                a = 50 / i;
              let l = setInterval(() => {
                (r -= a) <= 0 && ((r = 0), clearInterval(l)),
                  (t.style.opacity = r);
              }, 50);
            }
            static getWindowScrollTop() {
              let t = document.documentElement;
              return (window.pageYOffset || t.scrollTop) - (t.clientTop || 0);
            }
            static getWindowScrollLeft() {
              let t = document.documentElement;
              return (window.pageXOffset || t.scrollLeft) - (t.clientLeft || 0);
            }
            static matches(t, i) {
              var r = Element.prototype;
              return (
                r.matches ||
                r.webkitMatchesSelector ||
                r.mozMatchesSelector ||
                r.msMatchesSelector ||
                function (s) {
                  return (
                    -1 !== [].indexOf.call(document.querySelectorAll(s), this)
                  );
                }
              ).call(t, i);
            }
            static getOuterWidth(t, i) {
              let r = t.offsetWidth;
              if (i) {
                let o = getComputedStyle(t);
                r += parseFloat(o.marginLeft) + parseFloat(o.marginRight);
              }
              return r;
            }
            static getHorizontalPadding(t) {
              let i = getComputedStyle(t);
              return parseFloat(i.paddingLeft) + parseFloat(i.paddingRight);
            }
            static getHorizontalMargin(t) {
              let i = getComputedStyle(t);
              return parseFloat(i.marginLeft) + parseFloat(i.marginRight);
            }
            static innerWidth(t) {
              let i = t.offsetWidth,
                r = getComputedStyle(t);
              return (
                (i += parseFloat(r.paddingLeft) + parseFloat(r.paddingRight)), i
              );
            }
            static width(t) {
              let i = t.offsetWidth,
                r = getComputedStyle(t);
              return (
                (i -= parseFloat(r.paddingLeft) + parseFloat(r.paddingRight)), i
              );
            }
            static getInnerHeight(t) {
              let i = t.offsetHeight,
                r = getComputedStyle(t);
              return (
                (i += parseFloat(r.paddingTop) + parseFloat(r.paddingBottom)), i
              );
            }
            static getOuterHeight(t, i) {
              let r = t.offsetHeight;
              if (i) {
                let o = getComputedStyle(t);
                r += parseFloat(o.marginTop) + parseFloat(o.marginBottom);
              }
              return r;
            }
            static getHeight(t) {
              let i = t.offsetHeight,
                r = getComputedStyle(t);
              return (
                (i -=
                  parseFloat(r.paddingTop) +
                  parseFloat(r.paddingBottom) +
                  parseFloat(r.borderTopWidth) +
                  parseFloat(r.borderBottomWidth)),
                i
              );
            }
            static getWidth(t) {
              let i = t.offsetWidth,
                r = getComputedStyle(t);
              return (
                (i -=
                  parseFloat(r.paddingLeft) +
                  parseFloat(r.paddingRight) +
                  parseFloat(r.borderLeftWidth) +
                  parseFloat(r.borderRightWidth)),
                i
              );
            }
            static getViewport() {
              let t = window,
                i = document,
                r = i.documentElement,
                o = i.getElementsByTagName("body")[0];
              return {
                width: t.innerWidth || r.clientWidth || o.clientWidth,
                height: t.innerHeight || r.clientHeight || o.clientHeight,
              };
            }
            static getOffset(t) {
              var i = t.getBoundingClientRect();
              return {
                top:
                  i.top +
                  (window.pageYOffset ||
                    document.documentElement.scrollTop ||
                    document.body.scrollTop ||
                    0),
                left:
                  i.left +
                  (window.pageXOffset ||
                    document.documentElement.scrollLeft ||
                    document.body.scrollLeft ||
                    0),
              };
            }
            static replaceElementWith(t, i) {
              let r = t.parentNode;
              if (!r) throw "Can't replace element";
              return r.replaceChild(i, t);
            }
            static getUserAgent() {
              return navigator.userAgent;
            }
            static isIE() {
              var t = window.navigator.userAgent;
              return (
                t.indexOf("MSIE ") > 0 ||
                (t.indexOf("Trident/") > 0
                  ? (t.indexOf("rv:"), !0)
                  : t.indexOf("Edge/") > 0)
              );
            }
            static isIOS() {
              return (
                /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream
              );
            }
            static isAndroid() {
              return /(android)/i.test(navigator.userAgent);
            }
            static isTouchDevice() {
              return "ontouchstart" in window || navigator.maxTouchPoints > 0;
            }
            static appendChild(t, i) {
              if (this.isElement(i)) i.appendChild(t);
              else {
                if (!i.el || !i.el.nativeElement)
                  throw "Cannot append " + i + " to " + t;
                i.el.nativeElement.appendChild(t);
              }
            }
            static removeChild(t, i) {
              if (this.isElement(i)) i.removeChild(t);
              else {
                if (!i.el || !i.el.nativeElement)
                  throw "Cannot remove " + t + " from " + i;
                i.el.nativeElement.removeChild(t);
              }
            }
            static removeElement(t) {
              "remove" in Element.prototype
                ? t.remove()
                : t.parentNode.removeChild(t);
            }
            static isElement(t) {
              return "object" == typeof HTMLElement
                ? t instanceof HTMLElement
                : t &&
                    "object" == typeof t &&
                    null !== t &&
                    1 === t.nodeType &&
                    "string" == typeof t.nodeName;
            }
            static calculateScrollbarWidth(t) {
              if (t) {
                let i = getComputedStyle(t);
                return (
                  t.offsetWidth -
                  t.clientWidth -
                  parseFloat(i.borderLeftWidth) -
                  parseFloat(i.borderRightWidth)
                );
              }
              {
                if (null !== this.calculatedScrollbarWidth)
                  return this.calculatedScrollbarWidth;
                let i = document.createElement("div");
                (i.className = "p-scrollbar-measure"),
                  document.body.appendChild(i);
                let r = i.offsetWidth - i.clientWidth;
                return (
                  document.body.removeChild(i),
                  (this.calculatedScrollbarWidth = r),
                  r
                );
              }
            }
            static calculateScrollbarHeight() {
              if (null !== this.calculatedScrollbarHeight)
                return this.calculatedScrollbarHeight;
              let t = document.createElement("div");
              (t.className = "p-scrollbar-measure"),
                document.body.appendChild(t);
              let i = t.offsetHeight - t.clientHeight;
              return (
                document.body.removeChild(t),
                (this.calculatedScrollbarWidth = i),
                i
              );
            }
            static invokeElementMethod(t, i, r) {
              t[i].apply(t, r);
            }
            static clearSelection() {
              if (window.getSelection)
                window.getSelection().empty
                  ? window.getSelection().empty()
                  : window.getSelection().removeAllRanges &&
                    window.getSelection().rangeCount > 0 &&
                    window.getSelection().getRangeAt(0).getClientRects()
                      .length > 0 &&
                    window.getSelection().removeAllRanges();
              else if (document.selection && document.selection.empty)
                try {
                  document.selection.empty();
                } catch {}
            }
            static getBrowser() {
              if (!this.browser) {
                let t = this.resolveUserAgent();
                (this.browser = {}),
                  t.browser &&
                    ((this.browser[t.browser] = !0),
                    (this.browser.version = t.version)),
                  this.browser.chrome
                    ? (this.browser.webkit = !0)
                    : this.browser.webkit && (this.browser.safari = !0);
              }
              return this.browser;
            }
            static resolveUserAgent() {
              let t = navigator.userAgent.toLowerCase(),
                i =
                  /(chrome)[ \/]([\w.]+)/.exec(t) ||
                  /(webkit)[ \/]([\w.]+)/.exec(t) ||
                  /(opera)(?:.*version|)[ \/]([\w.]+)/.exec(t) ||
                  /(msie) ([\w.]+)/.exec(t) ||
                  (t.indexOf("compatible") < 0 &&
                    /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(t)) ||
                  [];
              return { browser: i[1] || "", version: i[2] || "0" };
            }
            static isInteger(t) {
              return Number.isInteger
                ? Number.isInteger(t)
                : "number" == typeof t && isFinite(t) && Math.floor(t) === t;
            }
            static isHidden(t) {
              return null === t.offsetParent;
            }
            static getFocusableElements(t) {
              let i = n.find(
                  t,
                  'button:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden]),\n                [href][clientHeight][clientWidth]:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden]),\n                input:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden]), select:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden]),\n                textarea:not([tabindex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden]), [tabIndex]:not([tabIndex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden]),\n                [contenteditable]:not([tabIndex = "-1"]):not([disabled]):not([style*="display:none"]):not([hidden]):not(.p-disabled)'
                ),
                r = [];
              for (let o of i)
                "none" != getComputedStyle(o).display &&
                  "hidden" != getComputedStyle(o).visibility &&
                  r.push(o);
              return r;
            }
            static generateZIndex() {
              return (this.zindex = this.zindex || 999), ++this.zindex;
            }
          }
          return (
            (n.zindex = 1e3),
            (n.calculatedScrollbarWidth = null),
            (n.calculatedScrollbarHeight = null),
            n
          );
        })();
      class lt {
        static equals(e, t, i) {
          return i
            ? this.resolveFieldData(e, i) === this.resolveFieldData(t, i)
            : this.equalsByValue(e, t);
        }
        static equalsByValue(e, t) {
          if (e === t) return !0;
          if (e && t && "object" == typeof e && "object" == typeof t) {
            var o,
              s,
              a,
              i = Array.isArray(e),
              r = Array.isArray(t);
            if (i && r) {
              if ((s = e.length) != t.length) return !1;
              for (o = s; 0 != o--; )
                if (!this.equalsByValue(e[o], t[o])) return !1;
              return !0;
            }
            if (i != r) return !1;
            var l = e instanceof Date,
              c = t instanceof Date;
            if (l != c) return !1;
            if (l && c) return e.getTime() == t.getTime();
            var u = e instanceof RegExp,
              d = t instanceof RegExp;
            if (u != d) return !1;
            if (u && d) return e.toString() == t.toString();
            var h = Object.keys(e);
            if ((s = h.length) !== Object.keys(t).length) return !1;
            for (o = s; 0 != o--; )
              if (!Object.prototype.hasOwnProperty.call(t, h[o])) return !1;
            for (o = s; 0 != o--; )
              if (!this.equalsByValue(e[(a = h[o])], t[a])) return !1;
            return !0;
          }
          return e != e && t != t;
        }
        static resolveFieldData(e, t) {
          if (e && t) {
            if (this.isFunction(t)) return t(e);
            if (-1 == t.indexOf(".")) return e[t];
            {
              let i = t.split("."),
                r = e;
              for (let o = 0, s = i.length; o < s; ++o) {
                if (null == r) return null;
                r = r[i[o]];
              }
              return r;
            }
          }
          return null;
        }
        static isFunction(e) {
          return !!(e && e.constructor && e.call && e.apply);
        }
        static reorderArray(e, t, i) {
          e &&
            t !== i &&
            (i >= e.length && ((i %= e.length), (t %= e.length)),
            e.splice(i, 0, e.splice(t, 1)[0]));
        }
        static insertIntoOrderedArray(e, t, i, r) {
          if (i.length > 0) {
            let o = !1;
            for (let s = 0; s < i.length; s++)
              if (this.findIndexInList(i[s], r) > t) {
                i.splice(s, 0, e), (o = !0);
                break;
              }
            o || i.push(e);
          } else i.push(e);
        }
        static findIndexInList(e, t) {
          let i = -1;
          if (t)
            for (let r = 0; r < t.length; r++)
              if (t[r] == e) {
                i = r;
                break;
              }
          return i;
        }
        static contains(e, t) {
          if (null != e && t && t.length)
            for (let i of t) if (this.equals(e, i)) return !0;
          return !1;
        }
        static removeAccents(e) {
          return (
            e &&
              e.search(/[\xC0-\xFF]/g) > -1 &&
              (e = e
                .replace(/[\xC0-\xC5]/g, "A")
                .replace(/[\xC6]/g, "AE")
                .replace(/[\xC7]/g, "C")
                .replace(/[\xC8-\xCB]/g, "E")
                .replace(/[\xCC-\xCF]/g, "I")
                .replace(/[\xD0]/g, "D")
                .replace(/[\xD1]/g, "N")
                .replace(/[\xD2-\xD6\xD8]/g, "O")
                .replace(/[\xD9-\xDC]/g, "U")
                .replace(/[\xDD]/g, "Y")
                .replace(/[\xDE]/g, "P")
                .replace(/[\xE0-\xE5]/g, "a")
                .replace(/[\xE6]/g, "ae")
                .replace(/[\xE7]/g, "c")
                .replace(/[\xE8-\xEB]/g, "e")
                .replace(/[\xEC-\xEF]/g, "i")
                .replace(/[\xF1]/g, "n")
                .replace(/[\xF2-\xF6\xF8]/g, "o")
                .replace(/[\xF9-\xFC]/g, "u")
                .replace(/[\xFE]/g, "p")
                .replace(/[\xFD\xFF]/g, "y")),
            e
          );
        }
        static isEmpty(e) {
          return (
            null == e ||
            "" === e ||
            (Array.isArray(e) && 0 === e.length) ||
            (!(e instanceof Date) &&
              "object" == typeof e &&
              0 === Object.keys(e).length)
          );
        }
        static isNotEmpty(e) {
          return !this.isEmpty(e);
        }
      }
      !(function Z3() {
        let n = [];
        const r = (o) => (o && parseInt(o.style.zIndex, 10)) || 0;
      })();
      const AI = ["*"];
      let Zt = (() => {
          class n {}
          return (
            (n.STARTS_WITH = "startsWith"),
            (n.CONTAINS = "contains"),
            (n.NOT_CONTAINS = "notContains"),
            (n.ENDS_WITH = "endsWith"),
            (n.EQUALS = "equals"),
            (n.NOT_EQUALS = "notEquals"),
            (n.IN = "in"),
            (n.LESS_THAN = "lt"),
            (n.LESS_THAN_OR_EQUAL_TO = "lte"),
            (n.GREATER_THAN = "gt"),
            (n.GREATER_THAN_OR_EQUAL_TO = "gte"),
            (n.BETWEEN = "between"),
            (n.IS = "is"),
            (n.IS_NOT = "isNot"),
            (n.BEFORE = "before"),
            (n.AFTER = "after"),
            (n.DATE_IS = "dateIs"),
            (n.DATE_IS_NOT = "dateIsNot"),
            (n.DATE_BEFORE = "dateBefore"),
            (n.DATE_AFTER = "dateAfter"),
            n
          );
        })(),
        OI = (() => {
          class n {
            constructor() {
              (this.ripple = !1),
                (this.filterMatchModeOptions = {
                  text: [
                    Zt.STARTS_WITH,
                    Zt.CONTAINS,
                    Zt.NOT_CONTAINS,
                    Zt.ENDS_WITH,
                    Zt.EQUALS,
                    Zt.NOT_EQUALS,
                  ],
                  numeric: [
                    Zt.EQUALS,
                    Zt.NOT_EQUALS,
                    Zt.LESS_THAN,
                    Zt.LESS_THAN_OR_EQUAL_TO,
                    Zt.GREATER_THAN,
                    Zt.GREATER_THAN_OR_EQUAL_TO,
                  ],
                  date: [
                    Zt.DATE_IS,
                    Zt.DATE_IS_NOT,
                    Zt.DATE_BEFORE,
                    Zt.DATE_AFTER,
                  ],
                }),
                (this.translation = {
                  startsWith: "Starts with",
                  contains: "Contains",
                  notContains: "Not contains",
                  endsWith: "Ends with",
                  equals: "Equals",
                  notEquals: "Not equals",
                  noFilter: "No Filter",
                  lt: "Less than",
                  lte: "Less than or equal to",
                  gt: "Greater than",
                  gte: "Greater than or equal to",
                  is: "Is",
                  isNot: "Is not",
                  before: "Before",
                  after: "After",
                  dateIs: "Date is",
                  dateIsNot: "Date is not",
                  dateBefore: "Date is before",
                  dateAfter: "Date is after",
                  clear: "Clear",
                  apply: "Apply",
                  matchAll: "Match All",
                  matchAny: "Match Any",
                  addRule: "Add Rule",
                  removeRule: "Remove Rule",
                  accept: "Yes",
                  reject: "No",
                  choose: "Choose",
                  upload: "Upload",
                  cancel: "Cancel",
                  dayNames: [
                    "Sunday",
                    "Monday",
                    "Tuesday",
                    "Wednesday",
                    "Thursday",
                    "Friday",
                    "Saturday",
                  ],
                  dayNamesShort: [
                    "Sun",
                    "Mon",
                    "Tue",
                    "Wed",
                    "Thu",
                    "Fri",
                    "Sat",
                  ],
                  dayNamesMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
                  monthNames: [
                    "January",
                    "February",
                    "March",
                    "April",
                    "May",
                    "June",
                    "July",
                    "August",
                    "September",
                    "October",
                    "November",
                    "December",
                  ],
                  monthNamesShort: [
                    "Jan",
                    "Feb",
                    "Mar",
                    "Apr",
                    "May",
                    "Jun",
                    "Jul",
                    "Aug",
                    "Sep",
                    "Oct",
                    "Nov",
                    "Dec",
                  ],
                  dateFormat: "mm/dd/yy",
                  firstDayOfWeek: 0,
                  today: "Today",
                  weekHeader: "Wk",
                  weak: "Weak",
                  medium: "Medium",
                  strong: "Strong",
                  passwordPrompt: "Enter a password",
                  emptyMessage: "No results found",
                  emptyFilterMessage: "No results found",
                }),
                (this.zIndex = {
                  modal: 1100,
                  overlay: 1e3,
                  menu: 1e3,
                  tooltip: 1100,
                }),
                (this.translationSource = new _e()),
                (this.translationObserver =
                  this.translationSource.asObservable());
            }
            getTranslation(t) {
              return this.translation[t];
            }
            setTranslation(t) {
              (this.translation = { ...this.translation, ...t }),
                this.translationSource.next(this.translation);
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵprov = j({ token: n, factory: n.ɵfac, providedIn: "root" })),
            n
          );
        })(),
        kI = (() => {
          class n {}
          return (
            (n.STARTS_WITH = "startsWith"),
            (n.CONTAINS = "contains"),
            (n.NOT_CONTAINS = "notContains"),
            (n.ENDS_WITH = "endsWith"),
            (n.EQUALS = "equals"),
            (n.NOT_EQUALS = "notEquals"),
            (n.NO_FILTER = "noFilter"),
            (n.LT = "lt"),
            (n.LTE = "lte"),
            (n.GT = "gt"),
            (n.GTE = "gte"),
            (n.IS = "is"),
            (n.IS_NOT = "isNot"),
            (n.BEFORE = "before"),
            (n.AFTER = "after"),
            (n.CLEAR = "clear"),
            (n.APPLY = "apply"),
            (n.MATCH_ALL = "matchAll"),
            (n.MATCH_ANY = "matchAny"),
            (n.ADD_RULE = "addRule"),
            (n.REMOVE_RULE = "removeRule"),
            (n.ACCEPT = "accept"),
            (n.REJECT = "reject"),
            (n.CHOOSE = "choose"),
            (n.UPLOAD = "upload"),
            (n.CANCEL = "cancel"),
            (n.DAY_NAMES = "dayNames"),
            (n.DAY_NAMES_SHORT = "dayNamesShort"),
            (n.DAY_NAMES_MIN = "dayNamesMin"),
            (n.MONTH_NAMES = "monthNames"),
            (n.MONTH_NAMES_SHORT = "monthNamesShort"),
            (n.FIRST_DAY_OF_WEEK = "firstDayOfWeek"),
            (n.TODAY = "today"),
            (n.WEEK_HEADER = "weekHeader"),
            (n.WEAK = "weak"),
            (n.MEDIUM = "medium"),
            (n.STRONG = "strong"),
            (n.PASSWORD_PROMPT = "passwordPrompt"),
            (n.EMPTY_MESSAGE = "emptyMessage"),
            (n.EMPTY_FILTER_MESSAGE = "emptyFilterMessage"),
            n
          );
        })(),
        Q3 = (() => {
          class n {
            constructor() {
              this.filters = {
                startsWith: (t, i, r) => {
                  if (null == i || "" === i.trim()) return !0;
                  if (null == t) return !1;
                  let o = lt.removeAccents(i.toString()).toLocaleLowerCase(r);
                  return (
                    lt
                      .removeAccents(t.toString())
                      .toLocaleLowerCase(r)
                      .slice(0, o.length) === o
                  );
                },
                contains: (t, i, r) => {
                  if (null == i || ("string" == typeof i && "" === i.trim()))
                    return !0;
                  if (null == t) return !1;
                  let o = lt.removeAccents(i.toString()).toLocaleLowerCase(r);
                  return (
                    -1 !==
                    lt
                      .removeAccents(t.toString())
                      .toLocaleLowerCase(r)
                      .indexOf(o)
                  );
                },
                notContains: (t, i, r) => {
                  if (null == i || ("string" == typeof i && "" === i.trim()))
                    return !0;
                  if (null == t) return !1;
                  let o = lt.removeAccents(i.toString()).toLocaleLowerCase(r);
                  return (
                    -1 ===
                    lt
                      .removeAccents(t.toString())
                      .toLocaleLowerCase(r)
                      .indexOf(o)
                  );
                },
                endsWith: (t, i, r) => {
                  if (null == i || "" === i.trim()) return !0;
                  if (null == t) return !1;
                  let o = lt.removeAccents(i.toString()).toLocaleLowerCase(r),
                    s = lt.removeAccents(t.toString()).toLocaleLowerCase(r);
                  return -1 !== s.indexOf(o, s.length - o.length);
                },
                equals: (t, i, r) =>
                  null == i ||
                  ("string" == typeof i && "" === i.trim()) ||
                  (null != t &&
                    (t.getTime && i.getTime
                      ? t.getTime() === i.getTime()
                      : lt.removeAccents(t.toString()).toLocaleLowerCase(r) ==
                        lt.removeAccents(i.toString()).toLocaleLowerCase(r))),
                notEquals: (t, i, r) =>
                  !(
                    null == i ||
                    ("string" == typeof i && "" === i.trim()) ||
                    (null != t &&
                      (t.getTime && i.getTime
                        ? t.getTime() === i.getTime()
                        : lt.removeAccents(t.toString()).toLocaleLowerCase(r) ==
                          lt.removeAccents(i.toString()).toLocaleLowerCase(r)))
                  ),
                in: (t, i) => {
                  if (null == i || 0 === i.length) return !0;
                  for (let r = 0; r < i.length; r++)
                    if (lt.equals(t, i[r])) return !0;
                  return !1;
                },
                between: (t, i) =>
                  null == i ||
                  null == i[0] ||
                  null == i[1] ||
                  (null != t &&
                    (t.getTime
                      ? i[0].getTime() <= t.getTime() &&
                        t.getTime() <= i[1].getTime()
                      : i[0] <= t && t <= i[1])),
                lt: (t, i, r) =>
                  null == i ||
                  (null != t &&
                    (t.getTime && i.getTime
                      ? t.getTime() < i.getTime()
                      : t < i)),
                lte: (t, i, r) =>
                  null == i ||
                  (null != t &&
                    (t.getTime && i.getTime
                      ? t.getTime() <= i.getTime()
                      : t <= i)),
                gt: (t, i, r) =>
                  null == i ||
                  (null != t &&
                    (t.getTime && i.getTime
                      ? t.getTime() > i.getTime()
                      : t > i)),
                gte: (t, i, r) =>
                  null == i ||
                  (null != t &&
                    (t.getTime && i.getTime
                      ? t.getTime() >= i.getTime()
                      : t >= i)),
                is: (t, i, r) => this.filters.equals(t, i, r),
                isNot: (t, i, r) => this.filters.notEquals(t, i, r),
                before: (t, i, r) => this.filters.lt(t, i, r),
                after: (t, i, r) => this.filters.gt(t, i, r),
                dateIs: (t, i) =>
                  null == i ||
                  (null != t && t.toDateString() === i.toDateString()),
                dateIsNot: (t, i) =>
                  null == i ||
                  (null != t && t.toDateString() !== i.toDateString()),
                dateBefore: (t, i) =>
                  null == i || (null != t && t.getTime() < i.getTime()),
                dateAfter: (t, i) =>
                  null == i || (null != t && t.getTime() > i.getTime()),
              };
            }
            filter(t, i, r, o, s) {
              let a = [];
              if (t)
                for (let l of t)
                  for (let c of i) {
                    let u = lt.resolveFieldData(l, c);
                    if (this.filters[o](u, r, s)) {
                      a.push(l);
                      break;
                    }
                  }
              return a;
            }
            register(t, i) {
              this.filters[t] = i;
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵprov = j({ token: n, factory: n.ɵfac, providedIn: "root" })),
            n
          );
        })(),
        NI = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵcmp = ht({
              type: n,
              selectors: [["p-header"]],
              ngContentSelectors: AI,
              decls: 1,
              vars: 0,
              template: function (t, i) {
                1 & t && (da(), Cr(0));
              },
              encapsulation: 2,
            })),
            n
          );
        })(),
        RI = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵcmp = ht({
              type: n,
              selectors: [["p-footer"]],
              ngContentSelectors: AI,
              decls: 1,
              vars: 0,
              template: function (t, i) {
                1 & t && (da(), Cr(0));
              },
              encapsulation: 2,
            })),
            n
          );
        })(),
        $y = (() => {
          class n {
            constructor(t) {
              this.template = t;
            }
            getType() {
              return this.name;
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(w(Gi));
            }),
            (n.ɵdir = q({
              type: n,
              selectors: [["", "pTemplate", ""]],
              inputs: { type: "type", name: ["pTemplate", "name"] },
            })),
            n
          );
        })(),
        fc = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = rt({ type: n })),
            (n.ɵinj = Xe({ imports: [bi] })),
            n
          );
        })(),
        J3 = (() => {
          class n {
            constructor(t, i, r) {
              (this.el = t), (this.zone = i), (this.config = r);
            }
            ngAfterViewInit() {
              this.config &&
                this.config.ripple &&
                this.zone.runOutsideAngular(() => {
                  this.create(),
                    (this.mouseDownListener = this.onMouseDown.bind(this)),
                    this.el.nativeElement.addEventListener(
                      "mousedown",
                      this.mouseDownListener
                    );
                });
            }
            onMouseDown(t) {
              let i = this.getInk();
              if (!i || "none" === getComputedStyle(i, null).display) return;
              if (
                (Mt.removeClass(i, "p-ink-active"),
                !Mt.getHeight(i) && !Mt.getWidth(i))
              ) {
                let a = Math.max(
                  Mt.getOuterWidth(this.el.nativeElement),
                  Mt.getOuterHeight(this.el.nativeElement)
                );
                (i.style.height = a + "px"), (i.style.width = a + "px");
              }
              let r = Mt.getOffset(this.el.nativeElement),
                o =
                  t.pageX -
                  r.left +
                  document.body.scrollTop -
                  Mt.getWidth(i) / 2,
                s =
                  t.pageY -
                  r.top +
                  document.body.scrollLeft -
                  Mt.getHeight(i) / 2;
              (i.style.top = s + "px"),
                (i.style.left = o + "px"),
                Mt.addClass(i, "p-ink-active");
            }
            getInk() {
              for (let t = 0; t < this.el.nativeElement.children.length; t++)
                if (
                  -1 !==
                  this.el.nativeElement.children[t].className.indexOf("p-ink")
                )
                  return this.el.nativeElement.children[t];
              return null;
            }
            resetInk() {
              let t = this.getInk();
              t && Mt.removeClass(t, "p-ink-active");
            }
            onAnimationEnd(t) {
              Mt.removeClass(t.currentTarget, "p-ink-active");
            }
            create() {
              let t = document.createElement("span");
              (t.className = "p-ink"),
                this.el.nativeElement.appendChild(t),
                (this.animationListener = this.onAnimationEnd.bind(this)),
                t.addEventListener("animationend", this.animationListener);
            }
            remove() {
              let t = this.getInk();
              t &&
                (this.el.nativeElement.removeEventListener(
                  "mousedown",
                  this.mouseDownListener
                ),
                t.removeEventListener("animationend", this.animationListener),
                Mt.removeElement(t));
            }
            ngOnDestroy() {
              this.config && this.config.ripple && this.remove();
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(w(ut), w(Ke), w(OI, 8));
            }),
            (n.ɵdir = q({
              type: n,
              selectors: [["", "pRipple", ""]],
              hostAttrs: [1, "p-ripple", "p-element"],
            })),
            n
          );
        })(),
        hh = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = rt({ type: n })),
            (n.ɵinj = Xe({ imports: [bi] })),
            n
          );
        })(),
        ez = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = rt({ type: n })),
            (n.ɵinj = Xe({ imports: [bi, hh] })),
            n
          );
        })();
      class tz extends Te {
        constructor(e, t) {
          super();
        }
        schedule(e, t = 0) {
          return this;
        }
      }
      class fh extends tz {
        constructor(e, t) {
          super(e, t),
            (this.scheduler = e),
            (this.work = t),
            (this.pending = !1);
        }
        schedule(e, t = 0) {
          if (this.closed) return this;
          this.state = e;
          const i = this.id,
            r = this.scheduler;
          return (
            null != i && (this.id = this.recycleAsyncId(r, i, t)),
            (this.pending = !0),
            (this.delay = t),
            (this.id = this.id || this.requestAsyncId(r, this.id, t)),
            this
          );
        }
        requestAsyncId(e, t, i = 0) {
          return setInterval(e.flush.bind(e, this), i);
        }
        recycleAsyncId(e, t, i = 0) {
          if (null !== i && this.delay === i && !1 === this.pending) return t;
          clearInterval(t);
        }
        execute(e, t) {
          if (this.closed) return new Error("executing a cancelled action");
          this.pending = !1;
          const i = this._execute(e, t);
          if (i) return i;
          !1 === this.pending &&
            null != this.id &&
            (this.id = this.recycleAsyncId(this.scheduler, this.id, null));
        }
        _execute(e, t) {
          let r,
            i = !1;
          try {
            this.work(e);
          } catch (o) {
            (i = !0), (r = (!!o && o) || new Error(o));
          }
          if (i) return this.unsubscribe(), r;
        }
        _unsubscribe() {
          const e = this.id,
            t = this.scheduler,
            i = t.actions,
            r = i.indexOf(this);
          (this.work = null),
            (this.state = null),
            (this.pending = !1),
            (this.scheduler = null),
            -1 !== r && i.splice(r, 1),
            null != e && (this.id = this.recycleAsyncId(t, e, null)),
            (this.delay = null);
        }
      }
      let PI = (() => {
        class n {
          constructor(t, i = n.now) {
            (this.SchedulerAction = t), (this.now = i);
          }
          schedule(t, i = 0, r) {
            return new this.SchedulerAction(this, t).schedule(r, i);
          }
        }
        return (n.now = () => Date.now()), n;
      })();
      class Di extends PI {
        constructor(e, t = PI.now) {
          super(e, () =>
            Di.delegate && Di.delegate !== this ? Di.delegate.now() : t()
          ),
            (this.actions = []),
            (this.active = !1),
            (this.scheduled = void 0);
        }
        schedule(e, t = 0, i) {
          return Di.delegate && Di.delegate !== this
            ? Di.delegate.schedule(e, t, i)
            : super.schedule(e, t, i);
        }
        flush(e) {
          const { actions: t } = this;
          if (this.active) return void t.push(e);
          let i;
          this.active = !0;
          do {
            if ((i = e.execute(e.state, e.delay))) break;
          } while ((e = t.shift()));
          if (((this.active = !1), i)) {
            for (; (e = t.shift()); ) e.unsubscribe();
            throw i;
          }
        }
      }
      const FI = new (class iz extends Di {
        flush(e) {
          (this.active = !0), (this.scheduled = void 0);
          const { actions: t } = this;
          let i,
            r = -1,
            o = t.length;
          e = e || t.shift();
          do {
            if ((i = e.execute(e.state, e.delay))) break;
          } while (++r < o && (e = t.shift()));
          if (((this.active = !1), i)) {
            for (; ++r < o && (e = t.shift()); ) e.unsubscribe();
            throw i;
          }
        }
      })(
        class nz extends fh {
          constructor(e, t) {
            super(e, t), (this.scheduler = e), (this.work = t);
          }
          requestAsyncId(e, t, i = 0) {
            return null !== i && i > 0
              ? super.requestAsyncId(e, t, i)
              : (e.actions.push(this),
                e.scheduled ||
                  (e.scheduled = requestAnimationFrame(() => e.flush(null))));
          }
          recycleAsyncId(e, t, i = 0) {
            if ((null !== i && i > 0) || (null === i && this.delay > 0))
              return super.recycleAsyncId(e, t, i);
            0 === e.actions.length &&
              (cancelAnimationFrame(t), (e.scheduled = void 0));
          }
        }
      );
      let rz = 1;
      const oz = Promise.resolve(),
        ph = {};
      function LI(n) {
        return n in ph && (delete ph[n], !0);
      }
      const VI = {
          setImmediate(n) {
            const e = rz++;
            return (ph[e] = !0), oz.then(() => LI(e) && n()), e;
          },
          clearImmediate(n) {
            LI(n);
          },
        },
        pc =
          (new (class az extends Di {
            flush(e) {
              (this.active = !0), (this.scheduled = void 0);
              const { actions: t } = this;
              let i,
                r = -1,
                o = t.length;
              e = e || t.shift();
              do {
                if ((i = e.execute(e.state, e.delay))) break;
              } while (++r < o && (e = t.shift()));
              if (((this.active = !1), i)) {
                for (; ++r < o && (e = t.shift()); ) e.unsubscribe();
                throw i;
              }
            }
          })(
            class sz extends fh {
              constructor(e, t) {
                super(e, t), (this.scheduler = e), (this.work = t);
              }
              requestAsyncId(e, t, i = 0) {
                return null !== i && i > 0
                  ? super.requestAsyncId(e, t, i)
                  : (e.actions.push(this),
                    e.scheduled ||
                      (e.scheduled = VI.setImmediate(e.flush.bind(e, null))));
              }
              recycleAsyncId(e, t, i = 0) {
                if ((null !== i && i > 0) || (null === i && this.delay > 0))
                  return super.recycleAsyncId(e, t, i);
                0 === e.actions.length &&
                  (VI.clearImmediate(t), (e.scheduled = void 0));
              }
            }
          ),
          new Di(fh));
      class uz {
        constructor(e) {
          this.durationSelector = e;
        }
        call(e, t) {
          return t.subscribe(new dz(e, this.durationSelector));
        }
      }
      class dz extends hl {
        constructor(e, t) {
          super(e), (this.durationSelector = t), (this.hasValue = !1);
        }
        _next(e) {
          if (((this.value = e), (this.hasValue = !0), !this.throttled)) {
            let t;
            try {
              const { durationSelector: r } = this;
              t = r(e);
            } catch (r) {
              return this.destination.error(r);
            }
            const i = fl(t, new dl(this));
            !i || i.closed
              ? this.clearThrottle()
              : this.add((this.throttled = i));
          }
        }
        clearThrottle() {
          const { value: e, hasValue: t, throttled: i } = this;
          i && (this.remove(i), (this.throttled = void 0), i.unsubscribe()),
            t &&
              ((this.value = void 0),
              (this.hasValue = !1),
              this.destination.next(e));
        }
        notifyNext() {
          this.clearThrottle();
        }
        notifyComplete() {
          this.clearThrottle();
        }
      }
      function Wy(n) {
        return !cl(n) && n - parseFloat(n) + 1 >= 0;
      }
      function fz(n) {
        const { index: e, period: t, subscriber: i } = n;
        if ((i.next(e), !i.closed)) {
          if (-1 === t) return i.complete();
          (n.index = e + 1), this.schedule(n, t);
        }
      }
      let Gy;
      try {
        Gy = typeof Intl < "u" && Intl.v8BreakIterator;
      } catch {
        Gy = !1;
      }
      let gc,
        qy,
        gz = (() => {
          class n {
            constructor(t) {
              (this._platformId = t),
                (this.isBrowser = this._platformId
                  ? (function dU(n) {
                      return n === XS;
                    })(this._platformId)
                  : "object" == typeof document && !!document),
                (this.EDGE =
                  this.isBrowser && /(edge)/i.test(navigator.userAgent)),
                (this.TRIDENT =
                  this.isBrowser &&
                  /(msie|trident)/i.test(navigator.userAgent)),
                (this.BLINK =
                  this.isBrowser &&
                  !(!window.chrome && !Gy) &&
                  typeof CSS < "u" &&
                  !this.EDGE &&
                  !this.TRIDENT),
                (this.WEBKIT =
                  this.isBrowser &&
                  /AppleWebKit/i.test(navigator.userAgent) &&
                  !this.BLINK &&
                  !this.EDGE &&
                  !this.TRIDENT),
                (this.IOS =
                  this.isBrowser &&
                  /iPad|iPhone|iPod/.test(navigator.userAgent) &&
                  !("MSStream" in window)),
                (this.FIREFOX =
                  this.isBrowser &&
                  /(firefox|minefield)/i.test(navigator.userAgent)),
                (this.ANDROID =
                  this.isBrowser &&
                  /android/i.test(navigator.userAgent) &&
                  !this.TRIDENT),
                (this.SAFARI =
                  this.isBrowser &&
                  /safari/i.test(navigator.userAgent) &&
                  this.WEBKIT);
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(T(Od));
            }),
            (n.ɵprov = j({ token: n, factory: n.ɵfac, providedIn: "root" })),
            n
          );
        })();
      function mc(n) {
        return (function mz() {
          if (null == gc && typeof window < "u")
            try {
              window.addEventListener(
                "test",
                null,
                Object.defineProperty({}, "passive", { get: () => (gc = !0) })
              );
            } finally {
              gc = gc || !1;
            }
          return gc;
        })()
          ? n
          : !!n.capture;
      }
      function jI(n) {
        if (
          (function yz() {
            if (null == qy) {
              const n = typeof document < "u" ? document.head : null;
              qy = !(!n || (!n.createShadowRoot && !n.attachShadow));
            }
            return qy;
          })()
        ) {
          const e = n.getRootNode ? n.getRootNode() : null;
          if (typeof ShadowRoot < "u" && ShadowRoot && e instanceof ShadowRoot)
            return e;
        }
        return null;
      }
      function mh(n) {
        return n.composedPath ? n.composedPath()[0] : n.target;
      }
      let _z = (() => {
          class n {
            constructor(t, i, r) {
              (this._platform = t),
                (this._change = new _e()),
                (this._changeListener = (o) => {
                  this._change.next(o);
                }),
                (this._document = r),
                i.runOutsideAngular(() => {
                  if (t.isBrowser) {
                    const o = this._getWindow();
                    o.addEventListener("resize", this._changeListener),
                      o.addEventListener(
                        "orientationchange",
                        this._changeListener
                      );
                  }
                  this.change().subscribe(() => (this._viewportSize = null));
                });
            }
            ngOnDestroy() {
              if (this._platform.isBrowser) {
                const t = this._getWindow();
                t.removeEventListener("resize", this._changeListener),
                  t.removeEventListener(
                    "orientationchange",
                    this._changeListener
                  );
              }
              this._change.complete();
            }
            getViewportSize() {
              this._viewportSize || this._updateViewportSize();
              const t = {
                width: this._viewportSize.width,
                height: this._viewportSize.height,
              };
              return this._platform.isBrowser || (this._viewportSize = null), t;
            }
            getViewportRect() {
              const t = this.getViewportScrollPosition(),
                { width: i, height: r } = this.getViewportSize();
              return {
                top: t.top,
                left: t.left,
                bottom: t.top + r,
                right: t.left + i,
                height: r,
                width: i,
              };
            }
            getViewportScrollPosition() {
              if (!this._platform.isBrowser) return { top: 0, left: 0 };
              const t = this._document,
                i = this._getWindow(),
                r = t.documentElement,
                o = r.getBoundingClientRect();
              return {
                top:
                  -o.top || t.body.scrollTop || i.scrollY || r.scrollTop || 0,
                left:
                  -o.left ||
                  t.body.scrollLeft ||
                  i.scrollX ||
                  r.scrollLeft ||
                  0,
              };
            }
            change(t = 20) {
              return t > 0
                ? this._change.pipe(
                    (function pz(n, e = pc) {
                      return (function cz(n) {
                        return function (t) {
                          return t.lift(new uz(n));
                        };
                      })(() =>
                        (function hz(n = 0, e, t) {
                          let i = -1;
                          return (
                            Wy(e)
                              ? (i = Number(e) < 1 ? 1 : Number(e))
                              : xs(e) && (t = e),
                            xs(t) || (t = pc),
                            new je((r) => {
                              const o = Wy(n) ? n : +n - t.now();
                              return t.schedule(fz, o, {
                                index: 0,
                                period: i,
                                subscriber: r,
                              });
                            })
                          );
                        })(n, e)
                      );
                    })(t)
                  )
                : this._change;
            }
            _getWindow() {
              return this._document.defaultView || window;
            }
            _updateViewportSize() {
              const t = this._getWindow();
              this._viewportSize = this._platform.isBrowser
                ? { width: t.innerWidth, height: t.innerHeight }
                : { width: 0, height: 0 };
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(T(gz), T(Ke), T(gt, 8));
            }),
            (n.ɵprov = j({ token: n, factory: n.ɵfac, providedIn: "root" })),
            n
          );
        })(),
        bz = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = rt({ type: n })),
            (n.ɵinj = Xe({})),
            n
          );
        })();
      function Xn(n) {
        return n instanceof ut ? n.nativeElement : n;
      }
      function so() {}
      function Vt(n, e, t) {
        return function (r) {
          return r.lift(new jz(n, e, t));
        };
      }
      class jz {
        constructor(e, t, i) {
          (this.nextOrObserver = e), (this.error = t), (this.complete = i);
        }
        call(e, t) {
          return t.subscribe(
            new Hz(e, this.nextOrObserver, this.error, this.complete)
          );
        }
      }
      class Hz extends Be {
        constructor(e, t, i, r) {
          super(e),
            (this._tapNext = so),
            (this._tapError = so),
            (this._tapComplete = so),
            (this._tapError = i || so),
            (this._tapComplete = r || so),
            Po(t)
              ? ((this._context = this), (this._tapNext = t))
              : t &&
                ((this._context = t),
                (this._tapNext = t.next || so),
                (this._tapError = t.error || so),
                (this._tapComplete = t.complete || so));
        }
        _next(e) {
          try {
            this._tapNext.call(this._context, e);
          } catch (t) {
            return void this.destination.error(t);
          }
          this.destination.next(e);
        }
        _error(e) {
          try {
            this._tapError.call(this._context, e);
          } catch (t) {
            return void this.destination.error(t);
          }
          this.destination.error(e);
        }
        _complete() {
          try {
            this._tapComplete.call(this._context);
          } catch (e) {
            return void this.destination.error(e);
          }
          return this.destination.complete();
        }
      }
      class zz {
        constructor(e, t) {
          (this.dueTime = e), (this.scheduler = t);
        }
        call(e, t) {
          return t.subscribe(new $z(e, this.dueTime, this.scheduler));
        }
      }
      class $z extends Be {
        constructor(e, t, i) {
          super(e),
            (this.dueTime = t),
            (this.scheduler = i),
            (this.debouncedSubscription = null),
            (this.lastValue = null),
            (this.hasValue = !1);
        }
        _next(e) {
          this.clearDebounce(),
            (this.lastValue = e),
            (this.hasValue = !0),
            this.add(
              (this.debouncedSubscription = this.scheduler.schedule(
                Wz,
                this.dueTime,
                this
              ))
            );
        }
        _complete() {
          this.debouncedNext(), this.destination.complete();
        }
        debouncedNext() {
          if ((this.clearDebounce(), this.hasValue)) {
            const { lastValue: e } = this;
            (this.lastValue = null),
              (this.hasValue = !1),
              this.destination.next(e);
          }
        }
        clearDebounce() {
          const e = this.debouncedSubscription;
          null !== e &&
            (this.remove(e),
            e.unsubscribe(),
            (this.debouncedSubscription = null));
        }
      }
      function Wz(n) {
        n.debouncedNext();
      }
      function ao(n, e) {
        return function (i) {
          return i.lift(new Gz(n, e));
        };
      }
      class Gz {
        constructor(e, t) {
          (this.predicate = e), (this.thisArg = t);
        }
        call(e, t) {
          return t.subscribe(new qz(e, this.predicate, this.thisArg));
        }
      }
      class qz extends Be {
        constructor(e, t, i) {
          super(e), (this.predicate = t), (this.thisArg = i), (this.count = 0);
        }
        _next(e) {
          let t;
          try {
            t = this.predicate.call(this.thisArg, e, this.count++);
          } catch (i) {
            return void this.destination.error(i);
          }
          t && this.destination.next(e);
        }
      }
      class zI extends class Zz {
        constructor(e) {
          (this._items = e),
            (this._activeItemIndex = -1),
            (this._activeItem = null),
            (this._wrap = !1),
            (this._letterKeyStream = new _e()),
            (this._typeaheadSubscription = Te.EMPTY),
            (this._vertical = !0),
            (this._allowedModifierKeys = []),
            (this._homeAndEnd = !1),
            (this._skipPredicateFn = (t) => t.disabled),
            (this._pressedLetters = []),
            (this.tabOut = new _e()),
            (this.change = new _e()),
            e instanceof Xl &&
              e.changes.subscribe((t) => {
                if (this._activeItem) {
                  const r = t.toArray().indexOf(this._activeItem);
                  r > -1 &&
                    r !== this._activeItemIndex &&
                    (this._activeItemIndex = r);
                }
              });
        }
        skipPredicate(e) {
          return (this._skipPredicateFn = e), this;
        }
        withWrap(e = !0) {
          return (this._wrap = e), this;
        }
        withVerticalOrientation(e = !0) {
          return (this._vertical = e), this;
        }
        withHorizontalOrientation(e) {
          return (this._horizontal = e), this;
        }
        withAllowedModifierKeys(e) {
          return (this._allowedModifierKeys = e), this;
        }
        withTypeAhead(e = 200) {
          return (
            this._typeaheadSubscription.unsubscribe(),
            (this._typeaheadSubscription = this._letterKeyStream
              .pipe(
                Vt((t) => this._pressedLetters.push(t)),
                (function Uz(n, e = pc) {
                  return (t) => t.lift(new zz(n, e));
                })(e),
                ao(() => this._pressedLetters.length > 0),
                ye(() => this._pressedLetters.join(""))
              )
              .subscribe((t) => {
                const i = this._getItemsArray();
                for (let r = 1; r < i.length + 1; r++) {
                  const o = (this._activeItemIndex + r) % i.length,
                    s = i[o];
                  if (
                    !this._skipPredicateFn(s) &&
                    0 === s.getLabel().toUpperCase().trim().indexOf(t)
                  ) {
                    this.setActiveItem(o);
                    break;
                  }
                }
                this._pressedLetters = [];
              })),
            this
          );
        }
        withHomeAndEnd(e = !0) {
          return (this._homeAndEnd = e), this;
        }
        setActiveItem(e) {
          const t = this._activeItem;
          this.updateActiveItem(e),
            this._activeItem !== t && this.change.next(this._activeItemIndex);
        }
        onKeydown(e) {
          const t = e.keyCode,
            r = ["altKey", "ctrlKey", "metaKey", "shiftKey"].every(
              (o) => !e[o] || this._allowedModifierKeys.indexOf(o) > -1
            );
          switch (t) {
            case 9:
              return void this.tabOut.next();
            case 40:
              if (this._vertical && r) {
                this.setNextItemActive();
                break;
              }
              return;
            case 38:
              if (this._vertical && r) {
                this.setPreviousItemActive();
                break;
              }
              return;
            case 39:
              if (this._horizontal && r) {
                "rtl" === this._horizontal
                  ? this.setPreviousItemActive()
                  : this.setNextItemActive();
                break;
              }
              return;
            case 37:
              if (this._horizontal && r) {
                "rtl" === this._horizontal
                  ? this.setNextItemActive()
                  : this.setPreviousItemActive();
                break;
              }
              return;
            case 36:
              if (this._homeAndEnd && r) {
                this.setFirstItemActive();
                break;
              }
              return;
            case 35:
              if (this._homeAndEnd && r) {
                this.setLastItemActive();
                break;
              }
              return;
            default:
              return void (
                (r ||
                  (function Bz(n, ...e) {
                    return e.length
                      ? e.some((t) => n[t])
                      : n.altKey || n.shiftKey || n.ctrlKey || n.metaKey;
                  })(e, "shiftKey")) &&
                (e.key && 1 === e.key.length
                  ? this._letterKeyStream.next(e.key.toLocaleUpperCase())
                  : ((t >= 65 && t <= 90) || (t >= 48 && t <= 57)) &&
                    this._letterKeyStream.next(String.fromCharCode(t)))
              );
          }
          (this._pressedLetters = []), e.preventDefault();
        }
        get activeItemIndex() {
          return this._activeItemIndex;
        }
        get activeItem() {
          return this._activeItem;
        }
        isTyping() {
          return this._pressedLetters.length > 0;
        }
        setFirstItemActive() {
          this._setActiveItemByIndex(0, 1);
        }
        setLastItemActive() {
          this._setActiveItemByIndex(this._items.length - 1, -1);
        }
        setNextItemActive() {
          this._activeItemIndex < 0
            ? this.setFirstItemActive()
            : this._setActiveItemByDelta(1);
        }
        setPreviousItemActive() {
          this._activeItemIndex < 0 && this._wrap
            ? this.setLastItemActive()
            : this._setActiveItemByDelta(-1);
        }
        updateActiveItem(e) {
          const t = this._getItemsArray(),
            i = "number" == typeof e ? e : t.indexOf(e);
          (this._activeItem = t[i] ?? null), (this._activeItemIndex = i);
        }
        _setActiveItemByDelta(e) {
          this._wrap
            ? this._setActiveInWrapMode(e)
            : this._setActiveInDefaultMode(e);
        }
        _setActiveInWrapMode(e) {
          const t = this._getItemsArray();
          for (let i = 1; i <= t.length; i++) {
            const r = (this._activeItemIndex + e * i + t.length) % t.length;
            if (!this._skipPredicateFn(t[r])) return void this.setActiveItem(r);
          }
        }
        _setActiveInDefaultMode(e) {
          this._setActiveItemByIndex(this._activeItemIndex + e, e);
        }
        _setActiveItemByIndex(e, t) {
          const i = this._getItemsArray();
          if (i[e]) {
            for (; this._skipPredicateFn(i[e]); ) if (!i[(e += t)]) return;
            this.setActiveItem(e);
          }
        }
        _getItemsArray() {
          return this._items instanceof Xl
            ? this._items.toArray()
            : this._items;
        }
      } {
        constructor() {
          super(...arguments), (this._origin = "program");
        }
        setFocusOrigin(e) {
          return (this._origin = e), this;
        }
        setActiveItem(e) {
          super.setActiveItem(e),
            this.activeItem && this.activeItem.focus(this._origin);
        }
      }
      function a4(n) {
        const { subscriber: e, counter: t, period: i } = n;
        e.next(t),
          this.schedule({ subscriber: e, counter: t + 1, period: i }, i);
      }
      function WI(n) {
        return (e) => e.lift(new l4(n));
      }
      class l4 {
        constructor(e) {
          this.notifier = e;
        }
        call(e, t) {
          const i = new c4(e),
            r = fl(this.notifier, new dl(i));
          return r && !i.seenValue ? (i.add(r), t.subscribe(i)) : i;
        }
      }
      class c4 extends hl {
        constructor(e) {
          super(e), (this.seenValue = !1);
        }
        notifyNext() {
          (this.seenValue = !0), this.complete();
        }
        notifyComplete() {}
      }
      function Ky(n, e, t) {
        for (let i in e)
          if (e.hasOwnProperty(i)) {
            const r = e[i];
            r
              ? n.setProperty(i, r, t?.has(i) ? "important" : "")
              : n.removeProperty(i);
          }
        return n;
      }
      function wa(n, e) {
        const t = e ? "" : "none";
        Ky(n.style, {
          "touch-action": e ? "" : "none",
          "-webkit-user-drag": e ? "" : "none",
          "-webkit-tap-highlight-color": e ? "" : "transparent",
          "user-select": t,
          "-ms-user-select": t,
          "-webkit-user-select": t,
          "-moz-user-select": t,
        });
      }
      function GI(n, e, t) {
        Ky(
          n.style,
          {
            position: e ? "" : "fixed",
            top: e ? "" : "0",
            opacity: e ? "" : "0",
            left: e ? "" : "-999em",
          },
          t
        );
      }
      function yh(n, e) {
        return e && "none" != e ? n + " " + e : n;
      }
      function qI(n) {
        const e = n.toLowerCase().indexOf("ms") > -1 ? 1 : 1e3;
        return parseFloat(n) * e;
      }
      function Yy(n, e) {
        return n
          .getPropertyValue(e)
          .split(",")
          .map((i) => i.trim());
      }
      function Zy(n) {
        const e = n.getBoundingClientRect();
        return {
          top: e.top,
          right: e.right,
          bottom: e.bottom,
          left: e.left,
          width: e.width,
          height: e.height,
          x: e.x,
          y: e.y,
        };
      }
      function Qy(n, e, t) {
        const { top: i, bottom: r, left: o, right: s } = n;
        return t >= i && t <= r && e >= o && e <= s;
      }
      function yc(n, e, t) {
        (n.top += e),
          (n.bottom = n.top + n.height),
          (n.left += t),
          (n.right = n.left + n.width);
      }
      function KI(n, e, t, i) {
        const { top: r, right: o, bottom: s, left: a, width: l, height: c } = n,
          u = l * e,
          d = c * e;
        return i > r - d && i < s + d && t > a - u && t < o + u;
      }
      class YI {
        constructor(e) {
          (this._document = e), (this.positions = new Map());
        }
        clear() {
          this.positions.clear();
        }
        cache(e) {
          this.clear(),
            this.positions.set(this._document, {
              scrollPosition: this.getViewportScrollPosition(),
            }),
            e.forEach((t) => {
              this.positions.set(t, {
                scrollPosition: { top: t.scrollTop, left: t.scrollLeft },
                clientRect: Zy(t),
              });
            });
        }
        handleScroll(e) {
          const t = mh(e),
            i = this.positions.get(t);
          if (!i) return null;
          const r = i.scrollPosition;
          let o, s;
          if (t === this._document) {
            const c = this.getViewportScrollPosition();
            (o = c.top), (s = c.left);
          } else (o = t.scrollTop), (s = t.scrollLeft);
          const a = r.top - o,
            l = r.left - s;
          return (
            this.positions.forEach((c, u) => {
              c.clientRect &&
                t !== u &&
                t.contains(u) &&
                yc(c.clientRect, a, l);
            }),
            (r.top = o),
            (r.left = s),
            { top: a, left: l }
          );
        }
        getViewportScrollPosition() {
          return { top: window.scrollY, left: window.scrollX };
        }
      }
      function ZI(n) {
        const e = n.cloneNode(!0),
          t = e.querySelectorAll("[id]"),
          i = n.nodeName.toLowerCase();
        e.removeAttribute("id");
        for (let r = 0; r < t.length; r++) t[r].removeAttribute("id");
        return (
          "canvas" === i
            ? XI(n, e)
            : ("input" === i || "select" === i || "textarea" === i) && JI(n, e),
          QI("canvas", n, e, XI),
          QI("input, textarea, select", n, e, JI),
          e
        );
      }
      function QI(n, e, t, i) {
        const r = e.querySelectorAll(n);
        if (r.length) {
          const o = t.querySelectorAll(n);
          for (let s = 0; s < r.length; s++) i(r[s], o[s]);
        }
      }
      let d4 = 0;
      function JI(n, e) {
        "file" !== e.type && (e.value = n.value),
          "radio" === e.type &&
            e.name &&
            (e.name = `mat-clone-${e.name}-${d4++}`);
      }
      function XI(n, e) {
        const t = e.getContext("2d");
        if (t)
          try {
            t.drawImage(n, 0, 0);
          } catch {}
      }
      const eT = mc({ passive: !0 }),
        vh = mc({ passive: !1 }),
        Jy = new Set(["position"]);
      class f4 {
        constructor(e, t, i, r, o, s) {
          (this._config = t),
            (this._document = i),
            (this._ngZone = r),
            (this._viewportRuler = o),
            (this._dragDropRegistry = s),
            (this._passiveTransform = { x: 0, y: 0 }),
            (this._activeTransform = { x: 0, y: 0 }),
            (this._hasStartedDragging = !1),
            (this._moveEvents = new _e()),
            (this._pointerMoveSubscription = Te.EMPTY),
            (this._pointerUpSubscription = Te.EMPTY),
            (this._scrollSubscription = Te.EMPTY),
            (this._resizeSubscription = Te.EMPTY),
            (this._boundaryElement = null),
            (this._nativeInteractionsEnabled = !0),
            (this._handles = []),
            (this._disabledHandles = new Set()),
            (this._direction = "ltr"),
            (this.dragStartDelay = 0),
            (this._disabled = !1),
            (this.beforeStarted = new _e()),
            (this.started = new _e()),
            (this.released = new _e()),
            (this.ended = new _e()),
            (this.entered = new _e()),
            (this.exited = new _e()),
            (this.dropped = new _e()),
            (this.moved = this._moveEvents),
            (this._pointerDown = (a) => {
              if ((this.beforeStarted.next(), this._handles.length)) {
                const l = this._getTargetHandle(a);
                l &&
                  !this._disabledHandles.has(l) &&
                  !this.disabled &&
                  this._initializeDragSequence(l, a);
              } else
                this.disabled ||
                  this._initializeDragSequence(this._rootElement, a);
            }),
            (this._pointerMove = (a) => {
              const l = this._getPointerPositionOnPage(a);
              if (!this._hasStartedDragging) {
                if (
                  Math.abs(l.x - this._pickupPositionOnPage.x) +
                    Math.abs(l.y - this._pickupPositionOnPage.y) >=
                  this._config.dragStartThreshold
                ) {
                  const f =
                      Date.now() >=
                      this._dragStartTime + this._getDragStartDelay(a),
                    p = this._dropContainer;
                  if (!f) return void this._endDragSequence(a);
                  (!p || (!p.isDragging() && !p.isReceiving())) &&
                    (a.preventDefault(),
                    (this._hasStartedDragging = !0),
                    this._ngZone.run(() => this._startDragSequence(a)));
                }
                return;
              }
              a.preventDefault();
              const c = this._getConstrainedPointerPosition(l);
              if (
                ((this._hasMoved = !0),
                (this._lastKnownPointerPosition = l),
                this._updatePointerDirectionDelta(c),
                this._dropContainer)
              )
                this._updateActiveDropContainer(c, l);
              else {
                const u = this.constrainPosition
                    ? this._initialClientRect
                    : this._pickupPositionOnPage,
                  d = this._activeTransform;
                (d.x = c.x - u.x + this._passiveTransform.x),
                  (d.y = c.y - u.y + this._passiveTransform.y),
                  this._applyRootElementTransform(d.x, d.y);
              }
              this._moveEvents.observers.length &&
                this._ngZone.run(() => {
                  this._moveEvents.next({
                    source: this,
                    pointerPosition: c,
                    event: a,
                    distance: this._getDragDistance(c),
                    delta: this._pointerDirectionDelta,
                  });
                });
            }),
            (this._pointerUp = (a) => {
              this._endDragSequence(a);
            }),
            (this._nativeDragStart = (a) => {
              if (this._handles.length) {
                const l = this._getTargetHandle(a);
                l &&
                  !this._disabledHandles.has(l) &&
                  !this.disabled &&
                  a.preventDefault();
              } else this.disabled || a.preventDefault();
            }),
            this.withRootElement(e).withParent(t.parentDragRef || null),
            (this._parentPositions = new YI(i)),
            s.registerDragItem(this);
        }
        get disabled() {
          return (
            this._disabled ||
            !(!this._dropContainer || !this._dropContainer.disabled)
          );
        }
        set disabled(e) {
          const t = (function Dz(n) {
            return null != n && "false" != `${n}`;
          })(e);
          t !== this._disabled &&
            ((this._disabled = t),
            this._toggleNativeDragInteractions(),
            this._handles.forEach((i) => wa(i, t)));
        }
        getPlaceholderElement() {
          return this._placeholder;
        }
        getRootElement() {
          return this._rootElement;
        }
        getVisibleElement() {
          return this.isDragging()
            ? this.getPlaceholderElement()
            : this.getRootElement();
        }
        withHandles(e) {
          (this._handles = e.map((i) => Xn(i))),
            this._handles.forEach((i) => wa(i, this.disabled)),
            this._toggleNativeDragInteractions();
          const t = new Set();
          return (
            this._disabledHandles.forEach((i) => {
              this._handles.indexOf(i) > -1 && t.add(i);
            }),
            (this._disabledHandles = t),
            this
          );
        }
        withPreviewTemplate(e) {
          return (this._previewTemplate = e), this;
        }
        withPlaceholderTemplate(e) {
          return (this._placeholderTemplate = e), this;
        }
        withRootElement(e) {
          const t = Xn(e);
          return (
            t !== this._rootElement &&
              (this._rootElement &&
                this._removeRootElementListeners(this._rootElement),
              this._ngZone.runOutsideAngular(() => {
                t.addEventListener("mousedown", this._pointerDown, vh),
                  t.addEventListener("touchstart", this._pointerDown, eT),
                  t.addEventListener("dragstart", this._nativeDragStart, vh);
              }),
              (this._initialTransform = void 0),
              (this._rootElement = t)),
            typeof SVGElement < "u" &&
              this._rootElement instanceof SVGElement &&
              (this._ownerSVGElement = this._rootElement.ownerSVGElement),
            this
          );
        }
        withBoundaryElement(e) {
          return (
            (this._boundaryElement = e ? Xn(e) : null),
            this._resizeSubscription.unsubscribe(),
            e &&
              (this._resizeSubscription = this._viewportRuler
                .change(10)
                .subscribe(() => this._containInsideBoundaryOnResize())),
            this
          );
        }
        withParent(e) {
          return (this._parentDragRef = e), this;
        }
        dispose() {
          this._removeRootElementListeners(this._rootElement),
            this.isDragging() && this._rootElement?.remove(),
            this._anchor?.remove(),
            this._destroyPreview(),
            this._destroyPlaceholder(),
            this._dragDropRegistry.removeDragItem(this),
            this._removeSubscriptions(),
            this.beforeStarted.complete(),
            this.started.complete(),
            this.released.complete(),
            this.ended.complete(),
            this.entered.complete(),
            this.exited.complete(),
            this.dropped.complete(),
            this._moveEvents.complete(),
            (this._handles = []),
            this._disabledHandles.clear(),
            (this._dropContainer = void 0),
            this._resizeSubscription.unsubscribe(),
            this._parentPositions.clear(),
            (this._boundaryElement =
              this._rootElement =
              this._ownerSVGElement =
              this._placeholderTemplate =
              this._previewTemplate =
              this._anchor =
              this._parentDragRef =
                null);
        }
        isDragging() {
          return (
            this._hasStartedDragging && this._dragDropRegistry.isDragging(this)
          );
        }
        reset() {
          (this._rootElement.style.transform = this._initialTransform || ""),
            (this._activeTransform = { x: 0, y: 0 }),
            (this._passiveTransform = { x: 0, y: 0 });
        }
        disableHandle(e) {
          !this._disabledHandles.has(e) &&
            this._handles.indexOf(e) > -1 &&
            (this._disabledHandles.add(e), wa(e, !0));
        }
        enableHandle(e) {
          this._disabledHandles.has(e) &&
            (this._disabledHandles.delete(e), wa(e, this.disabled));
        }
        withDirection(e) {
          return (this._direction = e), this;
        }
        _withDropContainer(e) {
          this._dropContainer = e;
        }
        getFreeDragPosition() {
          const e = this.isDragging()
            ? this._activeTransform
            : this._passiveTransform;
          return { x: e.x, y: e.y };
        }
        setFreeDragPosition(e) {
          return (
            (this._activeTransform = { x: 0, y: 0 }),
            (this._passiveTransform.x = e.x),
            (this._passiveTransform.y = e.y),
            this._dropContainer || this._applyRootElementTransform(e.x, e.y),
            this
          );
        }
        withPreviewContainer(e) {
          return (this._previewContainer = e), this;
        }
        _sortFromLastPointerPosition() {
          const e = this._lastKnownPointerPosition;
          e &&
            this._dropContainer &&
            this._updateActiveDropContainer(
              this._getConstrainedPointerPosition(e),
              e
            );
        }
        _removeSubscriptions() {
          this._pointerMoveSubscription.unsubscribe(),
            this._pointerUpSubscription.unsubscribe(),
            this._scrollSubscription.unsubscribe();
        }
        _destroyPreview() {
          this._preview?.remove(),
            this._previewRef?.destroy(),
            (this._preview = this._previewRef = null);
        }
        _destroyPlaceholder() {
          this._placeholder?.remove(),
            this._placeholderRef?.destroy(),
            (this._placeholder = this._placeholderRef = null);
        }
        _endDragSequence(e) {
          if (
            this._dragDropRegistry.isDragging(this) &&
            (this._removeSubscriptions(),
            this._dragDropRegistry.stopDragging(this),
            this._toggleNativeDragInteractions(),
            this._handles &&
              (this._rootElement.style.webkitTapHighlightColor =
                this._rootElementTapHighlight),
            this._hasStartedDragging)
          )
            if (
              (this.released.next({ source: this, event: e }),
              this._dropContainer)
            )
              this._dropContainer._stopScrolling(),
                this._animatePreviewToPlaceholder().then(() => {
                  this._cleanupDragArtifacts(e),
                    this._cleanupCachedDimensions(),
                    this._dragDropRegistry.stopDragging(this);
                });
            else {
              this._passiveTransform.x = this._activeTransform.x;
              const t = this._getPointerPositionOnPage(e);
              (this._passiveTransform.y = this._activeTransform.y),
                this._ngZone.run(() => {
                  this.ended.next({
                    source: this,
                    distance: this._getDragDistance(t),
                    dropPoint: t,
                    event: e,
                  });
                }),
                this._cleanupCachedDimensions(),
                this._dragDropRegistry.stopDragging(this);
            }
        }
        _startDragSequence(e) {
          vc(e) && (this._lastTouchEventTime = Date.now()),
            this._toggleNativeDragInteractions();
          const t = this._dropContainer;
          if (t) {
            const i = this._rootElement,
              r = i.parentNode,
              o = (this._placeholder = this._createPlaceholderElement()),
              s = (this._anchor =
                this._anchor || this._document.createComment("")),
              a = this._getShadowRoot();
            r.insertBefore(s, i),
              (this._initialTransform = i.style.transform || ""),
              (this._preview = this._createPreviewElement()),
              GI(i, !1, Jy),
              this._document.body.appendChild(r.replaceChild(o, i)),
              this._getPreviewInsertionPoint(r, a).appendChild(this._preview),
              this.started.next({ source: this, event: e }),
              t.start(),
              (this._initialContainer = t),
              (this._initialIndex = t.getItemIndex(this));
          } else
            this.started.next({ source: this, event: e }),
              (this._initialContainer = this._initialIndex = void 0);
          this._parentPositions.cache(t ? t.getScrollableParents() : []);
        }
        _initializeDragSequence(e, t) {
          this._parentDragRef && t.stopPropagation();
          const i = this.isDragging(),
            r = vc(t),
            o = !r && 0 !== t.button,
            s = this._rootElement,
            a = mh(t),
            l =
              !r &&
              this._lastTouchEventTime &&
              this._lastTouchEventTime + 800 > Date.now(),
            c = r
              ? (function r4(n) {
                  const e =
                    (n.touches && n.touches[0]) ||
                    (n.changedTouches && n.changedTouches[0]);
                  return !(
                    !e ||
                    -1 !== e.identifier ||
                    (null != e.radiusX && 1 !== e.radiusX) ||
                    (null != e.radiusY && 1 !== e.radiusY)
                  );
                })(t)
              : (function n4(n) {
                  return (
                    0 === n.buttons || (0 === n.offsetX && 0 === n.offsetY)
                  );
                })(t);
          if (
            (a && a.draggable && "mousedown" === t.type && t.preventDefault(),
            i || o || l || c)
          )
            return;
          if (this._handles.length) {
            const h = s.style;
            (this._rootElementTapHighlight = h.webkitTapHighlightColor || ""),
              (h.webkitTapHighlightColor = "transparent");
          }
          (this._hasStartedDragging = this._hasMoved = !1),
            this._removeSubscriptions(),
            (this._initialClientRect =
              this._rootElement.getBoundingClientRect()),
            (this._pointerMoveSubscription =
              this._dragDropRegistry.pointerMove.subscribe(this._pointerMove)),
            (this._pointerUpSubscription =
              this._dragDropRegistry.pointerUp.subscribe(this._pointerUp)),
            (this._scrollSubscription = this._dragDropRegistry
              .scrolled(this._getShadowRoot())
              .subscribe((h) => this._updateOnScroll(h))),
            this._boundaryElement &&
              (this._boundaryRect = Zy(this._boundaryElement));
          const u = this._previewTemplate;
          this._pickupPositionInElement =
            u && u.template && !u.matchSize
              ? { x: 0, y: 0 }
              : this._getPointerPositionInElement(
                  this._initialClientRect,
                  e,
                  t
                );
          const d =
            (this._pickupPositionOnPage =
            this._lastKnownPointerPosition =
              this._getPointerPositionOnPage(t));
          (this._pointerDirectionDelta = { x: 0, y: 0 }),
            (this._pointerPositionAtLastDirectionChange = { x: d.x, y: d.y }),
            (this._dragStartTime = Date.now()),
            this._dragDropRegistry.startDragging(this, t);
        }
        _cleanupDragArtifacts(e) {
          GI(this._rootElement, !0, Jy),
            this._anchor.parentNode.replaceChild(
              this._rootElement,
              this._anchor
            ),
            this._destroyPreview(),
            this._destroyPlaceholder(),
            (this._initialClientRect =
              this._boundaryRect =
              this._previewRect =
              this._initialTransform =
                void 0),
            this._ngZone.run(() => {
              const t = this._dropContainer,
                i = t.getItemIndex(this),
                r = this._getPointerPositionOnPage(e),
                o = this._getDragDistance(r),
                s = t._isOverContainer(r.x, r.y);
              this.ended.next({
                source: this,
                distance: o,
                dropPoint: r,
                event: e,
              }),
                this.dropped.next({
                  item: this,
                  currentIndex: i,
                  previousIndex: this._initialIndex,
                  container: t,
                  previousContainer: this._initialContainer,
                  isPointerOverContainer: s,
                  distance: o,
                  dropPoint: r,
                  event: e,
                }),
                t.drop(
                  this,
                  i,
                  this._initialIndex,
                  this._initialContainer,
                  s,
                  o,
                  r
                ),
                (this._dropContainer = this._initialContainer);
            });
        }
        _updateActiveDropContainer({ x: e, y: t }, { x: i, y: r }) {
          let o = this._initialContainer._getSiblingContainerFromPosition(
            this,
            e,
            t
          );
          !o &&
            this._dropContainer !== this._initialContainer &&
            this._initialContainer._isOverContainer(e, t) &&
            (o = this._initialContainer),
            o &&
              o !== this._dropContainer &&
              this._ngZone.run(() => {
                this.exited.next({
                  item: this,
                  container: this._dropContainer,
                }),
                  this._dropContainer.exit(this),
                  (this._dropContainer = o),
                  this._dropContainer.enter(
                    this,
                    e,
                    t,
                    o === this._initialContainer && o.sortingDisabled
                      ? this._initialIndex
                      : void 0
                  ),
                  this.entered.next({
                    item: this,
                    container: o,
                    currentIndex: o.getItemIndex(this),
                  });
              }),
            this.isDragging() &&
              (this._dropContainer._startScrollingIfNecessary(i, r),
              this._dropContainer._sortItem(
                this,
                e,
                t,
                this._pointerDirectionDelta
              ),
              this.constrainPosition
                ? this._applyPreviewTransform(e, t)
                : this._applyPreviewTransform(
                    e - this._pickupPositionInElement.x,
                    t - this._pickupPositionInElement.y
                  ));
        }
        _createPreviewElement() {
          const e = this._previewTemplate,
            t = this.previewClass,
            i = e ? e.template : null;
          let r;
          if (i && e) {
            const o = e.matchSize ? this._initialClientRect : null,
              s = e.viewContainer.createEmbeddedView(i, e.context);
            s.detectChanges(),
              (r = nT(s, this._document)),
              (this._previewRef = s),
              e.matchSize
                ? iT(r, o)
                : (r.style.transform = _h(
                    this._pickupPositionOnPage.x,
                    this._pickupPositionOnPage.y
                  ));
          } else
            (r = ZI(this._rootElement)),
              iT(r, this._initialClientRect),
              this._initialTransform &&
                (r.style.transform = this._initialTransform);
          return (
            Ky(
              r.style,
              {
                "pointer-events": "none",
                margin: "0",
                position: "fixed",
                top: "0",
                left: "0",
                "z-index": `${this._config.zIndex || 1e3}`,
              },
              Jy
            ),
            wa(r, !1),
            r.classList.add("cdk-drag-preview"),
            r.setAttribute("dir", this._direction),
            t &&
              (Array.isArray(t)
                ? t.forEach((o) => r.classList.add(o))
                : r.classList.add(t)),
            r
          );
        }
        _animatePreviewToPlaceholder() {
          if (!this._hasMoved) return Promise.resolve();
          const e = this._placeholder.getBoundingClientRect();
          this._preview.classList.add("cdk-drag-animating"),
            this._applyPreviewTransform(e.left, e.top);
          const t = (function u4(n) {
            const e = getComputedStyle(n),
              t = Yy(e, "transition-property"),
              i = t.find((a) => "transform" === a || "all" === a);
            if (!i) return 0;
            const r = t.indexOf(i),
              o = Yy(e, "transition-duration"),
              s = Yy(e, "transition-delay");
            return qI(o[r]) + qI(s[r]);
          })(this._preview);
          return 0 === t
            ? Promise.resolve()
            : this._ngZone.runOutsideAngular(
                () =>
                  new Promise((i) => {
                    const r = (s) => {
                        (!s ||
                          (mh(s) === this._preview &&
                            "transform" === s.propertyName)) &&
                          (this._preview?.removeEventListener(
                            "transitionend",
                            r
                          ),
                          i(),
                          clearTimeout(o));
                      },
                      o = setTimeout(r, 1.5 * t);
                    this._preview.addEventListener("transitionend", r);
                  })
              );
        }
        _createPlaceholderElement() {
          const e = this._placeholderTemplate,
            t = e ? e.template : null;
          let i;
          return (
            t
              ? ((this._placeholderRef = e.viewContainer.createEmbeddedView(
                  t,
                  e.context
                )),
                this._placeholderRef.detectChanges(),
                (i = nT(this._placeholderRef, this._document)))
              : (i = ZI(this._rootElement)),
            (i.style.pointerEvents = "none"),
            i.classList.add("cdk-drag-placeholder"),
            i
          );
        }
        _getPointerPositionInElement(e, t, i) {
          const r = t === this._rootElement ? null : t,
            o = r ? r.getBoundingClientRect() : e,
            s = vc(i) ? i.targetTouches[0] : i,
            a = this._getViewportScrollPosition();
          return {
            x: o.left - e.left + (s.pageX - o.left - a.left),
            y: o.top - e.top + (s.pageY - o.top - a.top),
          };
        }
        _getPointerPositionOnPage(e) {
          const t = this._getViewportScrollPosition(),
            i = vc(e)
              ? e.touches[0] || e.changedTouches[0] || { pageX: 0, pageY: 0 }
              : e,
            r = i.pageX - t.left,
            o = i.pageY - t.top;
          if (this._ownerSVGElement) {
            const s = this._ownerSVGElement.getScreenCTM();
            if (s) {
              const a = this._ownerSVGElement.createSVGPoint();
              return (a.x = r), (a.y = o), a.matrixTransform(s.inverse());
            }
          }
          return { x: r, y: o };
        }
        _getConstrainedPointerPosition(e) {
          const t = this._dropContainer ? this._dropContainer.lockAxis : null;
          let { x: i, y: r } = this.constrainPosition
            ? this.constrainPosition(e, this, this._initialClientRect)
            : e;
          if (
            ("x" === this.lockAxis || "x" === t
              ? (r = this._pickupPositionOnPage.y)
              : ("y" === this.lockAxis || "y" === t) &&
                (i = this._pickupPositionOnPage.x),
            this._boundaryRect)
          ) {
            const { x: o, y: s } = this._pickupPositionInElement,
              a = this._boundaryRect,
              { width: l, height: c } = this._getPreviewRect(),
              u = a.top + s,
              d = a.bottom - (c - s);
            (i = tT(i, a.left + o, a.right - (l - o))), (r = tT(r, u, d));
          }
          return { x: i, y: r };
        }
        _updatePointerDirectionDelta(e) {
          const { x: t, y: i } = e,
            r = this._pointerDirectionDelta,
            o = this._pointerPositionAtLastDirectionChange,
            s = Math.abs(t - o.x),
            a = Math.abs(i - o.y);
          return (
            s > this._config.pointerDirectionChangeThreshold &&
              ((r.x = t > o.x ? 1 : -1), (o.x = t)),
            a > this._config.pointerDirectionChangeThreshold &&
              ((r.y = i > o.y ? 1 : -1), (o.y = i)),
            r
          );
        }
        _toggleNativeDragInteractions() {
          if (!this._rootElement || !this._handles) return;
          const e = this._handles.length > 0 || !this.isDragging();
          e !== this._nativeInteractionsEnabled &&
            ((this._nativeInteractionsEnabled = e), wa(this._rootElement, e));
        }
        _removeRootElementListeners(e) {
          e.removeEventListener("mousedown", this._pointerDown, vh),
            e.removeEventListener("touchstart", this._pointerDown, eT),
            e.removeEventListener("dragstart", this._nativeDragStart, vh);
        }
        _applyRootElementTransform(e, t) {
          const i = _h(e, t),
            r = this._rootElement.style;
          null == this._initialTransform &&
            (this._initialTransform =
              r.transform && "none" != r.transform ? r.transform : ""),
            (r.transform = yh(i, this._initialTransform));
        }
        _applyPreviewTransform(e, t) {
          const i = this._previewTemplate?.template
              ? void 0
              : this._initialTransform,
            r = _h(e, t);
          this._preview.style.transform = yh(r, i);
        }
        _getDragDistance(e) {
          const t = this._pickupPositionOnPage;
          return t ? { x: e.x - t.x, y: e.y - t.y } : { x: 0, y: 0 };
        }
        _cleanupCachedDimensions() {
          (this._boundaryRect = this._previewRect = void 0),
            this._parentPositions.clear();
        }
        _containInsideBoundaryOnResize() {
          let { x: e, y: t } = this._passiveTransform;
          if (
            (0 === e && 0 === t) ||
            this.isDragging() ||
            !this._boundaryElement
          )
            return;
          const i = this._rootElement.getBoundingClientRect(),
            r = this._boundaryElement.getBoundingClientRect();
          if (
            (0 === r.width && 0 === r.height) ||
            (0 === i.width && 0 === i.height)
          )
            return;
          const o = r.left - i.left,
            s = i.right - r.right,
            a = r.top - i.top,
            l = i.bottom - r.bottom;
          r.width > i.width ? (o > 0 && (e += o), s > 0 && (e -= s)) : (e = 0),
            r.height > i.height
              ? (a > 0 && (t += a), l > 0 && (t -= l))
              : (t = 0),
            (e !== this._passiveTransform.x ||
              t !== this._passiveTransform.y) &&
              this.setFreeDragPosition({ y: t, x: e });
        }
        _getDragStartDelay(e) {
          const t = this.dragStartDelay;
          return "number" == typeof t ? t : vc(e) ? t.touch : t ? t.mouse : 0;
        }
        _updateOnScroll(e) {
          const t = this._parentPositions.handleScroll(e);
          if (t) {
            const i = mh(e);
            this._boundaryRect &&
              i !== this._boundaryElement &&
              i.contains(this._boundaryElement) &&
              yc(this._boundaryRect, t.top, t.left),
              (this._pickupPositionOnPage.x += t.left),
              (this._pickupPositionOnPage.y += t.top),
              this._dropContainer ||
                ((this._activeTransform.x -= t.left),
                (this._activeTransform.y -= t.top),
                this._applyRootElementTransform(
                  this._activeTransform.x,
                  this._activeTransform.y
                ));
          }
        }
        _getViewportScrollPosition() {
          return (
            this._parentPositions.positions.get(this._document)
              ?.scrollPosition ||
            this._parentPositions.getViewportScrollPosition()
          );
        }
        _getShadowRoot() {
          return (
            void 0 === this._cachedShadowRoot &&
              (this._cachedShadowRoot = jI(this._rootElement)),
            this._cachedShadowRoot
          );
        }
        _getPreviewInsertionPoint(e, t) {
          const i = this._previewContainer || "global";
          if ("parent" === i) return e;
          if ("global" === i) {
            const r = this._document;
            return (
              t ||
              r.fullscreenElement ||
              r.webkitFullscreenElement ||
              r.mozFullScreenElement ||
              r.msFullscreenElement ||
              r.body
            );
          }
          return Xn(i);
        }
        _getPreviewRect() {
          return (
            (!this._previewRect ||
              (!this._previewRect.width && !this._previewRect.height)) &&
              (this._previewRect = this._preview
                ? this._preview.getBoundingClientRect()
                : this._initialClientRect),
            this._previewRect
          );
        }
        _getTargetHandle(e) {
          return this._handles.find(
            (t) => e.target && (e.target === t || t.contains(e.target))
          );
        }
      }
      function _h(n, e) {
        return `translate3d(${Math.round(n)}px, ${Math.round(e)}px, 0)`;
      }
      function tT(n, e, t) {
        return Math.max(e, Math.min(t, n));
      }
      function vc(n) {
        return "t" === n.type[0];
      }
      function nT(n, e) {
        const t = n.rootNodes;
        if (1 === t.length && t[0].nodeType === e.ELEMENT_NODE) return t[0];
        const i = e.createElement("div");
        return t.forEach((r) => i.appendChild(r)), i;
      }
      function iT(n, e) {
        (n.style.width = `${e.width}px`),
          (n.style.height = `${e.height}px`),
          (n.style.transform = _h(e.left, e.top));
      }
      function _c(n, e) {
        return Math.max(0, Math.min(e, n));
      }
      class g4 {
        constructor(e, t) {
          (this._element = e),
            (this._dragDropRegistry = t),
            (this._itemPositions = []),
            (this.orientation = "vertical"),
            (this._previousSwap = { drag: null, delta: 0, overlaps: !1 });
        }
        start(e) {
          this.withItems(e);
        }
        sort(e, t, i, r) {
          const o = this._itemPositions,
            s = this._getItemIndexFromPointerPosition(e, t, i, r);
          if (-1 === s && o.length > 0) return null;
          const a = "horizontal" === this.orientation,
            l = o.findIndex((m) => m.drag === e),
            c = o[s],
            d = c.clientRect,
            h = l > s ? 1 : -1,
            f = this._getItemOffsetPx(o[l].clientRect, d, h),
            p = this._getSiblingOffsetPx(l, o, h),
            g = o.slice();
          return (
            (function p4(n, e, t) {
              const i = _c(e, n.length - 1),
                r = _c(t, n.length - 1);
              if (i === r) return;
              const o = n[i],
                s = r < i ? -1 : 1;
              for (let a = i; a !== r; a += s) n[a] = n[a + s];
              n[r] = o;
            })(o, l, s),
            o.forEach((m, v) => {
              if (g[v] === m) return;
              const _ = m.drag === e,
                b = _ ? f : p,
                y = _ ? e.getPlaceholderElement() : m.drag.getRootElement();
              (m.offset += b),
                a
                  ? ((y.style.transform = yh(
                      `translate3d(${Math.round(m.offset)}px, 0, 0)`,
                      m.initialTransform
                    )),
                    yc(m.clientRect, 0, b))
                  : ((y.style.transform = yh(
                      `translate3d(0, ${Math.round(m.offset)}px, 0)`,
                      m.initialTransform
                    )),
                    yc(m.clientRect, b, 0));
            }),
            (this._previousSwap.overlaps = Qy(d, t, i)),
            (this._previousSwap.drag = c.drag),
            (this._previousSwap.delta = a ? r.x : r.y),
            { previousIndex: l, currentIndex: s }
          );
        }
        enter(e, t, i, r) {
          const o =
              null == r || r < 0
                ? this._getItemIndexFromPointerPosition(e, t, i)
                : r,
            s = this._activeDraggables,
            a = s.indexOf(e),
            l = e.getPlaceholderElement();
          let c = s[o];
          if (
            (c === e && (c = s[o + 1]),
            !c &&
              (null == o || -1 === o || o < s.length - 1) &&
              this._shouldEnterAsFirstChild(t, i) &&
              (c = s[0]),
            a > -1 && s.splice(a, 1),
            c && !this._dragDropRegistry.isDragging(c))
          ) {
            const u = c.getRootElement();
            u.parentElement.insertBefore(l, u), s.splice(o, 0, e);
          } else Xn(this._element).appendChild(l), s.push(e);
          (l.style.transform = ""), this._cacheItemPositions();
        }
        withItems(e) {
          (this._activeDraggables = e.slice()), this._cacheItemPositions();
        }
        withSortPredicate(e) {
          this._sortPredicate = e;
        }
        reset() {
          this._activeDraggables.forEach((e) => {
            const t = e.getRootElement();
            if (t) {
              const i = this._itemPositions.find(
                (r) => r.drag === e
              )?.initialTransform;
              t.style.transform = i || "";
            }
          }),
            (this._itemPositions = []),
            (this._activeDraggables = []),
            (this._previousSwap.drag = null),
            (this._previousSwap.delta = 0),
            (this._previousSwap.overlaps = !1);
        }
        getActiveItemsSnapshot() {
          return this._activeDraggables;
        }
        getItemIndex(e) {
          return (
            "horizontal" === this.orientation && "rtl" === this.direction
              ? this._itemPositions.slice().reverse()
              : this._itemPositions
          ).findIndex((i) => i.drag === e);
        }
        updateOnScroll(e, t) {
          this._itemPositions.forEach(({ clientRect: i }) => {
            yc(i, e, t);
          }),
            this._itemPositions.forEach(({ drag: i }) => {
              this._dragDropRegistry.isDragging(i) &&
                i._sortFromLastPointerPosition();
            });
        }
        _cacheItemPositions() {
          const e = "horizontal" === this.orientation;
          this._itemPositions = this._activeDraggables
            .map((t) => {
              const i = t.getVisibleElement();
              return {
                drag: t,
                offset: 0,
                initialTransform: i.style.transform || "",
                clientRect: Zy(i),
              };
            })
            .sort((t, i) =>
              e
                ? t.clientRect.left - i.clientRect.left
                : t.clientRect.top - i.clientRect.top
            );
        }
        _getItemOffsetPx(e, t, i) {
          const r = "horizontal" === this.orientation;
          let o = r ? t.left - e.left : t.top - e.top;
          return (
            -1 === i && (o += r ? t.width - e.width : t.height - e.height), o
          );
        }
        _getSiblingOffsetPx(e, t, i) {
          const r = "horizontal" === this.orientation,
            o = t[e].clientRect,
            s = t[e + -1 * i];
          let a = o[r ? "width" : "height"] * i;
          if (s) {
            const l = r ? "left" : "top",
              c = r ? "right" : "bottom";
            -1 === i
              ? (a -= s.clientRect[l] - o[c])
              : (a += o[l] - s.clientRect[c]);
          }
          return a;
        }
        _shouldEnterAsFirstChild(e, t) {
          if (!this._activeDraggables.length) return !1;
          const i = this._itemPositions,
            r = "horizontal" === this.orientation;
          if (i[0].drag !== this._activeDraggables[0]) {
            const s = i[i.length - 1].clientRect;
            return r ? e >= s.right : t >= s.bottom;
          }
          {
            const s = i[0].clientRect;
            return r ? e <= s.left : t <= s.top;
          }
        }
        _getItemIndexFromPointerPosition(e, t, i, r) {
          const o = "horizontal" === this.orientation,
            s = this._itemPositions.findIndex(({ drag: a, clientRect: l }) => {
              if (a === e) return !1;
              if (r) {
                const c = o ? r.x : r.y;
                if (
                  a === this._previousSwap.drag &&
                  this._previousSwap.overlaps &&
                  c === this._previousSwap.delta
                )
                  return !1;
              }
              return o
                ? t >= Math.floor(l.left) && t < Math.floor(l.right)
                : i >= Math.floor(l.top) && i < Math.floor(l.bottom);
            });
          return -1 !== s && this._sortPredicate(s, e) ? s : -1;
        }
      }
      class m4 {
        constructor(e, t, i, r, o) {
          (this._dragDropRegistry = t),
            (this._ngZone = r),
            (this._viewportRuler = o),
            (this.disabled = !1),
            (this.sortingDisabled = !1),
            (this.autoScrollDisabled = !1),
            (this.autoScrollStep = 2),
            (this.enterPredicate = () => !0),
            (this.sortPredicate = () => !0),
            (this.beforeStarted = new _e()),
            (this.entered = new _e()),
            (this.exited = new _e()),
            (this.dropped = new _e()),
            (this.sorted = new _e()),
            (this._isDragging = !1),
            (this._draggables = []),
            (this._siblings = []),
            (this._activeSiblings = new Set()),
            (this._viewportScrollSubscription = Te.EMPTY),
            (this._verticalScrollDirection = 0),
            (this._horizontalScrollDirection = 0),
            (this._stopScrollTimers = new _e()),
            (this._cachedShadowRoot = null),
            (this._startScrollInterval = () => {
              this._stopScrolling(),
                (function s4(n = 0, e = pc) {
                  return (
                    (!Wy(n) || n < 0) && (n = 0),
                    (!e || "function" != typeof e.schedule) && (e = pc),
                    new je(
                      (t) => (
                        t.add(
                          e.schedule(a4, n, {
                            subscriber: t,
                            counter: 0,
                            period: n,
                          })
                        ),
                        t
                      )
                    )
                  );
                })(0, FI)
                  .pipe(WI(this._stopScrollTimers))
                  .subscribe(() => {
                    const s = this._scrollNode,
                      a = this.autoScrollStep;
                    1 === this._verticalScrollDirection
                      ? s.scrollBy(0, -a)
                      : 2 === this._verticalScrollDirection && s.scrollBy(0, a),
                      1 === this._horizontalScrollDirection
                        ? s.scrollBy(-a, 0)
                        : 2 === this._horizontalScrollDirection &&
                          s.scrollBy(a, 0);
                  });
            }),
            (this.element = Xn(e)),
            (this._document = i),
            this.withScrollableParents([this.element]),
            t.registerDropContainer(this),
            (this._parentPositions = new YI(i)),
            (this._sortStrategy = new g4(this.element, t)),
            this._sortStrategy.withSortPredicate((s, a) =>
              this.sortPredicate(s, a, this)
            );
        }
        dispose() {
          this._stopScrolling(),
            this._stopScrollTimers.complete(),
            this._viewportScrollSubscription.unsubscribe(),
            this.beforeStarted.complete(),
            this.entered.complete(),
            this.exited.complete(),
            this.dropped.complete(),
            this.sorted.complete(),
            this._activeSiblings.clear(),
            (this._scrollNode = null),
            this._parentPositions.clear(),
            this._dragDropRegistry.removeDropContainer(this);
        }
        isDragging() {
          return this._isDragging;
        }
        start() {
          this._draggingStarted(), this._notifyReceivingSiblings();
        }
        enter(e, t, i, r) {
          this._draggingStarted(),
            null == r &&
              this.sortingDisabled &&
              (r = this._draggables.indexOf(e)),
            this._sortStrategy.enter(e, t, i, r),
            this._cacheParentPositions(),
            this._notifyReceivingSiblings(),
            this.entered.next({
              item: e,
              container: this,
              currentIndex: this.getItemIndex(e),
            });
        }
        exit(e) {
          this._reset(), this.exited.next({ item: e, container: this });
        }
        drop(e, t, i, r, o, s, a, l = {}) {
          this._reset(),
            this.dropped.next({
              item: e,
              currentIndex: t,
              previousIndex: i,
              container: this,
              previousContainer: r,
              isPointerOverContainer: o,
              distance: s,
              dropPoint: a,
              event: l,
            });
        }
        withItems(e) {
          const t = this._draggables;
          return (
            (this._draggables = e),
            e.forEach((i) => i._withDropContainer(this)),
            this.isDragging() &&
              (t.filter((r) => r.isDragging()).every((r) => -1 === e.indexOf(r))
                ? this._reset()
                : this._sortStrategy.withItems(this._draggables)),
            this
          );
        }
        withDirection(e) {
          return (this._sortStrategy.direction = e), this;
        }
        connectedTo(e) {
          return (this._siblings = e.slice()), this;
        }
        withOrientation(e) {
          return (this._sortStrategy.orientation = e), this;
        }
        withScrollableParents(e) {
          const t = Xn(this.element);
          return (
            (this._scrollableElements =
              -1 === e.indexOf(t) ? [t, ...e] : e.slice()),
            this
          );
        }
        getScrollableParents() {
          return this._scrollableElements;
        }
        getItemIndex(e) {
          return this._isDragging
            ? this._sortStrategy.getItemIndex(e)
            : this._draggables.indexOf(e);
        }
        isReceiving() {
          return this._activeSiblings.size > 0;
        }
        _sortItem(e, t, i, r) {
          if (
            this.sortingDisabled ||
            !this._clientRect ||
            !KI(this._clientRect, 0.05, t, i)
          )
            return;
          const o = this._sortStrategy.sort(e, t, i, r);
          o &&
            this.sorted.next({
              previousIndex: o.previousIndex,
              currentIndex: o.currentIndex,
              container: this,
              item: e,
            });
        }
        _startScrollingIfNecessary(e, t) {
          if (this.autoScrollDisabled) return;
          let i,
            r = 0,
            o = 0;
          if (
            (this._parentPositions.positions.forEach((s, a) => {
              a === this._document ||
                !s.clientRect ||
                i ||
                (KI(s.clientRect, 0.05, e, t) &&
                  (([r, o] = (function y4(n, e, t, i) {
                    const r = sT(e, i),
                      o = aT(e, t);
                    let s = 0,
                      a = 0;
                    if (r) {
                      const l = n.scrollTop;
                      1 === r
                        ? l > 0 && (s = 1)
                        : n.scrollHeight - l > n.clientHeight && (s = 2);
                    }
                    if (o) {
                      const l = n.scrollLeft;
                      1 === o
                        ? l > 0 && (a = 1)
                        : n.scrollWidth - l > n.clientWidth && (a = 2);
                    }
                    return [s, a];
                  })(a, s.clientRect, e, t)),
                  (r || o) && (i = a)));
            }),
            !r && !o)
          ) {
            const { width: s, height: a } =
                this._viewportRuler.getViewportSize(),
              l = { width: s, height: a, top: 0, right: s, bottom: a, left: 0 };
            (r = sT(l, t)), (o = aT(l, e)), (i = window);
          }
          i &&
            (r !== this._verticalScrollDirection ||
              o !== this._horizontalScrollDirection ||
              i !== this._scrollNode) &&
            ((this._verticalScrollDirection = r),
            (this._horizontalScrollDirection = o),
            (this._scrollNode = i),
            (r || o) && i
              ? this._ngZone.runOutsideAngular(this._startScrollInterval)
              : this._stopScrolling());
        }
        _stopScrolling() {
          this._stopScrollTimers.next();
        }
        _draggingStarted() {
          const e = Xn(this.element).style;
          this.beforeStarted.next(),
            (this._isDragging = !0),
            (this._initialScrollSnap =
              e.msScrollSnapType || e.scrollSnapType || ""),
            (e.scrollSnapType = e.msScrollSnapType = "none"),
            this._sortStrategy.start(this._draggables),
            this._cacheParentPositions(),
            this._viewportScrollSubscription.unsubscribe(),
            this._listenToScrollEvents();
        }
        _cacheParentPositions() {
          const e = Xn(this.element);
          this._parentPositions.cache(this._scrollableElements),
            (this._clientRect =
              this._parentPositions.positions.get(e).clientRect);
        }
        _reset() {
          this._isDragging = !1;
          const e = Xn(this.element).style;
          (e.scrollSnapType = e.msScrollSnapType = this._initialScrollSnap),
            this._siblings.forEach((t) => t._stopReceiving(this)),
            this._sortStrategy.reset(),
            this._stopScrolling(),
            this._viewportScrollSubscription.unsubscribe(),
            this._parentPositions.clear();
        }
        _isOverContainer(e, t) {
          return null != this._clientRect && Qy(this._clientRect, e, t);
        }
        _getSiblingContainerFromPosition(e, t, i) {
          return this._siblings.find((r) => r._canReceive(e, t, i));
        }
        _canReceive(e, t, i) {
          if (
            !this._clientRect ||
            !Qy(this._clientRect, t, i) ||
            !this.enterPredicate(e, this)
          )
            return !1;
          const r = this._getShadowRoot().elementFromPoint(t, i);
          if (!r) return !1;
          const o = Xn(this.element);
          return r === o || o.contains(r);
        }
        _startReceiving(e, t) {
          const i = this._activeSiblings;
          !i.has(e) &&
            t.every(
              (r) =>
                this.enterPredicate(r, this) || this._draggables.indexOf(r) > -1
            ) &&
            (i.add(e),
            this._cacheParentPositions(),
            this._listenToScrollEvents());
        }
        _stopReceiving(e) {
          this._activeSiblings.delete(e),
            this._viewportScrollSubscription.unsubscribe();
        }
        _listenToScrollEvents() {
          this._viewportScrollSubscription = this._dragDropRegistry
            .scrolled(this._getShadowRoot())
            .subscribe((e) => {
              if (this.isDragging()) {
                const t = this._parentPositions.handleScroll(e);
                t && this._sortStrategy.updateOnScroll(t.top, t.left);
              } else this.isReceiving() && this._cacheParentPositions();
            });
        }
        _getShadowRoot() {
          if (!this._cachedShadowRoot) {
            const e = jI(Xn(this.element));
            this._cachedShadowRoot = e || this._document;
          }
          return this._cachedShadowRoot;
        }
        _notifyReceivingSiblings() {
          const e = this._sortStrategy
            .getActiveItemsSnapshot()
            .filter((t) => t.isDragging());
          this._siblings.forEach((t) => t._startReceiving(this, e));
        }
      }
      function sT(n, e) {
        const { top: t, bottom: i, height: r } = n,
          o = 0.05 * r;
        return e >= t - o && e <= t + o ? 1 : e >= i - o && e <= i + o ? 2 : 0;
      }
      function aT(n, e) {
        const { left: t, right: i, width: r } = n,
          o = 0.05 * r;
        return e >= t - o && e <= t + o ? 1 : e >= i - o && e <= i + o ? 2 : 0;
      }
      const bh = mc({ passive: !1, capture: !0 });
      let v4 = (() => {
        class n {
          constructor(t, i) {
            (this._ngZone = t),
              (this._dropInstances = new Set()),
              (this._dragInstances = new Set()),
              (this._activeDragInstances = []),
              (this._globalListeners = new Map()),
              (this._draggingPredicate = (r) => r.isDragging()),
              (this.pointerMove = new _e()),
              (this.pointerUp = new _e()),
              (this.scroll = new _e()),
              (this._preventDefaultWhileDragging = (r) => {
                this._activeDragInstances.length > 0 && r.preventDefault();
              }),
              (this._persistentTouchmoveListener = (r) => {
                this._activeDragInstances.length > 0 &&
                  (this._activeDragInstances.some(this._draggingPredicate) &&
                    r.preventDefault(),
                  this.pointerMove.next(r));
              }),
              (this._document = i);
          }
          registerDropContainer(t) {
            this._dropInstances.has(t) || this._dropInstances.add(t);
          }
          registerDragItem(t) {
            this._dragInstances.add(t),
              1 === this._dragInstances.size &&
                this._ngZone.runOutsideAngular(() => {
                  this._document.addEventListener(
                    "touchmove",
                    this._persistentTouchmoveListener,
                    bh
                  );
                });
          }
          removeDropContainer(t) {
            this._dropInstances.delete(t);
          }
          removeDragItem(t) {
            this._dragInstances.delete(t),
              this.stopDragging(t),
              0 === this._dragInstances.size &&
                this._document.removeEventListener(
                  "touchmove",
                  this._persistentTouchmoveListener,
                  bh
                );
          }
          startDragging(t, i) {
            if (
              !(this._activeDragInstances.indexOf(t) > -1) &&
              (this._activeDragInstances.push(t),
              1 === this._activeDragInstances.length)
            ) {
              const r = i.type.startsWith("touch");
              this._globalListeners
                .set(r ? "touchend" : "mouseup", {
                  handler: (o) => this.pointerUp.next(o),
                  options: !0,
                })
                .set("scroll", {
                  handler: (o) => this.scroll.next(o),
                  options: !0,
                })
                .set("selectstart", {
                  handler: this._preventDefaultWhileDragging,
                  options: bh,
                }),
                r ||
                  this._globalListeners.set("mousemove", {
                    handler: (o) => this.pointerMove.next(o),
                    options: bh,
                  }),
                this._ngZone.runOutsideAngular(() => {
                  this._globalListeners.forEach((o, s) => {
                    this._document.addEventListener(s, o.handler, o.options);
                  });
                });
            }
          }
          stopDragging(t) {
            const i = this._activeDragInstances.indexOf(t);
            i > -1 &&
              (this._activeDragInstances.splice(i, 1),
              0 === this._activeDragInstances.length &&
                this._clearGlobalListeners());
          }
          isDragging(t) {
            return this._activeDragInstances.indexOf(t) > -1;
          }
          scrolled(t) {
            const i = [this.scroll];
            return (
              t &&
                t !== this._document &&
                i.push(
                  new je((r) =>
                    this._ngZone.runOutsideAngular(() => {
                      const s = (a) => {
                        this._activeDragInstances.length && r.next(a);
                      };
                      return (
                        t.addEventListener("scroll", s, !0),
                        () => {
                          t.removeEventListener("scroll", s, !0);
                        }
                      );
                    })
                  )
                ),
              pp(...i)
            );
          }
          ngOnDestroy() {
            this._dragInstances.forEach((t) => this.removeDragItem(t)),
              this._dropInstances.forEach((t) => this.removeDropContainer(t)),
              this._clearGlobalListeners(),
              this.pointerMove.complete(),
              this.pointerUp.complete();
          }
          _clearGlobalListeners() {
            this._globalListeners.forEach((t, i) => {
              this._document.removeEventListener(i, t.handler, t.options);
            }),
              this._globalListeners.clear();
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(T(Ke), T(gt));
          }),
          (n.ɵprov = j({ token: n, factory: n.ɵfac, providedIn: "root" })),
          n
        );
      })();
      const _4 = { dragStartThreshold: 5, pointerDirectionChangeThreshold: 5 };
      let b4 = (() => {
          class n {
            constructor(t, i, r, o) {
              (this._document = t),
                (this._ngZone = i),
                (this._viewportRuler = r),
                (this._dragDropRegistry = o);
            }
            createDrag(t, i = _4) {
              return new f4(
                t,
                i,
                this._document,
                this._ngZone,
                this._viewportRuler,
                this._dragDropRegistry
              );
            }
            createDropList(t) {
              return new m4(
                t,
                this._dragDropRegistry,
                this._document,
                this._ngZone,
                this._viewportRuler
              );
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(T(gt), T(Ke), T(_z), T(v4));
            }),
            (n.ɵprov = j({ token: n, factory: n.ɵfac, providedIn: "root" })),
            n
          );
        })(),
        lT = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = rt({ type: n })),
            (n.ɵinj = Xe({ providers: [b4], imports: [bz] })),
            n
          );
        })(),
        P4 = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = rt({ type: n })),
            (n.ɵinj = Xe({ imports: [bi, ez, fc, hh, lT, fc, lT] })),
            n
          );
        })();
      const F4 = ["headerchkbox"],
        L4 = ["filter"];
      function V4(n, e) {
        1 & n && Kt(0);
      }
      function B4(n, e) {
        if (
          (1 & n &&
            (H(0, "div", 6), Cr(1), U(2, V4, 1, 0, "ng-container", 7), z()),
          2 & n)
        ) {
          const t = V();
          O(2), A("ngTemplateOutlet", t.headerTemplate);
        }
      }
      const cT = function (n) {
          return { "p-checkbox-disabled": n };
        },
        j4 = function (n, e, t) {
          return { "p-highlight": n, "p-focus": e, "p-disabled": t };
        },
        uT = function (n) {
          return { "pi pi-check": n };
        };
      function H4(n, e) {
        if (1 & n) {
          const t = Ui();
          H(0, "div", 11)(1, "div", 12)(2, "input", 13),
            Oe("focus", function () {
              return Ot(t), kt(V(2).onHeaderCheckboxFocus());
            })("blur", function () {
              return Ot(t), kt(V(2).onHeaderCheckboxBlur());
            })("keydown.space", function (r) {
              return Ot(t), kt(V(2).toggleAll(r));
            }),
            z()(),
            H(3, "div", 14, 15),
            Oe("click", function (r) {
              return Ot(t), kt(V(2).toggleAll(r));
            }),
            Lt(5, "span", 16),
            z()();
        }
        if (2 & n) {
          const t = V(2);
          A("ngClass", Kn(5, cT, t.disabled || t.toggleAllDisabled)),
            O(2),
            A("checked", t.allChecked)(
              "disabled",
              t.disabled || t.toggleAllDisabled
            ),
            O(1),
            A(
              "ngClass",
              (function ww(n, e, t, i, r, o) {
                return Iw(M(), sn(), n, e, t, i, r, o);
              })(
                7,
                j4,
                t.allChecked,
                t.headerCheckboxFocus,
                t.disabled || t.toggleAllDisabled
              )
            ),
            O(2),
            A("ngClass", Kn(11, uT, t.allChecked));
        }
      }
      function U4(n, e) {
        1 & n && Kt(0);
      }
      const z4 = function (n) {
        return { options: n };
      };
      function $4(n, e) {
        if (
          (1 & n && (ji(0), U(1, U4, 1, 0, "ng-container", 17), Hi()), 2 & n)
        ) {
          const t = V(2);
          O(1),
            A("ngTemplateOutlet", t.filterTemplate)(
              "ngTemplateOutletContext",
              Kn(2, z4, t.filterOptions)
            );
        }
      }
      function W4(n, e) {
        if (1 & n) {
          const t = Ui();
          H(0, "div", 19)(1, "input", 20, 21),
            Oe("input", function (r) {
              return Ot(t), kt(V(3).onFilter(r));
            }),
            z(),
            Lt(3, "span", 22),
            z();
        }
        if (2 & n) {
          const t = V(3);
          O(1),
            A("value", t.filterValue || "")("disabled", t.disabled),
            Ln("placeholder", t.filterPlaceHolder)(
              "aria-label",
              t.ariaFilterLabel
            );
        }
      }
      function G4(n, e) {
        1 & n && U(0, W4, 4, 4, "div", 18), 2 & n && A("ngIf", V(2).filter);
      }
      function q4(n, e) {
        if (
          (1 & n &&
            (H(0, "div", 6),
            U(1, H4, 6, 13, "div", 8),
            U(2, $4, 2, 4, "ng-container", 9),
            U(3, G4, 1, 1, "ng-template", null, 10, Xr),
            z()),
          2 & n)
        ) {
          const t = Dr(4),
            i = V();
          O(1),
            A("ngIf", i.checkbox && i.multiple && i.showToggleAll),
            O(1),
            A("ngIf", i.filterTemplate)("ngIfElse", t);
        }
      }
      function K4(n, e) {
        if ((1 & n && (H(0, "span"), ze(1), z()), 2 & n)) {
          const t = V().$implicit,
            i = V(2);
          O(1), _n(i.getOptionGroupLabel(t) || "empty");
        }
      }
      function Y4(n, e) {
        1 & n && Kt(0);
      }
      function Z4(n, e) {
        1 & n && Kt(0);
      }
      const Xy = function (n) {
        return { $implicit: n };
      };
      function Q4(n, e) {
        if (
          (1 & n &&
            (H(0, "li", 24),
            U(1, K4, 2, 1, "span", 3),
            U(2, Y4, 1, 0, "ng-container", 17),
            z(),
            U(3, Z4, 1, 0, "ng-container", 17)),
          2 & n)
        ) {
          const t = e.$implicit,
            i = V(2),
            r = Dr(8);
          O(1),
            A("ngIf", !i.groupTemplate),
            O(1),
            A("ngTemplateOutlet", i.groupTemplate)(
              "ngTemplateOutletContext",
              Kn(5, Xy, t)
            ),
            O(1),
            A("ngTemplateOutlet", r)(
              "ngTemplateOutletContext",
              Kn(7, Xy, i.getOptionGroupChildren(t))
            );
        }
      }
      function J4(n, e) {
        if (
          (1 & n && (ji(0), U(1, Q4, 4, 9, "ng-template", 23), Hi()), 2 & n)
        ) {
          const t = V();
          O(1), A("ngForOf", t.optionsToRender);
        }
      }
      function X4(n, e) {
        1 & n && Kt(0);
      }
      function e$(n, e) {
        if (
          (1 & n && (ji(0), U(1, X4, 1, 0, "ng-container", 17), Hi()), 2 & n)
        ) {
          const t = V(),
            i = Dr(8);
          O(1),
            A("ngTemplateOutlet", i)(
              "ngTemplateOutletContext",
              Kn(2, Xy, t.optionsToRender)
            );
        }
      }
      const t$ = function (n) {
        return { "p-highlight": n };
      };
      function n$(n, e) {
        if (
          (1 & n && (H(0, "div", 11)(1, "div", 28), Lt(2, "span", 16), z()()),
          2 & n)
        ) {
          const t = V().$implicit,
            i = V(2);
          A("ngClass", Kn(3, cT, i.disabled || i.isOptionDisabled(t))),
            O(1),
            A("ngClass", Kn(5, t$, i.isSelected(t))),
            O(1),
            A("ngClass", Kn(7, uT, i.isSelected(t)));
        }
      }
      function i$(n, e) {
        if ((1 & n && (H(0, "span"), ze(1), z()), 2 & n)) {
          const t = V().$implicit,
            i = V(2);
          O(1), _n(i.getOptionLabel(t));
        }
      }
      function r$(n, e) {
        1 & n && Kt(0);
      }
      const o$ = function (n, e) {
          return { "p-listbox-item": !0, "p-highlight": n, "p-disabled": e };
        },
        s$ = function (n, e) {
          return { $implicit: n, index: e };
        };
      function a$(n, e) {
        if (1 & n) {
          const t = Ui();
          H(0, "li", 27),
            Oe("click", function (r) {
              const s = Ot(t).$implicit;
              return kt(V(2).onOptionClick(r, s));
            })("dblclick", function (r) {
              const s = Ot(t).$implicit;
              return kt(V(2).onOptionDoubleClick(r, s));
            })("touchend", function () {
              const o = Ot(t).$implicit;
              return kt(V(2).onOptionTouchEnd(o));
            })("keydown", function (r) {
              const s = Ot(t).$implicit;
              return kt(V(2).onOptionKeyDown(r, s));
            }),
            U(1, n$, 3, 9, "div", 8),
            U(2, i$, 2, 1, "span", 3),
            U(3, r$, 1, 0, "ng-container", 17),
            z();
        }
        if (2 & n) {
          const t = e.$implicit,
            i = e.index,
            r = V(2);
          A("ngClass", Im(8, o$, r.isSelected(t), r.isOptionDisabled(t))),
            Ln("tabindex", r.disabled || r.isOptionDisabled(t) ? null : "0")(
              "aria-label",
              r.getOptionLabel(t)
            )("aria-selected", r.isSelected(t)),
            O(1),
            A("ngIf", r.checkbox && r.multiple),
            O(1),
            A("ngIf", !r.itemTemplate),
            O(1),
            A("ngTemplateOutlet", r.itemTemplate)(
              "ngTemplateOutletContext",
              Im(11, s$, t, i)
            );
        }
      }
      function l$(n, e) {
        if ((1 & n && (ji(0), ze(1), Hi()), 2 & n)) {
          const t = V(3);
          O(1), Zr(" ", t.emptyFilterMessageLabel, " ");
        }
      }
      function c$(n, e) {
        1 & n && Kt(0, null, 30);
      }
      function u$(n, e) {
        if (
          (1 & n &&
            (H(0, "li", 29),
            U(1, l$, 2, 1, "ng-container", 9),
            U(2, c$, 2, 0, "ng-container", 7),
            z()),
          2 & n)
        ) {
          const t = V(2);
          O(1),
            A("ngIf", !t.emptyFilterTemplate && !t.emptyTemplate)(
              "ngIfElse",
              t.emptyFilter
            ),
            O(1),
            A("ngTemplateOutlet", t.emptyFilterTemplate || t.emptyTemplate);
        }
      }
      function d$(n, e) {
        if ((1 & n && (ji(0), ze(1), Hi()), 2 & n)) {
          const t = V(3);
          O(1), Zr(" ", t.emptyMessageLabel, " ");
        }
      }
      function h$(n, e) {
        1 & n && Kt(0, null, 31);
      }
      function f$(n, e) {
        if (
          (1 & n &&
            (H(0, "li", 29),
            U(1, d$, 2, 1, "ng-container", 9),
            U(2, h$, 2, 0, "ng-container", 7),
            z()),
          2 & n)
        ) {
          const t = V(2);
          O(1),
            A("ngIf", !t.emptyTemplate)("ngIfElse", t.empty),
            O(1),
            A("ngTemplateOutlet", t.emptyTemplate);
        }
      }
      function p$(n, e) {
        if (
          (1 & n &&
            (U(0, a$, 4, 14, "li", 25),
            U(1, u$, 3, 3, "li", 26),
            U(2, f$, 3, 3, "li", 26)),
          2 & n)
        ) {
          const t = e.$implicit,
            i = V();
          A("ngForOf", t),
            O(1),
            A("ngIf", i.hasFilter() && i.isEmpty(t)),
            O(1),
            A("ngIf", !i.hasFilter() && i.isEmpty(t));
        }
      }
      function g$(n, e) {
        1 & n && Kt(0);
      }
      function m$(n, e) {
        if (
          (1 & n &&
            (H(0, "div", 32), Cr(1, 1), U(2, g$, 1, 0, "ng-container", 7), z()),
          2 & n)
        ) {
          const t = V();
          O(2), A("ngTemplateOutlet", t.footerTemplate);
        }
      }
      const y$ = [[["p-header"]], [["p-footer"]]],
        v$ = function (n) {
          return { "p-listbox p-component": !0, "p-disabled": n };
        },
        _$ = ["p-header", "p-footer"],
        b$ = { provide: Jn, useExisting: Ne(() => D$), multi: !0 };
      let D$ = (() => {
          class n {
            constructor(t, i, r, o) {
              (this.el = t),
                (this.cd = i),
                (this.filterService = r),
                (this.config = o),
                (this.checkbox = !1),
                (this.filter = !1),
                (this.filterMatchMode = "contains"),
                (this.metaKeySelection = !0),
                (this.showToggleAll = !0),
                (this.optionGroupChildren = "items"),
                (this.onChange = new Ie()),
                (this.onClick = new Ie()),
                (this.onDblClick = new Ie()),
                (this.onModelChange = () => {}),
                (this.onModelTouched = () => {});
            }
            get options() {
              return this._options;
            }
            set options(t) {
              (this._options = t), this.hasFilter() && this.activateFilter();
            }
            get filterValue() {
              return this._filterValue;
            }
            set filterValue(t) {
              (this._filterValue = t), this.activateFilter();
            }
            ngOnInit() {
              (this.translationSubscription =
                this.config.translationObserver.subscribe(() => {
                  this.cd.markForCheck();
                })),
                this.filterBy &&
                  (this.filterOptions = {
                    filter: (t) => this.onFilter(t),
                    reset: () => this.resetFilter(),
                  });
            }
            ngAfterContentInit() {
              this.templates.forEach((t) => {
                switch (t.getType()) {
                  case "item":
                  default:
                    this.itemTemplate = t.template;
                    break;
                  case "group":
                    this.groupTemplate = t.template;
                    break;
                  case "header":
                    this.headerTemplate = t.template;
                    break;
                  case "filter":
                    this.filterTemplate = t.template;
                    break;
                  case "footer":
                    this.footerTemplate = t.template;
                    break;
                  case "empty":
                    this.emptyTemplate = t.template;
                    break;
                  case "emptyfilter":
                    this.emptyFilterTemplate = t.template;
                }
              });
            }
            getOptionLabel(t) {
              return this.optionLabel
                ? lt.resolveFieldData(t, this.optionLabel)
                : null != t.label
                ? t.label
                : t;
            }
            getOptionGroupChildren(t) {
              return this.optionGroupChildren
                ? lt.resolveFieldData(t, this.optionGroupChildren)
                : t.items;
            }
            getOptionGroupLabel(t) {
              return this.optionGroupLabel
                ? lt.resolveFieldData(t, this.optionGroupLabel)
                : null != t.label
                ? t.label
                : t;
            }
            getOptionValue(t) {
              return this.optionValue
                ? lt.resolveFieldData(t, this.optionValue)
                : this.optionLabel || void 0 === t.value
                ? t
                : t.value;
            }
            isOptionDisabled(t) {
              return this.optionDisabled
                ? lt.resolveFieldData(t, this.optionDisabled)
                : void 0 !== t.disabled && t.disabled;
            }
            writeValue(t) {
              (this.value = t), this.cd.markForCheck();
            }
            registerOnChange(t) {
              this.onModelChange = t;
            }
            registerOnTouched(t) {
              this.onModelTouched = t;
            }
            setDisabledState(t) {
              (this.disabled = t), this.cd.markForCheck();
            }
            onOptionClick(t, i) {
              this.disabled ||
                this.isOptionDisabled(i) ||
                this.readonly ||
                (this.multiple
                  ? this.checkbox
                    ? this.onOptionClickCheckbox(t, i)
                    : this.onOptionClickMultiple(t, i)
                  : this.onOptionClickSingle(t, i),
                this.onClick.emit({
                  originalEvent: t,
                  option: i,
                  value: this.value,
                }),
                (this.optionTouched = !1));
            }
            onOptionTouchEnd(t) {
              this.disabled ||
                this.isOptionDisabled(t) ||
                this.readonly ||
                (this.optionTouched = !0);
            }
            onOptionDoubleClick(t, i) {
              this.disabled ||
                this.isOptionDisabled(i) ||
                this.readonly ||
                this.onDblClick.emit({
                  originalEvent: t,
                  option: i,
                  value: this.value,
                });
            }
            onOptionClickSingle(t, i) {
              let r = this.isSelected(i),
                o = !1;
              if (!this.optionTouched && this.metaKeySelection) {
                let a = t.metaKey || t.ctrlKey;
                r
                  ? a && ((this.value = null), (o = !0))
                  : ((this.value = this.getOptionValue(i)), (o = !0));
              } else (this.value = r ? null : this.getOptionValue(i)), (o = !0);
              o &&
                (this.onModelChange(this.value),
                this.onChange.emit({ originalEvent: t, value: this.value }));
            }
            onOptionClickMultiple(t, i) {
              let r = this.isSelected(i),
                o = !1;
              if (!this.optionTouched && this.metaKeySelection) {
                let a = t.metaKey || t.ctrlKey;
                r
                  ? (a
                      ? this.removeOption(i)
                      : (this.value = [this.getOptionValue(i)]),
                    (o = !0))
                  : ((this.value = (a && this.value) || []),
                    (this.value = [...this.value, this.getOptionValue(i)]),
                    (o = !0));
              } else
                r
                  ? this.removeOption(i)
                  : (this.value = [
                      ...(this.value || []),
                      this.getOptionValue(i),
                    ]),
                  (o = !0);
              o &&
                (this.onModelChange(this.value),
                this.onChange.emit({ originalEvent: t, value: this.value }));
            }
            onOptionClickCheckbox(t, i) {
              this.disabled ||
                this.readonly ||
                (this.isSelected(i)
                  ? this.removeOption(i)
                  : ((this.value = this.value ? this.value : []),
                    (this.value = [...this.value, this.getOptionValue(i)])),
                this.onModelChange(this.value),
                this.onChange.emit({ originalEvent: t, value: this.value }));
            }
            removeOption(t) {
              this.value = this.value.filter(
                (i) => !lt.equals(i, this.getOptionValue(t), this.dataKey)
              );
            }
            isSelected(t) {
              let i = !1,
                r = this.getOptionValue(t);
              if (this.multiple) {
                if (this.value)
                  for (let o of this.value)
                    if (lt.equals(o, r, this.dataKey)) {
                      i = !0;
                      break;
                    }
              } else i = lt.equals(this.value, r, this.dataKey);
              return i;
            }
            get allChecked() {
              let t = this.optionsToRender;
              if (!t || 0 === t.length) return !1;
              {
                let i = 0,
                  r = 0,
                  o = 0,
                  s = this.group ? 0 : this.optionsToRender.length;
                for (let a of t)
                  if (this.group)
                    for (let l of this.getOptionGroupChildren(a)) {
                      let c = this.isOptionDisabled(l),
                        u = this.isSelected(l);
                      if (c) u ? i++ : r++;
                      else {
                        if (!u) return !1;
                        o++;
                      }
                      s++;
                    }
                  else {
                    let l = this.isOptionDisabled(a),
                      c = this.isSelected(a);
                    if (l) c ? i++ : r++;
                    else {
                      if (!c) return !1;
                      o++;
                    }
                  }
                return s === i || s === o || (o && s === o + r + i);
              }
            }
            get optionsToRender() {
              return this._filteredOptions || this.options;
            }
            get emptyMessageLabel() {
              return (
                this.emptyMessage ||
                this.config.getTranslation(kI.EMPTY_MESSAGE)
              );
            }
            get emptyFilterMessageLabel() {
              return (
                this.emptyFilterMessage ||
                this.config.getTranslation(kI.EMPTY_FILTER_MESSAGE)
              );
            }
            hasFilter() {
              return this._filterValue && this._filterValue.trim().length > 0;
            }
            isEmpty(t) {
              return !t || (t && 0 === t.length);
            }
            onFilter(t) {
              (this._filterValue = t.target.value), this.activateFilter();
            }
            activateFilter() {
              if (this.hasFilter() && this._options)
                if (this.group) {
                  let t = (this.filterBy || this.optionLabel || "label").split(
                      ","
                    ),
                    i = [];
                  for (let r of this.options) {
                    let o = this.filterService.filter(
                      this.getOptionGroupChildren(r),
                      t,
                      this.filterValue,
                      this.filterMatchMode,
                      this.filterLocale
                    );
                    o &&
                      o.length &&
                      i.push({ ...r, [this.optionGroupChildren]: o });
                  }
                  this._filteredOptions = i;
                } else
                  this._filteredOptions = this._options.filter((t) =>
                    this.filterService.filters[this.filterMatchMode](
                      this.getOptionLabel(t),
                      this._filterValue,
                      this.filterLocale
                    )
                  );
              else this._filteredOptions = null;
            }
            resetFilter() {
              this.filterViewChild &&
                this.filterViewChild.nativeElement &&
                (this.filterViewChild.nativeElement.value = ""),
                (this._filterValue = null),
                (this._filteredOptions = null);
            }
            get toggleAllDisabled() {
              let t = this.optionsToRender;
              if (!t || 0 === t.length) return !0;
              for (let i of t) if (!this.isOptionDisabled(i)) return !1;
              return !0;
            }
            toggleAll(t) {
              this.disabled ||
                this.toggleAllDisabled ||
                this.readonly ||
                (this.allChecked ? this.uncheckAll() : this.checkAll(),
                this.onModelChange(this.value),
                this.onChange.emit({ originalEvent: t, value: this.value }),
                t.preventDefault());
            }
            checkAll() {
              let i = [];
              this.optionsToRender.forEach((r) => {
                if (this.group) {
                  let o = this.getOptionGroupChildren(r);
                  o &&
                    o.forEach((s) => {
                      let a = this.isOptionDisabled(s);
                      (!a || (a && this.isSelected(s))) &&
                        i.push(this.getOptionValue(s));
                    });
                } else {
                  let o = this.isOptionDisabled(r);
                  (!o || (o && this.isSelected(r))) &&
                    i.push(this.getOptionValue(r));
                }
              }),
                (this.value = i);
            }
            uncheckAll() {
              let i = [];
              this.optionsToRender.forEach((r) => {
                this.group
                  ? r.items &&
                    r.items.forEach((o) => {
                      this.isOptionDisabled(o) &&
                        this.isSelected(o) &&
                        i.push(this.getOptionValue(o));
                    })
                  : this.isOptionDisabled(r) &&
                    this.isSelected(r) &&
                    i.push(this.getOptionValue(r));
              }),
                (this.value = i);
            }
            onOptionKeyDown(t, i) {
              if (this.readonly) return;
              let r = t.currentTarget;
              switch (t.which) {
                case 40:
                  var o = this.findNextItem(r);
                  o && o.focus(), t.preventDefault();
                  break;
                case 38:
                  var s = this.findPrevItem(r);
                  s && s.focus(), t.preventDefault();
                  break;
                case 13:
                  this.onOptionClick(t, i), t.preventDefault();
              }
            }
            findNextItem(t) {
              let i = t.nextElementSibling;
              return i
                ? Mt.hasClass(i, "p-disabled") ||
                  Mt.isHidden(i) ||
                  Mt.hasClass(i, "p-listbox-item-group")
                  ? this.findNextItem(i)
                  : i
                : null;
            }
            findPrevItem(t) {
              let i = t.previousElementSibling;
              return i
                ? Mt.hasClass(i, "p-disabled") ||
                  Mt.isHidden(i) ||
                  Mt.hasClass(i, "p-listbox-item-group")
                  ? this.findPrevItem(i)
                  : i
                : null;
            }
            onHeaderCheckboxFocus() {
              this.headerCheckboxFocus = !0;
            }
            onHeaderCheckboxBlur() {
              this.headerCheckboxFocus = !1;
            }
            ngOnDestroy() {
              this.translationSubscription &&
                this.translationSubscription.unsubscribe();
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(w(ut), w(Zo), w(Q3), w(OI));
            }),
            (n.ɵcmp = ht({
              type: n,
              selectors: [["p-listbox"]],
              contentQueries: function (t, i, r) {
                if (
                  (1 & t && (qi(r, NI, 5), qi(r, RI, 5), qi(r, $y, 4)), 2 & t)
                ) {
                  let o;
                  bn((o = Dn())) && (i.headerFacet = o.first),
                    bn((o = Dn())) && (i.footerFacet = o.first),
                    bn((o = Dn())) && (i.templates = o);
                }
              },
              viewQuery: function (t, i) {
                if ((1 & t && (ec(F4, 5), ec(L4, 5)), 2 & t)) {
                  let r;
                  bn((r = Dn())) && (i.headerCheckboxViewChild = r.first),
                    bn((r = Dn())) && (i.filterViewChild = r.first);
                }
              },
              hostAttrs: [1, "p-element"],
              inputs: {
                multiple: "multiple",
                style: "style",
                styleClass: "styleClass",
                listStyle: "listStyle",
                listStyleClass: "listStyleClass",
                readonly: "readonly",
                disabled: "disabled",
                checkbox: "checkbox",
                filter: "filter",
                filterBy: "filterBy",
                filterMatchMode: "filterMatchMode",
                filterLocale: "filterLocale",
                metaKeySelection: "metaKeySelection",
                dataKey: "dataKey",
                showToggleAll: "showToggleAll",
                optionLabel: "optionLabel",
                optionValue: "optionValue",
                optionGroupChildren: "optionGroupChildren",
                optionGroupLabel: "optionGroupLabel",
                optionDisabled: "optionDisabled",
                ariaFilterLabel: "ariaFilterLabel",
                filterPlaceHolder: "filterPlaceHolder",
                emptyFilterMessage: "emptyFilterMessage",
                emptyMessage: "emptyMessage",
                group: "group",
                options: "options",
                filterValue: "filterValue",
              },
              outputs: {
                onChange: "onChange",
                onClick: "onClick",
                onDblClick: "onDblClick",
              },
              features: [$e([b$])],
              ngContentSelectors: _$,
              decls: 10,
              vars: 15,
              consts: [
                [3, "ngClass", "ngStyle"],
                ["class", "p-listbox-header", 4, "ngIf"],
                [
                  "role",
                  "listbox",
                  "aria-multiselectable",
                  "multiple",
                  1,
                  "p-listbox-list",
                ],
                [4, "ngIf"],
                ["itemslist", ""],
                ["class", "p-listbox-footer", 4, "ngIf"],
                [1, "p-listbox-header"],
                [4, "ngTemplateOutlet"],
                ["class", "p-checkbox p-component", 3, "ngClass", 4, "ngIf"],
                [4, "ngIf", "ngIfElse"],
                ["builtInFilterElement", ""],
                [1, "p-checkbox", "p-component", 3, "ngClass"],
                [1, "p-hidden-accessible"],
                [
                  "type",
                  "checkbox",
                  "readonly",
                  "readonly",
                  3,
                  "checked",
                  "disabled",
                  "focus",
                  "blur",
                  "keydown.space",
                ],
                [1, "p-checkbox-box", 3, "ngClass", "click"],
                ["headerchkbox", ""],
                [1, "p-checkbox-icon", 3, "ngClass"],
                [4, "ngTemplateOutlet", "ngTemplateOutletContext"],
                ["class", "p-listbox-filter-container", 4, "ngIf"],
                [1, "p-listbox-filter-container"],
                [
                  "type",
                  "text",
                  1,
                  "p-listbox-filter",
                  "p-inputtext",
                  "p-component",
                  3,
                  "value",
                  "disabled",
                  "input",
                ],
                ["filter", ""],
                [1, "p-listbox-filter-icon", "pi", "pi-search"],
                ["ngFor", "", 3, "ngForOf"],
                [1, "p-listbox-item-group"],
                [
                  "pRipple",
                  "",
                  "role",
                  "option",
                  3,
                  "ngClass",
                  "click",
                  "dblclick",
                  "touchend",
                  "keydown",
                  4,
                  "ngFor",
                  "ngForOf",
                ],
                ["class", "p-listbox-empty-message", 4, "ngIf"],
                [
                  "pRipple",
                  "",
                  "role",
                  "option",
                  3,
                  "ngClass",
                  "click",
                  "dblclick",
                  "touchend",
                  "keydown",
                ],
                [1, "p-checkbox-box", 3, "ngClass"],
                [1, "p-listbox-empty-message"],
                ["emptyFilter", ""],
                ["empty", ""],
                [1, "p-listbox-footer"],
              ],
              template: function (t, i) {
                1 & t &&
                  (da(y$),
                  H(0, "div", 0),
                  U(1, B4, 3, 1, "div", 1),
                  U(2, q4, 5, 3, "div", 1),
                  H(3, "div", 0)(4, "ul", 2),
                  U(5, J4, 2, 1, "ng-container", 3),
                  U(6, e$, 2, 4, "ng-container", 3),
                  U(7, p$, 3, 3, "ng-template", null, 4, Xr),
                  z()(),
                  U(9, m$, 3, 1, "div", 5),
                  z()),
                  2 & t &&
                    (yd(i.styleClass),
                    A("ngClass", Kn(13, v$, i.disabled))("ngStyle", i.style),
                    O(1),
                    A("ngIf", i.headerFacet || i.headerTemplate),
                    O(1),
                    A(
                      "ngIf",
                      (i.checkbox && i.multiple && i.showToggleAll) || i.filter
                    ),
                    O(1),
                    yd(i.listStyleClass),
                    A("ngClass", "p-listbox-list-wrapper")(
                      "ngStyle",
                      i.listStyle
                    ),
                    O(2),
                    A("ngIf", i.group),
                    O(1),
                    A("ngIf", !i.group),
                    O(3),
                    A("ngIf", i.footerFacet || i.footerTemplate));
              },
              dependencies: [sc, Kd, to, py, fy, J3],
              styles: [
                ".p-listbox-list-wrapper{overflow:auto}.p-listbox-list{list-style-type:none;margin:0;padding:0}.p-listbox-item{cursor:pointer;position:relative;overflow:hidden;display:flex;align-items:center;-webkit-user-select:none;user-select:none}.p-listbox-header{display:flex;align-items:center}.p-listbox-filter-container{position:relative;flex:1 1 auto}.p-listbox-filter-icon{position:absolute;top:50%;margin-top:-.5rem}.p-listbox-filter{width:100%}\n",
              ],
              encapsulation: 2,
              changeDetection: 0,
            })),
            n
          );
        })(),
        C$ = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = rt({ type: n })),
            (n.ɵinj = Xe({ imports: [bi, fc, hh, fc] })),
            n
          );
        })();
      function Qt(n) {
        this.content = n;
      }
      (Qt.prototype = {
        constructor: Qt,
        find: function (n) {
          for (var e = 0; e < this.content.length; e += 2)
            if (this.content[e] === n) return e;
          return -1;
        },
        get: function (n) {
          var e = this.find(n);
          return -1 == e ? void 0 : this.content[e + 1];
        },
        update: function (n, e, t) {
          var i = t && t != n ? this.remove(t) : this,
            r = i.find(n),
            o = i.content.slice();
          return (
            -1 == r ? o.push(t || n, e) : ((o[r + 1] = e), t && (o[r] = t)),
            new Qt(o)
          );
        },
        remove: function (n) {
          var e = this.find(n);
          if (-1 == e) return this;
          var t = this.content.slice();
          return t.splice(e, 2), new Qt(t);
        },
        addToStart: function (n, e) {
          return new Qt([n, e].concat(this.remove(n).content));
        },
        addToEnd: function (n, e) {
          var t = this.remove(n).content.slice();
          return t.push(n, e), new Qt(t);
        },
        addBefore: function (n, e, t) {
          var i = this.remove(e),
            r = i.content.slice(),
            o = i.find(n);
          return r.splice(-1 == o ? r.length : o, 0, e, t), new Qt(r);
        },
        forEach: function (n) {
          for (var e = 0; e < this.content.length; e += 2)
            n(this.content[e], this.content[e + 1]);
        },
        prepend: function (n) {
          return (n = Qt.from(n)).size
            ? new Qt(n.content.concat(this.subtract(n).content))
            : this;
        },
        append: function (n) {
          return (n = Qt.from(n)).size
            ? new Qt(this.subtract(n).content.concat(n.content))
            : this;
        },
        subtract: function (n) {
          var e = this;
          n = Qt.from(n);
          for (var t = 0; t < n.content.length; t += 2)
            e = e.remove(n.content[t]);
          return e;
        },
        get size() {
          return this.content.length >> 1;
        },
      }),
        (Qt.from = function (n) {
          if (n instanceof Qt) return n;
          var e = [];
          if (n) for (var t in n) e.push(t, n[t]);
          return new Qt(e);
        });
      const dT = Qt;
      function hT(n, e, t) {
        for (let i = 0; ; i++) {
          if (i == n.childCount || i == e.childCount)
            return n.childCount == e.childCount ? null : t;
          let r = n.child(i),
            o = e.child(i);
          if (r != o) {
            if (!r.sameMarkup(o)) return t;
            if (r.isText && r.text != o.text) {
              for (let s = 0; r.text[s] == o.text[s]; s++) t++;
              return t;
            }
            if (r.content.size || o.content.size) {
              let s = hT(r.content, o.content, t + 1);
              if (null != s) return s;
            }
            t += r.nodeSize;
          } else t += r.nodeSize;
        }
      }
      function fT(n, e, t, i) {
        for (let r = n.childCount, o = e.childCount; ; ) {
          if (0 == r || 0 == o) return r == o ? null : { a: t, b: i };
          let s = n.child(--r),
            a = e.child(--o),
            l = s.nodeSize;
          if (s != a) {
            if (!s.sameMarkup(a)) return { a: t, b: i };
            if (s.isText && s.text != a.text) {
              let c = 0,
                u = Math.min(s.text.length, a.text.length);
              for (
                ;
                c < u &&
                s.text[s.text.length - c - 1] == a.text[a.text.length - c - 1];

              )
                c++, t--, i--;
              return { a: t, b: i };
            }
            if (s.content.size || a.content.size) {
              let c = fT(s.content, a.content, t - 1, i - 1);
              if (c) return c;
            }
            (t -= l), (i -= l);
          } else (t -= l), (i -= l);
        }
      }
      class I {
        constructor(e, t) {
          if (((this.content = e), (this.size = t || 0), null == t))
            for (let i = 0; i < e.length; i++) this.size += e[i].nodeSize;
        }
        nodesBetween(e, t, i, r = 0, o) {
          for (let s = 0, a = 0; a < t; s++) {
            let l = this.content[s],
              c = a + l.nodeSize;
            if (c > e && !1 !== i(l, r + a, o || null, s) && l.content.size) {
              let u = a + 1;
              l.nodesBetween(
                Math.max(0, e - u),
                Math.min(l.content.size, t - u),
                i,
                r + u
              );
            }
            a = c;
          }
        }
        descendants(e) {
          this.nodesBetween(0, this.size, e);
        }
        textBetween(e, t, i, r) {
          let o = "",
            s = !0;
          return (
            this.nodesBetween(
              e,
              t,
              (a, l) => {
                a.isText
                  ? ((o += a.text.slice(Math.max(e, l) - l, t - l)), (s = !i))
                  : a.isLeaf
                  ? (r
                      ? (o += "function" == typeof r ? r(a) : r)
                      : a.type.spec.leafText && (o += a.type.spec.leafText(a)),
                    (s = !i))
                  : !s && a.isBlock && ((o += i), (s = !0));
              },
              0
            ),
            o
          );
        }
        append(e) {
          if (!e.size) return this;
          if (!this.size) return e;
          let t = this.lastChild,
            i = e.firstChild,
            r = this.content.slice(),
            o = 0;
          for (
            t.isText &&
            t.sameMarkup(i) &&
            ((r[r.length - 1] = t.withText(t.text + i.text)), (o = 1));
            o < e.content.length;
            o++
          )
            r.push(e.content[o]);
          return new I(r, this.size + e.size);
        }
        cut(e, t = this.size) {
          if (0 == e && t == this.size) return this;
          let i = [],
            r = 0;
          if (t > e)
            for (let o = 0, s = 0; s < t; o++) {
              let a = this.content[o],
                l = s + a.nodeSize;
              l > e &&
                ((s < e || l > t) &&
                  (a = a.isText
                    ? a.cut(Math.max(0, e - s), Math.min(a.text.length, t - s))
                    : a.cut(
                        Math.max(0, e - s - 1),
                        Math.min(a.content.size, t - s - 1)
                      )),
                i.push(a),
                (r += a.nodeSize)),
                (s = l);
            }
          return new I(i, r);
        }
        cutByIndex(e, t) {
          return e == t
            ? I.empty
            : 0 == e && t == this.content.length
            ? this
            : new I(this.content.slice(e, t));
        }
        replaceChild(e, t) {
          let i = this.content[e];
          if (i == t) return this;
          let r = this.content.slice(),
            o = this.size + t.nodeSize - i.nodeSize;
          return (r[e] = t), new I(r, o);
        }
        addToStart(e) {
          return new I([e].concat(this.content), this.size + e.nodeSize);
        }
        addToEnd(e) {
          return new I(this.content.concat(e), this.size + e.nodeSize);
        }
        eq(e) {
          if (this.content.length != e.content.length) return !1;
          for (let t = 0; t < this.content.length; t++)
            if (!this.content[t].eq(e.content[t])) return !1;
          return !0;
        }
        get firstChild() {
          return this.content.length ? this.content[0] : null;
        }
        get lastChild() {
          return this.content.length
            ? this.content[this.content.length - 1]
            : null;
        }
        get childCount() {
          return this.content.length;
        }
        child(e) {
          let t = this.content[e];
          if (!t)
            throw new RangeError("Index " + e + " out of range for " + this);
          return t;
        }
        maybeChild(e) {
          return this.content[e] || null;
        }
        forEach(e) {
          for (let t = 0, i = 0; t < this.content.length; t++) {
            let r = this.content[t];
            e(r, i, t), (i += r.nodeSize);
          }
        }
        findDiffStart(e, t = 0) {
          return hT(this, e, t);
        }
        findDiffEnd(e, t = this.size, i = e.size) {
          return fT(this, e, t, i);
        }
        findIndex(e, t = -1) {
          if (0 == e) return Dh(0, e);
          if (e == this.size) return Dh(this.content.length, e);
          if (e > this.size || e < 0)
            throw new RangeError(`Position ${e} outside of fragment (${this})`);
          for (let i = 0, r = 0; ; i++) {
            let s = r + this.child(i).nodeSize;
            if (s >= e) return s == e || t > 0 ? Dh(i + 1, s) : Dh(i, r);
            r = s;
          }
        }
        toString() {
          return "<" + this.toStringInner() + ">";
        }
        toStringInner() {
          return this.content.join(", ");
        }
        toJSON() {
          return this.content.length
            ? this.content.map((e) => e.toJSON())
            : null;
        }
        static fromJSON(e, t) {
          if (!t) return I.empty;
          if (!Array.isArray(t))
            throw new RangeError("Invalid input for Fragment.fromJSON");
          return new I(t.map(e.nodeFromJSON));
        }
        static fromArray(e) {
          if (!e.length) return I.empty;
          let t,
            i = 0;
          for (let r = 0; r < e.length; r++) {
            let o = e[r];
            (i += o.nodeSize),
              r && o.isText && e[r - 1].sameMarkup(o)
                ? (t || (t = e.slice(0, r)),
                  (t[t.length - 1] = o.withText(t[t.length - 1].text + o.text)))
                : t && t.push(o);
          }
          return new I(t || e, i);
        }
        static from(e) {
          if (!e) return I.empty;
          if (e instanceof I) return e;
          if (Array.isArray(e)) return this.fromArray(e);
          if (e.attrs) return new I([e], e.nodeSize);
          throw new RangeError(
            "Can not convert " +
              e +
              " to a Fragment" +
              (e.nodesBetween
                ? " (looks like multiple versions of prosemirror-model were loaded)"
                : "")
          );
        }
      }
      I.empty = new I([], 0);
      const ev = { index: 0, offset: 0 };
      function Dh(n, e) {
        return (ev.index = n), (ev.offset = e), ev;
      }
      function Ch(n, e) {
        if (n === e) return !0;
        if (!n || "object" != typeof n || !e || "object" != typeof e) return !1;
        let t = Array.isArray(n);
        if (Array.isArray(e) != t) return !1;
        if (t) {
          if (n.length != e.length) return !1;
          for (let i = 0; i < n.length; i++) if (!Ch(n[i], e[i])) return !1;
        } else {
          for (let i in n) if (!(i in e) || !Ch(n[i], e[i])) return !1;
          for (let i in e) if (!(i in n)) return !1;
        }
        return !0;
      }
      let Ye = (() => {
        class n {
          constructor(t, i) {
            (this.type = t), (this.attrs = i);
          }
          addToSet(t) {
            let i,
              r = !1;
            for (let o = 0; o < t.length; o++) {
              let s = t[o];
              if (this.eq(s)) return t;
              if (this.type.excludes(s.type)) i || (i = t.slice(0, o));
              else {
                if (s.type.excludes(this.type)) return t;
                !r &&
                  s.type.rank > this.type.rank &&
                  (i || (i = t.slice(0, o)), i.push(this), (r = !0)),
                  i && i.push(s);
              }
            }
            return i || (i = t.slice()), r || i.push(this), i;
          }
          removeFromSet(t) {
            for (let i = 0; i < t.length; i++)
              if (this.eq(t[i])) return t.slice(0, i).concat(t.slice(i + 1));
            return t;
          }
          isInSet(t) {
            for (let i = 0; i < t.length; i++) if (this.eq(t[i])) return !0;
            return !1;
          }
          eq(t) {
            return (
              this == t || (this.type == t.type && Ch(this.attrs, t.attrs))
            );
          }
          toJSON() {
            let t = { type: this.type.name };
            for (let i in this.attrs) {
              t.attrs = this.attrs;
              break;
            }
            return t;
          }
          static fromJSON(t, i) {
            if (!i) throw new RangeError("Invalid input for Mark.fromJSON");
            let r = t.marks[i.type];
            if (!r)
              throw new RangeError(
                `There is no mark type ${i.type} in this schema`
              );
            return r.create(i.attrs);
          }
          static sameSet(t, i) {
            if (t == i) return !0;
            if (t.length != i.length) return !1;
            for (let r = 0; r < t.length; r++) if (!t[r].eq(i[r])) return !1;
            return !0;
          }
          static setFrom(t) {
            if (!t || (Array.isArray(t) && 0 == t.length)) return n.none;
            if (t instanceof n) return [t];
            let i = t.slice();
            return i.sort((r, o) => r.type.rank - o.type.rank), i;
          }
        }
        return (n.none = []), n;
      })();
      class bc extends Error {}
      class P {
        constructor(e, t, i) {
          (this.content = e), (this.openStart = t), (this.openEnd = i);
        }
        get size() {
          return this.content.size - this.openStart - this.openEnd;
        }
        insertAt(e, t) {
          let i = gT(this.content, e + this.openStart, t);
          return i && new P(i, this.openStart, this.openEnd);
        }
        removeBetween(e, t) {
          return new P(
            pT(this.content, e + this.openStart, t + this.openStart),
            this.openStart,
            this.openEnd
          );
        }
        eq(e) {
          return (
            this.content.eq(e.content) &&
            this.openStart == e.openStart &&
            this.openEnd == e.openEnd
          );
        }
        toString() {
          return this.content + "(" + this.openStart + "," + this.openEnd + ")";
        }
        toJSON() {
          if (!this.content.size) return null;
          let e = { content: this.content.toJSON() };
          return (
            this.openStart > 0 && (e.openStart = this.openStart),
            this.openEnd > 0 && (e.openEnd = this.openEnd),
            e
          );
        }
        static fromJSON(e, t) {
          if (!t) return P.empty;
          let i = t.openStart || 0,
            r = t.openEnd || 0;
          if ("number" != typeof i || "number" != typeof r)
            throw new RangeError("Invalid input for Slice.fromJSON");
          return new P(I.fromJSON(e, t.content), i, r);
        }
        static maxOpen(e, t = !0) {
          let i = 0,
            r = 0;
          for (
            let o = e.firstChild;
            o && !o.isLeaf && (t || !o.type.spec.isolating);
            o = o.firstChild
          )
            i++;
          for (
            let o = e.lastChild;
            o && !o.isLeaf && (t || !o.type.spec.isolating);
            o = o.lastChild
          )
            r++;
          return new P(e, i, r);
        }
      }
      function pT(n, e, t) {
        let { index: i, offset: r } = n.findIndex(e),
          o = n.maybeChild(i),
          { index: s, offset: a } = n.findIndex(t);
        if (r == e || o.isText) {
          if (a != t && !n.child(s).isText)
            throw new RangeError("Removing non-flat range");
          return n.cut(0, e).append(n.cut(t));
        }
        if (i != s) throw new RangeError("Removing non-flat range");
        return n.replaceChild(i, o.copy(pT(o.content, e - r - 1, t - r - 1)));
      }
      function gT(n, e, t, i) {
        let { index: r, offset: o } = n.findIndex(e),
          s = n.maybeChild(r);
        if (o == e || s.isText)
          return i && !i.canReplace(r, r, t)
            ? null
            : n.cut(0, e).append(t).append(n.cut(e));
        let a = gT(s.content, e - o - 1, t);
        return a && n.replaceChild(r, s.copy(a));
      }
      function E$(n, e, t) {
        if (t.openStart > n.depth)
          throw new bc("Inserted content deeper than insertion position");
        if (n.depth - t.openStart != e.depth - t.openEnd)
          throw new bc("Inconsistent open depths");
        return mT(n, e, t, 0);
      }
      function mT(n, e, t, i) {
        let r = n.index(i),
          o = n.node(i);
        if (r == e.index(i) && i < n.depth - t.openStart) {
          let s = mT(n, e, t, i + 1);
          return o.copy(o.content.replaceChild(r, s));
        }
        if (t.content.size) {
          if (t.openStart || t.openEnd || n.depth != i || e.depth != i) {
            let { start: s, end: a } = (function w$(n, e) {
              let t = e.depth - n.openStart,
                r = e.node(t).copy(n.content);
              for (let o = t - 1; o >= 0; o--) r = e.node(o).copy(I.from(r));
              return {
                start: r.resolveNoCache(n.openStart + t),
                end: r.resolveNoCache(r.content.size - n.openEnd - t),
              };
            })(t, n);
            return is(o, vT(n, s, a, e, i));
          }
          {
            let s = n.parent,
              a = s.content;
            return is(
              s,
              a
                .cut(0, n.parentOffset)
                .append(t.content)
                .append(a.cut(e.parentOffset))
            );
          }
        }
        return is(o, Eh(n, e, i));
      }
      function yT(n, e) {
        if (!e.type.compatibleContent(n.type))
          throw new bc("Cannot join " + e.type.name + " onto " + n.type.name);
      }
      function tv(n, e, t) {
        let i = n.node(t);
        return yT(i, e.node(t)), i;
      }
      function ns(n, e) {
        let t = e.length - 1;
        t >= 0 && n.isText && n.sameMarkup(e[t])
          ? (e[t] = n.withText(e[t].text + n.text))
          : e.push(n);
      }
      function Dc(n, e, t, i) {
        let r = (e || n).node(t),
          o = 0,
          s = e ? e.index(t) : r.childCount;
        n &&
          ((o = n.index(t)),
          n.depth > t ? o++ : n.textOffset && (ns(n.nodeAfter, i), o++));
        for (let a = o; a < s; a++) ns(r.child(a), i);
        e && e.depth == t && e.textOffset && ns(e.nodeBefore, i);
      }
      function is(n, e) {
        if (!n.type.validContent(e))
          throw new bc("Invalid content for node " + n.type.name);
        return n.copy(e);
      }
      function vT(n, e, t, i, r) {
        let o = n.depth > r && tv(n, e, r + 1),
          s = i.depth > r && tv(t, i, r + 1),
          a = [];
        return (
          Dc(null, n, r, a),
          o && s && e.index(r) == t.index(r)
            ? (yT(o, s), ns(is(o, vT(n, e, t, i, r + 1)), a))
            : (o && ns(is(o, Eh(n, e, r + 1)), a),
              Dc(e, t, r, a),
              s && ns(is(s, Eh(t, i, r + 1)), a)),
          Dc(i, null, r, a),
          new I(a)
        );
      }
      function Eh(n, e, t) {
        let i = [];
        return (
          Dc(null, n, t, i),
          n.depth > t && ns(is(tv(n, e, t + 1), Eh(n, e, t + 1)), i),
          Dc(e, null, t, i),
          new I(i)
        );
      }
      P.empty = new P(I.empty, 0, 0);
      class Cc {
        constructor(e, t, i) {
          (this.pos = e),
            (this.path = t),
            (this.parentOffset = i),
            (this.depth = t.length / 3 - 1);
        }
        resolveDepth(e) {
          return null == e ? this.depth : e < 0 ? this.depth + e : e;
        }
        get parent() {
          return this.node(this.depth);
        }
        get doc() {
          return this.node(0);
        }
        node(e) {
          return this.path[3 * this.resolveDepth(e)];
        }
        index(e) {
          return this.path[3 * this.resolveDepth(e) + 1];
        }
        indexAfter(e) {
          return (
            (e = this.resolveDepth(e)),
            this.index(e) + (e != this.depth || this.textOffset ? 1 : 0)
          );
        }
        start(e) {
          return 0 == (e = this.resolveDepth(e)) ? 0 : this.path[3 * e - 1] + 1;
        }
        end(e) {
          return (
            (e = this.resolveDepth(e)),
            this.start(e) + this.node(e).content.size
          );
        }
        before(e) {
          if (!(e = this.resolveDepth(e)))
            throw new RangeError(
              "There is no position before the top-level node"
            );
          return e == this.depth + 1 ? this.pos : this.path[3 * e - 1];
        }
        after(e) {
          if (!(e = this.resolveDepth(e)))
            throw new RangeError(
              "There is no position after the top-level node"
            );
          return e == this.depth + 1
            ? this.pos
            : this.path[3 * e - 1] + this.path[3 * e].nodeSize;
        }
        get textOffset() {
          return this.pos - this.path[this.path.length - 1];
        }
        get nodeAfter() {
          let e = this.parent,
            t = this.index(this.depth);
          if (t == e.childCount) return null;
          let i = this.pos - this.path[this.path.length - 1],
            r = e.child(t);
          return i ? e.child(t).cut(i) : r;
        }
        get nodeBefore() {
          let e = this.index(this.depth),
            t = this.pos - this.path[this.path.length - 1];
          return t
            ? this.parent.child(e).cut(0, t)
            : 0 == e
            ? null
            : this.parent.child(e - 1);
        }
        posAtIndex(e, t) {
          t = this.resolveDepth(t);
          let i = this.path[3 * t],
            r = 0 == t ? 0 : this.path[3 * t - 1] + 1;
          for (let o = 0; o < e; o++) r += i.child(o).nodeSize;
          return r;
        }
        marks() {
          let e = this.parent,
            t = this.index();
          if (0 == e.content.size) return Ye.none;
          if (this.textOffset) return e.child(t).marks;
          let i = e.maybeChild(t - 1),
            r = e.maybeChild(t);
          if (!i) {
            let a = i;
            (i = r), (r = a);
          }
          let o = i.marks;
          for (var s = 0; s < o.length; s++)
            !1 === o[s].type.spec.inclusive &&
              (!r || !o[s].isInSet(r.marks)) &&
              (o = o[s--].removeFromSet(o));
          return o;
        }
        marksAcross(e) {
          let t = this.parent.maybeChild(this.index());
          if (!t || !t.isInline) return null;
          let i = t.marks,
            r = e.parent.maybeChild(e.index());
          for (var o = 0; o < i.length; o++)
            !1 === i[o].type.spec.inclusive &&
              (!r || !i[o].isInSet(r.marks)) &&
              (i = i[o--].removeFromSet(i));
          return i;
        }
        sharedDepth(e) {
          for (let t = this.depth; t > 0; t--)
            if (this.start(t) <= e && this.end(t) >= e) return t;
          return 0;
        }
        blockRange(e = this, t) {
          if (e.pos < this.pos) return e.blockRange(this);
          for (
            let i =
              this.depth -
              (this.parent.inlineContent || this.pos == e.pos ? 1 : 0);
            i >= 0;
            i--
          )
            if (e.pos <= this.end(i) && (!t || t(this.node(i))))
              return new wh(this, e, i);
          return null;
        }
        sameParent(e) {
          return this.pos - this.parentOffset == e.pos - e.parentOffset;
        }
        max(e) {
          return e.pos > this.pos ? e : this;
        }
        min(e) {
          return e.pos < this.pos ? e : this;
        }
        toString() {
          let e = "";
          for (let t = 1; t <= this.depth; t++)
            e +=
              (e ? "/" : "") + this.node(t).type.name + "_" + this.index(t - 1);
          return e + ":" + this.parentOffset;
        }
        static resolve(e, t) {
          if (!(t >= 0 && t <= e.content.size))
            throw new RangeError("Position " + t + " out of range");
          let i = [],
            r = 0,
            o = t;
          for (let s = e; ; ) {
            let { index: a, offset: l } = s.content.findIndex(o),
              c = o - l;
            if ((i.push(s, a, r + l), !c || ((s = s.child(a)), s.isText)))
              break;
            (o = c - 1), (r += l + 1);
          }
          return new Cc(t, i, o);
        }
        static resolveCached(e, t) {
          for (let r = 0; r < nv.length; r++) {
            let o = nv[r];
            if (o.pos == t && o.doc == e) return o;
          }
          let i = (nv[iv] = Cc.resolve(e, t));
          return (iv = (iv + 1) % S$), i;
        }
      }
      let nv = [],
        iv = 0,
        S$ = 12;
      class wh {
        constructor(e, t, i) {
          (this.$from = e), (this.$to = t), (this.depth = i);
        }
        get start() {
          return this.$from.before(this.depth + 1);
        }
        get end() {
          return this.$to.after(this.depth + 1);
        }
        get parent() {
          return this.$from.node(this.depth);
        }
        get startIndex() {
          return this.$from.index(this.depth);
        }
        get endIndex() {
          return this.$to.indexAfter(this.depth);
        }
      }
      const M$ = Object.create(null);
      class Yi {
        constructor(e, t, i, r = Ye.none) {
          (this.type = e),
            (this.attrs = t),
            (this.marks = r),
            (this.content = i || I.empty);
        }
        get nodeSize() {
          return this.isLeaf ? 1 : 2 + this.content.size;
        }
        get childCount() {
          return this.content.childCount;
        }
        child(e) {
          return this.content.child(e);
        }
        maybeChild(e) {
          return this.content.maybeChild(e);
        }
        forEach(e) {
          this.content.forEach(e);
        }
        nodesBetween(e, t, i, r = 0) {
          this.content.nodesBetween(e, t, i, r, this);
        }
        descendants(e) {
          this.nodesBetween(0, this.content.size, e);
        }
        get textContent() {
          return this.isLeaf && this.type.spec.leafText
            ? this.type.spec.leafText(this)
            : this.textBetween(0, this.content.size, "");
        }
        textBetween(e, t, i, r) {
          return this.content.textBetween(e, t, i, r);
        }
        get firstChild() {
          return this.content.firstChild;
        }
        get lastChild() {
          return this.content.lastChild;
        }
        eq(e) {
          return (
            this == e || (this.sameMarkup(e) && this.content.eq(e.content))
          );
        }
        sameMarkup(e) {
          return this.hasMarkup(e.type, e.attrs, e.marks);
        }
        hasMarkup(e, t, i) {
          return (
            this.type == e &&
            Ch(this.attrs, t || e.defaultAttrs || M$) &&
            Ye.sameSet(this.marks, i || Ye.none)
          );
        }
        copy(e = null) {
          return e == this.content
            ? this
            : new Yi(this.type, this.attrs, e, this.marks);
        }
        mark(e) {
          return e == this.marks
            ? this
            : new Yi(this.type, this.attrs, this.content, e);
        }
        cut(e, t = this.content.size) {
          return 0 == e && t == this.content.size
            ? this
            : this.copy(this.content.cut(e, t));
        }
        slice(e, t = this.content.size, i = !1) {
          if (e == t) return P.empty;
          let r = this.resolve(e),
            o = this.resolve(t),
            s = i ? 0 : r.sharedDepth(t),
            a = r.start(s),
            c = r.node(s).content.cut(r.pos - a, o.pos - a);
          return new P(c, r.depth - s, o.depth - s);
        }
        replace(e, t, i) {
          return E$(this.resolve(e), this.resolve(t), i);
        }
        nodeAt(e) {
          for (let t = this; ; ) {
            let { index: i, offset: r } = t.content.findIndex(e);
            if (((t = t.maybeChild(i)), !t)) return null;
            if (r == e || t.isText) return t;
            e -= r + 1;
          }
        }
        childAfter(e) {
          let { index: t, offset: i } = this.content.findIndex(e);
          return { node: this.content.maybeChild(t), index: t, offset: i };
        }
        childBefore(e) {
          if (0 == e) return { node: null, index: 0, offset: 0 };
          let { index: t, offset: i } = this.content.findIndex(e);
          if (i < e)
            return { node: this.content.child(t), index: t, offset: i };
          let r = this.content.child(t - 1);
          return { node: r, index: t - 1, offset: i - r.nodeSize };
        }
        resolve(e) {
          return Cc.resolveCached(this, e);
        }
        resolveNoCache(e) {
          return Cc.resolve(this, e);
        }
        rangeHasMark(e, t, i) {
          let r = !1;
          return (
            t > e &&
              this.nodesBetween(
                e,
                t,
                (o) => (i.isInSet(o.marks) && (r = !0), !r)
              ),
            r
          );
        }
        get isBlock() {
          return this.type.isBlock;
        }
        get isTextblock() {
          return this.type.isTextblock;
        }
        get inlineContent() {
          return this.type.inlineContent;
        }
        get isInline() {
          return this.type.isInline;
        }
        get isText() {
          return this.type.isText;
        }
        get isLeaf() {
          return this.type.isLeaf;
        }
        get isAtom() {
          return this.type.isAtom;
        }
        toString() {
          if (this.type.spec.toDebugString)
            return this.type.spec.toDebugString(this);
          let e = this.type.name;
          return (
            this.content.size &&
              (e += "(" + this.content.toStringInner() + ")"),
            _T(this.marks, e)
          );
        }
        contentMatchAt(e) {
          let t = this.type.contentMatch.matchFragment(this.content, 0, e);
          if (!t)
            throw new Error(
              "Called contentMatchAt on a node with invalid content"
            );
          return t;
        }
        canReplace(e, t, i = I.empty, r = 0, o = i.childCount) {
          let s = this.contentMatchAt(e).matchFragment(i, r, o),
            a = s && s.matchFragment(this.content, t);
          if (!a || !a.validEnd) return !1;
          for (let l = r; l < o; l++)
            if (!this.type.allowsMarks(i.child(l).marks)) return !1;
          return !0;
        }
        canReplaceWith(e, t, i, r) {
          if (r && !this.type.allowsMarks(r)) return !1;
          let o = this.contentMatchAt(e).matchType(i),
            s = o && o.matchFragment(this.content, t);
          return !!s && s.validEnd;
        }
        canAppend(e) {
          return e.content.size
            ? this.canReplace(this.childCount, this.childCount, e.content)
            : this.type.compatibleContent(e.type);
        }
        check() {
          if (!this.type.validContent(this.content))
            throw new RangeError(
              `Invalid content for node ${this.type.name}: ${this.content
                .toString()
                .slice(0, 50)}`
            );
          let e = Ye.none;
          for (let t = 0; t < this.marks.length; t++)
            e = this.marks[t].addToSet(e);
          if (!Ye.sameSet(e, this.marks))
            throw new RangeError(
              `Invalid collection of marks for node ${
                this.type.name
              }: ${this.marks.map((t) => t.type.name)}`
            );
          this.content.forEach((t) => t.check());
        }
        toJSON() {
          let e = { type: this.type.name };
          for (let t in this.attrs) {
            e.attrs = this.attrs;
            break;
          }
          return (
            this.content.size && (e.content = this.content.toJSON()),
            this.marks.length && (e.marks = this.marks.map((t) => t.toJSON())),
            e
          );
        }
        static fromJSON(e, t) {
          if (!t) throw new RangeError("Invalid input for Node.fromJSON");
          let i = null;
          if (t.marks) {
            if (!Array.isArray(t.marks))
              throw new RangeError("Invalid mark data for Node.fromJSON");
            i = t.marks.map(e.markFromJSON);
          }
          if ("text" == t.type) {
            if ("string" != typeof t.text)
              throw new RangeError("Invalid text node in JSON");
            return e.text(t.text, i);
          }
          let r = I.fromJSON(e, t.content);
          return e.nodeType(t.type).create(t.attrs, r, i);
        }
      }
      Yi.prototype.text = void 0;
      class Sh extends Yi {
        constructor(e, t, i, r) {
          if ((super(e, t, null, r), !i))
            throw new RangeError("Empty text nodes are not allowed");
          this.text = i;
        }
        toString() {
          return this.type.spec.toDebugString
            ? this.type.spec.toDebugString(this)
            : _T(this.marks, JSON.stringify(this.text));
        }
        get textContent() {
          return this.text;
        }
        textBetween(e, t) {
          return this.text.slice(e, t);
        }
        get nodeSize() {
          return this.text.length;
        }
        mark(e) {
          return e == this.marks
            ? this
            : new Sh(this.type, this.attrs, this.text, e);
        }
        withText(e) {
          return e == this.text
            ? this
            : new Sh(this.type, this.attrs, e, this.marks);
        }
        cut(e = 0, t = this.text.length) {
          return 0 == e && t == this.text.length
            ? this
            : this.withText(this.text.slice(e, t));
        }
        eq(e) {
          return this.sameMarkup(e) && this.text == e.text;
        }
        toJSON() {
          let e = super.toJSON();
          return (e.text = this.text), e;
        }
      }
      function _T(n, e) {
        for (let t = n.length - 1; t >= 0; t--)
          e = n[t].type.name + "(" + e + ")";
        return e;
      }
      class rs {
        constructor(e) {
          (this.validEnd = e), (this.next = []), (this.wrapCache = []);
        }
        static parse(e, t) {
          let i = new I$(e, t);
          if (null == i.next) return rs.empty;
          let r = bT(i);
          i.next && i.err("Unexpected trailing text");
          let o = (function R$(n) {
            let e = Object.create(null);
            return (function t(i) {
              let r = [];
              i.forEach((s) => {
                n[s].forEach(({ term: a, to: l }) => {
                  if (!a) return;
                  let c;
                  for (let u = 0; u < r.length; u++)
                    r[u][0] == a && (c = r[u][1]);
                  ET(n, l).forEach((u) => {
                    c || r.push([a, (c = [])]), -1 == c.indexOf(u) && c.push(u);
                  });
                });
              });
              let o = (e[i.join(",")] = new rs(i.indexOf(n.length - 1) > -1));
              for (let s = 0; s < r.length; s++) {
                let a = r[s][1].sort(CT);
                o.next.push({ type: r[s][0], next: e[a.join(",")] || t(a) });
              }
              return o;
            })(ET(n, 0));
          })(
            (function N$(n) {
              let e = [[]];
              return (
                r(
                  (function o(s, a) {
                    if ("choice" == s.type)
                      return s.exprs.reduce((l, c) => l.concat(o(c, a)), []);
                    if ("seq" != s.type) {
                      if ("star" == s.type) {
                        let l = t();
                        return i(a, l), r(o(s.expr, l), l), [i(l)];
                      }
                      if ("plus" == s.type) {
                        let l = t();
                        return r(o(s.expr, a), l), r(o(s.expr, l), l), [i(l)];
                      }
                      if ("opt" == s.type) return [i(a)].concat(o(s.expr, a));
                      if ("range" == s.type) {
                        let l = a;
                        for (let c = 0; c < s.min; c++) {
                          let u = t();
                          r(o(s.expr, l), u), (l = u);
                        }
                        if (-1 == s.max) r(o(s.expr, l), l);
                        else
                          for (let c = s.min; c < s.max; c++) {
                            let u = t();
                            i(l, u), r(o(s.expr, l), u), (l = u);
                          }
                        return [i(l)];
                      }
                      if ("name" == s.type) return [i(a, void 0, s.value)];
                      throw new Error("Unknown expr type");
                    }
                    for (let l = 0; ; l++) {
                      let c = o(s.exprs[l], a);
                      if (l == s.exprs.length - 1) return c;
                      r(c, (a = t()));
                    }
                  })(n, 0),
                  t()
                ),
                e
              );
              function t() {
                return e.push([]) - 1;
              }
              function i(s, a, l) {
                let c = { term: l, to: a };
                return e[s].push(c), c;
              }
              function r(s, a) {
                s.forEach((l) => (l.to = a));
              }
            })(r)
          );
          return (
            (function P$(n, e) {
              for (let t = 0, i = [n]; t < i.length; t++) {
                let r = i[t],
                  o = !r.validEnd,
                  s = [];
                for (let a = 0; a < r.next.length; a++) {
                  let { type: l, next: c } = r.next[a];
                  s.push(l.name),
                    o && !(l.isText || l.hasRequiredAttrs()) && (o = !1),
                    -1 == i.indexOf(c) && i.push(c);
                }
                o &&
                  e.err(
                    "Only non-generatable nodes (" +
                      s.join(", ") +
                      ") in a required position (see https://prosemirror.net/docs/guide/#generatable)"
                  );
              }
            })(o, i),
            o
          );
        }
        matchType(e) {
          for (let t = 0; t < this.next.length; t++)
            if (this.next[t].type == e) return this.next[t].next;
          return null;
        }
        matchFragment(e, t = 0, i = e.childCount) {
          let r = this;
          for (let o = t; r && o < i; o++) r = r.matchType(e.child(o).type);
          return r;
        }
        get inlineContent() {
          return this.next.length && this.next[0].type.isInline;
        }
        get defaultType() {
          for (let e = 0; e < this.next.length; e++) {
            let { type: t } = this.next[e];
            if (!t.isText && !t.hasRequiredAttrs()) return t;
          }
          return null;
        }
        compatible(e) {
          for (let t = 0; t < this.next.length; t++)
            for (let i = 0; i < e.next.length; i++)
              if (this.next[t].type == e.next[i].type) return !0;
          return !1;
        }
        fillBefore(e, t = !1, i = 0) {
          let r = [this];
          return (function o(s, a) {
            let l = s.matchFragment(e, i);
            if (l && (!t || l.validEnd))
              return I.from(a.map((c) => c.createAndFill()));
            for (let c = 0; c < s.next.length; c++) {
              let { type: u, next: d } = s.next[c];
              if (!u.isText && !u.hasRequiredAttrs() && -1 == r.indexOf(d)) {
                r.push(d);
                let h = o(d, a.concat(u));
                if (h) return h;
              }
            }
            return null;
          })(this, []);
        }
        findWrapping(e) {
          for (let i = 0; i < this.wrapCache.length; i += 2)
            if (this.wrapCache[i] == e) return this.wrapCache[i + 1];
          let t = this.computeWrapping(e);
          return this.wrapCache.push(e, t), t;
        }
        computeWrapping(e) {
          let t = Object.create(null),
            i = [{ match: this, type: null, via: null }];
          for (; i.length; ) {
            let r = i.shift(),
              o = r.match;
            if (o.matchType(e)) {
              let s = [];
              for (let a = r; a.type; a = a.via) s.push(a.type);
              return s.reverse();
            }
            for (let s = 0; s < o.next.length; s++) {
              let { type: a, next: l } = o.next[s];
              !a.isLeaf &&
                !a.hasRequiredAttrs() &&
                !(a.name in t) &&
                (!r.type || l.validEnd) &&
                (i.push({ match: a.contentMatch, type: a, via: r }),
                (t[a.name] = !0));
            }
          }
          return null;
        }
        get edgeCount() {
          return this.next.length;
        }
        edge(e) {
          if (e >= this.next.length)
            throw new RangeError(
              `There's no ${e}th edge in this content match`
            );
          return this.next[e];
        }
        toString() {
          let e = [];
          return (
            (function t(i) {
              e.push(i);
              for (let r = 0; r < i.next.length; r++)
                -1 == e.indexOf(i.next[r].next) && t(i.next[r].next);
            })(this),
            e
              .map((i, r) => {
                let o = r + (i.validEnd ? "*" : " ") + " ";
                for (let s = 0; s < i.next.length; s++)
                  o +=
                    (s ? ", " : "") +
                    i.next[s].type.name +
                    "->" +
                    e.indexOf(i.next[s].next);
                return o;
              })
              .join("\n")
          );
        }
      }
      rs.empty = new rs(!0);
      class I$ {
        constructor(e, t) {
          (this.string = e),
            (this.nodeTypes = t),
            (this.inline = null),
            (this.pos = 0),
            (this.tokens = e.split(/\s*(?=\b|\W|$)/)),
            "" == this.tokens[this.tokens.length - 1] && this.tokens.pop(),
            "" == this.tokens[0] && this.tokens.shift();
        }
        get next() {
          return this.tokens[this.pos];
        }
        eat(e) {
          return this.next == e && (this.pos++ || !0);
        }
        err(e) {
          throw new SyntaxError(
            e + " (in content expression '" + this.string + "')"
          );
        }
      }
      function bT(n) {
        let e = [];
        do {
          e.push(T$(n));
        } while (n.eat("|"));
        return 1 == e.length ? e[0] : { type: "choice", exprs: e };
      }
      function T$(n) {
        let e = [];
        do {
          e.push(x$(n));
        } while (n.next && ")" != n.next && "|" != n.next);
        return 1 == e.length ? e[0] : { type: "seq", exprs: e };
      }
      function x$(n) {
        let e = (function k$(n) {
          if (n.eat("(")) {
            let e = bT(n);
            return n.eat(")") || n.err("Missing closing paren"), e;
          }
          if (!/\W/.test(n.next)) {
            let e = (function O$(n, e) {
              let t = n.nodeTypes,
                i = t[e];
              if (i) return [i];
              let r = [];
              for (let o in t) {
                let s = t[o];
                s.groups.indexOf(e) > -1 && r.push(s);
              }
              return (
                0 == r.length &&
                  n.err("No node type or group '" + e + "' found"),
                r
              );
            })(n, n.next).map(
              (t) => (
                null == n.inline
                  ? (n.inline = t.isInline)
                  : n.inline != t.isInline &&
                    n.err("Mixing inline and block content"),
                { type: "name", value: t }
              )
            );
            return n.pos++, 1 == e.length ? e[0] : { type: "choice", exprs: e };
          }
          n.err("Unexpected token '" + n.next + "'");
        })(n);
        for (;;)
          if (n.eat("+")) e = { type: "plus", expr: e };
          else if (n.eat("*")) e = { type: "star", expr: e };
          else if (n.eat("?")) e = { type: "opt", expr: e };
          else {
            if (!n.eat("{")) break;
            e = A$(n, e);
          }
        return e;
      }
      function DT(n) {
        /\D/.test(n.next) && n.err("Expected number, got '" + n.next + "'");
        let e = Number(n.next);
        return n.pos++, e;
      }
      function A$(n, e) {
        let t = DT(n),
          i = t;
        return (
          n.eat(",") && (i = "}" != n.next ? DT(n) : -1),
          n.eat("}") || n.err("Unclosed braced range"),
          { type: "range", min: t, max: i, expr: e }
        );
      }
      function CT(n, e) {
        return e - n;
      }
      function ET(n, e) {
        let t = [];
        return (
          (function i(r) {
            let o = n[r];
            if (1 == o.length && !o[0].term) return i(o[0].to);
            t.push(r);
            for (let s = 0; s < o.length; s++) {
              let { term: a, to: l } = o[s];
              !a && -1 == t.indexOf(l) && i(l);
            }
          })(e),
          t.sort(CT)
        );
      }
      function wT(n) {
        let e = Object.create(null);
        for (let t in n) {
          let i = n[t];
          if (!i.hasDefault) return null;
          e[t] = i.default;
        }
        return e;
      }
      function ST(n, e) {
        let t = Object.create(null);
        for (let i in n) {
          let r = e && e[i];
          if (void 0 === r) {
            let o = n[i];
            if (!o.hasDefault)
              throw new RangeError("No value supplied for attribute " + i);
            r = o.default;
          }
          t[i] = r;
        }
        return t;
      }
      function MT(n) {
        let e = Object.create(null);
        if (n) for (let t in n) e[t] = new F$(n[t]);
        return e;
      }
      class Mh {
        constructor(e, t, i) {
          (this.name = e),
            (this.schema = t),
            (this.spec = i),
            (this.markSet = null),
            (this.groups = i.group ? i.group.split(" ") : []),
            (this.attrs = MT(i.attrs)),
            (this.defaultAttrs = wT(this.attrs)),
            (this.contentMatch = null),
            (this.inlineContent = null),
            (this.isBlock = !(i.inline || "text" == e)),
            (this.isText = "text" == e);
        }
        get isInline() {
          return !this.isBlock;
        }
        get isTextblock() {
          return this.isBlock && this.inlineContent;
        }
        get isLeaf() {
          return this.contentMatch == rs.empty;
        }
        get isAtom() {
          return this.isLeaf || !!this.spec.atom;
        }
        get whitespace() {
          return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
        }
        hasRequiredAttrs() {
          for (let e in this.attrs) if (this.attrs[e].isRequired) return !0;
          return !1;
        }
        compatibleContent(e) {
          return this == e || this.contentMatch.compatible(e.contentMatch);
        }
        computeAttrs(e) {
          return !e && this.defaultAttrs
            ? this.defaultAttrs
            : ST(this.attrs, e);
        }
        create(e = null, t, i) {
          if (this.isText)
            throw new Error("NodeType.create can't construct text nodes");
          return new Yi(this, this.computeAttrs(e), I.from(t), Ye.setFrom(i));
        }
        createChecked(e = null, t, i) {
          if (((t = I.from(t)), !this.validContent(t)))
            throw new RangeError("Invalid content for node " + this.name);
          return new Yi(this, this.computeAttrs(e), t, Ye.setFrom(i));
        }
        createAndFill(e = null, t, i) {
          if (((e = this.computeAttrs(e)), (t = I.from(t)).size)) {
            let s = this.contentMatch.fillBefore(t);
            if (!s) return null;
            t = s.append(t);
          }
          let r = this.contentMatch.matchFragment(t),
            o = r && r.fillBefore(I.empty, !0);
          return o ? new Yi(this, e, t.append(o), Ye.setFrom(i)) : null;
        }
        validContent(e) {
          let t = this.contentMatch.matchFragment(e);
          if (!t || !t.validEnd) return !1;
          for (let i = 0; i < e.childCount; i++)
            if (!this.allowsMarks(e.child(i).marks)) return !1;
          return !0;
        }
        allowsMarkType(e) {
          return null == this.markSet || this.markSet.indexOf(e) > -1;
        }
        allowsMarks(e) {
          if (null == this.markSet) return !0;
          for (let t = 0; t < e.length; t++)
            if (!this.allowsMarkType(e[t].type)) return !1;
          return !0;
        }
        allowedMarks(e) {
          if (null == this.markSet) return e;
          let t;
          for (let i = 0; i < e.length; i++)
            this.allowsMarkType(e[i].type)
              ? t && t.push(e[i])
              : t || (t = e.slice(0, i));
          return t ? (t.length ? t : Ye.none) : e;
        }
        static compile(e, t) {
          let i = Object.create(null);
          e.forEach((o, s) => (i[o] = new Mh(o, t, s)));
          let r = t.spec.topNode || "doc";
          if (!i[r])
            throw new RangeError(
              "Schema is missing its top node type ('" + r + "')"
            );
          if (!i.text) throw new RangeError("Every schema needs a 'text' type");
          for (let o in i.text.attrs)
            throw new RangeError(
              "The text node type should not have attributes"
            );
          return i;
        }
      }
      class F$ {
        constructor(e) {
          (this.hasDefault = Object.prototype.hasOwnProperty.call(
            e,
            "default"
          )),
            (this.default = e.default);
        }
        get isRequired() {
          return !this.hasDefault;
        }
      }
      class Ih {
        constructor(e, t, i, r) {
          (this.name = e),
            (this.rank = t),
            (this.schema = i),
            (this.spec = r),
            (this.attrs = MT(r.attrs)),
            (this.excluded = null);
          let o = wT(this.attrs);
          this.instance = o ? new Ye(this, o) : null;
        }
        create(e = null) {
          return !e && this.instance
            ? this.instance
            : new Ye(this, ST(this.attrs, e));
        }
        static compile(e, t) {
          let i = Object.create(null),
            r = 0;
          return e.forEach((o, s) => (i[o] = new Ih(o, r++, t, s))), i;
        }
        removeFromSet(e) {
          for (var t = 0; t < e.length; t++)
            e[t].type == this &&
              ((e = e.slice(0, t).concat(e.slice(t + 1))), t--);
          return e;
        }
        isInSet(e) {
          for (let t = 0; t < e.length; t++) if (e[t].type == this) return e[t];
        }
        excludes(e) {
          return this.excluded.indexOf(e) > -1;
        }
      }
      class L$ {
        constructor(e) {
          (this.cached = Object.create(null)),
            (this.spec = {
              nodes: dT.from(e.nodes),
              marks: dT.from(e.marks || {}),
              topNode: e.topNode,
            }),
            (this.nodes = Mh.compile(this.spec.nodes, this)),
            (this.marks = Ih.compile(this.spec.marks, this));
          let t = Object.create(null);
          for (let i in this.nodes) {
            if (i in this.marks)
              throw new RangeError(i + " can not be both a node and a mark");
            let r = this.nodes[i],
              o = r.spec.content || "",
              s = r.spec.marks;
            (r.contentMatch = t[o] || (t[o] = rs.parse(o, this.nodes))),
              (r.inlineContent = r.contentMatch.inlineContent),
              (r.markSet =
                "_" == s
                  ? null
                  : s
                  ? IT(this, s.split(" "))
                  : "" != s && r.inlineContent
                  ? null
                  : []);
          }
          for (let i in this.marks) {
            let r = this.marks[i],
              o = r.spec.excludes;
            r.excluded =
              null == o ? [r] : "" == o ? [] : IT(this, o.split(" "));
          }
          (this.nodeFromJSON = this.nodeFromJSON.bind(this)),
            (this.markFromJSON = this.markFromJSON.bind(this)),
            (this.topNodeType = this.nodes[this.spec.topNode || "doc"]),
            (this.cached.wrappings = Object.create(null));
        }
        node(e, t = null, i, r) {
          if ("string" == typeof e) e = this.nodeType(e);
          else {
            if (!(e instanceof Mh))
              throw new RangeError("Invalid node type: " + e);
            if (e.schema != this)
              throw new RangeError(
                "Node type from different schema used (" + e.name + ")"
              );
          }
          return e.createChecked(t, i, r);
        }
        text(e, t) {
          let i = this.nodes.text;
          return new Sh(i, i.defaultAttrs, e, Ye.setFrom(t));
        }
        mark(e, t) {
          return "string" == typeof e && (e = this.marks[e]), e.create(t);
        }
        nodeFromJSON(e) {
          return Yi.fromJSON(this, e);
        }
        markFromJSON(e) {
          return Ye.fromJSON(this, e);
        }
        nodeType(e) {
          let t = this.nodes[e];
          if (!t) throw new RangeError("Unknown node type: " + e);
          return t;
        }
      }
      function IT(n, e) {
        let t = [];
        for (let i = 0; i < e.length; i++) {
          let r = e[i],
            o = n.marks[r],
            s = o;
          if (o) t.push(o);
          else
            for (let a in n.marks) {
              let l = n.marks[a];
              ("_" == r ||
                (l.spec.group && l.spec.group.split(" ").indexOf(r) > -1)) &&
                t.push((s = l));
            }
          if (!s) throw new SyntaxError("Unknown mark type: '" + e[i] + "'");
        }
        return t;
      }
      class Sa {
        constructor(e, t) {
          (this.schema = e),
            (this.rules = t),
            (this.tags = []),
            (this.styles = []),
            t.forEach((i) => {
              i.tag ? this.tags.push(i) : i.style && this.styles.push(i);
            }),
            (this.normalizeLists = !this.tags.some((i) => {
              if (!/^(ul|ol)\b/.test(i.tag) || !i.node) return !1;
              let r = e.nodes[i.node];
              return r.contentMatch.matchType(r);
            }));
        }
        parse(e, t = {}) {
          let i = new OT(this, t, !1);
          return i.addAll(e, t.from, t.to), i.finish();
        }
        parseSlice(e, t = {}) {
          let i = new OT(this, t, !0);
          return i.addAll(e, t.from, t.to), P.maxOpen(i.finish());
        }
        matchTag(e, t, i) {
          for (
            let r = i ? this.tags.indexOf(i) + 1 : 0;
            r < this.tags.length;
            r++
          ) {
            let o = this.tags[r];
            if (
              j$(e, o.tag) &&
              (void 0 === o.namespace || e.namespaceURI == o.namespace) &&
              (!o.context || t.matchesContext(o.context))
            ) {
              if (o.getAttrs) {
                let s = o.getAttrs(e);
                if (!1 === s) continue;
                o.attrs = s || void 0;
              }
              return o;
            }
          }
        }
        matchStyle(e, t, i, r) {
          for (
            let o = r ? this.styles.indexOf(r) + 1 : 0;
            o < this.styles.length;
            o++
          ) {
            let s = this.styles[o],
              a = s.style;
            if (
              !(
                0 != a.indexOf(e) ||
                (s.context && !i.matchesContext(s.context)) ||
                (a.length > e.length &&
                  (61 != a.charCodeAt(e.length) || a.slice(e.length + 1) != t))
              )
            ) {
              if (s.getAttrs) {
                let l = s.getAttrs(t);
                if (!1 === l) continue;
                s.attrs = l || void 0;
              }
              return s;
            }
          }
        }
        static schemaRules(e) {
          let t = [];
          function i(r) {
            let o = r.priority ?? 50,
              s = 0;
            for (; s < t.length; s++) {
              if ((t[s].priority ?? 50) < o) break;
            }
            t.splice(s, 0, r);
          }
          for (let r in e.marks) {
            let o = e.marks[r].spec.parseDOM;
            o &&
              o.forEach((s) => {
                i((s = kT(s))), (s.mark = r);
              });
          }
          for (let r in e.nodes) {
            let o = e.nodes[r].spec.parseDOM;
            o &&
              o.forEach((s) => {
                i((s = kT(s))), (s.node = r);
              });
          }
          return t;
        }
        static fromSchema(e) {
          return (
            e.cached.domParser ||
            (e.cached.domParser = new Sa(e, Sa.schemaRules(e)))
          );
        }
      }
      const TT = {
          address: !0,
          article: !0,
          aside: !0,
          blockquote: !0,
          canvas: !0,
          dd: !0,
          div: !0,
          dl: !0,
          fieldset: !0,
          figcaption: !0,
          figure: !0,
          footer: !0,
          form: !0,
          h1: !0,
          h2: !0,
          h3: !0,
          h4: !0,
          h5: !0,
          h6: !0,
          header: !0,
          hgroup: !0,
          hr: !0,
          li: !0,
          noscript: !0,
          ol: !0,
          output: !0,
          p: !0,
          pre: !0,
          section: !0,
          table: !0,
          tfoot: !0,
          ul: !0,
        },
        V$ = {
          head: !0,
          noscript: !0,
          object: !0,
          script: !0,
          style: !0,
          title: !0,
        },
        xT = { ol: !0, ul: !0 };
      function AT(n, e, t) {
        return null != e
          ? (e ? 1 : 0) | ("full" === e ? 2 : 0)
          : n && "pre" == n.whitespace
          ? 3
          : -5 & t;
      }
      class Ah {
        constructor(e, t, i, r, o, s, a) {
          (this.type = e),
            (this.attrs = t),
            (this.marks = i),
            (this.pendingMarks = r),
            (this.solid = o),
            (this.options = a),
            (this.content = []),
            (this.activeMarks = Ye.none),
            (this.stashMarks = []),
            (this.match = s || (4 & a ? null : e.contentMatch));
        }
        findWrapping(e) {
          if (!this.match) {
            if (!this.type) return [];
            let t = this.type.contentMatch.fillBefore(I.from(e));
            if (!t) {
              let r,
                i = this.type.contentMatch;
              return (r = i.findWrapping(e.type))
                ? ((this.match = i), r)
                : null;
            }
            this.match = this.type.contentMatch.matchFragment(t);
          }
          return this.match.findWrapping(e.type);
        }
        finish(e) {
          if (!(1 & this.options)) {
            let r,
              i = this.content[this.content.length - 1];
            if (i && i.isText && (r = /[ \t\r\n\u000c]+$/.exec(i.text))) {
              let o = i;
              i.text.length == r[0].length
                ? this.content.pop()
                : (this.content[this.content.length - 1] = o.withText(
                    o.text.slice(0, o.text.length - r[0].length)
                  ));
            }
          }
          let t = I.from(this.content);
          return (
            !e &&
              this.match &&
              (t = t.append(this.match.fillBefore(I.empty, !0))),
            this.type ? this.type.create(this.attrs, t, this.marks) : t
          );
        }
        popFromStashMark(e) {
          for (let t = this.stashMarks.length - 1; t >= 0; t--)
            if (e.eq(this.stashMarks[t]))
              return this.stashMarks.splice(t, 1)[0];
        }
        applyPending(e) {
          for (let t = 0, i = this.pendingMarks; t < i.length; t++) {
            let r = i[t];
            (this.type ? this.type.allowsMarkType(r.type) : U$(r.type, e)) &&
              !r.isInSet(this.activeMarks) &&
              ((this.activeMarks = r.addToSet(this.activeMarks)),
              (this.pendingMarks = r.removeFromSet(this.pendingMarks)));
          }
        }
        inlineContext(e) {
          return this.type
            ? this.type.inlineContent
            : this.content.length
            ? this.content[0].isInline
            : e.parentNode &&
              !TT.hasOwnProperty(e.parentNode.nodeName.toLowerCase());
        }
      }
      class OT {
        constructor(e, t, i) {
          (this.parser = e),
            (this.options = t),
            (this.isOpen = i),
            (this.open = 0);
          let o,
            r = t.topNode,
            s = AT(null, t.preserveWhitespace, 0) | (i ? 4 : 0);
          (o = r
            ? new Ah(
                r.type,
                r.attrs,
                Ye.none,
                Ye.none,
                !0,
                t.topMatch || r.type.contentMatch,
                s
              )
            : new Ah(
                i ? null : e.schema.topNodeType,
                null,
                Ye.none,
                Ye.none,
                !0,
                null,
                s
              )),
            (this.nodes = [o]),
            (this.find = t.findPositions),
            (this.needsBlock = !1);
        }
        get top() {
          return this.nodes[this.open];
        }
        addDOM(e) {
          if (3 == e.nodeType) this.addTextNode(e);
          else if (1 == e.nodeType) {
            let t = e.getAttribute("style"),
              i = t
                ? this.readStyles(
                    (function H$(n) {
                      let t,
                        e = /\s*([\w-]+)\s*:\s*([^;]+)/g,
                        i = [];
                      for (; (t = e.exec(n)); ) i.push(t[1], t[2].trim());
                      return i;
                    })(t)
                  )
                : null,
              r = this.top;
            if (null != i)
              for (let o = 0; o < i.length; o++) this.addPendingMark(i[o]);
            if ((this.addElement(e), null != i))
              for (let o = 0; o < i.length; o++)
                this.removePendingMark(i[o], r);
          }
        }
        addTextNode(e) {
          let t = e.nodeValue,
            i = this.top;
          if (
            2 & i.options ||
            i.inlineContext(e) ||
            /[^ \t\r\n\u000c]/.test(t)
          ) {
            if (1 & i.options)
              t =
                2 & i.options
                  ? t.replace(/\r\n?/g, "\n")
                  : t.replace(/\r?\n|\r/g, " ");
            else if (
              ((t = t.replace(/[ \t\r\n\u000c]+/g, " ")),
              /^[ \t\r\n\u000c]/.test(t) && this.open == this.nodes.length - 1)
            ) {
              let r = i.content[i.content.length - 1],
                o = e.previousSibling;
              (!r ||
                (o && "BR" == o.nodeName) ||
                (r.isText && /[ \t\r\n\u000c]$/.test(r.text))) &&
                (t = t.slice(1));
            }
            t && this.insertNode(this.parser.schema.text(t)),
              this.findInText(e);
          } else this.findInside(e);
        }
        addElement(e, t) {
          let r,
            i = e.nodeName.toLowerCase();
          xT.hasOwnProperty(i) &&
            this.parser.normalizeLists &&
            (function B$(n) {
              for (let e = n.firstChild, t = null; e; e = e.nextSibling) {
                let i = 1 == e.nodeType ? e.nodeName.toLowerCase() : null;
                i && xT.hasOwnProperty(i) && t
                  ? (t.appendChild(e), (e = t))
                  : "li" == i
                  ? (t = e)
                  : i && (t = null);
              }
            })(e);
          let o =
            (this.options.ruleFromNode && this.options.ruleFromNode(e)) ||
            (r = this.parser.matchTag(e, this, t));
          if (o ? o.ignore : V$.hasOwnProperty(i))
            this.findInside(e), this.ignoreFallback(e);
          else if (!o || o.skip || o.closeParent) {
            o && o.closeParent
              ? (this.open = Math.max(0, this.open - 1))
              : o && o.skip.nodeType && (e = o.skip);
            let s,
              a = this.top,
              l = this.needsBlock;
            if (TT.hasOwnProperty(i))
              (s = !0), a.type || (this.needsBlock = !0);
            else if (!e.firstChild) return void this.leafFallback(e);
            this.addAll(e), s && this.sync(a), (this.needsBlock = l);
          } else this.addElementByRule(e, o, !1 === o.consuming ? r : void 0);
        }
        leafFallback(e) {
          "BR" == e.nodeName &&
            this.top.type &&
            this.top.type.inlineContent &&
            this.addTextNode(e.ownerDocument.createTextNode("\n"));
        }
        ignoreFallback(e) {
          "BR" == e.nodeName &&
            (!this.top.type || !this.top.type.inlineContent) &&
            this.findPlace(this.parser.schema.text("-"));
        }
        readStyles(e) {
          let t = Ye.none;
          e: for (let i = 0; i < e.length; i += 2)
            for (let r; ; ) {
              let o = this.parser.matchStyle(e[i], e[i + 1], this, r);
              if (!o) continue e;
              if (o.ignore) return null;
              if (
                ((t = this.parser.schema.marks[o.mark]
                  .create(o.attrs)
                  .addToSet(t)),
                !1 !== o.consuming)
              )
                break;
              r = o;
            }
          return t;
        }
        addElementByRule(e, t, i) {
          let r, o, s;
          t.node
            ? ((o = this.parser.schema.nodes[t.node]),
              o.isLeaf
                ? this.insertNode(o.create(t.attrs)) || this.leafFallback(e)
                : (r = this.enter(o, t.attrs || null, t.preserveWhitespace)))
            : ((s = this.parser.schema.marks[t.mark].create(t.attrs)),
              this.addPendingMark(s));
          let a = this.top;
          if (o && o.isLeaf) this.findInside(e);
          else if (i) this.addElement(e, i);
          else if (t.getContent)
            this.findInside(e),
              t
                .getContent(e, this.parser.schema)
                .forEach((l) => this.insertNode(l));
          else {
            let l = e;
            "string" == typeof t.contentElement
              ? (l = e.querySelector(t.contentElement))
              : "function" == typeof t.contentElement
              ? (l = t.contentElement(e))
              : t.contentElement && (l = t.contentElement),
              this.findAround(e, l, !0),
              this.addAll(l);
          }
          r && this.sync(a) && this.open--, s && this.removePendingMark(s, a);
        }
        addAll(e, t, i) {
          let r = t || 0;
          for (
            let o = t ? e.childNodes[t] : e.firstChild,
              s = null == i ? null : e.childNodes[i];
            o != s;
            o = o.nextSibling, ++r
          )
            this.findAtPoint(e, r), this.addDOM(o);
          this.findAtPoint(e, r);
        }
        findPlace(e) {
          let t, i;
          for (let r = this.open; r >= 0; r--) {
            let o = this.nodes[r],
              s = o.findWrapping(e);
            if (
              (s &&
                (!t || t.length > s.length) &&
                ((t = s), (i = o), !s.length)) ||
              o.solid
            )
              break;
          }
          if (!t) return !1;
          this.sync(i);
          for (let r = 0; r < t.length; r++) this.enterInner(t[r], null, !1);
          return !0;
        }
        insertNode(e) {
          if (e.isInline && this.needsBlock && !this.top.type) {
            let t = this.textblockFromContext();
            t && this.enterInner(t);
          }
          if (this.findPlace(e)) {
            this.closeExtra();
            let t = this.top;
            t.applyPending(e.type),
              t.match && (t.match = t.match.matchType(e.type));
            let i = t.activeMarks;
            for (let r = 0; r < e.marks.length; r++)
              (!t.type || t.type.allowsMarkType(e.marks[r].type)) &&
                (i = e.marks[r].addToSet(i));
            return t.content.push(e.mark(i)), !0;
          }
          return !1;
        }
        enter(e, t, i) {
          let r = this.findPlace(e.create(t));
          return r && this.enterInner(e, t, !0, i), r;
        }
        enterInner(e, t = null, i = !1, r) {
          this.closeExtra();
          let o = this.top;
          o.applyPending(e), (o.match = o.match && o.match.matchType(e));
          let s = AT(e, r, o.options);
          4 & o.options && 0 == o.content.length && (s |= 4),
            this.nodes.push(
              new Ah(e, t, o.activeMarks, o.pendingMarks, i, null, s)
            ),
            this.open++;
        }
        closeExtra(e = !1) {
          let t = this.nodes.length - 1;
          if (t > this.open) {
            for (; t > this.open; t--)
              this.nodes[t - 1].content.push(this.nodes[t].finish(e));
            this.nodes.length = this.open + 1;
          }
        }
        finish() {
          return (
            (this.open = 0),
            this.closeExtra(this.isOpen),
            this.nodes[0].finish(this.isOpen || this.options.topOpen)
          );
        }
        sync(e) {
          for (let t = this.open; t >= 0; t--)
            if (this.nodes[t] == e) return (this.open = t), !0;
          return !1;
        }
        get currentPos() {
          this.closeExtra();
          let e = 0;
          for (let t = this.open; t >= 0; t--) {
            let i = this.nodes[t].content;
            for (let r = i.length - 1; r >= 0; r--) e += i[r].nodeSize;
            t && e++;
          }
          return e;
        }
        findAtPoint(e, t) {
          if (this.find)
            for (let i = 0; i < this.find.length; i++)
              this.find[i].node == e &&
                this.find[i].offset == t &&
                (this.find[i].pos = this.currentPos);
        }
        findInside(e) {
          if (this.find)
            for (let t = 0; t < this.find.length; t++)
              null == this.find[t].pos &&
                1 == e.nodeType &&
                e.contains(this.find[t].node) &&
                (this.find[t].pos = this.currentPos);
        }
        findAround(e, t, i) {
          if (e != t && this.find)
            for (let r = 0; r < this.find.length; r++)
              null == this.find[r].pos &&
                1 == e.nodeType &&
                e.contains(this.find[r].node) &&
                t.compareDocumentPosition(this.find[r].node) & (i ? 2 : 4) &&
                (this.find[r].pos = this.currentPos);
        }
        findInText(e) {
          if (this.find)
            for (let t = 0; t < this.find.length; t++)
              this.find[t].node == e &&
                (this.find[t].pos =
                  this.currentPos - (e.nodeValue.length - this.find[t].offset));
        }
        matchesContext(e) {
          if (e.indexOf("|") > -1)
            return e.split(/\s*\|\s*/).some(this.matchesContext, this);
          let t = e.split("/"),
            i = this.options.context,
            r = !(this.isOpen || (i && i.parent.type != this.nodes[0].type)),
            o = (r ? 0 : 1) - (i ? i.depth + 1 : 0),
            s = (a, l) => {
              for (; a >= 0; a--) {
                let c = t[a];
                if ("" == c) {
                  if (a == t.length - 1 || 0 == a) continue;
                  for (; l >= o; l--) if (s(a - 1, l)) return !0;
                  return !1;
                }
                {
                  let u =
                    l > 0 || (0 == l && r)
                      ? this.nodes[l].type
                      : i && l >= o
                      ? i.node(l - o).type
                      : null;
                  if (!u || (u.name != c && -1 == u.groups.indexOf(c)))
                    return !1;
                  l--;
                }
              }
              return !0;
            };
          return s(t.length - 1, this.open);
        }
        textblockFromContext() {
          let e = this.options.context;
          if (e)
            for (let t = e.depth; t >= 0; t--) {
              let i = e.node(t).contentMatchAt(e.indexAfter(t)).defaultType;
              if (i && i.isTextblock && i.defaultAttrs) return i;
            }
          for (let t in this.parser.schema.nodes) {
            let i = this.parser.schema.nodes[t];
            if (i.isTextblock && i.defaultAttrs) return i;
          }
        }
        addPendingMark(e) {
          let t = (function z$(n, e) {
            for (let t = 0; t < e.length; t++) if (n.eq(e[t])) return e[t];
          })(e, this.top.pendingMarks);
          t && this.top.stashMarks.push(t),
            (this.top.pendingMarks = e.addToSet(this.top.pendingMarks));
        }
        removePendingMark(e, t) {
          for (let i = this.open; i >= 0; i--) {
            let r = this.nodes[i];
            if (r.pendingMarks.lastIndexOf(e) > -1)
              r.pendingMarks = e.removeFromSet(r.pendingMarks);
            else {
              r.activeMarks = e.removeFromSet(r.activeMarks);
              let s = r.popFromStashMark(e);
              s &&
                r.type &&
                r.type.allowsMarkType(s.type) &&
                (r.activeMarks = s.addToSet(r.activeMarks));
            }
            if (r == t) break;
          }
        }
      }
      function j$(n, e) {
        return (
          n.matches ||
          n.msMatchesSelector ||
          n.webkitMatchesSelector ||
          n.mozMatchesSelector
        ).call(n, e);
      }
      function kT(n) {
        let e = {};
        for (let t in n) e[t] = n[t];
        return e;
      }
      function U$(n, e) {
        let t = e.schema.nodes;
        for (let i in t) {
          let r = t[i];
          if (!r.allowsMarkType(n)) continue;
          let o = [],
            s = (a) => {
              o.push(a);
              for (let l = 0; l < a.edgeCount; l++) {
                let { type: c, next: u } = a.edge(l);
                if (c == e || (o.indexOf(u) < 0 && s(u))) return !0;
              }
            };
          if (s(r.contentMatch)) return !0;
        }
      }
      class Zi {
        constructor(e, t) {
          (this.nodes = e), (this.marks = t);
        }
        serializeFragment(e, t = {}, i) {
          i || (i = rv(t).createDocumentFragment());
          let r = i,
            o = [];
          return (
            e.forEach((s) => {
              if (o.length || s.marks.length) {
                let a = 0,
                  l = 0;
                for (; a < o.length && l < s.marks.length; ) {
                  let c = s.marks[l];
                  if (this.marks[c.type.name]) {
                    if (!c.eq(o[a][0]) || !1 === c.type.spec.spanning) break;
                    a++, l++;
                  } else l++;
                }
                for (; a < o.length; ) r = o.pop()[1];
                for (; l < s.marks.length; ) {
                  let c = s.marks[l++],
                    u = this.serializeMark(c, s.isInline, t);
                  u &&
                    (o.push([c, r]),
                    r.appendChild(u.dom),
                    (r = u.contentDOM || u.dom));
                }
              }
              r.appendChild(this.serializeNodeInner(s, t));
            }),
            i
          );
        }
        serializeNodeInner(e, t) {
          let { dom: i, contentDOM: r } = Zi.renderSpec(
            rv(t),
            this.nodes[e.type.name](e)
          );
          if (r) {
            if (e.isLeaf)
              throw new RangeError(
                "Content hole not allowed in a leaf node spec"
              );
            this.serializeFragment(e.content, t, r);
          }
          return i;
        }
        serializeNode(e, t = {}) {
          let i = this.serializeNodeInner(e, t);
          for (let r = e.marks.length - 1; r >= 0; r--) {
            let o = this.serializeMark(e.marks[r], e.isInline, t);
            o && ((o.contentDOM || o.dom).appendChild(i), (i = o.dom));
          }
          return i;
        }
        serializeMark(e, t, i = {}) {
          let r = this.marks[e.type.name];
          return r && Zi.renderSpec(rv(i), r(e, t));
        }
        static renderSpec(e, t, i = null) {
          if ("string" == typeof t) return { dom: e.createTextNode(t) };
          if (null != t.nodeType) return { dom: t };
          if (t.dom && null != t.dom.nodeType) return t;
          let r = t[0],
            o = r.indexOf(" ");
          o > 0 && ((i = r.slice(0, o)), (r = r.slice(o + 1)));
          let s,
            a = i ? e.createElementNS(i, r) : e.createElement(r),
            l = t[1],
            c = 1;
          if (
            l &&
            "object" == typeof l &&
            null == l.nodeType &&
            !Array.isArray(l)
          ) {
            c = 2;
            for (let u in l)
              if (null != l[u]) {
                let d = u.indexOf(" ");
                d > 0
                  ? a.setAttributeNS(u.slice(0, d), u.slice(d + 1), l[u])
                  : a.setAttribute(u, l[u]);
              }
          }
          for (let u = c; u < t.length; u++) {
            let d = t[u];
            if (0 === d) {
              if (u < t.length - 1 || u > c)
                throw new RangeError(
                  "Content hole must be the only child of its parent node"
                );
              return { dom: a, contentDOM: a };
            }
            {
              let { dom: h, contentDOM: f } = Zi.renderSpec(e, d, i);
              if ((a.appendChild(h), f)) {
                if (s) throw new RangeError("Multiple content holes");
                s = f;
              }
            }
          }
          return { dom: a, contentDOM: s };
        }
        static fromSchema(e) {
          return (
            e.cached.domSerializer ||
            (e.cached.domSerializer = new Zi(
              this.nodesFromSchema(e),
              this.marksFromSchema(e)
            ))
          );
        }
        static nodesFromSchema(e) {
          let t = NT(e.nodes);
          return t.text || (t.text = (i) => i.text), t;
        }
        static marksFromSchema(e) {
          return NT(e.marks);
        }
      }
      function NT(n) {
        let e = {};
        for (let t in n) {
          let i = n[t].spec.toDOM;
          i && (e[t] = i);
        }
        return e;
      }
      function rv(n) {
        return n.document || window.document;
      }
      const PT = Math.pow(2, 16);
      function $$(n, e) {
        return n + e * PT;
      }
      function FT(n) {
        return 65535 & n;
      }
      class ov {
        constructor(e, t, i) {
          (this.pos = e), (this.delInfo = t), (this.recover = i);
        }
        get deleted() {
          return (8 & this.delInfo) > 0;
        }
        get deletedBefore() {
          return (5 & this.delInfo) > 0;
        }
        get deletedAfter() {
          return (6 & this.delInfo) > 0;
        }
        get deletedAcross() {
          return (4 & this.delInfo) > 0;
        }
      }
      class Ci {
        constructor(e, t = !1) {
          if (((this.ranges = e), (this.inverted = t), !e.length && Ci.empty))
            return Ci.empty;
        }
        recover(e) {
          let t = 0,
            i = FT(e);
          if (!this.inverted)
            for (let r = 0; r < i; r++)
              t += this.ranges[3 * r + 2] - this.ranges[3 * r + 1];
          return (
            this.ranges[3 * i] +
            t +
            (function W$(n) {
              return (n - (65535 & n)) / PT;
            })(e)
          );
        }
        mapResult(e, t = 1) {
          return this._map(e, t, !1);
        }
        map(e, t = 1) {
          return this._map(e, t, !0);
        }
        _map(e, t, i) {
          let r = 0,
            o = this.inverted ? 2 : 1,
            s = this.inverted ? 1 : 2;
          for (let a = 0; a < this.ranges.length; a += 3) {
            let l = this.ranges[a] - (this.inverted ? r : 0);
            if (l > e) break;
            let c = this.ranges[a + o],
              u = this.ranges[a + s],
              d = l + c;
            if (e <= d) {
              let f =
                l + r + ((c ? (e == l ? -1 : e == d ? 1 : t) : t) < 0 ? 0 : u);
              if (i) return f;
              let p = e == (t < 0 ? l : d) ? null : $$(a / 3, e - l),
                g = e == l ? 2 : e == d ? 1 : 4;
              return (t < 0 ? e != l : e != d) && (g |= 8), new ov(f, g, p);
            }
            r += u - c;
          }
          return i ? e + r : new ov(e + r, 0, null);
        }
        touches(e, t) {
          let i = 0,
            r = FT(t),
            o = this.inverted ? 2 : 1,
            s = this.inverted ? 1 : 2;
          for (let a = 0; a < this.ranges.length; a += 3) {
            let l = this.ranges[a] - (this.inverted ? i : 0);
            if (l > e) break;
            let c = this.ranges[a + o];
            if (e <= l + c && a == 3 * r) return !0;
            i += this.ranges[a + s] - c;
          }
          return !1;
        }
        forEach(e) {
          let t = this.inverted ? 2 : 1,
            i = this.inverted ? 1 : 2;
          for (let r = 0, o = 0; r < this.ranges.length; r += 3) {
            let s = this.ranges[r],
              a = s - (this.inverted ? o : 0),
              l = s + (this.inverted ? 0 : o),
              c = this.ranges[r + t],
              u = this.ranges[r + i];
            e(a, a + c, l, l + u), (o += u - c);
          }
        }
        invert() {
          return new Ci(this.ranges, !this.inverted);
        }
        toString() {
          return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
        }
        static offset(e) {
          return 0 == e ? Ci.empty : new Ci(e < 0 ? [0, -e, 0] : [0, 0, e]);
        }
      }
      Ci.empty = new Ci([]);
      class Ma {
        constructor(e = [], t, i = 0, r = e.length) {
          (this.maps = e), (this.mirror = t), (this.from = i), (this.to = r);
        }
        slice(e = 0, t = this.maps.length) {
          return new Ma(this.maps, this.mirror, e, t);
        }
        copy() {
          return new Ma(
            this.maps.slice(),
            this.mirror && this.mirror.slice(),
            this.from,
            this.to
          );
        }
        appendMap(e, t) {
          (this.to = this.maps.push(e)),
            null != t && this.setMirror(this.maps.length - 1, t);
        }
        appendMapping(e) {
          for (let t = 0, i = this.maps.length; t < e.maps.length; t++) {
            let r = e.getMirror(t);
            this.appendMap(e.maps[t], null != r && r < t ? i + r : void 0);
          }
        }
        getMirror(e) {
          if (this.mirror)
            for (let t = 0; t < this.mirror.length; t++)
              if (this.mirror[t] == e) return this.mirror[t + (t % 2 ? -1 : 1)];
        }
        setMirror(e, t) {
          this.mirror || (this.mirror = []), this.mirror.push(e, t);
        }
        appendMappingInverted(e) {
          for (
            let t = e.maps.length - 1, i = this.maps.length + e.maps.length;
            t >= 0;
            t--
          ) {
            let r = e.getMirror(t);
            this.appendMap(
              e.maps[t].invert(),
              null != r && r > t ? i - r - 1 : void 0
            );
          }
        }
        invert() {
          let e = new Ma();
          return e.appendMappingInverted(this), e;
        }
        map(e, t = 1) {
          if (this.mirror) return this._map(e, t, !0);
          for (let i = this.from; i < this.to; i++) e = this.maps[i].map(e, t);
          return e;
        }
        mapResult(e, t = 1) {
          return this._map(e, t, !1);
        }
        _map(e, t, i) {
          let r = 0;
          for (let o = this.from; o < this.to; o++) {
            let a = this.maps[o].mapResult(e, t);
            if (null != a.recover) {
              let l = this.getMirror(o);
              if (null != l && l > o && l < this.to) {
                (o = l), (e = this.maps[l].recover(a.recover));
                continue;
              }
            }
            (r |= a.delInfo), (e = a.pos);
          }
          return i ? e : new ov(e, r, null);
        }
      }
      const sv = Object.create(null);
      class lo {
        getMap() {
          return Ci.empty;
        }
        merge(e) {
          return null;
        }
        static fromJSON(e, t) {
          if (!t || !t.stepType)
            throw new RangeError("Invalid input for Step.fromJSON");
          let i = sv[t.stepType];
          if (!i) throw new RangeError(`No step type ${t.stepType} defined`);
          return i.fromJSON(e, t);
        }
        static jsonID(e, t) {
          if (e in sv)
            throw new RangeError("Duplicate use of step JSON ID " + e);
          return (sv[e] = t), (t.prototype.jsonID = e), t;
        }
      }
      class Vn {
        constructor(e, t) {
          (this.doc = e), (this.failed = t);
        }
        static ok(e) {
          return new Vn(e, null);
        }
        static fail(e) {
          return new Vn(null, e);
        }
        static fromReplace(e, t, i, r) {
          try {
            return Vn.ok(e.replace(t, i, r));
          } catch (o) {
            if (o instanceof bc) return Vn.fail(o.message);
            throw o;
          }
        }
      }
      function av(n, e, t) {
        let i = [];
        for (let r = 0; r < n.childCount; r++) {
          let o = n.child(r);
          o.content.size && (o = o.copy(av(o.content, e, o))),
            o.isInline && (o = e(o, t, r)),
            i.push(o);
        }
        return I.fromArray(i);
      }
      class co extends lo {
        constructor(e, t, i) {
          super(), (this.from = e), (this.to = t), (this.mark = i);
        }
        apply(e) {
          let t = e.slice(this.from, this.to),
            i = e.resolve(this.from),
            r = i.node(i.sharedDepth(this.to)),
            o = new P(
              av(
                t.content,
                (s, a) =>
                  s.isAtom && a.type.allowsMarkType(this.mark.type)
                    ? s.mark(this.mark.addToSet(s.marks))
                    : s,
                r
              ),
              t.openStart,
              t.openEnd
            );
          return Vn.fromReplace(e, this.from, this.to, o);
        }
        invert() {
          return new Qi(this.from, this.to, this.mark);
        }
        map(e) {
          let t = e.mapResult(this.from, 1),
            i = e.mapResult(this.to, -1);
          return (t.deleted && i.deleted) || t.pos >= i.pos
            ? null
            : new co(t.pos, i.pos, this.mark);
        }
        merge(e) {
          return e instanceof co &&
            e.mark.eq(this.mark) &&
            this.from <= e.to &&
            this.to >= e.from
            ? new co(
                Math.min(this.from, e.from),
                Math.max(this.to, e.to),
                this.mark
              )
            : null;
        }
        toJSON() {
          return {
            stepType: "addMark",
            mark: this.mark.toJSON(),
            from: this.from,
            to: this.to,
          };
        }
        static fromJSON(e, t) {
          if ("number" != typeof t.from || "number" != typeof t.to)
            throw new RangeError("Invalid input for AddMarkStep.fromJSON");
          return new co(t.from, t.to, e.markFromJSON(t.mark));
        }
      }
      lo.jsonID("addMark", co);
      class Qi extends lo {
        constructor(e, t, i) {
          super(), (this.from = e), (this.to = t), (this.mark = i);
        }
        apply(e) {
          let t = e.slice(this.from, this.to),
            i = new P(
              av(t.content, (r) => r.mark(this.mark.removeFromSet(r.marks)), e),
              t.openStart,
              t.openEnd
            );
          return Vn.fromReplace(e, this.from, this.to, i);
        }
        invert() {
          return new co(this.from, this.to, this.mark);
        }
        map(e) {
          let t = e.mapResult(this.from, 1),
            i = e.mapResult(this.to, -1);
          return (t.deleted && i.deleted) || t.pos >= i.pos
            ? null
            : new Qi(t.pos, i.pos, this.mark);
        }
        merge(e) {
          return e instanceof Qi &&
            e.mark.eq(this.mark) &&
            this.from <= e.to &&
            this.to >= e.from
            ? new Qi(
                Math.min(this.from, e.from),
                Math.max(this.to, e.to),
                this.mark
              )
            : null;
        }
        toJSON() {
          return {
            stepType: "removeMark",
            mark: this.mark.toJSON(),
            from: this.from,
            to: this.to,
          };
        }
        static fromJSON(e, t) {
          if ("number" != typeof t.from || "number" != typeof t.to)
            throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
          return new Qi(t.from, t.to, e.markFromJSON(t.mark));
        }
      }
      lo.jsonID("removeMark", Qi);
      class Jt extends lo {
        constructor(e, t, i, r = !1) {
          super(),
            (this.from = e),
            (this.to = t),
            (this.slice = i),
            (this.structure = r);
        }
        apply(e) {
          return this.structure && lv(e, this.from, this.to)
            ? Vn.fail("Structure replace would overwrite content")
            : Vn.fromReplace(e, this.from, this.to, this.slice);
        }
        getMap() {
          return new Ci([this.from, this.to - this.from, this.slice.size]);
        }
        invert(e) {
          return new Jt(
            this.from,
            this.from + this.slice.size,
            e.slice(this.from, this.to)
          );
        }
        map(e) {
          let t = e.mapResult(this.from, 1),
            i = e.mapResult(this.to, -1);
          return t.deletedAcross && i.deletedAcross
            ? null
            : new Jt(t.pos, Math.max(t.pos, i.pos), this.slice);
        }
        merge(e) {
          if (!(e instanceof Jt) || e.structure || this.structure) return null;
          if (
            this.from + this.slice.size != e.from ||
            this.slice.openEnd ||
            e.slice.openStart
          ) {
            if (e.to != this.from || this.slice.openStart || e.slice.openEnd)
              return null;
            {
              let t =
                this.slice.size + e.slice.size == 0
                  ? P.empty
                  : new P(
                      e.slice.content.append(this.slice.content),
                      e.slice.openStart,
                      this.slice.openEnd
                    );
              return new Jt(e.from, this.to, t, this.structure);
            }
          }
          {
            let t =
              this.slice.size + e.slice.size == 0
                ? P.empty
                : new P(
                    this.slice.content.append(e.slice.content),
                    this.slice.openStart,
                    e.slice.openEnd
                  );
            return new Jt(
              this.from,
              this.to + (e.to - e.from),
              t,
              this.structure
            );
          }
        }
        toJSON() {
          let e = { stepType: "replace", from: this.from, to: this.to };
          return (
            this.slice.size && (e.slice = this.slice.toJSON()),
            this.structure && (e.structure = !0),
            e
          );
        }
        static fromJSON(e, t) {
          if ("number" != typeof t.from || "number" != typeof t.to)
            throw new RangeError("Invalid input for ReplaceStep.fromJSON");
          return new Jt(t.from, t.to, P.fromJSON(e, t.slice), !!t.structure);
        }
      }
      lo.jsonID("replace", Jt);
      class Rt extends lo {
        constructor(e, t, i, r, o, s, a = !1) {
          super(),
            (this.from = e),
            (this.to = t),
            (this.gapFrom = i),
            (this.gapTo = r),
            (this.slice = o),
            (this.insert = s),
            (this.structure = a);
        }
        apply(e) {
          if (
            this.structure &&
            (lv(e, this.from, this.gapFrom) || lv(e, this.gapTo, this.to))
          )
            return Vn.fail("Structure gap-replace would overwrite content");
          let t = e.slice(this.gapFrom, this.gapTo);
          if (t.openStart || t.openEnd)
            return Vn.fail("Gap is not a flat range");
          let i = this.slice.insertAt(this.insert, t.content);
          return i
            ? Vn.fromReplace(e, this.from, this.to, i)
            : Vn.fail("Content does not fit in gap");
        }
        getMap() {
          return new Ci([
            this.from,
            this.gapFrom - this.from,
            this.insert,
            this.gapTo,
            this.to - this.gapTo,
            this.slice.size - this.insert,
          ]);
        }
        invert(e) {
          let t = this.gapTo - this.gapFrom;
          return new Rt(
            this.from,
            this.from + this.slice.size + t,
            this.from + this.insert,
            this.from + this.insert + t,
            e
              .slice(this.from, this.to)
              .removeBetween(this.gapFrom - this.from, this.gapTo - this.from),
            this.gapFrom - this.from,
            this.structure
          );
        }
        map(e) {
          let t = e.mapResult(this.from, 1),
            i = e.mapResult(this.to, -1),
            r = e.map(this.gapFrom, -1),
            o = e.map(this.gapTo, 1);
          return (t.deletedAcross && i.deletedAcross) || r < t.pos || o > i.pos
            ? null
            : new Rt(
                t.pos,
                i.pos,
                r,
                o,
                this.slice,
                this.insert,
                this.structure
              );
        }
        toJSON() {
          let e = {
            stepType: "replaceAround",
            from: this.from,
            to: this.to,
            gapFrom: this.gapFrom,
            gapTo: this.gapTo,
            insert: this.insert,
          };
          return (
            this.slice.size && (e.slice = this.slice.toJSON()),
            this.structure && (e.structure = !0),
            e
          );
        }
        static fromJSON(e, t) {
          if (
            "number" != typeof t.from ||
            "number" != typeof t.to ||
            "number" != typeof t.gapFrom ||
            "number" != typeof t.gapTo ||
            "number" != typeof t.insert
          )
            throw new RangeError(
              "Invalid input for ReplaceAroundStep.fromJSON"
            );
          return new Rt(
            t.from,
            t.to,
            t.gapFrom,
            t.gapTo,
            P.fromJSON(e, t.slice),
            t.insert,
            !!t.structure
          );
        }
      }
      function lv(n, e, t) {
        let i = n.resolve(e),
          r = t - e,
          o = i.depth;
        for (; r > 0 && o > 0 && i.indexAfter(o) == i.node(o).childCount; )
          o--, r--;
        if (r > 0) {
          let s = i.node(o).maybeChild(i.indexAfter(o));
          for (; r > 0; ) {
            if (!s || s.isLeaf) return !0;
            (s = s.firstChild), r--;
          }
        }
        return !1;
      }
      function Y$(n, e, t) {
        return (
          (0 == e || n.canReplace(e, n.childCount)) &&
          (t == n.childCount || n.canReplace(0, t))
        );
      }
      function Ia(n) {
        let t = n.parent.content.cutByIndex(n.startIndex, n.endIndex);
        for (let i = n.depth; ; --i) {
          let r = n.$from.node(i),
            o = n.$from.index(i),
            s = n.$to.indexAfter(i);
          if (i < n.depth && r.canReplace(o, s, t)) return i;
          if (0 == i || r.type.spec.isolating || !Y$(r, o, s)) break;
        }
        return null;
      }
      function cv(n, e, t = null, i = n) {
        let r = (function Q$(n, e) {
            let { parent: t, startIndex: i, endIndex: r } = n,
              o = t.contentMatchAt(i).findWrapping(e);
            return o && t.canReplaceWith(i, r, o.length ? o[0] : e) ? o : null;
          })(n, e),
          o =
            r &&
            (function J$(n, e) {
              let { parent: t, startIndex: i, endIndex: r } = n,
                o = t.child(i),
                s = e.contentMatch.findWrapping(o.type);
              if (!s) return null;
              let l = (s.length ? s[s.length - 1] : e).contentMatch;
              for (let c = i; l && c < r; c++) l = l.matchType(t.child(c).type);
              return l && l.validEnd ? s : null;
            })(i, e);
        return o
          ? r.map(jT).concat({ type: e, attrs: t }).concat(o.map(jT))
          : null;
      }
      function jT(n) {
        return { type: n, attrs: null };
      }
      function Tr(n, e, t = 1, i) {
        let r = n.resolve(e),
          o = r.depth - t,
          s = (i && i[i.length - 1]) || r.parent;
        if (
          o < 0 ||
          r.parent.type.spec.isolating ||
          !r.parent.canReplace(r.index(), r.parent.childCount) ||
          !s.type.validContent(
            r.parent.content.cutByIndex(r.index(), r.parent.childCount)
          )
        )
          return !1;
        for (let c = r.depth - 1, u = t - 2; c > o; c--, u--) {
          let d = r.node(c),
            h = r.index(c);
          if (d.type.spec.isolating) return !1;
          let f = d.content.cutByIndex(h, d.childCount),
            p = (i && i[u]) || d;
          if (
            (p != d && (f = f.replaceChild(0, p.type.create(p.attrs))),
            !d.canReplace(h + 1, d.childCount) || !p.type.validContent(f))
          )
            return !1;
        }
        let a = r.indexAfter(o),
          l = i && i[0];
        return r.node(o).canReplaceWith(a, a, l ? l.type : r.node(o + 1).type);
      }
      function wc(n, e) {
        let t = n.resolve(e),
          i = t.index();
        return (
          (function HT(n, e) {
            return !(!n || !e || n.isLeaf || !n.canAppend(e));
          })(t.nodeBefore, t.nodeAfter) && t.parent.canReplace(i, i + 1)
        );
      }
      function UT(n, e, t) {
        let i = n.resolve(e);
        if (!t.content.size) return e;
        let r = t.content;
        for (let o = 0; o < t.openStart; o++) r = r.firstChild.content;
        for (let o = 1; o <= (0 == t.openStart && t.size ? 2 : 1); o++)
          for (let s = i.depth; s >= 0; s--) {
            let a =
                s == i.depth
                  ? 0
                  : i.pos <= (i.start(s + 1) + i.end(s + 1)) / 2
                  ? -1
                  : 1,
              l = i.index(s) + (a > 0 ? 1 : 0),
              c = i.node(s),
              u = !1;
            if (1 == o) u = c.canReplace(l, l, r);
            else {
              let d = c.contentMatchAt(l).findWrapping(r.firstChild.type);
              u = d && c.canReplaceWith(l, l, d[0]);
            }
            if (u)
              return 0 == a ? i.pos : a < 0 ? i.before(s + 1) : i.after(s + 1);
          }
        return null;
      }
      function uv(n, e, t = e, i = P.empty) {
        if (e == t && !i.size) return null;
        let r = n.resolve(e),
          o = n.resolve(t);
        return zT(r, o, i) ? new Jt(e, t, i) : new s8(r, o, i).fit();
      }
      function zT(n, e, t) {
        return (
          !t.openStart &&
          !t.openEnd &&
          n.start() == e.start() &&
          n.parent.canReplace(n.index(), e.index(), t.content)
        );
      }
      lo.jsonID("replaceAround", Rt);
      class s8 {
        constructor(e, t, i) {
          (this.$from = e),
            (this.$to = t),
            (this.unplaced = i),
            (this.frontier = []),
            (this.placed = I.empty);
          for (let r = 0; r <= e.depth; r++) {
            let o = e.node(r);
            this.frontier.push({
              type: o.type,
              match: o.contentMatchAt(e.indexAfter(r)),
            });
          }
          for (let r = e.depth; r > 0; r--)
            this.placed = I.from(e.node(r).copy(this.placed));
        }
        get depth() {
          return this.frontier.length - 1;
        }
        fit() {
          for (; this.unplaced.size; ) {
            let c = this.findFittable();
            c ? this.placeNodes(c) : this.openMore() || this.dropNode();
          }
          let e = this.mustMoveInline(),
            t = this.placed.size - this.depth - this.$from.depth,
            i = this.$from,
            r = this.close(e < 0 ? this.$to : i.doc.resolve(e));
          if (!r) return null;
          let o = this.placed,
            s = i.depth,
            a = r.depth;
          for (; s && a && 1 == o.childCount; )
            (o = o.firstChild.content), s--, a--;
          let l = new P(o, s, a);
          return e > -1
            ? new Rt(i.pos, e, this.$to.pos, this.$to.end(), l, t)
            : l.size || i.pos != this.$to.pos
            ? new Jt(i.pos, r.pos, l)
            : null;
        }
        findFittable() {
          for (let e = 1; e <= 2; e++)
            for (let t = this.unplaced.openStart; t >= 0; t--) {
              let i,
                r = null;
              t
                ? ((r = dv(this.unplaced.content, t - 1).firstChild),
                  (i = r.content))
                : (i = this.unplaced.content);
              let o = i.firstChild;
              for (let s = this.depth; s >= 0; s--) {
                let c,
                  { type: a, match: l } = this.frontier[s],
                  u = null;
                if (
                  1 == e &&
                  (o
                    ? l.matchType(o.type) || (u = l.fillBefore(I.from(o), !1))
                    : r && a.compatibleContent(r.type))
                )
                  return {
                    sliceDepth: t,
                    frontierDepth: s,
                    parent: r,
                    inject: u,
                  };
                if (2 == e && o && (c = l.findWrapping(o.type)))
                  return {
                    sliceDepth: t,
                    frontierDepth: s,
                    parent: r,
                    wrap: c,
                  };
                if (r && l.matchType(r.type)) break;
              }
            }
        }
        openMore() {
          let { content: e, openStart: t, openEnd: i } = this.unplaced,
            r = dv(e, t);
          return !(
            !r.childCount ||
            r.firstChild.isLeaf ||
            ((this.unplaced = new P(
              e,
              t + 1,
              Math.max(i, r.size + t >= e.size - i ? t + 1 : 0)
            )),
            0)
          );
        }
        dropNode() {
          let { content: e, openStart: t, openEnd: i } = this.unplaced,
            r = dv(e, t);
          if (r.childCount <= 1 && t > 0) {
            let o = e.size - t <= t + r.size;
            this.unplaced = new P(Sc(e, t - 1, 1), t - 1, o ? t - 1 : i);
          } else this.unplaced = new P(Sc(e, t, 1), t, i);
        }
        placeNodes({
          sliceDepth: e,
          frontierDepth: t,
          parent: i,
          inject: r,
          wrap: o,
        }) {
          for (; this.depth > t; ) this.closeFrontierNode();
          if (o) for (let g = 0; g < o.length; g++) this.openFrontierNode(o[g]);
          let s = this.unplaced,
            a = i ? i.content : s.content,
            l = s.openStart - e,
            c = 0,
            u = [],
            { match: d, type: h } = this.frontier[t];
          if (r) {
            for (let g = 0; g < r.childCount; g++) u.push(r.child(g));
            d = d.matchFragment(r);
          }
          let f = a.size + e - (s.content.size - s.openEnd);
          for (; c < a.childCount; ) {
            let g = a.child(c),
              m = d.matchType(g.type);
            if (!m) break;
            c++,
              (c > 1 || 0 == l || g.content.size) &&
                ((d = m),
                u.push(
                  $T(
                    g.mark(h.allowedMarks(g.marks)),
                    1 == c ? l : 0,
                    c == a.childCount ? f : -1
                  )
                ));
          }
          let p = c == a.childCount;
          p || (f = -1),
            (this.placed = Mc(this.placed, t, I.from(u))),
            (this.frontier[t].match = d),
            p &&
              f < 0 &&
              i &&
              i.type == this.frontier[this.depth].type &&
              this.frontier.length > 1 &&
              this.closeFrontierNode();
          for (let g = 0, m = a; g < f; g++) {
            let v = m.lastChild;
            this.frontier.push({
              type: v.type,
              match: v.contentMatchAt(v.childCount),
            }),
              (m = v.content);
          }
          this.unplaced = p
            ? 0 == e
              ? P.empty
              : new P(Sc(s.content, e - 1, 1), e - 1, f < 0 ? s.openEnd : e - 1)
            : new P(Sc(s.content, e, c), s.openStart, s.openEnd);
        }
        mustMoveInline() {
          if (!this.$to.parent.isTextblock) return -1;
          let t,
            e = this.frontier[this.depth];
          if (
            !e.type.isTextblock ||
            !hv(this.$to, this.$to.depth, e.type, e.match, !1) ||
            (this.$to.depth == this.depth &&
              (t = this.findCloseLevel(this.$to)) &&
              t.depth == this.depth)
          )
            return -1;
          let { depth: i } = this.$to,
            r = this.$to.after(i);
          for (; i > 1 && r == this.$to.end(--i); ) ++r;
          return r;
        }
        findCloseLevel(e) {
          e: for (let t = Math.min(this.depth, e.depth); t >= 0; t--) {
            let { match: i, type: r } = this.frontier[t],
              o = t < e.depth && e.end(t + 1) == e.pos + (e.depth - (t + 1)),
              s = hv(e, t, r, i, o);
            if (s) {
              for (let a = t - 1; a >= 0; a--) {
                let { match: l, type: c } = this.frontier[a],
                  u = hv(e, a, c, l, !0);
                if (!u || u.childCount) continue e;
              }
              return {
                depth: t,
                fit: s,
                move: o ? e.doc.resolve(e.after(t + 1)) : e,
              };
            }
          }
        }
        close(e) {
          let t = this.findCloseLevel(e);
          if (!t) return null;
          for (; this.depth > t.depth; ) this.closeFrontierNode();
          t.fit.childCount && (this.placed = Mc(this.placed, t.depth, t.fit)),
            (e = t.move);
          for (let i = t.depth + 1; i <= e.depth; i++) {
            let r = e.node(i),
              o = r.type.contentMatch.fillBefore(r.content, !0, e.index(i));
            this.openFrontierNode(r.type, r.attrs, o);
          }
          return e;
        }
        openFrontierNode(e, t = null, i) {
          let r = this.frontier[this.depth];
          (r.match = r.match.matchType(e)),
            (this.placed = Mc(this.placed, this.depth, I.from(e.create(t, i)))),
            this.frontier.push({ type: e, match: e.contentMatch });
        }
        closeFrontierNode() {
          let t = this.frontier.pop().match.fillBefore(I.empty, !0);
          t.childCount &&
            (this.placed = Mc(this.placed, this.frontier.length, t));
        }
      }
      function Sc(n, e, t) {
        return 0 == e
          ? n.cutByIndex(t, n.childCount)
          : n.replaceChild(
              0,
              n.firstChild.copy(Sc(n.firstChild.content, e - 1, t))
            );
      }
      function Mc(n, e, t) {
        return 0 == e
          ? n.append(t)
          : n.replaceChild(
              n.childCount - 1,
              n.lastChild.copy(Mc(n.lastChild.content, e - 1, t))
            );
      }
      function dv(n, e) {
        for (let t = 0; t < e; t++) n = n.firstChild.content;
        return n;
      }
      function $T(n, e, t) {
        if (e <= 0) return n;
        let i = n.content;
        return (
          e > 1 &&
            (i = i.replaceChild(
              0,
              $T(i.firstChild, e - 1, 1 == i.childCount ? t - 1 : 0)
            )),
          e > 0 &&
            ((i = n.type.contentMatch.fillBefore(i).append(i)),
            t <= 0 &&
              (i = i.append(
                n.type.contentMatch.matchFragment(i).fillBefore(I.empty, !0)
              ))),
          n.copy(i)
        );
      }
      function hv(n, e, t, i, r) {
        let o = n.node(e),
          s = r ? n.indexAfter(e) : n.index(e);
        if (s == o.childCount && !t.compatibleContent(o.type)) return null;
        let a = i.fillBefore(o.content, !0, s);
        return a &&
          !(function a8(n, e, t) {
            for (let i = t; i < e.childCount; i++)
              if (!n.allowsMarks(e.child(i).marks)) return !0;
            return !1;
          })(t, o.content, s)
          ? a
          : null;
      }
      function l8(n) {
        return n.spec.defining || n.spec.definingForContent;
      }
      function WT(n, e, t, i, r) {
        if (e < t) {
          let o = n.firstChild;
          n = n.replaceChild(0, o.copy(WT(o.content, e + 1, t, i, o)));
        }
        if (e > i) {
          let o = r.contentMatchAt(0),
            s = o.fillBefore(n).append(n);
          n = s.append(o.matchFragment(s).fillBefore(I.empty, !0));
        }
        return n;
      }
      function GT(n, e) {
        let t = [];
        for (let r = Math.min(n.depth, e.depth); r >= 0; r--) {
          let o = n.start(r);
          if (
            o < n.pos - (n.depth - r) ||
            e.end(r) > e.pos + (e.depth - r) ||
            n.node(r).type.spec.isolating ||
            e.node(r).type.spec.isolating
          )
            break;
          (o == e.start(r) ||
            (r == n.depth &&
              r == e.depth &&
              n.parent.inlineContent &&
              e.parent.inlineContent &&
              r &&
              e.start(r - 1) == o - 1)) &&
            t.push(r);
        }
        return t;
      }
      let Ta = class extends Error {};
      (Ta = function n(e) {
        let t = Error.call(this, e);
        return (t.__proto__ = n.prototype), t;
      }),
        ((Ta.prototype = Object.create(Error.prototype)).constructor = Ta),
        (Ta.prototype.name = "TransformError");
      class qT {
        constructor(e) {
          (this.doc = e),
            (this.steps = []),
            (this.docs = []),
            (this.mapping = new Ma());
        }
        get before() {
          return this.docs.length ? this.docs[0] : this.doc;
        }
        step(e) {
          let t = this.maybeStep(e);
          if (t.failed) throw new Ta(t.failed);
          return this;
        }
        maybeStep(e) {
          let t = e.apply(this.doc);
          return t.failed || this.addStep(e, t.doc), t;
        }
        get docChanged() {
          return this.steps.length > 0;
        }
        addStep(e, t) {
          this.docs.push(this.doc),
            this.steps.push(e),
            this.mapping.appendMap(e.getMap()),
            (this.doc = t);
        }
        replace(e, t = e, i = P.empty) {
          let r = uv(this.doc, e, t, i);
          return r && this.step(r), this;
        }
        replaceWith(e, t, i) {
          return this.replace(e, t, new P(I.from(i), 0, 0));
        }
        delete(e, t) {
          return this.replace(e, t, P.empty);
        }
        insert(e, t) {
          return this.replaceWith(e, e, t);
        }
        replaceRange(e, t, i) {
          return (
            (function c8(n, e, t, i) {
              if (!i.size) return n.deleteRange(e, t);
              let r = n.doc.resolve(e),
                o = n.doc.resolve(t);
              if (zT(r, o, i)) return n.step(new Jt(e, t, i));
              let s = GT(r, n.doc.resolve(t));
              0 == s[s.length - 1] && s.pop();
              let a = -(r.depth + 1);
              s.unshift(a);
              for (let h = r.depth, f = r.pos - 1; h > 0; h--, f--) {
                let p = r.node(h).type.spec;
                if (p.defining || p.definingAsContext || p.isolating) break;
                s.indexOf(h) > -1
                  ? (a = h)
                  : r.before(h) == f && s.splice(1, 0, -h);
              }
              let l = s.indexOf(a),
                c = [],
                u = i.openStart;
              for (let h = i.content, f = 0; ; f++) {
                let p = h.firstChild;
                if ((c.push(p), f == i.openStart)) break;
                h = p.content;
              }
              for (let h = u - 1; h >= 0; h--) {
                let f = c[h].type,
                  p = l8(f);
                if (p && r.node(l).type != f) u = h;
                else if (p || !f.isTextblock) break;
              }
              for (let h = i.openStart; h >= 0; h--) {
                let f = (h + u + 1) % (i.openStart + 1),
                  p = c[f];
                if (p)
                  for (let g = 0; g < s.length; g++) {
                    let m = s[(g + l) % s.length],
                      v = !0;
                    m < 0 && ((v = !1), (m = -m));
                    let _ = r.node(m - 1),
                      b = r.index(m - 1);
                    if (_.canReplaceWith(b, b, p.type, p.marks))
                      return n.replace(
                        r.before(m),
                        v ? o.after(m) : t,
                        new P(WT(i.content, 0, i.openStart, f), f, i.openEnd)
                      );
                  }
              }
              let d = n.steps.length;
              for (
                let h = s.length - 1;
                h >= 0 && (n.replace(e, t, i), !(n.steps.length > d));
                h--
              ) {
                let f = s[h];
                f < 0 || ((e = r.before(f)), (t = o.after(f)));
              }
            })(this, e, t, i),
            this
          );
        }
        replaceRangeWith(e, t, i) {
          return (
            (function u8(n, e, t, i) {
              if (
                !i.isInline &&
                e == t &&
                n.doc.resolve(e).parent.content.size
              ) {
                let r = (function o8(n, e, t) {
                  let i = n.resolve(e);
                  if (i.parent.canReplaceWith(i.index(), i.index(), t))
                    return e;
                  if (0 == i.parentOffset)
                    for (let r = i.depth - 1; r >= 0; r--) {
                      let o = i.index(r);
                      if (i.node(r).canReplaceWith(o, o, t))
                        return i.before(r + 1);
                      if (o > 0) return null;
                    }
                  if (i.parentOffset == i.parent.content.size)
                    for (let r = i.depth - 1; r >= 0; r--) {
                      let o = i.indexAfter(r);
                      if (i.node(r).canReplaceWith(o, o, t))
                        return i.after(r + 1);
                      if (o < i.node(r).childCount) return null;
                    }
                  return null;
                })(n.doc, e, i.type);
                null != r && (e = t = r);
              }
              n.replaceRange(e, t, new P(I.from(i), 0, 0));
            })(this, e, t, i),
            this
          );
        }
        deleteRange(e, t) {
          return (
            (function d8(n, e, t) {
              let i = n.doc.resolve(e),
                r = n.doc.resolve(t),
                o = GT(i, r);
              for (let s = 0; s < o.length; s++) {
                let a = o[s],
                  l = s == o.length - 1;
                if ((l && 0 == a) || i.node(a).type.contentMatch.validEnd)
                  return n.delete(i.start(a), r.end(a));
                if (
                  a > 0 &&
                  (l ||
                    i
                      .node(a - 1)
                      .canReplace(i.index(a - 1), r.indexAfter(a - 1)))
                )
                  return n.delete(i.before(a), r.after(a));
              }
              for (let s = 1; s <= i.depth && s <= r.depth; s++)
                if (
                  e - i.start(s) == i.depth - s &&
                  t > i.end(s) &&
                  r.end(s) - t != r.depth - s
                )
                  return n.delete(i.before(s), t);
              n.delete(e, t);
            })(this, e, t),
            this
          );
        }
        lift(e, t) {
          return (
            (function Z$(n, e, t) {
              let { $from: i, $to: r, depth: o } = e,
                s = i.before(o + 1),
                a = r.after(o + 1),
                l = s,
                c = a,
                u = I.empty,
                d = 0;
              for (let p = o, g = !1; p > t; p--)
                g || i.index(p) > 0
                  ? ((g = !0), (u = I.from(i.node(p).copy(u))), d++)
                  : l--;
              let h = I.empty,
                f = 0;
              for (let p = o, g = !1; p > t; p--)
                g || r.after(p + 1) < r.end(p)
                  ? ((g = !0), (h = I.from(r.node(p).copy(h))), f++)
                  : c++;
              n.step(
                new Rt(l, c, s, a, new P(u.append(h), d, f), u.size - d, !0)
              );
            })(this, e, t),
            this
          );
        }
        join(e, t = 1) {
          return (
            (function r8(n, e, t) {
              let i = new Jt(e - t, e + t, P.empty, !0);
              n.step(i);
            })(this, e, t),
            this
          );
        }
        wrap(e, t) {
          return (
            (function X$(n, e, t) {
              let i = I.empty;
              for (let s = t.length - 1; s >= 0; s--) {
                if (i.size) {
                  let a = t[s].type.contentMatch.matchFragment(i);
                  if (!a || !a.validEnd)
                    throw new RangeError(
                      "Wrapper type given to Transform.wrap does not form valid content of its parent wrapper"
                    );
                }
                i = I.from(t[s].type.create(t[s].attrs, i));
              }
              let r = e.start,
                o = e.end;
              n.step(new Rt(r, o, r, o, new P(i, 0, 0), t.length, !0));
            })(this, e, t),
            this
          );
        }
        setBlockType(e, t = e, i, r = null) {
          return (
            (function e8(n, e, t, i, r) {
              if (!i.isTextblock)
                throw new RangeError(
                  "Type given to setBlockType should be a textblock"
                );
              let o = n.steps.length;
              n.doc.nodesBetween(e, t, (s, a) => {
                if (
                  s.isTextblock &&
                  !s.hasMarkup(i, r) &&
                  (function t8(n, e, t) {
                    let i = n.resolve(e),
                      r = i.index();
                    return i.parent.canReplaceWith(r, r + 1, t);
                  })(n.doc, n.mapping.slice(o).map(a), i)
                ) {
                  n.clearIncompatible(n.mapping.slice(o).map(a, 1), i);
                  let l = n.mapping.slice(o),
                    c = l.map(a, 1),
                    u = l.map(a + s.nodeSize, 1);
                  return (
                    n.step(
                      new Rt(
                        c,
                        u,
                        c + 1,
                        u - 1,
                        new P(I.from(i.create(r, null, s.marks)), 0, 0),
                        1,
                        !0
                      )
                    ),
                    !1
                  );
                }
              });
            })(this, e, t, i, r),
            this
          );
        }
        setNodeMarkup(e, t, i = null, r = []) {
          return (
            (function n8(n, e, t, i, r) {
              let o = n.doc.nodeAt(e);
              if (!o) throw new RangeError("No node at given position");
              t || (t = o.type);
              let s = t.create(i, null, r || o.marks);
              if (o.isLeaf) return n.replaceWith(e, e + o.nodeSize, s);
              if (!t.validContent(o.content))
                throw new RangeError("Invalid content for node type " + t.name);
              n.step(
                new Rt(
                  e,
                  e + o.nodeSize,
                  e + 1,
                  e + o.nodeSize - 1,
                  new P(I.from(s), 0, 0),
                  1,
                  !0
                )
              );
            })(this, e, t, i, r),
            this
          );
        }
        split(e, t = 1, i) {
          return (
            (function i8(n, e, t = 1, i) {
              let r = n.doc.resolve(e),
                o = I.empty,
                s = I.empty;
              for (
                let a = r.depth, l = r.depth - t, c = t - 1;
                a > l;
                a--, c--
              ) {
                o = I.from(r.node(a).copy(o));
                let u = i && i[c];
                s = I.from(u ? u.type.create(u.attrs, s) : r.node(a).copy(s));
              }
              n.step(new Jt(e, e, new P(o.append(s), t, t), !0));
            })(this, e, t, i),
            this
          );
        }
        addMark(e, t, i) {
          return (
            (function G$(n, e, t, i) {
              let s,
                a,
                r = [],
                o = [];
              n.doc.nodesBetween(e, t, (l, c, u) => {
                if (!l.isInline) return;
                let d = l.marks;
                if (!i.isInSet(d) && u.type.allowsMarkType(i.type)) {
                  let h = Math.max(c, e),
                    f = Math.min(c + l.nodeSize, t),
                    p = i.addToSet(d);
                  for (let g = 0; g < d.length; g++)
                    d[g].isInSet(p) ||
                      (s && s.to == h && s.mark.eq(d[g])
                        ? (s.to = f)
                        : r.push((s = new Qi(h, f, d[g]))));
                  a && a.to == h ? (a.to = f) : o.push((a = new co(h, f, i)));
                }
              }),
                r.forEach((l) => n.step(l)),
                o.forEach((l) => n.step(l));
            })(this, e, t, i),
            this
          );
        }
        removeMark(e, t, i) {
          return (
            (function q$(n, e, t, i) {
              let r = [],
                o = 0;
              n.doc.nodesBetween(e, t, (s, a) => {
                if (!s.isInline) return;
                o++;
                let l = null;
                if (i instanceof Ih) {
                  let u,
                    c = s.marks;
                  for (; (u = i.isInSet(c)); )
                    (l || (l = [])).push(u), (c = u.removeFromSet(c));
                } else i ? i.isInSet(s.marks) && (l = [i]) : (l = s.marks);
                if (l && l.length) {
                  let c = Math.min(a + s.nodeSize, t);
                  for (let u = 0; u < l.length; u++) {
                    let h,
                      d = l[u];
                    for (let f = 0; f < r.length; f++) {
                      let p = r[f];
                      p.step == o - 1 && d.eq(r[f].style) && (h = p);
                    }
                    h
                      ? ((h.to = c), (h.step = o))
                      : r.push({
                          style: d,
                          from: Math.max(a, e),
                          to: c,
                          step: o,
                        });
                  }
                }
              }),
                r.forEach((s) => n.step(new Qi(s.from, s.to, s.style)));
            })(this, e, t, i),
            this
          );
        }
        clearIncompatible(e, t, i) {
          return (
            (function K$(n, e, t, i = t.contentMatch) {
              let r = n.doc.nodeAt(e),
                o = [],
                s = e + 1;
              for (let a = 0; a < r.childCount; a++) {
                let l = r.child(a),
                  c = s + l.nodeSize,
                  u = i.matchType(l.type);
                if (u) {
                  i = u;
                  for (let d = 0; d < l.marks.length; d++)
                    t.allowsMarkType(l.marks[d].type) ||
                      n.step(new Qi(s, c, l.marks[d]));
                } else o.push(new Jt(s, c, P.empty));
                s = c;
              }
              if (!i.validEnd) {
                let a = i.fillBefore(I.empty, !0);
                n.replace(s, s, new P(a, 0, 0));
              }
              for (let a = o.length - 1; a >= 0; a--) n.step(o[a]);
            })(this, e, t, i),
            this
          );
        }
      }
      const fv = Object.create(null);
      class ce {
        constructor(e, t, i) {
          (this.$anchor = e),
            (this.$head = t),
            (this.ranges = i || [new h8(e.min(t), e.max(t))]);
        }
        get anchor() {
          return this.$anchor.pos;
        }
        get head() {
          return this.$head.pos;
        }
        get from() {
          return this.$from.pos;
        }
        get to() {
          return this.$to.pos;
        }
        get $from() {
          return this.ranges[0].$from;
        }
        get $to() {
          return this.ranges[0].$to;
        }
        get empty() {
          let e = this.ranges;
          for (let t = 0; t < e.length; t++)
            if (e[t].$from.pos != e[t].$to.pos) return !1;
          return !0;
        }
        content() {
          return this.$from.doc.slice(this.from, this.to, !0);
        }
        replace(e, t = P.empty) {
          let i = t.content.lastChild,
            r = null;
          for (let a = 0; a < t.openEnd; a++) (r = i), (i = i.lastChild);
          let o = e.steps.length,
            s = this.ranges;
          for (let a = 0; a < s.length; a++) {
            let { $from: l, $to: c } = s[a],
              u = e.mapping.slice(o);
            e.replaceRange(u.map(l.pos), u.map(c.pos), a ? P.empty : t),
              0 == a &&
                ZT(e, o, (i ? i.isInline : r && r.isTextblock) ? -1 : 1);
          }
        }
        replaceWith(e, t) {
          let i = e.steps.length,
            r = this.ranges;
          for (let o = 0; o < r.length; o++) {
            let { $from: s, $to: a } = r[o],
              l = e.mapping.slice(i),
              c = l.map(s.pos),
              u = l.map(a.pos);
            o
              ? e.deleteRange(c, u)
              : (e.replaceRangeWith(c, u, t), ZT(e, i, t.isInline ? -1 : 1));
          }
        }
        static findFrom(e, t, i = !1) {
          let r = e.parent.inlineContent
            ? new ue(e)
            : xa(e.node(0), e.parent, e.pos, e.index(), t, i);
          if (r) return r;
          for (let o = e.depth - 1; o >= 0; o--) {
            let s =
              t < 0
                ? xa(e.node(0), e.node(o), e.before(o + 1), e.index(o), t, i)
                : xa(
                    e.node(0),
                    e.node(o),
                    e.after(o + 1),
                    e.index(o) + 1,
                    t,
                    i
                  );
            if (s) return s;
          }
          return null;
        }
        static near(e, t = 1) {
          return (
            this.findFrom(e, t) || this.findFrom(e, -t) || new Bn(e.node(0))
          );
        }
        static atStart(e) {
          return xa(e, e, 0, 0, 1) || new Bn(e);
        }
        static atEnd(e) {
          return xa(e, e, e.content.size, e.childCount, -1) || new Bn(e);
        }
        static fromJSON(e, t) {
          if (!t || !t.type)
            throw new RangeError("Invalid input for Selection.fromJSON");
          let i = fv[t.type];
          if (!i) throw new RangeError(`No selection type ${t.type} defined`);
          return i.fromJSON(e, t);
        }
        static jsonID(e, t) {
          if (e in fv)
            throw new RangeError("Duplicate use of selection JSON ID " + e);
          return (fv[e] = t), (t.prototype.jsonID = e), t;
        }
        getBookmark() {
          return ue.between(this.$anchor, this.$head).getBookmark();
        }
      }
      ce.prototype.visible = !0;
      class h8 {
        constructor(e, t) {
          (this.$from = e), (this.$to = t);
        }
      }
      let KT = !1;
      function YT(n) {
        !KT &&
          !n.parent.inlineContent &&
          ((KT = !0),
          console.warn(
            "TextSelection endpoint not pointing into a node with inline content (" +
              n.parent.type.name +
              ")"
          ));
      }
      class ue extends ce {
        constructor(e, t = e) {
          YT(e), YT(t), super(e, t);
        }
        get $cursor() {
          return this.$anchor.pos == this.$head.pos ? this.$head : null;
        }
        map(e, t) {
          let i = e.resolve(t.map(this.head));
          if (!i.parent.inlineContent) return ce.near(i);
          let r = e.resolve(t.map(this.anchor));
          return new ue(r.parent.inlineContent ? r : i, i);
        }
        replace(e, t = P.empty) {
          if ((super.replace(e, t), t == P.empty)) {
            let i = this.$from.marksAcross(this.$to);
            i && e.ensureMarks(i);
          }
        }
        eq(e) {
          return (
            e instanceof ue && e.anchor == this.anchor && e.head == this.head
          );
        }
        getBookmark() {
          return new kh(this.anchor, this.head);
        }
        toJSON() {
          return { type: "text", anchor: this.anchor, head: this.head };
        }
        static fromJSON(e, t) {
          if ("number" != typeof t.anchor || "number" != typeof t.head)
            throw new RangeError("Invalid input for TextSelection.fromJSON");
          return new ue(e.resolve(t.anchor), e.resolve(t.head));
        }
        static create(e, t, i = t) {
          let r = e.resolve(t);
          return new this(r, i == t ? r : e.resolve(i));
        }
        static between(e, t, i) {
          let r = e.pos - t.pos;
          if (((!i || r) && (i = r >= 0 ? 1 : -1), !t.parent.inlineContent)) {
            let o = ce.findFrom(t, i, !0) || ce.findFrom(t, -i, !0);
            if (!o) return ce.near(t, i);
            t = o.$head;
          }
          return (
            e.parent.inlineContent ||
              ((0 == r ||
                (e = (ce.findFrom(e, -i, !0) || ce.findFrom(e, i, !0)).$anchor)
                  .pos <
                  t.pos !=
                  r < 0) &&
                (e = t)),
            new ue(e, t)
          );
        }
      }
      ce.jsonID("text", ue);
      class kh {
        constructor(e, t) {
          (this.anchor = e), (this.head = t);
        }
        map(e) {
          return new kh(e.map(this.anchor), e.map(this.head));
        }
        resolve(e) {
          return ue.between(e.resolve(this.anchor), e.resolve(this.head));
        }
      }
      class Y extends ce {
        constructor(e) {
          let t = e.nodeAfter,
            i = e.node(0).resolve(e.pos + t.nodeSize);
          super(e, i), (this.node = t);
        }
        map(e, t) {
          let { deleted: i, pos: r } = t.mapResult(this.anchor),
            o = e.resolve(r);
          return i ? ce.near(o) : new Y(o);
        }
        content() {
          return new P(I.from(this.node), 0, 0);
        }
        eq(e) {
          return e instanceof Y && e.anchor == this.anchor;
        }
        toJSON() {
          return { type: "node", anchor: this.anchor };
        }
        getBookmark() {
          return new pv(this.anchor);
        }
        static fromJSON(e, t) {
          if ("number" != typeof t.anchor)
            throw new RangeError("Invalid input for NodeSelection.fromJSON");
          return new Y(e.resolve(t.anchor));
        }
        static create(e, t) {
          return new Y(e.resolve(t));
        }
        static isSelectable(e) {
          return !e.isText && !1 !== e.type.spec.selectable;
        }
      }
      (Y.prototype.visible = !1), ce.jsonID("node", Y);
      class pv {
        constructor(e) {
          this.anchor = e;
        }
        map(e) {
          let { deleted: t, pos: i } = e.mapResult(this.anchor);
          return t ? new kh(i, i) : new pv(i);
        }
        resolve(e) {
          let t = e.resolve(this.anchor),
            i = t.nodeAfter;
          return i && Y.isSelectable(i) ? new Y(t) : ce.near(t);
        }
      }
      class Bn extends ce {
        constructor(e) {
          super(e.resolve(0), e.resolve(e.content.size));
        }
        replace(e, t = P.empty) {
          if (t == P.empty) {
            e.delete(0, e.doc.content.size);
            let i = ce.atStart(e.doc);
            i.eq(e.selection) || e.setSelection(i);
          } else super.replace(e, t);
        }
        toJSON() {
          return { type: "all" };
        }
        static fromJSON(e) {
          return new Bn(e);
        }
        map(e) {
          return new Bn(e);
        }
        eq(e) {
          return e instanceof Bn;
        }
        getBookmark() {
          return f8;
        }
      }
      ce.jsonID("all", Bn);
      const f8 = {
        map() {
          return this;
        },
        resolve: (n) => new Bn(n),
      };
      function xa(n, e, t, i, r, o = !1) {
        if (e.inlineContent) return ue.create(n, t);
        for (
          let s = i - (r > 0 ? 0 : 1);
          r > 0 ? s < e.childCount : s >= 0;
          s += r
        ) {
          let a = e.child(s);
          if (a.isAtom) {
            if (!o && Y.isSelectable(a))
              return Y.create(n, t - (r < 0 ? a.nodeSize : 0));
          } else {
            let l = xa(n, a, t + r, r < 0 ? a.childCount : 0, r, o);
            if (l) return l;
          }
          t += a.nodeSize * r;
        }
        return null;
      }
      function ZT(n, e, t) {
        let i = n.steps.length - 1;
        if (i < e) return;
        let s,
          r = n.steps[i];
        (r instanceof Jt || r instanceof Rt) &&
          (n.mapping.maps[i].forEach((a, l, c, u) => {
            null == s && (s = u);
          }),
          n.setSelection(ce.near(n.doc.resolve(s), t)));
      }
      class p8 extends qT {
        constructor(e) {
          super(e.doc),
            (this.curSelectionFor = 0),
            (this.updated = 0),
            (this.meta = Object.create(null)),
            (this.time = Date.now()),
            (this.curSelection = e.selection),
            (this.storedMarks = e.storedMarks);
        }
        get selection() {
          return (
            this.curSelectionFor < this.steps.length &&
              ((this.curSelection = this.curSelection.map(
                this.doc,
                this.mapping.slice(this.curSelectionFor)
              )),
              (this.curSelectionFor = this.steps.length)),
            this.curSelection
          );
        }
        setSelection(e) {
          if (e.$from.doc != this.doc)
            throw new RangeError(
              "Selection passed to setSelection must point at the current document"
            );
          return (
            (this.curSelection = e),
            (this.curSelectionFor = this.steps.length),
            (this.updated = -3 & (1 | this.updated)),
            (this.storedMarks = null),
            this
          );
        }
        get selectionSet() {
          return (1 & this.updated) > 0;
        }
        setStoredMarks(e) {
          return (this.storedMarks = e), (this.updated |= 2), this;
        }
        ensureMarks(e) {
          return (
            Ye.sameSet(this.storedMarks || this.selection.$from.marks(), e) ||
              this.setStoredMarks(e),
            this
          );
        }
        addStoredMark(e) {
          return this.ensureMarks(
            e.addToSet(this.storedMarks || this.selection.$head.marks())
          );
        }
        removeStoredMark(e) {
          return this.ensureMarks(
            e.removeFromSet(this.storedMarks || this.selection.$head.marks())
          );
        }
        get storedMarksSet() {
          return (2 & this.updated) > 0;
        }
        addStep(e, t) {
          super.addStep(e, t),
            (this.updated = -3 & this.updated),
            (this.storedMarks = null);
        }
        setTime(e) {
          return (this.time = e), this;
        }
        replaceSelection(e) {
          return this.selection.replace(this, e), this;
        }
        replaceSelectionWith(e, t = !0) {
          let i = this.selection;
          return (
            t &&
              (e = e.mark(
                this.storedMarks ||
                  (i.empty
                    ? i.$from.marks()
                    : i.$from.marksAcross(i.$to) || Ye.none)
              )),
            i.replaceWith(this, e),
            this
          );
        }
        deleteSelection() {
          return this.selection.replace(this), this;
        }
        insertText(e, t, i) {
          let r = this.doc.type.schema;
          if (null == t)
            return e
              ? this.replaceSelectionWith(r.text(e), !0)
              : this.deleteSelection();
          {
            if ((null == i && (i = t), (i = i ?? t), !e))
              return this.deleteRange(t, i);
            let o = this.storedMarks;
            if (!o) {
              let s = this.doc.resolve(t);
              o = i == t ? s.marks() : s.marksAcross(this.doc.resolve(i));
            }
            return (
              this.replaceRangeWith(t, i, r.text(e, o)),
              this.selection.empty ||
                this.setSelection(ce.near(this.selection.$to)),
              this
            );
          }
        }
        setMeta(e, t) {
          return (this.meta["string" == typeof e ? e : e.key] = t), this;
        }
        getMeta(e) {
          return this.meta["string" == typeof e ? e : e.key];
        }
        get isGeneric() {
          for (let e in this.meta) return !1;
          return !0;
        }
        scrollIntoView() {
          return (this.updated |= 4), this;
        }
        get scrolledIntoView() {
          return (4 & this.updated) > 0;
        }
      }
      function XT(n, e) {
        return e && n ? n.bind(e) : n;
      }
      class Ic {
        constructor(e, t, i) {
          (this.name = e),
            (this.init = XT(t.init, i)),
            (this.apply = XT(t.apply, i));
        }
      }
      const g8 = [
        new Ic("doc", {
          init: (n) => n.doc || n.schema.topNodeType.createAndFill(),
          apply: (n) => n.doc,
        }),
        new Ic("selection", {
          init: (n, e) => n.selection || ce.atStart(e.doc),
          apply: (n) => n.selection,
        }),
        new Ic("storedMarks", {
          init: (n) => n.storedMarks || null,
          apply: (n, e, t, i) => (i.selection.$cursor ? n.storedMarks : null),
        }),
        new Ic("scrollToSelection", {
          init: () => 0,
          apply: (n, e) => (n.scrolledIntoView ? e + 1 : e),
        }),
      ];
      class gv {
        constructor(e, t) {
          (this.schema = e),
            (this.plugins = []),
            (this.pluginsByKey = Object.create(null)),
            (this.fields = g8.slice()),
            t &&
              t.forEach((i) => {
                if (this.pluginsByKey[i.key])
                  throw new RangeError(
                    "Adding different instances of a keyed plugin (" +
                      i.key +
                      ")"
                  );
                this.plugins.push(i),
                  (this.pluginsByKey[i.key] = i),
                  i.spec.state &&
                    this.fields.push(new Ic(i.key, i.spec.state, i));
              });
        }
      }
      class Aa {
        constructor(e) {
          this.config = e;
        }
        get schema() {
          return this.config.schema;
        }
        get plugins() {
          return this.config.plugins;
        }
        apply(e) {
          return this.applyTransaction(e).state;
        }
        filterTransaction(e, t = -1) {
          for (let i = 0; i < this.config.plugins.length; i++)
            if (i != t) {
              let r = this.config.plugins[i];
              if (
                r.spec.filterTransaction &&
                !r.spec.filterTransaction.call(r, e, this)
              )
                return !1;
            }
          return !0;
        }
        applyTransaction(e) {
          if (!this.filterTransaction(e))
            return { state: this, transactions: [] };
          let t = [e],
            i = this.applyInner(e),
            r = null;
          for (;;) {
            let o = !1;
            for (let s = 0; s < this.config.plugins.length; s++) {
              let a = this.config.plugins[s];
              if (a.spec.appendTransaction) {
                let l = r ? r[s].n : 0,
                  c = r ? r[s].state : this,
                  u =
                    l < t.length &&
                    a.spec.appendTransaction.call(a, l ? t.slice(l) : t, c, i);
                if (u && i.filterTransaction(u, s)) {
                  if ((u.setMeta("appendedTransaction", e), !r)) {
                    r = [];
                    for (let d = 0; d < this.config.plugins.length; d++)
                      r.push(
                        d < s
                          ? { state: i, n: t.length }
                          : { state: this, n: 0 }
                      );
                  }
                  t.push(u), (i = i.applyInner(u)), (o = !0);
                }
                r && (r[s] = { state: i, n: t.length });
              }
            }
            if (!o) return { state: i, transactions: t };
          }
        }
        applyInner(e) {
          if (!e.before.eq(this.doc))
            throw new RangeError("Applying a mismatched transaction");
          let t = new Aa(this.config),
            i = this.config.fields;
          for (let r = 0; r < i.length; r++) {
            let o = i[r];
            t[o.name] = o.apply(e, this[o.name], this, t);
          }
          return t;
        }
        get tr() {
          return new p8(this);
        }
        static create(e) {
          let t = new gv(e.doc ? e.doc.type.schema : e.schema, e.plugins),
            i = new Aa(t);
          for (let r = 0; r < t.fields.length; r++)
            i[t.fields[r].name] = t.fields[r].init(e, i);
          return i;
        }
        reconfigure(e) {
          let t = new gv(this.schema, e.plugins),
            i = t.fields,
            r = new Aa(t);
          for (let o = 0; o < i.length; o++) {
            let s = i[o].name;
            r[s] = this.hasOwnProperty(s) ? this[s] : i[o].init(e, r);
          }
          return r;
        }
        toJSON(e) {
          let t = {
            doc: this.doc.toJSON(),
            selection: this.selection.toJSON(),
          };
          if (
            (this.storedMarks &&
              (t.storedMarks = this.storedMarks.map((i) => i.toJSON())),
            e && "object" == typeof e)
          )
            for (let i in e) {
              if ("doc" == i || "selection" == i)
                throw new RangeError(
                  "The JSON fields `doc` and `selection` are reserved"
                );
              let r = e[i],
                o = r.spec.state;
              o && o.toJSON && (t[i] = o.toJSON.call(r, this[r.key]));
            }
          return t;
        }
        static fromJSON(e, t, i) {
          if (!t)
            throw new RangeError("Invalid input for EditorState.fromJSON");
          if (!e.schema)
            throw new RangeError("Required config field 'schema' missing");
          let r = new gv(e.schema, e.plugins),
            o = new Aa(r);
          return (
            r.fields.forEach((s) => {
              if ("doc" == s.name) o.doc = Yi.fromJSON(e.schema, t.doc);
              else if ("selection" == s.name)
                o.selection = ce.fromJSON(o.doc, t.selection);
              else if ("storedMarks" == s.name)
                t.storedMarks &&
                  (o.storedMarks = t.storedMarks.map(e.schema.markFromJSON));
              else {
                if (i)
                  for (let a in i) {
                    let l = i[a],
                      c = l.spec.state;
                    if (
                      l.key == s.name &&
                      c &&
                      c.fromJSON &&
                      Object.prototype.hasOwnProperty.call(t, a)
                    )
                      return void (o[s.name] = c.fromJSON.call(l, e, t[a], o));
                  }
                o[s.name] = s.init(e, o);
              }
            }),
            o
          );
        }
      }
      function ex(n, e, t) {
        for (let i in n) {
          let r = n[i];
          r instanceof Function
            ? (r = r.bind(e))
            : "handleDOMEvents" == i && (r = ex(r, e, {})),
            (t[i] = r);
        }
        return t;
      }
      class Qe {
        constructor(e) {
          (this.spec = e),
            (this.props = {}),
            e.props && ex(e.props, this, this.props),
            (this.key = e.key ? e.key.key : tx("plugin"));
        }
        getState(e) {
          return e[this.key];
        }
      }
      const mv = Object.create(null);
      function tx(n) {
        return n in mv ? n + "$" + ++mv[n] : ((mv[n] = 0), n + "$");
      }
      class It {
        constructor(e = "key") {
          this.key = tx(e);
        }
        get(e) {
          return e.config.pluginsByKey[this.key];
        }
        getState(e) {
          return e[this.key];
        }
      }
      const uo = typeof navigator < "u" ? navigator : null,
        nx = typeof document < "u" ? document : null,
        ho = (uo && uo.userAgent) || "",
        yv = /Edge\/(\d+)/.exec(ho),
        ix = /MSIE \d/.exec(ho),
        vv = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(ho),
        jn = !!(ix || vv || yv),
        fo = ix ? document.documentMode : vv ? +vv[1] : yv ? +yv[1] : 0,
        Ji = !jn && /gecko\/(\d+)/i.test(ho);
      Ji && /Firefox\/(\d+)/.exec(ho);
      const _v = !jn && /Chrome\/(\d+)/.exec(ho),
        hn = !!_v,
        m8 = _v ? +_v[1] : 0,
        En = !jn && !!uo && /Apple Computer/.test(uo.vendor),
        Oa = En && (/Mobile\/\w+/.test(ho) || (!!uo && uo.maxTouchPoints > 2)),
        ei = Oa || (!!uo && /Mac/.test(uo.platform)),
        Xi = /Android \d/.test(ho),
        Rh = !!nx && "webkitFontSmoothing" in nx.documentElement.style,
        y8 = Rh
          ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1]
          : 0,
        Hn = function (n) {
          for (var e = 0; ; e++) if (!(n = n.previousSibling)) return e;
        },
        bv = function (n) {
          let e = n.assignedSlot || n.parentNode;
          return e && 11 == e.nodeType ? e.host : e;
        };
      let rx = null;
      const xr = function (n, e, t) {
          let i = rx || (rx = document.createRange());
          return i.setEnd(n, t ?? n.nodeValue.length), i.setStart(n, e || 0), i;
        },
        Tc = function (n, e, t, i) {
          return t && (ox(n, e, t, i, -1) || ox(n, e, t, i, 1));
        },
        v8 = /^(img|br|input|textarea|hr)$/i;
      function ox(n, e, t, i, r) {
        for (;;) {
          if (n == t && e == i) return !0;
          if (e == (r < 0 ? 0 : er(n))) {
            let o = n.parentNode;
            if (
              !o ||
              1 != o.nodeType ||
              b8(n) ||
              v8.test(n.nodeName) ||
              "false" == n.contentEditable
            )
              return !1;
            (e = Hn(n) + (r < 0 ? 0 : 1)), (n = o);
          } else {
            if (1 != n.nodeType) return !1;
            if (
              "false" ==
              (n = n.childNodes[e + (r < 0 ? -1 : 0)]).contentEditable
            )
              return !1;
            e = r < 0 ? er(n) : 0;
          }
        }
      }
      function er(n) {
        return 3 == n.nodeType ? n.nodeValue.length : n.childNodes.length;
      }
      function b8(n) {
        let e;
        for (let t = n; t && !(e = t.pmViewDesc); t = t.parentNode);
        return (
          e && e.node && e.node.isBlock && (e.dom == n || e.contentDOM == n)
        );
      }
      const Dv = function (n) {
        let e = n.isCollapsed;
        return (
          e && hn && n.rangeCount && !n.getRangeAt(0).collapsed && (e = !1), e
        );
      };
      function ka(n, e) {
        let t = document.createEvent("Event");
        return (
          t.initEvent("keydown", !0, !0),
          (t.keyCode = n),
          (t.key = t.code = e),
          t
        );
      }
      function D8(n) {
        return {
          left: 0,
          right: n.documentElement.clientWidth,
          top: 0,
          bottom: n.documentElement.clientHeight,
        };
      }
      function po(n, e) {
        return "number" == typeof n ? n : n[e];
      }
      function C8(n) {
        let e = n.getBoundingClientRect();
        return {
          left: e.left,
          right: e.left + n.clientWidth * (e.width / n.offsetWidth || 1),
          top: e.top,
          bottom: e.top + n.clientHeight * (e.height / n.offsetHeight || 1),
        };
      }
      function sx(n, e, t) {
        let i = n.someProp("scrollThreshold") || 0,
          r = n.someProp("scrollMargin") || 5,
          o = n.dom.ownerDocument;
        for (let s = t || n.dom; s; s = bv(s)) {
          if (1 != s.nodeType) continue;
          let a = s,
            l = a == o.body,
            c = l ? D8(o) : C8(a),
            u = 0,
            d = 0;
          if (
            (e.top < c.top + po(i, "top")
              ? (d = -(c.top - e.top + po(r, "top")))
              : e.bottom > c.bottom - po(i, "bottom") &&
                (d = e.bottom - c.bottom + po(r, "bottom")),
            e.left < c.left + po(i, "left")
              ? (u = -(c.left - e.left + po(r, "left")))
              : e.right > c.right - po(i, "right") &&
                (u = e.right - c.right + po(r, "right")),
            u || d)
          )
            if (l) o.defaultView.scrollBy(u, d);
            else {
              let h = a.scrollLeft,
                f = a.scrollTop;
              d && (a.scrollTop += d), u && (a.scrollLeft += u);
              let p = a.scrollLeft - h,
                g = a.scrollTop - f;
              e = {
                left: e.left - p,
                top: e.top - g,
                right: e.right - p,
                bottom: e.bottom - g,
              };
            }
          if (l) break;
        }
      }
      function ax(n) {
        let e = [],
          t = n.ownerDocument;
        for (
          let i = n;
          i &&
          (e.push({ dom: i, top: i.scrollTop, left: i.scrollLeft }), n != t);
          i = bv(i)
        );
        return e;
      }
      function lx(n, e) {
        for (let t = 0; t < n.length; t++) {
          let { dom: i, top: r, left: o } = n[t];
          i.scrollTop != r + e && (i.scrollTop = r + e),
            i.scrollLeft != o && (i.scrollLeft = o);
        }
      }
      let Na = null;
      function cx(n, e) {
        let t,
          r,
          i = 2e8,
          o = 0,
          s = e.top,
          a = e.top;
        for (let l = n.firstChild, c = 0; l; l = l.nextSibling, c++) {
          let u;
          if (1 == l.nodeType) u = l.getClientRects();
          else {
            if (3 != l.nodeType) continue;
            u = xr(l).getClientRects();
          }
          for (let d = 0; d < u.length; d++) {
            let h = u[d];
            if (h.top <= s && h.bottom >= a) {
              (s = Math.max(h.bottom, s)), (a = Math.min(h.top, a));
              let f =
                h.left > e.left
                  ? h.left - e.left
                  : h.right < e.left
                  ? e.left - h.right
                  : 0;
              if (f < i) {
                (t = l),
                  (i = f),
                  (r =
                    f && 3 == t.nodeType
                      ? {
                          left: h.right < e.left ? h.right : h.left,
                          top: e.top,
                        }
                      : e),
                  1 == l.nodeType &&
                    f &&
                    (o = c + (e.left >= (h.left + h.right) / 2 ? 1 : 0));
                continue;
              }
            }
            !t &&
              ((e.left >= h.right && e.top >= h.top) ||
                (e.left >= h.left && e.top >= h.bottom)) &&
              (o = c + 1);
          }
        }
        return t && 3 == t.nodeType
          ? (function M8(n, e) {
              let t = n.nodeValue.length,
                i = document.createRange();
              for (let r = 0; r < t; r++) {
                i.setEnd(n, r + 1), i.setStart(n, r);
                let o = go(i, 1);
                if (o.top != o.bottom && Cv(e, o))
                  return {
                    node: n,
                    offset: r + (e.left >= (o.left + o.right) / 2 ? 1 : 0),
                  };
              }
              return { node: n, offset: 0 };
            })(t, r)
          : !t || (i && 1 == t.nodeType)
          ? { node: n, offset: o }
          : cx(t, r);
      }
      function Cv(n, e) {
        return (
          n.left >= e.left - 1 &&
          n.left <= e.right + 1 &&
          n.top >= e.top - 1 &&
          n.top <= e.bottom + 1
        );
      }
      function ux(n, e, t) {
        let i = n.childNodes.length;
        if (i && t.top < t.bottom)
          for (
            let r = Math.max(
                0,
                Math.min(
                  i - 1,
                  Math.floor((i * (e.top - t.top)) / (t.bottom - t.top)) - 2
                )
              ),
              o = r;
            ;

          ) {
            let s = n.childNodes[o];
            if (1 == s.nodeType) {
              let a = s.getClientRects();
              for (let l = 0; l < a.length; l++) {
                let c = a[l];
                if (Cv(e, c)) return ux(s, e, c);
              }
            }
            if ((o = (o + 1) % i) == r) break;
          }
        return n;
      }
      function A8(n, e) {
        let i,
          t = n.dom.ownerDocument,
          r = 0;
        if (t.caretPositionFromPoint)
          try {
            let l = t.caretPositionFromPoint(e.left, e.top);
            l && ({ offsetNode: i, offset: r } = l);
          } catch {}
        if (!i && t.caretRangeFromPoint) {
          let l = t.caretRangeFromPoint(e.left, e.top);
          l && ({ startContainer: i, startOffset: r } = l);
        }
        let s,
          o = (n.root.elementFromPoint ? n.root : t).elementFromPoint(
            e.left,
            e.top + 1
          );
        if (!o || !n.dom.contains(1 != o.nodeType ? o.parentNode : o)) {
          let l = n.dom.getBoundingClientRect();
          if (!Cv(e, l) || ((o = ux(n.dom, e, l)), !o)) return null;
        }
        if (En) for (let l = o; i && l; l = bv(l)) l.draggable && (i = void 0);
        if (
          ((o = (function I8(n, e) {
            let t = n.parentNode;
            return t &&
              /^li$/i.test(t.nodeName) &&
              e.left < n.getBoundingClientRect().left
              ? t
              : n;
          })(o, e)),
          i)
        ) {
          if (
            Ji &&
            1 == i.nodeType &&
            ((r = Math.min(r, i.childNodes.length)), r < i.childNodes.length)
          ) {
            let c,
              l = i.childNodes[r];
            "IMG" == l.nodeName &&
              (c = l.getBoundingClientRect()).right <= e.left &&
              c.bottom > e.top &&
              r++;
          }
          i == n.dom &&
          r == i.childNodes.length - 1 &&
          1 == i.lastChild.nodeType &&
          e.top > i.lastChild.getBoundingClientRect().bottom
            ? (s = n.state.doc.content.size)
            : (0 == r ||
                1 != i.nodeType ||
                "BR" != i.childNodes[r - 1].nodeName) &&
              (s = (function x8(n, e, t, i) {
                let r = -1;
                for (let o = e; o != n.dom; ) {
                  let s = n.docView.nearestDesc(o, !0);
                  if (!s) return null;
                  if (s.node.isBlock && s.parent) {
                    let a = s.dom.getBoundingClientRect();
                    if (a.left > i.left || a.top > i.top) r = s.posBefore;
                    else {
                      if (!(a.right < i.left || a.bottom < i.top)) break;
                      r = s.posAfter;
                    }
                  }
                  o = s.dom.parentNode;
                }
                return r > -1 ? r : n.docView.posFromDOM(e, t, 1);
              })(n, i, r, e));
        }
        null == s &&
          (s = (function T8(n, e, t) {
            let { node: i, offset: r } = cx(e, t),
              o = -1;
            if (1 == i.nodeType && !i.firstChild) {
              let s = i.getBoundingClientRect();
              o = s.left != s.right && t.left > (s.left + s.right) / 2 ? 1 : -1;
            }
            return n.docView.posFromDOM(i, r, o);
          })(n, o, e));
        let a = n.docView.nearestDesc(o, !0);
        return { pos: s, inside: a ? a.posAtStart - a.border : -1 };
      }
      function go(n, e) {
        let t = n.getClientRects();
        return t.length
          ? t[e < 0 ? 0 : t.length - 1]
          : n.getBoundingClientRect();
      }
      const O8 = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
      function dx(n, e, t) {
        let { node: i, offset: r } = n.docView.domFromPos(e, t < 0 ? -1 : 1),
          o = Rh || Ji;
        if (3 == i.nodeType) {
          if (
            !o ||
            (!O8.test(i.nodeValue) && (t < 0 ? r : r != i.nodeValue.length))
          ) {
            let s = r,
              a = r,
              l = t < 0 ? 1 : -1;
            return (
              t < 0 && !r
                ? (a++, (l = -1))
                : t >= 0 && r == i.nodeValue.length
                ? (s--, (l = 1))
                : t < 0
                ? s--
                : a++,
              xc(go(xr(i, s, a), l), l < 0)
            );
          }
          {
            let s = go(xr(i, r, r), t);
            if (
              Ji &&
              r &&
              /\s/.test(i.nodeValue[r - 1]) &&
              r < i.nodeValue.length
            ) {
              let a = go(xr(i, r - 1, r - 1), -1);
              if (a.top == s.top) {
                let l = go(xr(i, r, r + 1), -1);
                if (l.top != s.top) return xc(l, l.left < a.left);
              }
            }
            return s;
          }
        }
        if (!n.state.doc.resolve(e).parent.inlineContent) {
          if (r && (t < 0 || r == er(i))) {
            let s = i.childNodes[r - 1];
            if (1 == s.nodeType) return Ev(s.getBoundingClientRect(), !1);
          }
          if (r < er(i)) {
            let s = i.childNodes[r];
            if (1 == s.nodeType) return Ev(s.getBoundingClientRect(), !0);
          }
          return Ev(i.getBoundingClientRect(), t >= 0);
        }
        if (r && (t < 0 || r == er(i))) {
          let s = i.childNodes[r - 1],
            a =
              3 == s.nodeType
                ? xr(s, er(s) - (o ? 0 : 1))
                : 1 != s.nodeType || ("BR" == s.nodeName && s.nextSibling)
                ? null
                : s;
          if (a) return xc(go(a, 1), !1);
        }
        if (r < er(i)) {
          let s = i.childNodes[r];
          for (; s.pmViewDesc && s.pmViewDesc.ignoreForCoords; )
            s = s.nextSibling;
          let a = s
            ? 3 == s.nodeType
              ? xr(s, 0, o ? 0 : 1)
              : 1 == s.nodeType
              ? s
              : null
            : null;
          if (a) return xc(go(a, -1), !0);
        }
        return xc(go(3 == i.nodeType ? xr(i) : i, -t), t >= 0);
      }
      function xc(n, e) {
        if (0 == n.width) return n;
        let t = e ? n.left : n.right;
        return { top: n.top, bottom: n.bottom, left: t, right: t };
      }
      function Ev(n, e) {
        if (0 == n.height) return n;
        let t = e ? n.top : n.bottom;
        return { top: t, bottom: t, left: n.left, right: n.right };
      }
      function hx(n, e, t) {
        let i = n.state,
          r = n.root.activeElement;
        i != e && n.updateState(e), r != n.dom && n.focus();
        try {
          return t();
        } finally {
          i != e && n.updateState(i), r != n.dom && r && r.focus();
        }
      }
      const N8 = /[\u0590-\u08ac]/;
      let fx = null,
        px = null,
        gx = !1;
      class Ac {
        constructor(e, t, i, r) {
          (this.parent = e),
            (this.children = t),
            (this.dom = i),
            (this.contentDOM = r),
            (this.dirty = 0),
            (i.pmViewDesc = this);
        }
        matchesWidget(e) {
          return !1;
        }
        matchesMark(e) {
          return !1;
        }
        matchesNode(e, t, i) {
          return !1;
        }
        matchesHack(e) {
          return !1;
        }
        parseRule() {
          return null;
        }
        stopEvent(e) {
          return !1;
        }
        get size() {
          let e = 0;
          for (let t = 0; t < this.children.length; t++)
            e += this.children[t].size;
          return e;
        }
        get border() {
          return 0;
        }
        destroy() {
          (this.parent = void 0),
            this.dom.pmViewDesc == this && (this.dom.pmViewDesc = void 0);
          for (let e = 0; e < this.children.length; e++)
            this.children[e].destroy();
        }
        posBeforeChild(e) {
          for (let t = 0, i = this.posAtStart; ; t++) {
            let r = this.children[t];
            if (r == e) return i;
            i += r.size;
          }
        }
        get posBefore() {
          return this.parent.posBeforeChild(this);
        }
        get posAtStart() {
          return this.parent
            ? this.parent.posBeforeChild(this) + this.border
            : 0;
        }
        get posAfter() {
          return this.posBefore + this.size;
        }
        get posAtEnd() {
          return this.posAtStart + this.size - 2 * this.border;
        }
        localPosFromDOM(e, t, i) {
          if (
            this.contentDOM &&
            this.contentDOM.contains(1 == e.nodeType ? e : e.parentNode)
          ) {
            if (i < 0) {
              let o, s;
              if (e == this.contentDOM) o = e.childNodes[t - 1];
              else {
                for (; e.parentNode != this.contentDOM; ) e = e.parentNode;
                o = e.previousSibling;
              }
              for (; o && (!(s = o.pmViewDesc) || s.parent != this); )
                o = o.previousSibling;
              return o ? this.posBeforeChild(s) + s.size : this.posAtStart;
            }
            {
              let o, s;
              if (e == this.contentDOM) o = e.childNodes[t];
              else {
                for (; e.parentNode != this.contentDOM; ) e = e.parentNode;
                o = e.nextSibling;
              }
              for (; o && (!(s = o.pmViewDesc) || s.parent != this); )
                o = o.nextSibling;
              return o ? this.posBeforeChild(s) : this.posAtEnd;
            }
          }
          let r;
          if (e == this.dom && this.contentDOM) r = t > Hn(this.contentDOM);
          else if (
            this.contentDOM &&
            this.contentDOM != this.dom &&
            this.dom.contains(this.contentDOM)
          )
            r = 2 & e.compareDocumentPosition(this.contentDOM);
          else if (this.dom.firstChild) {
            if (0 == t)
              for (let o = e; ; o = o.parentNode) {
                if (o == this.dom) {
                  r = !1;
                  break;
                }
                if (o.previousSibling) break;
              }
            if (null == r && t == e.childNodes.length)
              for (let o = e; ; o = o.parentNode) {
                if (o == this.dom) {
                  r = !0;
                  break;
                }
                if (o.nextSibling) break;
              }
          }
          return r ?? i > 0 ? this.posAtEnd : this.posAtStart;
        }
        nearestDesc(e, t = !1) {
          for (let i = !0, r = e; r; r = r.parentNode) {
            let s,
              o = this.getDesc(r);
            if (o && (!t || o.node)) {
              if (
                !i ||
                !(s = o.nodeDOM) ||
                (1 == s.nodeType
                  ? s.contains(1 == e.nodeType ? e : e.parentNode)
                  : s == e)
              )
                return o;
              i = !1;
            }
          }
        }
        getDesc(e) {
          let t = e.pmViewDesc;
          for (let i = t; i; i = i.parent) if (i == this) return t;
        }
        posFromDOM(e, t, i) {
          for (let r = e; r; r = r.parentNode) {
            let o = this.getDesc(r);
            if (o) return o.localPosFromDOM(e, t, i);
          }
          return -1;
        }
        descAt(e) {
          for (let t = 0, i = 0; t < this.children.length; t++) {
            let r = this.children[t],
              o = i + r.size;
            if (i == e && o != i) {
              for (; !r.border && r.children.length; ) r = r.children[0];
              return r;
            }
            if (e < o) return r.descAt(e - i - r.border);
            i = o;
          }
        }
        domFromPos(e, t) {
          if (!this.contentDOM) return { node: this.dom, offset: 0 };
          let o,
            i = 0,
            r = 0;
          for (let o = 0; i < this.children.length; i++) {
            let s = this.children[i],
              a = o + s.size;
            if (a > e || s instanceof _x) {
              r = e - o;
              break;
            }
            o = a;
          }
          if (r)
            return this.children[i].domFromPos(r - this.children[i].border, t);
          for (
            ;
            i &&
            !(o = this.children[i - 1]).size &&
            o instanceof yx &&
            o.side >= 0;
            i--
          );
          if (t <= 0) {
            let o,
              s = !0;
            for (
              ;
              (o = i ? this.children[i - 1] : null),
                o && o.dom.parentNode != this.contentDOM;
              i--, s = !1
            );
            return o && t && s && !o.border && !o.domAtom
              ? o.domFromPos(o.size, t)
              : { node: this.contentDOM, offset: o ? Hn(o.dom) + 1 : 0 };
          }
          {
            let o,
              s = !0;
            for (
              ;
              (o = i < this.children.length ? this.children[i] : null),
                o && o.dom.parentNode != this.contentDOM;
              i++, s = !1
            );
            return o && s && !o.border && !o.domAtom
              ? o.domFromPos(0, t)
              : {
                  node: this.contentDOM,
                  offset: o ? Hn(o.dom) : this.contentDOM.childNodes.length,
                };
          }
        }
        parseRange(e, t, i = 0) {
          if (0 == this.children.length)
            return {
              node: this.contentDOM,
              from: e,
              to: t,
              fromOffset: 0,
              toOffset: this.contentDOM.childNodes.length,
            };
          let r = -1,
            o = -1;
          for (let s = i, a = 0; ; a++) {
            let l = this.children[a],
              c = s + l.size;
            if (-1 == r && e <= c) {
              let u = s + l.border;
              if (
                e >= u &&
                t <= c - l.border &&
                l.node &&
                l.contentDOM &&
                this.contentDOM.contains(l.contentDOM)
              )
                return l.parseRange(e, t, u);
              e = s;
              for (let d = a; d > 0; d--) {
                let h = this.children[d - 1];
                if (
                  h.size &&
                  h.dom.parentNode == this.contentDOM &&
                  !h.emptyChildAt(1)
                ) {
                  r = Hn(h.dom) + 1;
                  break;
                }
                e -= h.size;
              }
              -1 == r && (r = 0);
            }
            if (r > -1 && (c > t || a == this.children.length - 1)) {
              t = c;
              for (let u = a + 1; u < this.children.length; u++) {
                let d = this.children[u];
                if (
                  d.size &&
                  d.dom.parentNode == this.contentDOM &&
                  !d.emptyChildAt(-1)
                ) {
                  o = Hn(d.dom);
                  break;
                }
                t += d.size;
              }
              -1 == o && (o = this.contentDOM.childNodes.length);
              break;
            }
            s = c;
          }
          return {
            node: this.contentDOM,
            from: e,
            to: t,
            fromOffset: r,
            toOffset: o,
          };
        }
        emptyChildAt(e) {
          if (this.border || !this.contentDOM || !this.children.length)
            return !1;
          let t = this.children[e < 0 ? 0 : this.children.length - 1];
          return 0 == t.size || t.emptyChildAt(e);
        }
        domAfterPos(e) {
          let { node: t, offset: i } = this.domFromPos(e, 0);
          if (1 != t.nodeType || i == t.childNodes.length)
            throw new RangeError("No node after pos " + e);
          return t.childNodes[i];
        }
        setSelection(e, t, i, r = !1) {
          let o = Math.min(e, t),
            s = Math.max(e, t);
          for (let h = 0, f = 0; h < this.children.length; h++) {
            let p = this.children[h],
              g = f + p.size;
            if (o > f && s < g)
              return p.setSelection(e - f - p.border, t - f - p.border, i, r);
            f = g;
          }
          let a = this.domFromPos(e, e ? -1 : 1),
            l = t == e ? a : this.domFromPos(t, t ? -1 : 1),
            c = i.getSelection(),
            u = !1;
          if ((Ji || En) && e == t) {
            let { node: h, offset: f } = a;
            if (3 == h.nodeType) {
              if (
                ((u = !(!f || "\n" != h.nodeValue[f - 1])),
                u && f == h.nodeValue.length)
              )
                for (let g, p = h; p; p = p.parentNode) {
                  if ((g = p.nextSibling)) {
                    "BR" == g.nodeName &&
                      (a = l = { node: g.parentNode, offset: Hn(g) + 1 });
                    break;
                  }
                  let m = p.pmViewDesc;
                  if (m && m.node && m.node.isBlock) break;
                }
            } else {
              let p = h.childNodes[f - 1];
              u = p && ("BR" == p.nodeName || "false" == p.contentEditable);
            }
          }
          if (
            Ji &&
            c.focusNode &&
            c.focusNode != l.node &&
            1 == c.focusNode.nodeType
          ) {
            let h = c.focusNode.childNodes[c.focusOffset];
            h && "false" == h.contentEditable && (r = !0);
          }
          if (
            !(r || (u && En)) &&
            Tc(a.node, a.offset, c.anchorNode, c.anchorOffset) &&
            Tc(l.node, l.offset, c.focusNode, c.focusOffset)
          )
            return;
          let d = !1;
          if ((c.extend || e == t) && !u) {
            c.collapse(a.node, a.offset);
            try {
              e != t && c.extend(l.node, l.offset), (d = !0);
            } catch (h) {
              if (!(h instanceof DOMException)) throw h;
            }
          }
          if (!d) {
            if (e > t) {
              let f = a;
              (a = l), (l = f);
            }
            let h = document.createRange();
            h.setEnd(l.node, l.offset),
              h.setStart(a.node, a.offset),
              c.removeAllRanges(),
              c.addRange(h);
          }
        }
        ignoreMutation(e) {
          return !this.contentDOM && "selection" != e.type;
        }
        get contentLost() {
          return (
            this.contentDOM &&
            this.contentDOM != this.dom &&
            !this.dom.contains(this.contentDOM)
          );
        }
        markDirty(e, t) {
          for (let i = 0, r = 0; r < this.children.length; r++) {
            let o = this.children[r],
              s = i + o.size;
            if (i == s ? e <= s && t >= i : e < s && t > i) {
              let a = i + o.border,
                l = s - o.border;
              if (e >= a && t <= l)
                return (
                  (this.dirty = e == i || t == s ? 2 : 1),
                  void (e != a ||
                  t != l ||
                  (!o.contentLost && o.dom.parentNode == this.contentDOM)
                    ? o.markDirty(e - a, t - a)
                    : (o.dirty = 3))
                );
              o.dirty =
                o.dom != o.contentDOM ||
                o.dom.parentNode != this.contentDOM ||
                o.children.length
                  ? 3
                  : 2;
            }
            i = s;
          }
          this.dirty = 2;
        }
        markParentsDirty() {
          let e = 1;
          for (let t = this.parent; t; t = t.parent, e++) {
            let i = 1 == e ? 2 : 1;
            t.dirty < i && (t.dirty = i);
          }
        }
        get domAtom() {
          return !1;
        }
        get ignoreForCoords() {
          return !1;
        }
      }
      class yx extends Ac {
        constructor(e, t, i, r) {
          let o,
            s = t.type.toDOM;
          if (
            ("function" == typeof s &&
              (s = s(i, () =>
                o ? (o.parent ? o.parent.posBeforeChild(o) : void 0) : r
              )),
            !t.type.spec.raw)
          ) {
            if (1 != s.nodeType) {
              let a = document.createElement("span");
              a.appendChild(s), (s = a);
            }
            (s.contentEditable = "false"),
              s.classList.add("ProseMirror-widget");
          }
          super(e, [], s, null),
            (this.widget = t),
            (this.widget = t),
            (o = this);
        }
        matchesWidget(e) {
          return 0 == this.dirty && e.type.eq(this.widget.type);
        }
        parseRule() {
          return { ignore: !0 };
        }
        stopEvent(e) {
          let t = this.widget.spec.stopEvent;
          return !!t && t(e);
        }
        ignoreMutation(e) {
          return "selection" != e.type || this.widget.spec.ignoreSelection;
        }
        destroy() {
          this.widget.type.destroy(this.dom), super.destroy();
        }
        get domAtom() {
          return !0;
        }
        get side() {
          return this.widget.type.side;
        }
      }
      class F8 extends Ac {
        constructor(e, t, i, r) {
          super(e, [], t, null), (this.textDOM = i), (this.text = r);
        }
        get size() {
          return this.text.length;
        }
        localPosFromDOM(e, t) {
          return e != this.textDOM
            ? this.posAtStart + (t ? this.size : 0)
            : this.posAtStart + t;
        }
        domFromPos(e) {
          return { node: this.textDOM, offset: e };
        }
        ignoreMutation(e) {
          return "characterData" === e.type && e.target.nodeValue == e.oldValue;
        }
      }
      class ss extends Ac {
        constructor(e, t, i, r) {
          super(e, [], i, r), (this.mark = t);
        }
        static create(e, t, i, r) {
          let o = r.nodeViews[t.type.name],
            s = o && o(t, r, i);
          return (
            (!s || !s.dom) &&
              (s = Zi.renderSpec(document, t.type.spec.toDOM(t, i))),
            new ss(e, t, s.dom, s.contentDOM || s.dom)
          );
        }
        parseRule() {
          return 3 & this.dirty || this.mark.type.spec.reparseInView
            ? null
            : {
                mark: this.mark.type.name,
                attrs: this.mark.attrs,
                contentElement: this.contentDOM || void 0,
              };
        }
        matchesMark(e) {
          return 3 != this.dirty && this.mark.eq(e);
        }
        markDirty(e, t) {
          if ((super.markDirty(e, t), 0 != this.dirty)) {
            let i = this.parent;
            for (; !i.node; ) i = i.parent;
            i.dirty < this.dirty && (i.dirty = this.dirty), (this.dirty = 0);
          }
        }
        slice(e, t, i) {
          let r = ss.create(this.parent, this.mark, !0, i),
            o = this.children,
            s = this.size;
          t < s && (o = Mv(o, t, s, i)), e > 0 && (o = Mv(o, 0, e, i));
          for (let a = 0; a < o.length; a++) o[a].parent = r;
          return (r.children = o), r;
        }
      }
      class as extends Ac {
        constructor(e, t, i, r, o, s, a, l, c) {
          super(e, [], o, s),
            (this.node = t),
            (this.outerDeco = i),
            (this.innerDeco = r),
            (this.nodeDOM = a),
            s && this.updateChildren(l, c);
        }
        static create(e, t, i, r, o, s) {
          let l,
            a = o.nodeViews[t.type.name],
            c =
              a &&
              a(
                t,
                o,
                () =>
                  l ? (l.parent ? l.parent.posBeforeChild(l) : void 0) : s,
                i,
                r
              ),
            u = c && c.dom,
            d = c && c.contentDOM;
          if (t.isText)
            if (u) {
              if (3 != u.nodeType)
                throw new RangeError(
                  "Text must be rendered as a DOM text node"
                );
            } else u = document.createTextNode(t.text);
          else
            u ||
              ({ dom: u, contentDOM: d } = Zi.renderSpec(
                document,
                t.type.spec.toDOM(t)
              ));
          !d &&
            !t.isText &&
            "BR" != u.nodeName &&
            (u.hasAttribute("contenteditable") || (u.contentEditable = "false"),
            t.type.spec.draggable && (u.draggable = !0));
          let h = u;
          return (
            (u = Cx(u, i, t)),
            c
              ? (l = new L8(e, t, i, r, u, d || null, h, c, o, s + 1))
              : t.isText
              ? new Ph(e, t, i, r, u, h, o)
              : new as(e, t, i, r, u, d || null, h, o, s + 1)
          );
        }
        parseRule() {
          if (this.node.type.spec.reparseInView) return null;
          let e = { node: this.node.type.name, attrs: this.node.attrs };
          if (
            ("pre" == this.node.type.whitespace &&
              (e.preserveWhitespace = "full"),
            this.contentDOM)
          )
            if (this.contentLost) {
              for (let t = this.children.length - 1; t >= 0; t--) {
                let i = this.children[t];
                if (this.dom.contains(i.dom.parentNode)) {
                  e.contentElement = i.dom.parentNode;
                  break;
                }
              }
              e.contentElement || (e.getContent = () => I.empty);
            } else e.contentElement = this.contentDOM;
          else e.getContent = () => this.node.content;
          return e;
        }
        matchesNode(e, t, i) {
          return (
            0 == this.dirty &&
            e.eq(this.node) &&
            Sv(t, this.outerDeco) &&
            i.eq(this.innerDeco)
          );
        }
        get size() {
          return this.node.nodeSize;
        }
        get border() {
          return this.node.isLeaf ? 0 : 1;
        }
        updateChildren(e, t) {
          let i = this.node.inlineContent,
            r = t,
            o = e.composing ? this.localCompositionInfo(e, t) : null,
            s = o && o.pos > -1 ? o : null,
            a = o && o.pos < 0,
            l = new B8(this, s && s.node);
          (function U8(n, e, t, i) {
            let r = e.locals(n),
              o = 0;
            if (0 == r.length) {
              for (let c = 0; c < n.childCount; c++) {
                let u = n.child(c);
                i(u, r, e.forChild(o, u), c), (o += u.nodeSize);
              }
              return;
            }
            let s = 0,
              a = [],
              l = null;
            for (let c = 0; ; ) {
              if (s < r.length && r[s].to == o) {
                let g,
                  p = r[s++];
                for (; s < r.length && r[s].to == o; )
                  (g || (g = [p])).push(r[s++]);
                if (g) {
                  g.sort(H8);
                  for (let m = 0; m < g.length; m++) t(g[m], c, !!l);
                } else t(p, c, !!l);
              }
              let u, d;
              if (l) (d = -1), (u = l), (l = null);
              else {
                if (!(c < n.childCount)) break;
                (d = c), (u = n.child(c++));
              }
              for (let p = 0; p < a.length; p++)
                a[p].to <= o && a.splice(p--, 1);
              for (; s < r.length && r[s].from <= o && r[s].to > o; )
                a.push(r[s++]);
              let h = o + u.nodeSize;
              if (u.isText) {
                let p = h;
                s < r.length && r[s].from < p && (p = r[s].from);
                for (let g = 0; g < a.length; g++) a[g].to < p && (p = a[g].to);
                p < h &&
                  ((l = u.cut(p - o)),
                  (u = u.cut(0, p - o)),
                  (h = p),
                  (d = -1));
              }
              i(
                u,
                u.isInline && !u.isLeaf
                  ? a.filter((p) => !p.inline)
                  : a.slice(),
                e.forChild(o, u),
                d
              ),
                (o = h);
            }
          })(
            this.node,
            this.innerDeco,
            (c, u, d) => {
              c.spec.marks
                ? l.syncToMarks(c.spec.marks, i, e)
                : c.type.side >= 0 &&
                  !d &&
                  l.syncToMarks(
                    u == this.node.childCount
                      ? Ye.none
                      : this.node.child(u).marks,
                    i,
                    e
                  ),
                l.placeWidget(c, e, r);
            },
            (c, u, d, h) => {
              let f;
              l.syncToMarks(c.marks, i, e),
                l.findNodeMatch(c, u, d, h) ||
                  (a &&
                    e.state.selection.from > r &&
                    e.state.selection.to < r + c.nodeSize &&
                    (f = l.findIndexWithChild(o.node)) > -1 &&
                    l.updateNodeAt(c, u, d, f, e)) ||
                  l.updateNextNode(c, u, d, e, h) ||
                  l.addNode(c, u, d, e, r),
                (r += c.nodeSize);
            }
          ),
            l.syncToMarks([], i, e),
            this.node.isTextblock && l.addTextblockHacks(),
            l.destroyRest(),
            (l.changed || 2 == this.dirty) &&
              (s && this.protectLocalComposition(e, s),
              bx(this.contentDOM, this.children, e),
              Oa &&
                (function z8(n) {
                  if ("UL" == n.nodeName || "OL" == n.nodeName) {
                    let e = n.style.cssText;
                    (n.style.cssText = e + "; list-style: square !important"),
                      window.getComputedStyle(n),
                      (n.style.cssText = e);
                  }
                })(this.dom));
        }
        localCompositionInfo(e, t) {
          let { from: i, to: r } = e.state.selection;
          if (
            !(e.state.selection instanceof ue) ||
            i < t ||
            r > t + this.node.content.size
          )
            return null;
          let o = e.domSelection(),
            s = (function $8(n, e) {
              for (;;) {
                if (3 == n.nodeType) return n;
                if (1 == n.nodeType && e > 0) {
                  if (n.childNodes.length > e && 3 == n.childNodes[e].nodeType)
                    return n.childNodes[e];
                  e = er((n = n.childNodes[e - 1]));
                } else {
                  if (!(1 == n.nodeType && e < n.childNodes.length))
                    return null;
                  (n = n.childNodes[e]), (e = 0);
                }
              }
            })(o.focusNode, o.focusOffset);
          if (!s || !this.dom.contains(s.parentNode)) return null;
          if (this.node.inlineContent) {
            let a = s.nodeValue,
              l = (function W8(n, e, t, i) {
                for (let r = 0, o = 0; r < n.childCount && o <= i; ) {
                  let s = n.child(r++),
                    a = o;
                  if (((o += s.nodeSize), !s.isText)) continue;
                  let l = s.text;
                  for (; r < n.childCount; ) {
                    let c = n.child(r++);
                    if (((o += c.nodeSize), !c.isText)) break;
                    l += c.text;
                  }
                  if (o >= t) {
                    let c = a < i ? l.lastIndexOf(e, i - a - 1) : -1;
                    if (c >= 0 && c + e.length + a >= t) return a + c;
                    if (
                      t == i &&
                      l.length >= i + e.length - a &&
                      l.slice(i - a, i - a + e.length) == e
                    )
                      return i;
                  }
                }
                return -1;
              })(this.node.content, a, i - t, r - t);
            return l < 0 ? null : { node: s, pos: l, text: a };
          }
          return { node: s, pos: -1, text: "" };
        }
        protectLocalComposition(e, { node: t, pos: i, text: r }) {
          if (this.getDesc(t)) return;
          let o = t;
          for (; o.parentNode != this.contentDOM; o = o.parentNode) {
            for (; o.previousSibling; )
              o.parentNode.removeChild(o.previousSibling);
            for (; o.nextSibling; ) o.parentNode.removeChild(o.nextSibling);
            o.pmViewDesc && (o.pmViewDesc = void 0);
          }
          let s = new F8(this, o, t, r);
          e.input.compositionNodes.push(s),
            (this.children = Mv(this.children, i, i + r.length, e, s));
        }
        update(e, t, i, r) {
          return !(
            3 == this.dirty ||
            !e.sameMarkup(this.node) ||
            (this.updateInner(e, t, i, r), 0)
          );
        }
        updateInner(e, t, i, r) {
          this.updateOuterDeco(t),
            (this.node = e),
            (this.innerDeco = i),
            this.contentDOM && this.updateChildren(r, this.posAtStart),
            (this.dirty = 0);
        }
        updateOuterDeco(e) {
          if (Sv(e, this.outerDeco)) return;
          let t = 1 != this.nodeDOM.nodeType,
            i = this.dom;
          (this.dom = Dx(
            this.dom,
            this.nodeDOM,
            wv(this.outerDeco, this.node, t),
            wv(e, this.node, t)
          )),
            this.dom != i &&
              ((i.pmViewDesc = void 0), (this.dom.pmViewDesc = this)),
            (this.outerDeco = e);
        }
        selectNode() {
          1 == this.nodeDOM.nodeType &&
            this.nodeDOM.classList.add("ProseMirror-selectednode"),
            (this.contentDOM || !this.node.type.spec.draggable) &&
              (this.dom.draggable = !0);
        }
        deselectNode() {
          1 == this.nodeDOM.nodeType &&
            this.nodeDOM.classList.remove("ProseMirror-selectednode"),
            (this.contentDOM || !this.node.type.spec.draggable) &&
              this.dom.removeAttribute("draggable");
        }
        get domAtom() {
          return this.node.isAtom;
        }
      }
      function vx(n, e, t, i, r) {
        return Cx(i, e, n), new as(void 0, n, e, t, i, i, i, r, 0);
      }
      class Ph extends as {
        constructor(e, t, i, r, o, s, a) {
          super(e, t, i, r, o, null, s, a, 0);
        }
        parseRule() {
          let e = this.nodeDOM.parentNode;
          for (; e && e != this.dom && !e.pmIsDeco; ) e = e.parentNode;
          return { skip: e || !0 };
        }
        update(e, t, i, r) {
          return !(
            3 == this.dirty ||
            (0 != this.dirty && !this.inParent()) ||
            !e.sameMarkup(this.node) ||
            (this.updateOuterDeco(t),
            (0 != this.dirty || e.text != this.node.text) &&
              e.text != this.nodeDOM.nodeValue &&
              ((this.nodeDOM.nodeValue = e.text),
              r.trackWrites == this.nodeDOM && (r.trackWrites = null)),
            (this.node = e),
            (this.dirty = 0),
            0)
          );
        }
        inParent() {
          let e = this.parent.contentDOM;
          for (let t = this.nodeDOM; t; t = t.parentNode) if (t == e) return !0;
          return !1;
        }
        domFromPos(e) {
          return { node: this.nodeDOM, offset: e };
        }
        localPosFromDOM(e, t, i) {
          return e == this.nodeDOM
            ? this.posAtStart + Math.min(t, this.node.text.length)
            : super.localPosFromDOM(e, t, i);
        }
        ignoreMutation(e) {
          return "characterData" != e.type && "selection" != e.type;
        }
        slice(e, t, i) {
          let r = this.node.cut(e, t),
            o = document.createTextNode(r.text);
          return new Ph(
            this.parent,
            r,
            this.outerDeco,
            this.innerDeco,
            o,
            o,
            i
          );
        }
        markDirty(e, t) {
          super.markDirty(e, t),
            this.dom != this.nodeDOM &&
              (0 == e || t == this.nodeDOM.nodeValue.length) &&
              (this.dirty = 3);
        }
        get domAtom() {
          return !1;
        }
      }
      class _x extends Ac {
        parseRule() {
          return { ignore: !0 };
        }
        matchesHack(e) {
          return 0 == this.dirty && this.dom.nodeName == e;
        }
        get domAtom() {
          return !0;
        }
        get ignoreForCoords() {
          return "IMG" == this.dom.nodeName;
        }
      }
      class L8 extends as {
        constructor(e, t, i, r, o, s, a, l, c, u) {
          super(e, t, i, r, o, s, a, c, u), (this.spec = l);
        }
        update(e, t, i, r) {
          if (3 == this.dirty) return !1;
          if (this.spec.update) {
            let o = this.spec.update(e, t, i);
            return o && this.updateInner(e, t, i, r), o;
          }
          return !(!this.contentDOM && !e.isLeaf) && super.update(e, t, i, r);
        }
        selectNode() {
          this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
        }
        deselectNode() {
          this.spec.deselectNode
            ? this.spec.deselectNode()
            : super.deselectNode();
        }
        setSelection(e, t, i, r) {
          this.spec.setSelection
            ? this.spec.setSelection(e, t, i)
            : super.setSelection(e, t, i, r);
        }
        destroy() {
          this.spec.destroy && this.spec.destroy(), super.destroy();
        }
        stopEvent(e) {
          return !!this.spec.stopEvent && this.spec.stopEvent(e);
        }
        ignoreMutation(e) {
          return this.spec.ignoreMutation
            ? this.spec.ignoreMutation(e)
            : super.ignoreMutation(e);
        }
      }
      function bx(n, e, t) {
        let i = n.firstChild,
          r = !1;
        for (let o = 0; o < e.length; o++) {
          let s = e[o],
            a = s.dom;
          if (a.parentNode == n) {
            for (; a != i; ) (i = Ex(i)), (r = !0);
            i = i.nextSibling;
          } else (r = !0), n.insertBefore(a, i);
          if (s instanceof ss) {
            let l = i ? i.previousSibling : n.lastChild;
            bx(s.contentDOM, s.children, t),
              (i = l ? l.nextSibling : n.firstChild);
          }
        }
        for (; i; ) (i = Ex(i)), (r = !0);
        r && t.trackWrites == n && (t.trackWrites = null);
      }
      const Oc = function (n) {
        n && (this.nodeName = n);
      };
      Oc.prototype = Object.create(null);
      const ls = [new Oc()];
      function wv(n, e, t) {
        if (0 == n.length) return ls;
        let i = t ? ls[0] : new Oc(),
          r = [i];
        for (let o = 0; o < n.length; o++) {
          let s = n[o].type.attrs;
          if (s) {
            s.nodeName && r.push((i = new Oc(s.nodeName)));
            for (let a in s) {
              let l = s[a];
              null != l &&
                (t &&
                  1 == r.length &&
                  r.push((i = new Oc(e.isInline ? "span" : "div"))),
                "class" == a
                  ? (i.class = (i.class ? i.class + " " : "") + l)
                  : "style" == a
                  ? (i.style = (i.style ? i.style + ";" : "") + l)
                  : "nodeName" != a && (i[a] = l));
            }
          }
        }
        return r;
      }
      function Dx(n, e, t, i) {
        if (t == ls && i == ls) return e;
        let r = e;
        for (let o = 0; o < i.length; o++) {
          let s = i[o],
            a = t[o];
          if (o) {
            let l;
            (a &&
              a.nodeName == s.nodeName &&
              r != n &&
              (l = r.parentNode) &&
              l.nodeName.toLowerCase() == s.nodeName) ||
              ((l = document.createElement(s.nodeName)),
              (l.pmIsDeco = !0),
              l.appendChild(r),
              (a = ls[0])),
              (r = l);
          }
          V8(r, a || ls[0], s);
        }
        return r;
      }
      function V8(n, e, t) {
        for (let i in e)
          "class" != i &&
            "style" != i &&
            "nodeName" != i &&
            !(i in t) &&
            n.removeAttribute(i);
        for (let i in t)
          "class" != i &&
            "style" != i &&
            "nodeName" != i &&
            t[i] != e[i] &&
            n.setAttribute(i, t[i]);
        if (e.class != t.class) {
          let i = e.class ? e.class.split(" ").filter(Boolean) : [],
            r = t.class ? t.class.split(" ").filter(Boolean) : [];
          for (let o = 0; o < i.length; o++)
            -1 == r.indexOf(i[o]) && n.classList.remove(i[o]);
          for (let o = 0; o < r.length; o++)
            -1 == i.indexOf(r[o]) && n.classList.add(r[o]);
          0 == n.classList.length && n.removeAttribute("class");
        }
        if (e.style != t.style) {
          if (e.style) {
            let r,
              i =
                /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g;
            for (; (r = i.exec(e.style)); ) n.style.removeProperty(r[1]);
          }
          t.style && (n.style.cssText += t.style);
        }
      }
      function Cx(n, e, t) {
        return Dx(n, n, ls, wv(e, t, 1 != n.nodeType));
      }
      function Sv(n, e) {
        if (n.length != e.length) return !1;
        for (let t = 0; t < n.length; t++)
          if (!n[t].type.eq(e[t].type)) return !1;
        return !0;
      }
      function Ex(n) {
        let e = n.nextSibling;
        return n.parentNode.removeChild(n), e;
      }
      class B8 {
        constructor(e, t) {
          (this.lock = t),
            (this.index = 0),
            (this.stack = []),
            (this.changed = !1),
            (this.top = e),
            (this.preMatch = (function j8(n, e) {
              let t = e,
                i = t.children.length,
                r = n.childCount,
                o = new Map(),
                s = [];
              e: for (; r > 0; ) {
                let a;
                for (;;)
                  if (i) {
                    let c = t.children[i - 1];
                    if (!(c instanceof ss)) {
                      (a = c), i--;
                      break;
                    }
                    (t = c), (i = c.children.length);
                  } else {
                    if (t == e) break e;
                    (i = t.parent.children.indexOf(t)), (t = t.parent);
                  }
                let l = a.node;
                if (l) {
                  if (l != n.child(r - 1)) break;
                  --r, o.set(a, r), s.push(a);
                }
              }
              return { index: r, matched: o, matches: s.reverse() };
            })(e.node.content, e));
        }
        destroyBetween(e, t) {
          if (e != t) {
            for (let i = e; i < t; i++) this.top.children[i].destroy();
            this.top.children.splice(e, t - e), (this.changed = !0);
          }
        }
        destroyRest() {
          this.destroyBetween(this.index, this.top.children.length);
        }
        syncToMarks(e, t, i) {
          let r = 0,
            o = this.stack.length >> 1,
            s = Math.min(o, e.length);
          for (
            ;
            r < s &&
            (r == o - 1 ? this.top : this.stack[(r + 1) << 1]).matchesMark(
              e[r]
            ) &&
            !1 !== e[r].type.spec.spanning;

          )
            r++;
          for (; r < o; )
            this.destroyRest(),
              (this.top.dirty = 0),
              (this.index = this.stack.pop()),
              (this.top = this.stack.pop()),
              o--;
          for (; o < e.length; ) {
            this.stack.push(this.top, this.index + 1);
            let a = -1;
            for (
              let l = this.index;
              l < Math.min(this.index + 3, this.top.children.length);
              l++
            )
              if (this.top.children[l].matchesMark(e[o])) {
                a = l;
                break;
              }
            if (a > -1)
              a > this.index &&
                ((this.changed = !0), this.destroyBetween(this.index, a)),
                (this.top = this.top.children[this.index]);
            else {
              let l = ss.create(this.top, e[o], t, i);
              this.top.children.splice(this.index, 0, l),
                (this.top = l),
                (this.changed = !0);
            }
            (this.index = 0), o++;
          }
        }
        findNodeMatch(e, t, i, r) {
          let s,
            o = -1;
          if (
            r >= this.preMatch.index &&
            (s = this.preMatch.matches[r - this.preMatch.index]).parent ==
              this.top &&
            s.matchesNode(e, t, i)
          )
            o = this.top.children.indexOf(s, this.index);
          else
            for (
              let a = this.index, l = Math.min(this.top.children.length, a + 5);
              a < l;
              a++
            ) {
              let c = this.top.children[a];
              if (c.matchesNode(e, t, i) && !this.preMatch.matched.has(c)) {
                o = a;
                break;
              }
            }
          return !(
            o < 0 || (this.destroyBetween(this.index, o), this.index++, 0)
          );
        }
        updateNodeAt(e, t, i, r, o) {
          let s = this.top.children[r];
          return (
            3 == s.dirty && s.dom == s.contentDOM && (s.dirty = 2),
            !!s.update(e, t, i, o) &&
              (this.destroyBetween(this.index, r), (this.index = r + 1), !0)
          );
        }
        findIndexWithChild(e) {
          for (;;) {
            let t = e.parentNode;
            if (!t) return -1;
            if (t == this.top.contentDOM) {
              let i = e.pmViewDesc;
              if (i)
                for (let r = this.index; r < this.top.children.length; r++)
                  if (this.top.children[r] == i) return r;
              return -1;
            }
            e = t;
          }
        }
        updateNextNode(e, t, i, r, o) {
          for (let s = this.index; s < this.top.children.length; s++) {
            let a = this.top.children[s];
            if (a instanceof as) {
              let l = this.preMatch.matched.get(a);
              if (null != l && l != o) return !1;
              let c = a.dom;
              if (
                (!this.lock ||
                  !(
                    c == this.lock ||
                    (1 == c.nodeType && c.contains(this.lock.parentNode))
                  ) ||
                  (e.isText &&
                    a.node &&
                    a.node.isText &&
                    a.nodeDOM.nodeValue == e.text &&
                    3 != a.dirty &&
                    Sv(t, a.outerDeco))) &&
                a.update(e, t, i, r)
              )
                return (
                  this.destroyBetween(this.index, s),
                  a.dom != c && (this.changed = !0),
                  this.index++,
                  !0
                );
              break;
            }
          }
          return !1;
        }
        addNode(e, t, i, r, o) {
          this.top.children.splice(
            this.index++,
            0,
            as.create(this.top, e, t, i, r, o)
          ),
            (this.changed = !0);
        }
        placeWidget(e, t, i) {
          let r =
            this.index < this.top.children.length
              ? this.top.children[this.index]
              : null;
          if (
            !r ||
            !r.matchesWidget(e) ||
            (e != r.widget && r.widget.type.toDOM.parentNode)
          ) {
            let o = new yx(this.top, e, t, i);
            this.top.children.splice(this.index++, 0, o), (this.changed = !0);
          } else this.index++;
        }
        addTextblockHacks() {
          let e = this.top.children[this.index - 1],
            t = this.top;
          for (; e instanceof ss; )
            (t = e), (e = t.children[t.children.length - 1]);
          (!e || !(e instanceof Ph) || /\n$/.test(e.node.text)) &&
            ((En || hn) &&
              e &&
              "false" == e.dom.contentEditable &&
              this.addHackNode("IMG", t),
            this.addHackNode("BR", this.top));
        }
        addHackNode(e, t) {
          if (
            t == this.top &&
            this.index < t.children.length &&
            t.children[this.index].matchesHack(e)
          )
            this.index++;
          else {
            let i = document.createElement(e);
            "IMG" == e &&
              ((i.className = "ProseMirror-separator"), (i.alt = "")),
              "BR" == e && (i.className = "ProseMirror-trailingBreak");
            let r = new _x(this.top, [], i, null);
            t != this.top
              ? t.children.push(r)
              : t.children.splice(this.index++, 0, r),
              (this.changed = !0);
          }
        }
      }
      function H8(n, e) {
        return n.type.side - e.type.side;
      }
      function Mv(n, e, t, i, r) {
        let o = [];
        for (let s = 0, a = 0; s < n.length; s++) {
          let l = n[s],
            c = a,
            u = (a += l.size);
          c >= t || u <= e
            ? o.push(l)
            : (c < e && o.push(l.slice(0, e - c, i)),
              r && (o.push(r), (r = void 0)),
              u > t && o.push(l.slice(t - c, l.size, i)));
        }
        return o;
      }
      function wx(n, e = null) {
        let t = n.domSelection(),
          i = n.state.doc;
        if (!t.focusNode) return null;
        let r = n.docView.nearestDesc(t.focusNode),
          o = r && 0 == r.size,
          s = n.docView.posFromDOM(t.focusNode, t.focusOffset, 1);
        if (s < 0) return null;
        let l,
          c,
          a = i.resolve(s);
        if (Dv(t)) {
          for (l = a; r && !r.node; ) r = r.parent;
          let u = r.node;
          if (
            r &&
            u.isAtom &&
            Y.isSelectable(u) &&
            r.parent &&
            (!u.isInline ||
              !(function _8(n, e, t) {
                for (let i = 0 == e, r = e == er(n); i || r; ) {
                  if (n == t) return !0;
                  let o = Hn(n);
                  if (!(n = n.parentNode)) return !1;
                  (i = i && 0 == o), (r = r && o == er(n));
                }
              })(t.focusNode, t.focusOffset, r.dom))
          ) {
            let d = r.posBefore;
            c = new Y(s == d ? a : i.resolve(d));
          }
        } else {
          let u = n.docView.posFromDOM(t.anchorNode, t.anchorOffset, 1);
          if (u < 0) return null;
          l = i.resolve(u);
        }
        return (
          c ||
            (c = Tv(
              n,
              l,
              a,
              "pointer" == e || (n.state.selection.head < a.pos && !o) ? 1 : -1
            )),
          c
        );
      }
      function Sx(n) {
        return n.editable
          ? n.hasFocus()
          : kx(n) &&
              document.activeElement &&
              document.activeElement.contains(n.dom);
      }
      function mo(n, e = !1) {
        let t = n.state.selection;
        if ((xx(n, t), Sx(n))) {
          if (!e && n.input.mouseDown && n.input.mouseDown.allowDefault && hn) {
            let i = n.domSelection(),
              r = n.domObserver.currentSelection;
            if (
              i.anchorNode &&
              r.anchorNode &&
              Tc(i.anchorNode, i.anchorOffset, r.anchorNode, r.anchorOffset)
            )
              return (
                (n.input.mouseDown.delayedSelectionSync = !0),
                void n.domObserver.setCurSelection()
              );
          }
          if ((n.domObserver.disconnectSelection(), n.cursorWrapper))
            !(function q8(n) {
              let e = n.domSelection(),
                t = document.createRange(),
                i = n.cursorWrapper.dom,
                r = "IMG" == i.nodeName;
              r ? t.setEnd(i.parentNode, Hn(i) + 1) : t.setEnd(i, 0),
                t.collapse(!1),
                e.removeAllRanges(),
                e.addRange(t),
                !r &&
                  !n.state.selection.visible &&
                  jn &&
                  fo <= 11 &&
                  ((i.disabled = !0), (i.disabled = !1));
            })(n);
          else {
            let o,
              s,
              { anchor: i, head: r } = t;
            Mx &&
              !(t instanceof ue) &&
              (t.$from.parent.inlineContent || (o = Ix(n, t.from)),
              !t.empty && !t.$from.parent.inlineContent && (s = Ix(n, t.to))),
              n.docView.setSelection(i, r, n.root, e),
              Mx && (o && Tx(o), s && Tx(s)),
              t.visible
                ? n.dom.classList.remove("ProseMirror-hideselection")
                : (n.dom.classList.add("ProseMirror-hideselection"),
                  "onselectionchange" in document &&
                    (function G8(n) {
                      let e = n.dom.ownerDocument;
                      e.removeEventListener(
                        "selectionchange",
                        n.input.hideSelectionGuard
                      );
                      let t = n.domSelection(),
                        i = t.anchorNode,
                        r = t.anchorOffset;
                      e.addEventListener(
                        "selectionchange",
                        (n.input.hideSelectionGuard = () => {
                          (t.anchorNode != i || t.anchorOffset != r) &&
                            (e.removeEventListener(
                              "selectionchange",
                              n.input.hideSelectionGuard
                            ),
                            setTimeout(() => {
                              (!Sx(n) || n.state.selection.visible) &&
                                n.dom.classList.remove(
                                  "ProseMirror-hideselection"
                                );
                            }, 20));
                        })
                      );
                    })(n));
          }
          n.domObserver.setCurSelection(), n.domObserver.connectSelection();
        }
      }
      const Mx = En || (hn && m8 < 63);
      function Ix(n, e) {
        let { node: t, offset: i } = n.docView.domFromPos(e, 0),
          r = i < t.childNodes.length ? t.childNodes[i] : null,
          o = i ? t.childNodes[i - 1] : null;
        if (En && r && "false" == r.contentEditable) return Iv(r);
        if (
          !(
            (r && "false" != r.contentEditable) ||
            (o && "false" != o.contentEditable)
          )
        ) {
          if (r) return Iv(r);
          if (o) return Iv(o);
        }
      }
      function Iv(n) {
        return (
          (n.contentEditable = "true"),
          En && n.draggable && ((n.draggable = !1), (n.wasDraggable = !0)),
          n
        );
      }
      function Tx(n) {
        (n.contentEditable = "false"),
          n.wasDraggable && ((n.draggable = !0), (n.wasDraggable = null));
      }
      function xx(n, e) {
        if (e instanceof Y) {
          let t = n.docView.descAt(e.from);
          t != n.lastSelectedViewDesc &&
            (Ax(n), t && t.selectNode(), (n.lastSelectedViewDesc = t));
        } else Ax(n);
      }
      function Ax(n) {
        n.lastSelectedViewDesc &&
          (n.lastSelectedViewDesc.parent &&
            n.lastSelectedViewDesc.deselectNode(),
          (n.lastSelectedViewDesc = void 0));
      }
      function Tv(n, e, t, i) {
        return (
          n.someProp("createSelectionBetween", (r) => r(n, e, t)) ||
          ue.between(e, t, i)
        );
      }
      function Ox(n) {
        return (!n.editable || n.root.activeElement == n.dom) && kx(n);
      }
      function kx(n) {
        let e = n.domSelection();
        if (!e.anchorNode) return !1;
        try {
          return (
            n.dom.contains(
              3 == e.anchorNode.nodeType
                ? e.anchorNode.parentNode
                : e.anchorNode
            ) &&
            (n.editable ||
              n.dom.contains(
                3 == e.focusNode.nodeType ? e.focusNode.parentNode : e.focusNode
              ))
          );
        } catch {
          return !1;
        }
      }
      function xv(n, e) {
        let { $anchor: t, $head: i } = n.selection,
          r = e > 0 ? t.max(i) : t.min(i),
          o = r.parent.inlineContent
            ? r.depth
              ? n.doc.resolve(e > 0 ? r.after() : r.before())
              : null
            : r;
        return o && ce.findFrom(o, e);
      }
      function cs(n, e) {
        return n.dispatch(n.state.tr.setSelection(e).scrollIntoView()), !0;
      }
      function Nx(n, e, t) {
        let i = n.state.selection;
        if (!(i instanceof ue)) {
          if (i instanceof Y && i.node.isInline)
            return cs(n, new ue(e > 0 ? i.$to : i.$from));
          {
            let r = xv(n.state, e);
            return !!r && cs(n, r);
          }
        }
        if (!i.empty || t.indexOf("s") > -1) return !1;
        if (n.endOfTextblock(e > 0 ? "right" : "left")) {
          let r = xv(n.state, e);
          return !!(r && r instanceof Y) && cs(n, r);
        }
        if (!(ei && t.indexOf("m") > -1)) {
          let s,
            r = i.$head,
            o = r.textOffset ? null : e < 0 ? r.nodeBefore : r.nodeAfter;
          if (!o || o.isText) return !1;
          let a = e < 0 ? r.pos - o.nodeSize : r.pos;
          return (
            !!(o.isAtom || ((s = n.docView.descAt(a)) && !s.contentDOM)) &&
            (Y.isSelectable(o)
              ? cs(
                  n,
                  new Y(e < 0 ? n.state.doc.resolve(r.pos - o.nodeSize) : r)
                )
              : !!Rh &&
                cs(n, new ue(n.state.doc.resolve(e < 0 ? a : a + o.nodeSize))))
          );
        }
      }
      function Fh(n) {
        return 3 == n.nodeType ? n.nodeValue.length : n.childNodes.length;
      }
      function kc(n) {
        let e = n.pmViewDesc;
        return e && 0 == e.size && (n.nextSibling || "BR" != n.nodeName);
      }
      function Av(n) {
        let e = n.domSelection(),
          t = e.focusNode,
          i = e.focusOffset;
        if (!t) return;
        let r,
          o,
          s = !1;
        for (
          Ji && 1 == t.nodeType && i < Fh(t) && kc(t.childNodes[i]) && (s = !0);
          ;

        )
          if (i > 0) {
            if (1 != t.nodeType) break;
            {
              let a = t.childNodes[i - 1];
              if (kc(a)) (r = t), (o = --i);
              else {
                if (3 != a.nodeType) break;
                (t = a), (i = t.nodeValue.length);
              }
            }
          } else {
            if (Rx(t)) break;
            {
              let a = t.previousSibling;
              for (; a && kc(a); )
                (r = t.parentNode), (o = Hn(a)), (a = a.previousSibling);
              if (a) (t = a), (i = Fh(t));
              else {
                if (((t = t.parentNode), t == n.dom)) break;
                i = 0;
              }
            }
          }
        s ? kv(n, e, t, i) : r && kv(n, e, r, o);
      }
      function Ov(n) {
        let e = n.domSelection(),
          t = e.focusNode,
          i = e.focusOffset;
        if (!t) return;
        let o,
          s,
          r = Fh(t);
        for (;;)
          if (i < r) {
            if (1 != t.nodeType) break;
            if (!kc(t.childNodes[i])) break;
            (o = t), (s = ++i);
          } else {
            if (Rx(t)) break;
            {
              let a = t.nextSibling;
              for (; a && kc(a); )
                (o = a.parentNode), (s = Hn(a) + 1), (a = a.nextSibling);
              if (a) (t = a), (i = 0), (r = Fh(t));
              else {
                if (((t = t.parentNode), t == n.dom)) break;
                i = r = 0;
              }
            }
          }
        o && kv(n, e, o, s);
      }
      function Rx(n) {
        let e = n.pmViewDesc;
        return e && e.node && e.node.isBlock;
      }
      function kv(n, e, t, i) {
        if (Dv(e)) {
          let o = document.createRange();
          o.setEnd(t, i), o.setStart(t, i), e.removeAllRanges(), e.addRange(o);
        } else e.extend && e.extend(t, i);
        n.domObserver.setCurSelection();
        let { state: r } = n;
        setTimeout(() => {
          n.state == r && mo(n);
        }, 50);
      }
      function Px(n, e, t) {
        let i = n.state.selection;
        if (
          (i instanceof ue && !i.empty) ||
          t.indexOf("s") > -1 ||
          (ei && t.indexOf("m") > -1)
        )
          return !1;
        let { $from: r, $to: o } = i;
        if (
          !r.parent.inlineContent ||
          n.endOfTextblock(e < 0 ? "up" : "down")
        ) {
          let s = xv(n.state, e);
          if (s && s instanceof Y) return cs(n, s);
        }
        if (!r.parent.inlineContent) {
          let s = e < 0 ? r : o,
            a = i instanceof Bn ? ce.near(s, e) : ce.findFrom(s, e);
          return !!a && cs(n, a);
        }
        return !1;
      }
      function Fx(n, e) {
        if (!(n.state.selection instanceof ue)) return !0;
        let { $head: t, $anchor: i, empty: r } = n.state.selection;
        if (!t.sameParent(i)) return !0;
        if (!r) return !1;
        if (n.endOfTextblock(e > 0 ? "forward" : "backward")) return !0;
        let o = !t.textOffset && (e < 0 ? t.nodeBefore : t.nodeAfter);
        if (o && !o.isText) {
          let s = n.state.tr;
          return (
            e < 0
              ? s.delete(t.pos - o.nodeSize, t.pos)
              : s.delete(t.pos, t.pos + o.nodeSize),
            n.dispatch(s),
            !0
          );
        }
        return !1;
      }
      function Lx(n, e, t) {
        n.domObserver.stop(), (e.contentEditable = t), n.domObserver.start();
      }
      function Vx(n, e) {
        let t = [],
          { content: i, openStart: r, openEnd: o } = e;
        for (
          ;
          r > 1 && o > 1 && 1 == i.childCount && 1 == i.firstChild.childCount;

        ) {
          r--, o--;
          let f = i.firstChild;
          t.push(f.type.name, f.attrs != f.type.defaultAttrs ? f.attrs : null),
            (i = f.content);
        }
        let s =
            n.someProp("clipboardSerializer") || Zi.fromSchema(n.state.schema),
          a = Gx(),
          l = a.createElement("div");
        l.appendChild(s.serializeFragment(i, { document: a }));
        let u,
          c = l.firstChild,
          d = 0;
        for (; c && 1 == c.nodeType && (u = $x[c.nodeName.toLowerCase()]); ) {
          for (let f = u.length - 1; f >= 0; f--) {
            let p = a.createElement(u[f]);
            for (; l.firstChild; ) p.appendChild(l.firstChild);
            l.appendChild(p), d++;
          }
          c = l.firstChild;
        }
        return (
          c &&
            1 == c.nodeType &&
            c.setAttribute(
              "data-pm-slice",
              `${r} ${o}${d ? ` -${d}` : ""} ${JSON.stringify(t)}`
            ),
          {
            dom: l,
            text:
              n.someProp("clipboardTextSerializer", (f) => f(e)) ||
              e.content.textBetween(0, e.content.size, "\n\n"),
          }
        );
      }
      function Bx(n, e, t, i, r) {
        let s,
          a,
          o = r.parent.type.spec.code;
        if (!t && !e) return null;
        let l = e && (i || o || !t);
        if (l) {
          if (
            (n.someProp("transformPastedText", (h) => {
              e = h(e, o || i);
            }),
            o)
          )
            return e
              ? new P(
                  I.from(n.state.schema.text(e.replace(/\r\n?/g, "\n"))),
                  0,
                  0
                )
              : P.empty;
          let d = n.someProp("clipboardTextParser", (h) => h(e, r, i));
          if (d) a = d;
          else {
            let h = r.marks(),
              { schema: f } = n.state,
              p = Zi.fromSchema(f);
            (s = document.createElement("div")),
              e.split(/(?:\r\n?|\n)+/).forEach((g) => {
                let m = s.appendChild(document.createElement("p"));
                g && m.appendChild(p.serializeNode(f.text(g, h)));
              });
          }
        } else
          n.someProp("transformPastedHTML", (d) => {
            t = d(t);
          }),
            (s = (function eW(n) {
              let e = /^(\s*<meta [^>]*>)*/.exec(n);
              e && (n = n.slice(e[0].length));
              let r,
                t = Gx().createElement("div"),
                i = /<([a-z][^>\s]+)/i.exec(n);
              if (
                ((r = i && $x[i[1].toLowerCase()]) &&
                  (n =
                    r.map((o) => "<" + o + ">").join("") +
                    n +
                    r
                      .map((o) => "</" + o + ">")
                      .reverse()
                      .join("")),
                (t.innerHTML = n),
                r)
              )
                for (let o = 0; o < r.length; o++)
                  t = t.querySelector(r[o]) || t;
              return t;
            })(t)),
            Rh &&
              (function tW(n) {
                let e = n.querySelectorAll(
                  hn
                    ? "span:not([class]):not([style])"
                    : "span.Apple-converted-space"
                );
                for (let t = 0; t < e.length; t++) {
                  let i = e[t];
                  1 == i.childNodes.length &&
                    "\xa0" == i.textContent &&
                    i.parentNode &&
                    i.parentNode.replaceChild(
                      n.ownerDocument.createTextNode(" "),
                      i
                    );
                }
              })(s);
        let c = s && s.querySelector("[data-pm-slice]"),
          u =
            c &&
            /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(
              c.getAttribute("data-pm-slice") || ""
            );
        if (u && u[3])
          for (let d = +u[3]; d > 0 && s.firstChild; d--) s = s.firstChild;
        if (
          (a ||
            (a = (
              n.someProp("clipboardParser") ||
              n.someProp("domParser") ||
              Sa.fromSchema(n.state.schema)
            ).parseSlice(s, {
              preserveWhitespace: !(!l && !u),
              context: r,
              ruleFromNode: (h) =>
                "BR" != h.nodeName ||
                h.nextSibling ||
                !h.parentNode ||
                J8.test(h.parentNode.nodeName)
                  ? null
                  : { ignore: !0 },
            })),
          u)
        )
          a = (function nW(n, e) {
            if (!n.size) return n;
            let i,
              t = n.content.firstChild.type.schema;
            try {
              i = JSON.parse(e);
            } catch {
              return n;
            }
            let { content: r, openStart: o, openEnd: s } = n;
            for (let a = i.length - 2; a >= 0; a -= 2) {
              let l = t.nodes[i[a]];
              if (!l || l.hasRequiredAttrs()) break;
              (r = I.from(l.create(i[a + 1], r))), o++, s++;
            }
            return new P(r, o, s);
          })(zx(a, +u[1], +u[2]), u[4]);
        else if (
          ((a = P.maxOpen(
            (function X8(n, e) {
              if (n.childCount < 2) return n;
              for (let t = e.depth; t >= 0; t--) {
                let o,
                  r = e.node(t).contentMatchAt(e.index(t)),
                  s = [];
                if (
                  (n.forEach((a) => {
                    if (!s) return;
                    let c,
                      l = r.findWrapping(a.type);
                    if (!l) return (s = null);
                    if (
                      (c =
                        s.length && o.length && Hx(l, o, a, s[s.length - 1], 0))
                    )
                      s[s.length - 1] = c;
                    else {
                      s.length &&
                        (s[s.length - 1] = Ux(s[s.length - 1], o.length));
                      let u = jx(a, l);
                      s.push(u), (r = r.matchType(u.type)), (o = l);
                    }
                  }),
                  s)
                )
                  return I.from(s);
              }
              return n;
            })(a.content, r),
            !0
          )),
          a.openStart || a.openEnd)
        ) {
          let d = 0,
            h = 0;
          for (
            let f = a.content.firstChild;
            d < a.openStart && !f.type.spec.isolating;
            d++, f = f.firstChild
          );
          for (
            let f = a.content.lastChild;
            h < a.openEnd && !f.type.spec.isolating;
            h++, f = f.lastChild
          );
          a = zx(a, d, h);
        }
        return (
          n.someProp("transformPasted", (d) => {
            a = d(a);
          }),
          a
        );
      }
      const J8 =
        /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
      function jx(n, e, t = 0) {
        for (let i = e.length - 1; i >= t; i--)
          n = e[i].create(null, I.from(n));
        return n;
      }
      function Hx(n, e, t, i, r) {
        if (r < n.length && r < e.length && n[r] == e[r]) {
          let o = Hx(n, e, t, i.lastChild, r + 1);
          if (o) return i.copy(i.content.replaceChild(i.childCount - 1, o));
          if (
            i
              .contentMatchAt(i.childCount)
              .matchType(r == n.length - 1 ? t.type : n[r + 1])
          )
            return i.copy(i.content.append(I.from(jx(t, n, r + 1))));
        }
      }
      function Ux(n, e) {
        if (0 == e) return n;
        let t = n.content.replaceChild(
            n.childCount - 1,
            Ux(n.lastChild, e - 1)
          ),
          i = n.contentMatchAt(n.childCount).fillBefore(I.empty, !0);
        return n.copy(t.append(i));
      }
      function Nv(n, e, t, i, r, o) {
        let s = e < 0 ? n.firstChild : n.lastChild,
          a = s.content;
        return (
          r < i - 1 && (a = Nv(a, e, t, i, r + 1, o)),
          r >= t &&
            (a =
              e < 0
                ? s
                    .contentMatchAt(0)
                    .fillBefore(a, n.childCount > 1 || o <= r)
                    .append(a)
                : a.append(
                    s.contentMatchAt(s.childCount).fillBefore(I.empty, !0)
                  )),
          n.replaceChild(e < 0 ? 0 : n.childCount - 1, s.copy(a))
        );
      }
      function zx(n, e, t) {
        return (
          e < n.openStart &&
            (n = new P(
              Nv(n.content, -1, e, n.openStart, 0, n.openEnd),
              e,
              n.openEnd
            )),
          t < n.openEnd &&
            (n = new P(Nv(n.content, 1, t, n.openEnd, 0, 0), n.openStart, t)),
          n
        );
      }
      const $x = {
        thead: ["table"],
        tbody: ["table"],
        tfoot: ["table"],
        caption: ["table"],
        colgroup: ["table"],
        col: ["table", "colgroup"],
        tr: ["table", "tbody"],
        td: ["table", "tbody", "tr"],
        th: ["table", "tbody", "tr"],
      };
      let Wx = null;
      function Gx() {
        return Wx || (Wx = document.implementation.createHTMLDocument("title"));
      }
      const wn = {};
      let fn = {};
      class iW {
        constructor() {
          (this.shiftKey = !1),
            (this.mouseDown = null),
            (this.lastKeyCode = null),
            (this.lastKeyCodeTime = 0),
            (this.lastClick = { time: 0, x: 0, y: 0, type: "" }),
            (this.lastSelectionOrigin = null),
            (this.lastSelectionTime = 0),
            (this.lastIOSEnter = 0),
            (this.lastIOSEnterFallbackTimeout = -1),
            (this.lastAndroidDelete = 0),
            (this.composing = !1),
            (this.composingTimeout = -1),
            (this.compositionNodes = []),
            (this.compositionEndedAt = -2e8),
            (this.domChangeCount = 0),
            (this.eventHandlers = Object.create(null)),
            (this.hideSelectionGuard = null);
        }
      }
      function us(n, e) {
        (n.input.lastSelectionOrigin = e),
          (n.input.lastSelectionTime = Date.now());
      }
      function Rv(n) {
        n.someProp("handleDOMEvents", (e) => {
          for (let t in e)
            n.input.eventHandlers[t] ||
              n.dom.addEventListener(
                t,
                (n.input.eventHandlers[t] = (i) => Pv(n, i))
              );
        });
      }
      function Pv(n, e) {
        return n.someProp("handleDOMEvents", (t) => {
          let i = t[e.type];
          return !!i && (i(n, e) || e.defaultPrevented);
        });
      }
      function sW(n, e) {
        if (!e.bubbles) return !0;
        if (e.defaultPrevented) return !1;
        for (let t = e.target; t != n.dom; t = t.parentNode)
          if (
            !t ||
            11 == t.nodeType ||
            (t.pmViewDesc && t.pmViewDesc.stopEvent(e))
          )
            return !1;
        return !0;
      }
      function Lh(n) {
        return { left: n.clientX, top: n.clientY };
      }
      function Fv(n, e, t, i, r) {
        if (-1 == i) return !1;
        let o = n.state.doc.resolve(i);
        for (let s = o.depth + 1; s > 0; s--)
          if (
            n.someProp(e, (a) =>
              s > o.depth
                ? a(n, t, o.nodeAfter, o.before(s), r, !0)
                : a(n, t, o.node(s), o.before(s), r, !1)
            )
          )
            return !0;
        return !1;
      }
      function Pa(n, e, t) {
        n.focused || n.focus();
        let i = n.state.tr.setSelection(e);
        "pointer" == t && i.setMeta("pointer", !0), n.dispatch(i);
      }
      function hW(n, e, t, i) {
        return (
          Fv(n, "handleDoubleClickOn", e, t, i) ||
          n.someProp("handleDoubleClick", (r) => r(n, e, i))
        );
      }
      function fW(n, e, t, i) {
        return (
          Fv(n, "handleTripleClickOn", e, t, i) ||
          n.someProp("handleTripleClick", (r) => r(n, e, i)) ||
          (function pW(n, e, t) {
            if (0 != t.button) return !1;
            let i = n.state.doc;
            if (-1 == e)
              return (
                !!i.inlineContent &&
                (Pa(n, ue.create(i, 0, i.content.size), "pointer"), !0)
              );
            let r = i.resolve(e);
            for (let o = r.depth + 1; o > 0; o--) {
              let s = o > r.depth ? r.nodeAfter : r.node(o),
                a = r.before(o);
              if (s.inlineContent)
                Pa(n, ue.create(i, a + 1, a + 1 + s.content.size), "pointer");
              else {
                if (!Y.isSelectable(s)) continue;
                Pa(n, Y.create(i, a), "pointer");
              }
              return !0;
            }
          })(n, t, i)
        );
      }
      function Lv(n) {
        return Vh(n);
      }
      (fn.keydown = (n, e) => {
        let t = e;
        if (
          ((n.input.shiftKey = 16 == t.keyCode || t.shiftKey),
          !Kx(n, t) &&
            ((n.input.lastKeyCode = t.keyCode),
            (n.input.lastKeyCodeTime = Date.now()),
            !Xi || !hn || 13 != t.keyCode))
        )
          if (
            (229 != t.keyCode && n.domObserver.forceFlush(),
            !Oa || 13 != t.keyCode || t.ctrlKey || t.altKey || t.metaKey)
          )
            n.someProp("handleKeyDown", (i) => i(n, t)) ||
            (function Q8(n, e) {
              let t = e.keyCode,
                i = (function Z8(n) {
                  let e = "";
                  return (
                    n.ctrlKey && (e += "c"),
                    n.metaKey && (e += "m"),
                    n.altKey && (e += "a"),
                    n.shiftKey && (e += "s"),
                    e
                  );
                })(e);
              return 8 == t || (ei && 72 == t && "c" == i)
                ? Fx(n, -1) || Av(n)
                : 46 == t || (ei && 68 == t && "c" == i)
                ? Fx(n, 1) || Ov(n)
                : 13 == t ||
                  27 == t ||
                  (37 == t || (ei && 66 == t && "c" == i)
                    ? Nx(n, -1, i) || Av(n)
                    : 39 == t || (ei && 70 == t && "c" == i)
                    ? Nx(n, 1, i) || Ov(n)
                    : 38 == t || (ei && 80 == t && "c" == i)
                    ? Px(n, -1, i) || Av(n)
                    : 40 == t || (ei && 78 == t && "c" == i)
                    ? (function Y8(n) {
                        if (!En || n.state.selection.$head.parentOffset > 0)
                          return !1;
                        let { focusNode: e, focusOffset: t } = n.domSelection();
                        if (
                          e &&
                          1 == e.nodeType &&
                          0 == t &&
                          e.firstChild &&
                          "false" == e.firstChild.contentEditable
                        ) {
                          let i = e.firstChild;
                          Lx(n, i, "true"),
                            setTimeout(() => Lx(n, i, "false"), 20);
                        }
                        return !1;
                      })(n) ||
                      Px(n, 1, i) ||
                      Ov(n)
                    : i == (ei ? "m" : "c") &&
                      (66 == t || 73 == t || 89 == t || 90 == t));
            })(n, t)
              ? t.preventDefault()
              : us(n, "key");
          else {
            let i = Date.now();
            (n.input.lastIOSEnter = i),
              (n.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
                n.input.lastIOSEnter == i &&
                  (n.someProp("handleKeyDown", (r) => r(n, ka(13, "Enter"))),
                  (n.input.lastIOSEnter = 0));
              }, 200));
          }
      }),
        (fn.keyup = (n, e) => {
          16 == e.keyCode && (n.input.shiftKey = !1);
        }),
        (fn.keypress = (n, e) => {
          let t = e;
          if (
            Kx(n, t) ||
            !t.charCode ||
            (t.ctrlKey && !t.altKey) ||
            (ei && t.metaKey)
          )
            return;
          if (n.someProp("handleKeyPress", (r) => r(n, t)))
            return void t.preventDefault();
          let i = n.state.selection;
          if (!(i instanceof ue && i.$from.sameParent(i.$to))) {
            let r = String.fromCharCode(t.charCode);
            n.someProp("handleTextInput", (o) =>
              o(n, i.$from.pos, i.$to.pos, r)
            ) || n.dispatch(n.state.tr.insertText(r).scrollIntoView()),
              t.preventDefault();
          }
        });
      const qx = ei ? "metaKey" : "ctrlKey";
      wn.mousedown = (n, e) => {
        let t = e;
        n.input.shiftKey = t.shiftKey;
        let i = Lv(n),
          r = Date.now(),
          o = "singleClick";
        r - n.input.lastClick.time < 500 &&
          (function lW(n, e) {
            let t = e.x - n.clientX,
              i = e.y - n.clientY;
            return t * t + i * i < 100;
          })(t, n.input.lastClick) &&
          !t[qx] &&
          ("singleClick" == n.input.lastClick.type
            ? (o = "doubleClick")
            : "doubleClick" == n.input.lastClick.type && (o = "tripleClick")),
          (n.input.lastClick = {
            time: r,
            x: t.clientX,
            y: t.clientY,
            type: o,
          });
        let s = n.posAtCoords(Lh(t));
        !s ||
          ("singleClick" == o
            ? (n.input.mouseDown && n.input.mouseDown.done(),
              (n.input.mouseDown = new gW(n, s, t, !!i)))
            : ("doubleClick" == o ? hW : fW)(n, s.pos, s.inside, t)
            ? t.preventDefault()
            : us(n, "pointer"));
      };
      class gW {
        constructor(e, t, i, r) {
          let o, s;
          if (
            ((this.view = e),
            (this.pos = t),
            (this.event = i),
            (this.flushed = r),
            (this.delayedSelectionSync = !1),
            (this.mightDrag = null),
            (this.startDoc = e.state.doc),
            (this.selectNode = !!i[qx]),
            (this.allowDefault = i.shiftKey),
            t.inside > -1)
          )
            (o = e.state.doc.nodeAt(t.inside)), (s = t.inside);
          else {
            let u = e.state.doc.resolve(t.pos);
            (o = u.parent), (s = u.depth ? u.before() : 0);
          }
          const a = r ? null : i.target,
            l = a ? e.docView.nearestDesc(a, !0) : null;
          this.target = l ? l.dom : null;
          let { selection: c } = e.state;
          ((0 == i.button &&
            o.type.spec.draggable &&
            !1 !== o.type.spec.selectable) ||
            (c instanceof Y && c.from <= s && c.to > s)) &&
            (this.mightDrag = {
              node: o,
              pos: s,
              addAttr: !(!this.target || this.target.draggable),
              setUneditable: !(
                !this.target ||
                !Ji ||
                this.target.hasAttribute("contentEditable")
              ),
            }),
            this.target &&
              this.mightDrag &&
              (this.mightDrag.addAttr || this.mightDrag.setUneditable) &&
              (this.view.domObserver.stop(),
              this.mightDrag.addAttr && (this.target.draggable = !0),
              this.mightDrag.setUneditable &&
                setTimeout(() => {
                  this.view.input.mouseDown == this &&
                    this.target.setAttribute("contentEditable", "false");
                }, 20),
              this.view.domObserver.start()),
            e.root.addEventListener("mouseup", (this.up = this.up.bind(this))),
            e.root.addEventListener(
              "mousemove",
              (this.move = this.move.bind(this))
            ),
            us(e, "pointer");
        }
        done() {
          this.view.root.removeEventListener("mouseup", this.up),
            this.view.root.removeEventListener("mousemove", this.move),
            this.mightDrag &&
              this.target &&
              (this.view.domObserver.stop(),
              this.mightDrag.addAttr &&
                this.target.removeAttribute("draggable"),
              this.mightDrag.setUneditable &&
                this.target.removeAttribute("contentEditable"),
              this.view.domObserver.start()),
            this.delayedSelectionSync && setTimeout(() => mo(this.view)),
            (this.view.input.mouseDown = null);
        }
        up(e) {
          if ((this.done(), !this.view.dom.contains(e.target))) return;
          let t = this.pos;
          this.view.state.doc != this.startDoc &&
            (t = this.view.posAtCoords(Lh(e))),
            this.allowDefault || !t
              ? us(this.view, "pointer")
              : (function dW(n, e, t, i, r) {
                  return (
                    Fv(n, "handleClickOn", e, t, i) ||
                    n.someProp("handleClick", (o) => o(n, e, i)) ||
                    (r
                      ? (function uW(n, e) {
                          if (-1 == e) return !1;
                          let i,
                            r,
                            t = n.state.selection;
                          t instanceof Y && (i = t.node);
                          let o = n.state.doc.resolve(e);
                          for (let s = o.depth + 1; s > 0; s--) {
                            let a = s > o.depth ? o.nodeAfter : o.node(s);
                            if (Y.isSelectable(a)) {
                              r =
                                i &&
                                t.$from.depth > 0 &&
                                s >= t.$from.depth &&
                                o.before(t.$from.depth + 1) == t.$from.pos
                                  ? o.before(t.$from.depth)
                                  : o.before(s);
                              break;
                            }
                          }
                          return (
                            null != r &&
                            (Pa(n, Y.create(n.state.doc, r), "pointer"), !0)
                          );
                        })(n, t)
                      : (function cW(n, e) {
                          if (-1 == e) return !1;
                          let t = n.state.doc.resolve(e),
                            i = t.nodeAfter;
                          return (
                            !!(i && i.isAtom && Y.isSelectable(i)) &&
                            (Pa(n, new Y(t), "pointer"), !0)
                          );
                        })(n, t))
                  );
                })(this.view, t.pos, t.inside, e, this.selectNode)
              ? e.preventDefault()
              : 0 == e.button &&
                (this.flushed ||
                  (En && this.mightDrag && !this.mightDrag.node.isAtom) ||
                  (hn &&
                    !(this.view.state.selection instanceof ue) &&
                    Math.min(
                      Math.abs(t.pos - this.view.state.selection.from),
                      Math.abs(t.pos - this.view.state.selection.to)
                    ) <= 2))
              ? (Pa(
                  this.view,
                  ce.near(this.view.state.doc.resolve(t.pos)),
                  "pointer"
                ),
                e.preventDefault())
              : us(this.view, "pointer");
        }
        move(e) {
          !this.allowDefault &&
            (Math.abs(this.event.x - e.clientX) > 4 ||
              Math.abs(this.event.y - e.clientY) > 4) &&
            (this.allowDefault = !0),
            us(this.view, "pointer"),
            0 == e.buttons && this.done();
        }
      }
      function Kx(n, e) {
        return (
          !!n.composing ||
          (!!(En && Math.abs(e.timeStamp - n.input.compositionEndedAt) < 500) &&
            ((n.input.compositionEndedAt = -2e8), !0))
        );
      }
      (wn.touchdown = (n) => {
        Lv(n), us(n, "pointer");
      }),
        (wn.contextmenu = (n) => Lv(n));
      const mW = Xi ? 5e3 : -1;
      function Yx(n, e) {
        clearTimeout(n.input.composingTimeout),
          e > -1 && (n.input.composingTimeout = setTimeout(() => Vh(n), e));
      }
      function Zx(n) {
        for (
          n.composing &&
          ((n.input.composing = !1),
          (n.input.compositionEndedAt = (function yW() {
            let n = document.createEvent("Event");
            return n.initEvent("event", !0, !0), n.timeStamp;
          })()));
          n.input.compositionNodes.length > 0;

        )
          n.input.compositionNodes.pop().markParentsDirty();
      }
      function Vh(n, e = !1) {
        if (!(Xi && n.domObserver.flushingSoon >= 0)) {
          if (
            (n.domObserver.forceFlush(),
            Zx(n),
            e || (n.docView && n.docView.dirty))
          ) {
            let t = wx(n);
            return (
              t && !t.eq(n.state.selection)
                ? n.dispatch(n.state.tr.setSelection(t))
                : n.updateState(n.state),
              !0
            );
          }
          return !1;
        }
      }
      (fn.compositionstart = fn.compositionupdate =
        (n) => {
          if (!n.composing) {
            n.domObserver.flush();
            let { state: e } = n,
              t = e.selection.$from;
            if (
              e.selection.empty &&
              (e.storedMarks ||
                (!t.textOffset &&
                  t.parentOffset &&
                  t.nodeBefore.marks.some((i) => !1 === i.type.spec.inclusive)))
            )
              (n.markCursor = n.state.storedMarks || t.marks()),
                Vh(n, !0),
                (n.markCursor = null);
            else if (
              (Vh(n),
              Ji &&
                e.selection.empty &&
                t.parentOffset &&
                !t.textOffset &&
                t.nodeBefore.marks.length)
            ) {
              let i = n.domSelection();
              for (
                let r = i.focusNode, o = i.focusOffset;
                r && 1 == r.nodeType && 0 != o;

              ) {
                let s = o < 0 ? r.lastChild : r.childNodes[o - 1];
                if (!s) break;
                if (3 == s.nodeType) {
                  i.collapse(s, s.nodeValue.length);
                  break;
                }
                (r = s), (o = -1);
              }
            }
            n.input.composing = !0;
          }
          Yx(n, mW);
        }),
        (fn.compositionend = (n, e) => {
          n.composing &&
            ((n.input.composing = !1),
            (n.input.compositionEndedAt = e.timeStamp),
            Yx(n, 20));
        });
      const Fa = (jn && fo < 15) || (Oa && y8 < 604);
      function Vv(n, e, t, i) {
        let r = Bx(n, e, t, n.input.shiftKey, n.state.selection.$from);
        if (n.someProp("handlePaste", (a) => a(n, i, r || P.empty))) return !0;
        if (!r) return !1;
        let o = (function _W(n) {
            return 0 == n.openStart &&
              0 == n.openEnd &&
              1 == n.content.childCount
              ? n.content.firstChild
              : null;
          })(r),
          s = o
            ? n.state.tr.replaceSelectionWith(o, n.input.shiftKey)
            : n.state.tr.replaceSelection(r);
        return (
          n.dispatch(
            s.scrollIntoView().setMeta("paste", !0).setMeta("uiEvent", "paste")
          ),
          !0
        );
      }
      (wn.copy = fn.cut =
        (n, e) => {
          let t = e,
            i = n.state.selection,
            r = "cut" == t.type;
          if (i.empty) return;
          let o = Fa ? null : t.clipboardData,
            s = i.content(),
            { dom: a, text: l } = Vx(n, s);
          o
            ? (t.preventDefault(),
              o.clearData(),
              o.setData("text/html", a.innerHTML),
              o.setData("text/plain", l))
            : (function vW(n, e) {
                if (!n.dom.parentNode) return;
                let t = n.dom.parentNode.appendChild(
                  document.createElement("div")
                );
                t.appendChild(e),
                  (t.style.cssText =
                    "position: fixed; left: -10000px; top: 10px");
                let i = getSelection(),
                  r = document.createRange();
                r.selectNodeContents(e),
                  n.dom.blur(),
                  i.removeAllRanges(),
                  i.addRange(r),
                  setTimeout(() => {
                    t.parentNode && t.parentNode.removeChild(t), n.focus();
                  }, 50);
              })(n, a),
            r &&
              n.dispatch(
                n.state.tr
                  .deleteSelection()
                  .scrollIntoView()
                  .setMeta("uiEvent", "cut")
              );
        }),
        (fn.paste = (n, e) => {
          let t = e;
          if (n.composing && !Xi) return;
          let i = Fa ? null : t.clipboardData;
          i && Vv(n, i.getData("text/plain"), i.getData("text/html"), t)
            ? t.preventDefault()
            : (function bW(n, e) {
                if (!n.dom.parentNode) return;
                let t =
                    n.input.shiftKey ||
                    n.state.selection.$from.parent.type.spec.code,
                  i = n.dom.parentNode.appendChild(
                    document.createElement(t ? "textarea" : "div")
                  );
                t || (i.contentEditable = "true"),
                  (i.style.cssText =
                    "position: fixed; left: -10000px; top: 10px"),
                  i.focus(),
                  setTimeout(() => {
                    n.focus(),
                      i.parentNode && i.parentNode.removeChild(i),
                      t
                        ? Vv(n, i.value, null, e)
                        : Vv(n, i.textContent, i.innerHTML, e);
                  }, 50);
              })(n, t);
        });
      class DW {
        constructor(e, t) {
          (this.slice = e), (this.move = t);
        }
      }
      const Qx = ei ? "altKey" : "ctrlKey";
      (wn.dragstart = (n, e) => {
        let t = e,
          i = n.input.mouseDown;
        if ((i && i.done(), !t.dataTransfer)) return;
        let r = n.state.selection,
          o = r.empty ? null : n.posAtCoords(Lh(t));
        if (
          !(o && o.pos >= r.from && o.pos <= (r instanceof Y ? r.to - 1 : r.to))
        )
          if (i && i.mightDrag)
            n.dispatch(
              n.state.tr.setSelection(Y.create(n.state.doc, i.mightDrag.pos))
            );
          else if (t.target && 1 == t.target.nodeType) {
            let c = n.docView.nearestDesc(t.target, !0);
            c &&
              c.node.type.spec.draggable &&
              c != n.docView &&
              n.dispatch(
                n.state.tr.setSelection(Y.create(n.state.doc, c.posBefore))
              );
          }
        let s = n.state.selection.content(),
          { dom: a, text: l } = Vx(n, s);
        t.dataTransfer.clearData(),
          t.dataTransfer.setData(Fa ? "Text" : "text/html", a.innerHTML),
          (t.dataTransfer.effectAllowed = "copyMove"),
          Fa || t.dataTransfer.setData("text/plain", l),
          (n.dragging = new DW(s, !t[Qx]));
      }),
        (wn.dragend = (n) => {
          let e = n.dragging;
          window.setTimeout(() => {
            n.dragging == e && (n.dragging = null);
          }, 50);
        }),
        (fn.dragover = fn.dragenter = (n, e) => e.preventDefault()),
        (fn.drop = (n, e) => {
          let t = e,
            i = n.dragging;
          if (((n.dragging = null), !t.dataTransfer)) return;
          let r = n.posAtCoords(Lh(t));
          if (!r) return;
          let o = n.state.doc.resolve(r.pos);
          if (!o) return;
          let s = i && i.slice;
          s
            ? n.someProp("transformPasted", (p) => {
                s = p(s);
              })
            : (s = Bx(
                n,
                t.dataTransfer.getData(Fa ? "Text" : "text/plain"),
                Fa ? null : t.dataTransfer.getData("text/html"),
                !1,
                o
              ));
          let a = !(!i || t[Qx]);
          if (n.someProp("handleDrop", (p) => p(n, t, s || P.empty, a)))
            return void t.preventDefault();
          if (!s) return;
          t.preventDefault();
          let l = s ? UT(n.state.doc, o.pos, s) : o.pos;
          null == l && (l = o.pos);
          let c = n.state.tr;
          a && c.deleteSelection();
          let u = c.mapping.map(l),
            d = 0 == s.openStart && 0 == s.openEnd && 1 == s.content.childCount,
            h = c.doc;
          if (
            (d
              ? c.replaceRangeWith(u, u, s.content.firstChild)
              : c.replaceRange(u, u, s),
            c.doc.eq(h))
          )
            return;
          let f = c.doc.resolve(u);
          if (
            d &&
            Y.isSelectable(s.content.firstChild) &&
            f.nodeAfter &&
            f.nodeAfter.sameMarkup(s.content.firstChild)
          )
            c.setSelection(new Y(f));
          else {
            let p = c.mapping.map(l);
            c.mapping.maps[c.mapping.maps.length - 1].forEach(
              (g, m, v, _) => (p = _)
            ),
              c.setSelection(Tv(n, f, c.doc.resolve(p)));
          }
          n.focus(), n.dispatch(c.setMeta("uiEvent", "drop"));
        }),
        (wn.focus = (n) => {
          n.focused ||
            (n.domObserver.stop(),
            n.dom.classList.add("ProseMirror-focused"),
            n.domObserver.start(),
            (n.focused = !0),
            setTimeout(() => {
              n.docView &&
                n.hasFocus() &&
                !n.domObserver.currentSelection.eq(n.domSelection()) &&
                mo(n);
            }, 20));
        }),
        (wn.blur = (n, e) => {
          let t = e;
          n.focused &&
            (n.domObserver.stop(),
            n.dom.classList.remove("ProseMirror-focused"),
            n.domObserver.start(),
            t.relatedTarget &&
              n.dom.contains(t.relatedTarget) &&
              n.domObserver.currentSelection.clear(),
            (n.focused = !1));
        }),
        (wn.beforeinput = (n, e) => {
          if (hn && Xi && "deleteContentBackward" == e.inputType) {
            n.domObserver.flushSoon();
            let { domChangeCount: i } = n.input;
            setTimeout(() => {
              if (
                n.input.domChangeCount != i ||
                (n.dom.blur(),
                n.focus(),
                n.someProp("handleKeyDown", (o) => o(n, ka(8, "Backspace"))))
              )
                return;
              let { $cursor: r } = n.state.selection;
              r &&
                r.pos > 0 &&
                n.dispatch(
                  n.state.tr.delete(r.pos - 1, r.pos).scrollIntoView()
                );
            }, 50);
          }
        });
      for (let n in fn) wn[n] = fn[n];
      function Nc(n, e) {
        if (n == e) return !0;
        for (let t in n) if (n[t] !== e[t]) return !1;
        for (let t in e) if (!(t in n)) return !1;
        return !0;
      }
      class Bv {
        constructor(e, t) {
          (this.toDOM = e),
            (this.spec = t || ds),
            (this.side = this.spec.side || 0);
        }
        map(e, t, i, r) {
          let { pos: o, deleted: s } = e.mapResult(
            t.from + r,
            this.side < 0 ? -1 : 1
          );
          return s ? null : new pn(o - i, o - i, this);
        }
        valid() {
          return !0;
        }
        eq(e) {
          return (
            this == e ||
            (e instanceof Bv &&
              ((this.spec.key && this.spec.key == e.spec.key) ||
                (this.toDOM == e.toDOM && Nc(this.spec, e.spec))))
          );
        }
        destroy(e) {
          this.spec.destroy && this.spec.destroy(e);
        }
      }
      class yo {
        constructor(e, t) {
          (this.attrs = e), (this.spec = t || ds);
        }
        map(e, t, i, r) {
          let o = e.map(t.from + r, this.spec.inclusiveStart ? -1 : 1) - i,
            s = e.map(t.to + r, this.spec.inclusiveEnd ? 1 : -1) - i;
          return o >= s ? null : new pn(o, s, this);
        }
        valid(e, t) {
          return t.from < t.to;
        }
        eq(e) {
          return (
            this == e ||
            (e instanceof yo &&
              Nc(this.attrs, e.attrs) &&
              Nc(this.spec, e.spec))
          );
        }
        static is(e) {
          return e.type instanceof yo;
        }
        destroy() {}
      }
      class jv {
        constructor(e, t) {
          (this.attrs = e), (this.spec = t || ds);
        }
        map(e, t, i, r) {
          let o = e.mapResult(t.from + r, 1);
          if (o.deleted) return null;
          let s = e.mapResult(t.to + r, -1);
          return s.deleted || s.pos <= o.pos
            ? null
            : new pn(o.pos - i, s.pos - i, this);
        }
        valid(e, t) {
          let o,
            { index: i, offset: r } = e.content.findIndex(t.from);
          return (
            r == t.from && !(o = e.child(i)).isText && r + o.nodeSize == t.to
          );
        }
        eq(e) {
          return (
            this == e ||
            (e instanceof jv &&
              Nc(this.attrs, e.attrs) &&
              Nc(this.spec, e.spec))
          );
        }
        destroy() {}
      }
      class pn {
        constructor(e, t, i) {
          (this.from = e), (this.to = t), (this.type = i);
        }
        copy(e, t) {
          return new pn(e, t, this.type);
        }
        eq(e, t = 0) {
          return (
            this.type.eq(e.type) &&
            this.from + t == e.from &&
            this.to + t == e.to
          );
        }
        map(e, t, i) {
          return this.type.map(e, this, t, i);
        }
        static widget(e, t, i) {
          return new pn(e, e, new Bv(t, i));
        }
        static inline(e, t, i, r) {
          return new pn(e, t, new yo(i, r));
        }
        static node(e, t, i, r) {
          return new pn(e, t, new jv(i, r));
        }
        get spec() {
          return this.type.spec;
        }
        get inline() {
          return this.type instanceof yo;
        }
      }
      const La = [],
        ds = {};
      class vt {
        constructor(e, t) {
          (this.local = e.length ? e : La), (this.children = t.length ? t : La);
        }
        static create(e, t) {
          return t.length ? Bh(t, e, 0, ds) : Xt;
        }
        find(e, t, i) {
          let r = [];
          return this.findInner(e ?? 0, t ?? 1e9, r, 0, i), r;
        }
        findInner(e, t, i, r, o) {
          for (let s = 0; s < this.local.length; s++) {
            let a = this.local[s];
            a.from <= t &&
              a.to >= e &&
              (!o || o(a.spec)) &&
              i.push(a.copy(a.from + r, a.to + r));
          }
          for (let s = 0; s < this.children.length; s += 3)
            if (this.children[s] < t && this.children[s + 1] > e) {
              let a = this.children[s] + 1;
              this.children[s + 2].findInner(e - a, t - a, i, r + a, o);
            }
        }
        map(e, t, i) {
          return this == Xt || 0 == e.maps.length
            ? this
            : this.mapInner(e, t, 0, 0, i || ds);
        }
        mapInner(e, t, i, r, o) {
          let s;
          for (let a = 0; a < this.local.length; a++) {
            let l = this.local[a].map(e, i, r);
            l && l.type.valid(t, l)
              ? (s || (s = [])).push(l)
              : o.onRemove && o.onRemove(this.local[a].spec);
          }
          return this.children.length
            ? (function CW(n, e, t, i, r, o, s) {
                let a = n.slice(),
                  l = (u, d, h, f) => {
                    for (let p = 0; p < a.length; p += 3) {
                      let m,
                        g = a[p + 1];
                      if (g < 0 || u > g + o) continue;
                      let v = a[p] + o;
                      d >= v
                        ? (a[p + 1] = u <= v ? -2 : -1)
                        : h >= r &&
                          (m = f - h - (d - u)) &&
                          ((a[p] += m), (a[p + 1] += m));
                    }
                  };
                for (let u = 0; u < t.maps.length; u++) t.maps[u].forEach(l);
                let c = !1;
                for (let u = 0; u < a.length; u += 3)
                  if (a[u + 1] < 0) {
                    if (-2 == a[u + 1]) {
                      (c = !0), (a[u + 1] = -1);
                      continue;
                    }
                    let d = t.map(n[u] + o),
                      h = d - r;
                    if (h < 0 || h >= i.content.size) {
                      c = !0;
                      continue;
                    }
                    let p = t.map(n[u + 1] + o, -1) - r,
                      { index: g, offset: m } = i.content.findIndex(h),
                      v = i.maybeChild(g);
                    if (v && m == h && m + v.nodeSize == p) {
                      let _ = a[u + 2].mapInner(t, v, d + 1, n[u] + o + 1, s);
                      _ != Xt
                        ? ((a[u] = h), (a[u + 1] = p), (a[u + 2] = _))
                        : ((a[u + 1] = -2), (c = !0));
                    } else c = !0;
                  }
                if (c) {
                  let u = (function EW(n, e, t, i, r, o, s) {
                      function a(l, c) {
                        for (let u = 0; u < l.local.length; u++) {
                          let d = l.local[u].map(i, r, c);
                          d
                            ? t.push(d)
                            : s.onRemove && s.onRemove(l.local[u].spec);
                        }
                        for (let u = 0; u < l.children.length; u += 3)
                          a(l.children[u + 2], l.children[u] + c + 1);
                      }
                      for (let l = 0; l < n.length; l += 3)
                        -1 == n[l + 1] && a(n[l + 2], e[l] + o + 1);
                      return t;
                    })(a, n, e, t, r, o, s),
                    d = Bh(u, i, 0, s);
                  e = d.local;
                  for (let h = 0; h < a.length; h += 3)
                    a[h + 1] < 0 && (a.splice(h, 3), (h -= 3));
                  for (let h = 0, f = 0; h < d.children.length; h += 3) {
                    let p = d.children[h];
                    for (; f < a.length && a[f] < p; ) f += 3;
                    a.splice(
                      f,
                      0,
                      d.children[h],
                      d.children[h + 1],
                      d.children[h + 2]
                    );
                  }
                }
                return new vt(e.sort(hs), a);
              })(this.children, s || [], e, t, i, r, o)
            : s
            ? new vt(s.sort(hs), La)
            : Xt;
        }
        add(e, t) {
          return t.length
            ? this == Xt
              ? vt.create(e, t)
              : this.addInner(e, t, 0)
            : this;
        }
        addInner(e, t, i) {
          let r,
            o = 0;
          e.forEach((a, l) => {
            let u,
              c = l + i;
            if ((u = Xx(t, a, c))) {
              for (r || (r = this.children.slice()); o < r.length && r[o] < l; )
                o += 3;
              r[o] == l
                ? (r[o + 2] = r[o + 2].addInner(a, u, c + 1))
                : r.splice(o, 0, l, l + a.nodeSize, Bh(u, a, c + 1, ds)),
                (o += 3);
            }
          });
          let s = Jx(o ? eA(t) : t, -i);
          for (let a = 0; a < s.length; a++)
            s[a].type.valid(e, s[a]) || s.splice(a--, 1);
          return new vt(
            s.length ? this.local.concat(s).sort(hs) : this.local,
            r || this.children
          );
        }
        remove(e) {
          return 0 == e.length || this == Xt ? this : this.removeInner(e, 0);
        }
        removeInner(e, t) {
          let i = this.children,
            r = this.local;
          for (let o = 0; o < i.length; o += 3) {
            let s,
              a = i[o] + t,
              l = i[o + 1] + t;
            for (let d, u = 0; u < e.length; u++)
              (d = e[u]) &&
                d.from > a &&
                d.to < l &&
                ((e[u] = null), (s || (s = [])).push(d));
            if (!s) continue;
            i == this.children && (i = this.children.slice());
            let c = i[o + 2].removeInner(s, a + 1);
            c != Xt ? (i[o + 2] = c) : (i.splice(o, 3), (o -= 3));
          }
          if (r.length)
            for (let s, o = 0; o < e.length; o++)
              if ((s = e[o]))
                for (let a = 0; a < r.length; a++)
                  r[a].eq(s, t) &&
                    (r == this.local && (r = this.local.slice()),
                    r.splice(a--, 1));
          return i == this.children && r == this.local
            ? this
            : r.length || i.length
            ? new vt(r, i)
            : Xt;
        }
        forChild(e, t) {
          if (this == Xt) return this;
          if (t.isLeaf) return vt.empty;
          let i, r;
          for (let a = 0; a < this.children.length; a += 3)
            if (this.children[a] >= e) {
              this.children[a] == e && (i = this.children[a + 2]);
              break;
            }
          let o = e + 1,
            s = o + t.content.size;
          for (let a = 0; a < this.local.length; a++) {
            let l = this.local[a];
            if (l.from < s && l.to > o && l.type instanceof yo) {
              let c = Math.max(o, l.from) - o,
                u = Math.min(s, l.to) - o;
              c < u && (r || (r = [])).push(l.copy(c, u));
            }
          }
          if (r) {
            let a = new vt(r.sort(hs), La);
            return i ? new vo([a, i]) : a;
          }
          return i || Xt;
        }
        eq(e) {
          if (this == e) return !0;
          if (
            !(e instanceof vt) ||
            this.local.length != e.local.length ||
            this.children.length != e.children.length
          )
            return !1;
          for (let t = 0; t < this.local.length; t++)
            if (!this.local[t].eq(e.local[t])) return !1;
          for (let t = 0; t < this.children.length; t += 3)
            if (
              this.children[t] != e.children[t] ||
              this.children[t + 1] != e.children[t + 1] ||
              !this.children[t + 2].eq(e.children[t + 2])
            )
              return !1;
          return !0;
        }
        locals(e) {
          return Hv(this.localsInner(e));
        }
        localsInner(e) {
          if (this == Xt) return La;
          if (e.inlineContent || !this.local.some(yo.is)) return this.local;
          let t = [];
          for (let i = 0; i < this.local.length; i++)
            this.local[i].type instanceof yo || t.push(this.local[i]);
          return t;
        }
      }
      (vt.empty = new vt([], [])), (vt.removeOverlap = Hv);
      const Xt = vt.empty;
      class vo {
        constructor(e) {
          this.members = e;
        }
        map(e, t) {
          const i = this.members.map((r) => r.map(e, t, ds));
          return vo.from(i);
        }
        forChild(e, t) {
          if (t.isLeaf) return vt.empty;
          let i = [];
          for (let r = 0; r < this.members.length; r++) {
            let o = this.members[r].forChild(e, t);
            o != Xt &&
              (o instanceof vo ? (i = i.concat(o.members)) : i.push(o));
          }
          return vo.from(i);
        }
        eq(e) {
          if (!(e instanceof vo) || e.members.length != this.members.length)
            return !1;
          for (let t = 0; t < this.members.length; t++)
            if (!this.members[t].eq(e.members[t])) return !1;
          return !0;
        }
        locals(e) {
          let t,
            i = !0;
          for (let r = 0; r < this.members.length; r++) {
            let o = this.members[r].localsInner(e);
            if (o.length)
              if (t) {
                i && ((t = t.slice()), (i = !1));
                for (let s = 0; s < o.length; s++) t.push(o[s]);
              } else t = o;
          }
          return t ? Hv(i ? t : t.sort(hs)) : La;
        }
        static from(e) {
          switch (e.length) {
            case 0:
              return Xt;
            case 1:
              return e[0];
            default:
              return new vo(e);
          }
        }
      }
      function Jx(n, e) {
        if (!e || !n.length) return n;
        let t = [];
        for (let i = 0; i < n.length; i++) {
          let r = n[i];
          t.push(new pn(r.from + e, r.to + e, r.type));
        }
        return t;
      }
      function Xx(n, e, t) {
        if (e.isLeaf) return null;
        let i = t + e.nodeSize,
          r = null;
        for (let s, o = 0; o < n.length; o++)
          (s = n[o]) &&
            s.from > t &&
            s.to < i &&
            ((r || (r = [])).push(s), (n[o] = null));
        return r;
      }
      function eA(n) {
        let e = [];
        for (let t = 0; t < n.length; t++) null != n[t] && e.push(n[t]);
        return e;
      }
      function Bh(n, e, t, i) {
        let r = [],
          o = !1;
        e.forEach((a, l) => {
          let c = Xx(n, a, l + t);
          if (c) {
            o = !0;
            let u = Bh(c, a, t + l + 1, i);
            u != Xt && r.push(l, l + a.nodeSize, u);
          }
        });
        let s = Jx(o ? eA(n) : n, -t).sort(hs);
        for (let a = 0; a < s.length; a++)
          s[a].type.valid(e, s[a]) ||
            (i.onRemove && i.onRemove(s[a].spec), s.splice(a--, 1));
        return s.length || r.length ? new vt(s, r) : Xt;
      }
      function hs(n, e) {
        return n.from - e.from || n.to - e.to;
      }
      function Hv(n) {
        let e = n;
        for (let t = 0; t < e.length - 1; t++) {
          let i = e[t];
          if (i.from != i.to)
            for (let r = t + 1; r < e.length; r++) {
              let o = e[r];
              if (o.from != i.from) {
                o.from < i.to &&
                  (e == n && (e = n.slice()),
                  (e[t] = i.copy(i.from, o.from)),
                  tA(e, r, i.copy(o.from, i.to)));
                break;
              }
              o.to != i.to &&
                (e == n && (e = n.slice()),
                (e[r] = o.copy(o.from, i.to)),
                tA(e, r + 1, o.copy(i.to, o.to)));
            }
        }
        return e;
      }
      function tA(n, e, t) {
        for (; e < n.length && hs(t, n[e]) > 0; ) e++;
        n.splice(e, 0, t);
      }
      function Uv(n) {
        let e = [];
        return (
          n.someProp("decorations", (t) => {
            let i = t(n.state);
            i && i != Xt && e.push(i);
          }),
          n.cursorWrapper &&
            e.push(vt.create(n.state.doc, [n.cursorWrapper.deco])),
          vo.from(e)
        );
      }
      const wW = {
          childList: !0,
          characterData: !0,
          characterDataOldValue: !0,
          attributes: !0,
          attributeOldValue: !0,
          subtree: !0,
        },
        SW = jn && fo <= 11;
      class MW {
        constructor() {
          (this.anchorNode = null),
            (this.anchorOffset = 0),
            (this.focusNode = null),
            (this.focusOffset = 0);
        }
        set(e) {
          (this.anchorNode = e.anchorNode),
            (this.anchorOffset = e.anchorOffset),
            (this.focusNode = e.focusNode),
            (this.focusOffset = e.focusOffset);
        }
        clear() {
          this.anchorNode = this.focusNode = null;
        }
        eq(e) {
          return (
            e.anchorNode == this.anchorNode &&
            e.anchorOffset == this.anchorOffset &&
            e.focusNode == this.focusNode &&
            e.focusOffset == this.focusOffset
          );
        }
      }
      class IW {
        constructor(e, t) {
          (this.view = e),
            (this.handleDOMChange = t),
            (this.queue = []),
            (this.flushingSoon = -1),
            (this.observer = null),
            (this.currentSelection = new MW()),
            (this.onCharData = null),
            (this.suppressingSelectionUpdates = !1),
            (this.observer =
              window.MutationObserver &&
              new window.MutationObserver((i) => {
                for (let r = 0; r < i.length; r++) this.queue.push(i[r]);
                jn &&
                fo <= 11 &&
                i.some(
                  (r) =>
                    ("childList" == r.type && r.removedNodes.length) ||
                    ("characterData" == r.type &&
                      r.oldValue.length > r.target.nodeValue.length)
                )
                  ? this.flushSoon()
                  : this.flush();
              })),
            SW &&
              (this.onCharData = (i) => {
                this.queue.push({
                  target: i.target,
                  type: "characterData",
                  oldValue: i.prevValue,
                }),
                  this.flushSoon();
              }),
            (this.onSelectionChange = this.onSelectionChange.bind(this));
        }
        flushSoon() {
          this.flushingSoon < 0 &&
            (this.flushingSoon = window.setTimeout(() => {
              (this.flushingSoon = -1), this.flush();
            }, 20));
        }
        forceFlush() {
          this.flushingSoon > -1 &&
            (window.clearTimeout(this.flushingSoon),
            (this.flushingSoon = -1),
            this.flush());
        }
        start() {
          this.observer && this.observer.observe(this.view.dom, wW),
            this.onCharData &&
              this.view.dom.addEventListener(
                "DOMCharacterDataModified",
                this.onCharData
              ),
            this.connectSelection();
        }
        stop() {
          if (this.observer) {
            let e = this.observer.takeRecords();
            if (e.length) {
              for (let t = 0; t < e.length; t++) this.queue.push(e[t]);
              window.setTimeout(() => this.flush(), 20);
            }
            this.observer.disconnect();
          }
          this.onCharData &&
            this.view.dom.removeEventListener(
              "DOMCharacterDataModified",
              this.onCharData
            ),
            this.disconnectSelection();
        }
        connectSelection() {
          this.view.dom.ownerDocument.addEventListener(
            "selectionchange",
            this.onSelectionChange
          );
        }
        disconnectSelection() {
          this.view.dom.ownerDocument.removeEventListener(
            "selectionchange",
            this.onSelectionChange
          );
        }
        suppressSelectionUpdates() {
          (this.suppressingSelectionUpdates = !0),
            setTimeout(() => (this.suppressingSelectionUpdates = !1), 50);
        }
        onSelectionChange() {
          if (Ox(this.view)) {
            if (this.suppressingSelectionUpdates) return mo(this.view);
            if (jn && fo <= 11 && !this.view.state.selection.empty) {
              let e = this.view.domSelection();
              if (
                e.focusNode &&
                Tc(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset)
              )
                return this.flushSoon();
            }
            this.flush();
          }
        }
        setCurSelection() {
          this.currentSelection.set(this.view.domSelection());
        }
        ignoreSelectionChange(e) {
          if (0 == e.rangeCount) return !0;
          let t = e.getRangeAt(0).commonAncestorContainer,
            i = this.view.docView.nearestDesc(t);
          return i &&
            i.ignoreMutation({
              type: "selection",
              target: 3 == t.nodeType ? t.parentNode : t,
            })
            ? (this.setCurSelection(), !0)
            : void 0;
        }
        flush() {
          if (!this.view.docView || this.flushingSoon > -1) return;
          let e = this.observer ? this.observer.takeRecords() : [];
          this.queue.length &&
            ((e = this.queue.concat(e)), (this.queue.length = 0));
          let t = this.view.domSelection(),
            i =
              !this.suppressingSelectionUpdates &&
              !this.currentSelection.eq(t) &&
              Ox(this.view) &&
              !this.ignoreSelectionChange(t),
            r = -1,
            o = -1,
            s = !1,
            a = [];
          if (this.view.editable)
            for (let l = 0; l < e.length; l++) {
              let c = this.registerMutation(e[l], a);
              c &&
                ((r = r < 0 ? c.from : Math.min(c.from, r)),
                (o = o < 0 ? c.to : Math.max(c.to, o)),
                c.typeOver && (s = !0));
            }
          if (Ji && a.length > 1) {
            let l = a.filter((c) => "BR" == c.nodeName);
            if (2 == l.length) {
              let c = l[0],
                u = l[1];
              c.parentNode && c.parentNode.parentNode == u.parentNode
                ? u.remove()
                : c.remove();
            }
          }
          (r > -1 || i) &&
            (r > -1 &&
              (this.view.docView.markDirty(r, o),
              (function TW(n) {
                nA ||
                  ((nA = !0),
                  "normal" == getComputedStyle(n.dom).whiteSpace &&
                    console.warn(
                      "ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package."
                    ));
              })(this.view)),
            this.handleDOMChange(r, o, s, a),
            this.view.docView && this.view.docView.dirty
              ? this.view.updateState(this.view.state)
              : this.currentSelection.eq(t) || mo(this.view),
            this.currentSelection.set(t));
        }
        registerMutation(e, t) {
          if (t.indexOf(e.target) > -1) return null;
          let i = this.view.docView.nearestDesc(e.target);
          if (
            ("attributes" == e.type &&
              (i == this.view.docView ||
                "contenteditable" == e.attributeName ||
                ("style" == e.attributeName &&
                  !e.oldValue &&
                  !e.target.getAttribute("style")))) ||
            !i ||
            i.ignoreMutation(e)
          )
            return null;
          if ("childList" == e.type) {
            for (let u = 0; u < e.addedNodes.length; u++)
              t.push(e.addedNodes[u]);
            if (
              i.contentDOM &&
              i.contentDOM != i.dom &&
              !i.contentDOM.contains(e.target)
            )
              return { from: i.posBefore, to: i.posAfter };
            let r = e.previousSibling,
              o = e.nextSibling;
            if (jn && fo <= 11 && e.addedNodes.length)
              for (let u = 0; u < e.addedNodes.length; u++) {
                let { previousSibling: d, nextSibling: h } = e.addedNodes[u];
                (!d || Array.prototype.indexOf.call(e.addedNodes, d) < 0) &&
                  (r = d),
                  (!h || Array.prototype.indexOf.call(e.addedNodes, h) < 0) &&
                    (o = h);
              }
            let s = r && r.parentNode == e.target ? Hn(r) + 1 : 0,
              a = i.localPosFromDOM(e.target, s, -1),
              l =
                o && o.parentNode == e.target
                  ? Hn(o)
                  : e.target.childNodes.length;
            return { from: a, to: i.localPosFromDOM(e.target, l, 1) };
          }
          return "attributes" == e.type
            ? { from: i.posAtStart - i.border, to: i.posAtEnd + i.border }
            : {
                from: i.posAtStart,
                to: i.posAtEnd,
                typeOver: e.target.nodeValue == e.oldValue,
              };
        }
      }
      let nA = !1;
      function AW(n) {
        let e = n.pmViewDesc;
        if (e) return e.parseRule();
        if ("BR" == n.nodeName && n.parentNode) {
          if (En && /^(ul|ol)$/i.test(n.parentNode.nodeName)) {
            let t = document.createElement("div");
            return t.appendChild(document.createElement("li")), { skip: t };
          }
          if (
            n.parentNode.lastChild == n ||
            (En && /^(tr|table)$/i.test(n.parentNode.nodeName))
          )
            return { ignore: !0 };
        } else if ("IMG" == n.nodeName && n.getAttribute("mark-placeholder"))
          return { ignore: !0 };
        return null;
      }
      function iA(n, e, t) {
        return Math.max(t.anchor, t.head) > e.content.size
          ? null
          : Tv(n, e.resolve(t.anchor), e.resolve(t.head));
      }
      function zv(n, e, t) {
        let i = n.depth,
          r = e ? n.end() : n.pos;
        for (; i > 0 && (e || n.indexAfter(i) == n.node(i).childCount); )
          i--, r++, (e = !1);
        if (t) {
          let o = n.node(i).maybeChild(n.indexAfter(i));
          for (; o && !o.isLeaf; ) (o = o.firstChild), r++;
        }
        return r;
      }
      class PW {
        constructor(e, t) {
          (this._root = null),
            (this.focused = !1),
            (this.trackWrites = null),
            (this.mounted = !1),
            (this.markCursor = null),
            (this.cursorWrapper = null),
            (this.lastSelectedViewDesc = void 0),
            (this.input = new iW()),
            (this.prevDirectPlugins = []),
            (this.pluginViews = []),
            (this.dragging = null),
            (this._props = t),
            (this.state = t.state),
            (this.directPlugins = t.plugins || []),
            this.directPlugins.forEach(lA),
            (this.dispatch = this.dispatch.bind(this)),
            (this.dom = (e && e.mount) || document.createElement("div")),
            e &&
              (e.appendChild
                ? e.appendChild(this.dom)
                : "function" == typeof e
                ? e(this.dom)
                : e.mount && (this.mounted = !0)),
            (this.editable = sA(this)),
            oA(this),
            (this.nodeViews = aA(this)),
            (this.docView = vx(
              this.state.doc,
              rA(this),
              Uv(this),
              this.dom,
              this
            )),
            (this.domObserver = new IW(this, (i, r, o, s) =>
              (function OW(n, e, t, i, r) {
                if (e < 0) {
                  let S =
                      n.input.lastSelectionTime > Date.now() - 50
                        ? n.input.lastSelectionOrigin
                        : null,
                    $ = wx(n, S);
                  if ($ && !n.state.selection.eq($)) {
                    let X = n.state.tr.setSelection($);
                    "pointer" == S
                      ? X.setMeta("pointer", !0)
                      : "key" == S && X.scrollIntoView(),
                      n.dispatch(X);
                  }
                  return;
                }
                let o = n.state.doc.resolve(e),
                  s = o.sharedDepth(t);
                (e = o.before(s + 1)),
                  (t = n.state.doc.resolve(t).after(s + 1));
                let a = n.state.selection,
                  l = (function xW(n, e, t) {
                    let c,
                      {
                        node: i,
                        fromOffset: r,
                        toOffset: o,
                        from: s,
                        to: a,
                      } = n.docView.parseRange(e, t),
                      l = n.domSelection(),
                      u = l.anchorNode;
                    if (
                      (u &&
                        n.dom.contains(1 == u.nodeType ? u : u.parentNode) &&
                        ((c = [{ node: u, offset: l.anchorOffset }]),
                        Dv(l) ||
                          c.push({ node: l.focusNode, offset: l.focusOffset })),
                      hn && 8 === n.input.lastKeyCode)
                    )
                      for (let m = o; m > r; m--) {
                        let v = i.childNodes[m - 1],
                          _ = v.pmViewDesc;
                        if ("BR" == v.nodeName && !_) {
                          o = m;
                          break;
                        }
                        if (!_ || _.size) break;
                      }
                    let d = n.state.doc,
                      h =
                        n.someProp("domParser") ||
                        Sa.fromSchema(n.state.schema),
                      f = d.resolve(s),
                      p = null,
                      g = h.parse(i, {
                        topNode: f.parent,
                        topMatch: f.parent.contentMatchAt(f.index()),
                        topOpen: !0,
                        from: r,
                        to: o,
                        preserveWhitespace:
                          "pre" != f.parent.type.whitespace || "full",
                        findPositions: c,
                        ruleFromNode: AW,
                        context: f,
                      });
                    if (c && null != c[0].pos) {
                      let m = c[0].pos,
                        v = c[1] && c[1].pos;
                      null == v && (v = m),
                        (p = { anchor: m + s, head: v + s });
                    }
                    return { doc: g, sel: p, from: s, to: a };
                  })(n, e, t);
                if (
                  hn &&
                  n.cursorWrapper &&
                  l.sel &&
                  l.sel.anchor == n.cursorWrapper.deco.from
                ) {
                  let S = n.cursorWrapper.deco.type.toDOM.nextSibling,
                    $ = S && S.nodeValue ? S.nodeValue.length : 1;
                  l.sel = { anchor: l.sel.anchor + $, head: l.sel.anchor + $ };
                }
                let d,
                  h,
                  c = n.state.doc,
                  u = c.slice(l.from, l.to);
                8 === n.input.lastKeyCode &&
                Date.now() - 100 < n.input.lastKeyCodeTime
                  ? ((d = n.state.selection.to), (h = "end"))
                  : ((d = n.state.selection.from), (h = "start")),
                  (n.input.lastKeyCode = null);
                let f = (function RW(n, e, t, i, r) {
                  let o = n.findDiffStart(e, t);
                  if (null == o) return null;
                  let { a: s, b: a } = n.findDiffEnd(e, t + n.size, t + e.size);
                  return (
                    "end" == r &&
                      (i -= s + Math.max(0, o - Math.min(s, a)) - o),
                    s < o && n.size < e.size
                      ? ((o -= i <= o && i >= s ? o - i : 0),
                        (a = o + (a - s)),
                        (s = o))
                      : a < o &&
                        ((o -= i <= o && i >= a ? o - i : 0),
                        (s = o + (s - a)),
                        (a = o)),
                    { start: o, endA: s, endB: a }
                  );
                })(u.content, l.doc.content, l.from, d, h);
                if (
                  ((Oa && n.input.lastIOSEnter > Date.now() - 225) || Xi) &&
                  r.some((S) => "DIV" == S.nodeName || "P" == S.nodeName) &&
                  (!f || f.endA >= f.endB) &&
                  n.someProp("handleKeyDown", (S) => S(n, ka(13, "Enter")))
                )
                  return void (n.input.lastIOSEnter = 0);
                if (!f) {
                  if (
                    !(
                      i &&
                      a instanceof ue &&
                      !a.empty &&
                      a.$head.sameParent(a.$anchor)
                    ) ||
                    n.composing ||
                    (l.sel && l.sel.anchor != l.sel.head)
                  ) {
                    if (l.sel) {
                      let S = iA(n, n.state.doc, l.sel);
                      S &&
                        !S.eq(n.state.selection) &&
                        n.dispatch(n.state.tr.setSelection(S));
                    }
                    return;
                  }
                  f = { start: a.from, endA: a.to, endB: a.to };
                }
                n.input.domChangeCount++,
                  n.state.selection.from < n.state.selection.to &&
                    f.start == f.endB &&
                    n.state.selection instanceof ue &&
                    (f.start > n.state.selection.from &&
                    f.start <= n.state.selection.from + 2 &&
                    n.state.selection.from >= l.from
                      ? (f.start = n.state.selection.from)
                      : f.endA < n.state.selection.to &&
                        f.endA >= n.state.selection.to - 2 &&
                        n.state.selection.to <= l.to &&
                        ((f.endB += n.state.selection.to - f.endA),
                        (f.endA = n.state.selection.to))),
                  jn &&
                    fo <= 11 &&
                    f.endB == f.start + 1 &&
                    f.endA == f.start &&
                    f.start > l.from &&
                    " \xa0" ==
                      l.doc.textBetween(
                        f.start - l.from - 1,
                        f.start - l.from + 1
                      ) &&
                    (f.start--, f.endA--, f.endB--);
                let _,
                  p = l.doc.resolveNoCache(f.start - l.from),
                  g = l.doc.resolveNoCache(f.endB - l.from),
                  m = c.resolve(f.start),
                  v =
                    p.sameParent(g) &&
                    p.parent.inlineContent &&
                    m.end() >= f.endA;
                if (
                  ((Oa &&
                    n.input.lastIOSEnter > Date.now() - 225 &&
                    (!v ||
                      r.some(
                        (S) => "DIV" == S.nodeName || "P" == S.nodeName
                      ))) ||
                    (!v &&
                      p.pos < l.doc.content.size &&
                      (_ = ce.findFrom(l.doc.resolve(p.pos + 1), 1, !0)) &&
                      _.head == g.pos)) &&
                  n.someProp("handleKeyDown", (S) => S(n, ka(13, "Enter")))
                )
                  return void (n.input.lastIOSEnter = 0);
                if (
                  n.state.selection.anchor > f.start &&
                  (function NW(n, e, t, i, r) {
                    if (
                      !i.parent.isTextblock ||
                      t - e <= r.pos - i.pos ||
                      zv(i, !0, !1) < r.pos
                    )
                      return !1;
                    let o = n.resolve(e);
                    if (
                      o.parentOffset < o.parent.content.size ||
                      !o.parent.isTextblock
                    )
                      return !1;
                    let s = n.resolve(zv(o, !0, !0));
                    return (
                      !(
                        !s.parent.isTextblock ||
                        s.pos > t ||
                        zv(s, !0, !1) < t
                      ) &&
                      i.parent.content.cut(i.parentOffset).eq(s.parent.content)
                    );
                  })(c, f.start, f.endA, p, g) &&
                  n.someProp("handleKeyDown", (S) => S(n, ka(8, "Backspace")))
                )
                  return void (
                    Xi &&
                    hn &&
                    n.domObserver.suppressSelectionUpdates()
                  );
                hn &&
                  Xi &&
                  f.endB == f.start &&
                  (n.input.lastAndroidDelete = Date.now()),
                  Xi &&
                    !v &&
                    p.start() != g.start() &&
                    0 == g.parentOffset &&
                    p.depth == g.depth &&
                    l.sel &&
                    l.sel.anchor == l.sel.head &&
                    l.sel.head == f.endA &&
                    ((f.endB -= 2),
                    (g = l.doc.resolveNoCache(f.endB - l.from)),
                    setTimeout(() => {
                      n.someProp("handleKeyDown", function (S) {
                        return S(n, ka(13, "Enter"));
                      });
                    }, 20));
                let D,
                  C,
                  R,
                  b = f.start,
                  y = f.endA;
                if (v)
                  if (p.pos == g.pos)
                    jn &&
                      fo <= 11 &&
                      0 == p.parentOffset &&
                      (n.domObserver.suppressSelectionUpdates(),
                      setTimeout(() => mo(n), 20)),
                      (D = n.state.tr.delete(b, y)),
                      (C = c.resolve(f.start).marksAcross(c.resolve(f.endA)));
                  else if (
                    f.endA == f.endB &&
                    (R = (function kW(n, e) {
                      let s,
                        a,
                        l,
                        t = n.firstChild.marks,
                        i = e.firstChild.marks,
                        r = t,
                        o = i;
                      for (let u = 0; u < i.length; u++)
                        r = i[u].removeFromSet(r);
                      for (let u = 0; u < t.length; u++)
                        o = t[u].removeFromSet(o);
                      if (1 == r.length && 0 == o.length)
                        (a = r[0]),
                          (s = "add"),
                          (l = (u) => u.mark(a.addToSet(u.marks)));
                      else {
                        if (0 != r.length || 1 != o.length) return null;
                        (a = o[0]),
                          (s = "remove"),
                          (l = (u) => u.mark(a.removeFromSet(u.marks)));
                      }
                      let c = [];
                      for (let u = 0; u < e.childCount; u++)
                        c.push(l(e.child(u)));
                      if (I.from(c).eq(n)) return { mark: a, type: s };
                    })(
                      p.parent.content.cut(p.parentOffset, g.parentOffset),
                      m.parent.content.cut(m.parentOffset, f.endA - m.start())
                    ))
                  )
                    (D = n.state.tr),
                      "add" == R.type
                        ? D.addMark(b, y, R.mark)
                        : D.removeMark(b, y, R.mark);
                  else if (
                    p.parent.child(p.index()).isText &&
                    p.index() == g.index() - (g.textOffset ? 0 : 1)
                  ) {
                    let S = p.parent.textBetween(
                      p.parentOffset,
                      g.parentOffset
                    );
                    if (n.someProp("handleTextInput", ($) => $(n, b, y, S)))
                      return;
                    D = n.state.tr.insertText(S, b, y);
                  }
                if (
                  (D ||
                    (D = n.state.tr.replace(
                      b,
                      y,
                      l.doc.slice(f.start - l.from, f.endB - l.from)
                    )),
                  l.sel)
                ) {
                  let S = iA(n, D.doc, l.sel);
                  S &&
                    !(
                      (hn &&
                        Xi &&
                        n.composing &&
                        S.empty &&
                        (f.start != f.endB ||
                          n.input.lastAndroidDelete < Date.now() - 100) &&
                        (S.head == b || S.head == D.mapping.map(y) - 1)) ||
                      (jn && S.empty && S.head == b)
                    ) &&
                    D.setSelection(S);
                }
                C && D.ensureMarks(C), n.dispatch(D.scrollIntoView());
              })(this, i, r, o, s)
            )),
            this.domObserver.start(),
            (function rW(n) {
              for (let e in wn) {
                let t = wn[e];
                n.dom.addEventListener(
                  e,
                  (n.input.eventHandlers[e] = (i) => {
                    sW(n, i) &&
                      !Pv(n, i) &&
                      (n.editable || !(i.type in fn)) &&
                      t(n, i);
                  })
                );
              }
              En && n.dom.addEventListener("input", () => null), Rv(n);
            })(this),
            this.updatePluginViews();
        }
        get composing() {
          return this.input.composing;
        }
        get props() {
          if (this._props.state != this.state) {
            let e = this._props;
            this._props = {};
            for (let t in e) this._props[t] = e[t];
            this._props.state = this.state;
          }
          return this._props;
        }
        update(e) {
          e.handleDOMEvents != this._props.handleDOMEvents && Rv(this),
            (this._props = e),
            e.plugins &&
              (e.plugins.forEach(lA), (this.directPlugins = e.plugins)),
            this.updateStateInner(e.state, !0);
        }
        setProps(e) {
          let t = {};
          for (let i in this._props) t[i] = this._props[i];
          t.state = this.state;
          for (let i in e) t[i] = e[i];
          this.update(t);
        }
        updateState(e) {
          this.updateStateInner(e, this.state.plugins != e.plugins);
        }
        updateStateInner(e, t) {
          let i = this.state,
            r = !1,
            o = !1;
          if (
            (e.storedMarks && this.composing && (Zx(this), (o = !0)),
            (this.state = e),
            t)
          ) {
            let d = aA(this);
            (function LW(n, e) {
              let t = 0,
                i = 0;
              for (let r in n) {
                if (n[r] != e[r]) return !0;
                t++;
              }
              for (let r in e) i++;
              return t != i;
            })(d, this.nodeViews) && ((this.nodeViews = d), (r = !0)),
              Rv(this);
          }
          (this.editable = sA(this)), oA(this);
          let s = Uv(this),
            a = rA(this),
            l = t
              ? "reset"
              : e.scrollToSelection > i.scrollToSelection
              ? "to selection"
              : "preserve",
            c = r || !this.docView.matchesNode(e.doc, a, s);
          (c || !e.selection.eq(i.selection)) && (o = !0);
          let u =
            "preserve" == l &&
            o &&
            null == this.dom.style.overflowAnchor &&
            (function E8(n) {
              let i,
                r,
                e = n.dom.getBoundingClientRect(),
                t = Math.max(0, e.top);
              for (
                let o = (e.left + e.right) / 2, s = t + 1;
                s < Math.min(innerHeight, e.bottom);
                s += 5
              ) {
                let a = n.root.elementFromPoint(o, s);
                if (!a || a == n.dom || !n.dom.contains(a)) continue;
                let l = a.getBoundingClientRect();
                if (l.top >= t - 20) {
                  (i = a), (r = l.top);
                  break;
                }
              }
              return { refDOM: i, refTop: r, stack: ax(n.dom) };
            })(this);
          if (o) {
            this.domObserver.stop();
            let d =
              c &&
              (jn || hn) &&
              !this.composing &&
              !i.selection.empty &&
              !e.selection.empty &&
              (function FW(n, e) {
                let t = Math.min(
                  n.$anchor.sharedDepth(n.head),
                  e.$anchor.sharedDepth(e.head)
                );
                return n.$anchor.start(t) != e.$anchor.start(t);
              })(i.selection, e.selection);
            if (c) {
              let h = hn
                ? (this.trackWrites = this.domSelection().focusNode)
                : null;
              (r || !this.docView.update(e.doc, a, s, this)) &&
                (this.docView.updateOuterDeco([]),
                this.docView.destroy(),
                (this.docView = vx(e.doc, a, s, this.dom, this))),
                h && !this.trackWrites && (d = !0);
            }
            d ||
            !(
              this.input.mouseDown &&
              this.domObserver.currentSelection.eq(this.domSelection()) &&
              (function K8(n) {
                let e = n.docView.domFromPos(n.state.selection.anchor, 0),
                  t = n.domSelection();
                return Tc(e.node, e.offset, t.anchorNode, t.anchorOffset);
              })(this)
            )
              ? mo(this, d)
              : (xx(this, e.selection), this.domObserver.setCurSelection()),
              this.domObserver.start();
          }
          if ((this.updatePluginViews(i), "reset" == l)) this.dom.scrollTop = 0;
          else if ("to selection" == l) {
            let d = this.domSelection().focusNode;
            if (!this.someProp("handleScrollToSelection", (h) => h(this)))
              if (e.selection instanceof Y) {
                let h = this.docView.domAfterPos(e.selection.from);
                1 == h.nodeType && sx(this, h.getBoundingClientRect(), d);
              } else sx(this, this.coordsAtPos(e.selection.head, 1), d);
          } else
            u &&
              (function w8({ refDOM: n, refTop: e, stack: t }) {
                let i = n ? n.getBoundingClientRect().top : 0;
                lx(t, 0 == i ? 0 : i - e);
              })(u);
        }
        destroyPluginViews() {
          let e;
          for (; (e = this.pluginViews.pop()); ) e.destroy && e.destroy();
        }
        updatePluginViews(e) {
          if (
            e &&
            e.plugins == this.state.plugins &&
            this.directPlugins == this.prevDirectPlugins
          )
            for (let t = 0; t < this.pluginViews.length; t++) {
              let i = this.pluginViews[t];
              i.update && i.update(this, e);
            }
          else {
            (this.prevDirectPlugins = this.directPlugins),
              this.destroyPluginViews();
            for (let t = 0; t < this.directPlugins.length; t++) {
              let i = this.directPlugins[t];
              i.spec.view && this.pluginViews.push(i.spec.view(this));
            }
            for (let t = 0; t < this.state.plugins.length; t++) {
              let i = this.state.plugins[t];
              i.spec.view && this.pluginViews.push(i.spec.view(this));
            }
          }
        }
        someProp(e, t) {
          let r,
            i = this._props && this._props[e];
          if (null != i && (r = t ? t(i) : i)) return r;
          for (let s = 0; s < this.directPlugins.length; s++) {
            let a = this.directPlugins[s].props[e];
            if (null != a && (r = t ? t(a) : a)) return r;
          }
          let o = this.state.plugins;
          if (o)
            for (let s = 0; s < o.length; s++) {
              let a = o[s].props[e];
              if (null != a && (r = t ? t(a) : a)) return r;
            }
        }
        hasFocus() {
          return this.root.activeElement == this.dom;
        }
        focus() {
          this.domObserver.stop(),
            this.editable &&
              (function S8(n) {
                if (n.setActive) return n.setActive();
                if (Na) return n.focus(Na);
                let e = ax(n);
                n.focus(
                  null == Na
                    ? {
                        get preventScroll() {
                          return (Na = { preventScroll: !0 }), !0;
                        },
                      }
                    : void 0
                ),
                  Na || ((Na = !1), lx(e, 0));
              })(this.dom),
            mo(this),
            this.domObserver.start();
        }
        get root() {
          let e = this._root;
          if (null == e)
            for (let t = this.dom.parentNode; t; t = t.parentNode)
              if (9 == t.nodeType || (11 == t.nodeType && t.host))
                return (
                  t.getSelection ||
                    (Object.getPrototypeOf(t).getSelection = () =>
                      t.ownerDocument.getSelection()),
                  (this._root = t)
                );
          return e || document;
        }
        posAtCoords(e) {
          return A8(this, e);
        }
        coordsAtPos(e, t = 1) {
          return dx(this, e, t);
        }
        domAtPos(e, t = 0) {
          return this.docView.domFromPos(e, t);
        }
        nodeDOM(e) {
          let t = this.docView.descAt(e);
          return t ? t.nodeDOM : null;
        }
        posAtDOM(e, t, i = -1) {
          let r = this.docView.posFromDOM(e, t, i);
          if (null == r)
            throw new RangeError("DOM position not inside the editor");
          return r;
        }
        endOfTextblock(e, t) {
          return (function P8(n, e, t) {
            return fx == e && px == t
              ? gx
              : ((fx = e),
                (px = t),
                (gx =
                  "up" == t || "down" == t
                    ? (function k8(n, e, t) {
                        let i = e.selection,
                          r = "up" == t ? i.$from : i.$to;
                        return hx(n, e, () => {
                          let { node: o } = n.docView.domFromPos(
                            r.pos,
                            "up" == t ? -1 : 1
                          );
                          for (;;) {
                            let a = n.docView.nearestDesc(o, !0);
                            if (!a) break;
                            if (a.node.isBlock) {
                              o = a.dom;
                              break;
                            }
                            o = a.dom.parentNode;
                          }
                          let s = dx(n, r.pos, 1);
                          for (let a = o.firstChild; a; a = a.nextSibling) {
                            let l;
                            if (1 == a.nodeType) l = a.getClientRects();
                            else {
                              if (3 != a.nodeType) continue;
                              l = xr(a, 0, a.nodeValue.length).getClientRects();
                            }
                            for (let c = 0; c < l.length; c++) {
                              let u = l[c];
                              if (
                                u.bottom > u.top + 1 &&
                                ("up" == t
                                  ? s.top - u.top > 2 * (u.bottom - s.top)
                                  : u.bottom - s.bottom >
                                    2 * (s.bottom - u.top))
                              )
                                return !1;
                            }
                          }
                          return !0;
                        });
                      })(n, e, t)
                    : (function R8(n, e, t) {
                        let { $head: i } = e.selection;
                        if (!i.parent.isTextblock) return !1;
                        let r = i.parentOffset,
                          o = !r,
                          s = r == i.parent.content.size,
                          a = n.domSelection();
                        return N8.test(i.parent.textContent) && a.modify
                          ? hx(n, e, () => {
                              let l = a.getRangeAt(0),
                                c = a.focusNode,
                                u = a.focusOffset,
                                d = a.caretBidiLevel;
                              a.modify("move", t, "character");
                              let f =
                                !(
                                  i.depth
                                    ? n.docView.domAfterPos(i.before())
                                    : n.dom
                                ).contains(
                                  1 == a.focusNode.nodeType
                                    ? a.focusNode
                                    : a.focusNode.parentNode
                                ) ||
                                (c == a.focusNode && u == a.focusOffset);
                              return (
                                a.removeAllRanges(),
                                a.addRange(l),
                                null != d && (a.caretBidiLevel = d),
                                f
                              );
                            })
                          : "left" == t || "backward" == t
                          ? o
                          : s;
                      })(n, e, t)));
          })(this, t || this.state, e);
        }
        destroy() {
          !this.docView ||
            ((function oW(n) {
              n.domObserver.stop();
              for (let e in n.input.eventHandlers)
                n.dom.removeEventListener(e, n.input.eventHandlers[e]);
              clearTimeout(n.input.composingTimeout),
                clearTimeout(n.input.lastIOSEnterFallbackTimeout);
            })(this),
            this.destroyPluginViews(),
            this.mounted
              ? (this.docView.update(this.state.doc, [], Uv(this), this),
                (this.dom.textContent = ""))
              : this.dom.parentNode &&
                this.dom.parentNode.removeChild(this.dom),
            this.docView.destroy(),
            (this.docView = null));
        }
        get isDestroyed() {
          return null == this.docView;
        }
        dispatchEvent(e) {
          return (function aW(n, e) {
            !Pv(n, e) &&
              wn[e.type] &&
              (n.editable || !(e.type in fn)) &&
              wn[e.type](n, e);
          })(this, e);
        }
        dispatch(e) {
          let t = this._props.dispatchTransaction;
          t ? t.call(this, e) : this.updateState(this.state.apply(e));
        }
        domSelection() {
          return this.root.getSelection();
        }
      }
      function rA(n) {
        let e = Object.create(null);
        return (
          (e.class = "ProseMirror"),
          (e.contenteditable = String(n.editable)),
          (e.translate = "no"),
          n.someProp("attributes", (t) => {
            if (("function" == typeof t && (t = t(n.state)), t))
              for (let i in t)
                "class" == i && (e.class += " " + t[i]),
                  "style" == i
                    ? (e.style = (e.style ? e.style + ";" : "") + t[i])
                    : !e[i] &&
                      "contenteditable" != i &&
                      "nodeName" != i &&
                      (e[i] = String(t[i]));
          }),
          [pn.node(0, n.state.doc.content.size, e)]
        );
      }
      function oA(n) {
        if (n.markCursor) {
          let e = document.createElement("img");
          (e.className = "ProseMirror-separator"),
            e.setAttribute("mark-placeholder", "true"),
            e.setAttribute("alt", ""),
            (n.cursorWrapper = {
              dom: e,
              deco: pn.widget(n.state.selection.head, e, {
                raw: !0,
                marks: n.markCursor,
              }),
            });
        } else n.cursorWrapper = null;
      }
      function sA(n) {
        return !n.someProp("editable", (e) => !1 === e(n.state));
      }
      function aA(n) {
        let e = Object.create(null);
        function t(i) {
          for (let r in i)
            Object.prototype.hasOwnProperty.call(e, r) || (e[r] = i[r]);
        }
        return n.someProp("nodeViews", t), n.someProp("markViews", t), e;
      }
      function lA(n) {
        if (
          n.spec.state ||
          n.spec.filterTransaction ||
          n.spec.appendTransaction
        )
          throw new RangeError(
            "Plugins passed directly to the view must not have a state component"
          );
      }
      for (
        var _o = {
            8: "Backspace",
            9: "Tab",
            10: "Enter",
            12: "NumLock",
            13: "Enter",
            16: "Shift",
            17: "Control",
            18: "Alt",
            20: "CapsLock",
            27: "Escape",
            32: " ",
            33: "PageUp",
            34: "PageDown",
            35: "End",
            36: "Home",
            37: "ArrowLeft",
            38: "ArrowUp",
            39: "ArrowRight",
            40: "ArrowDown",
            44: "PrintScreen",
            45: "Insert",
            46: "Delete",
            59: ";",
            61: "=",
            91: "Meta",
            92: "Meta",
            106: "*",
            107: "+",
            108: ",",
            109: "-",
            110: ".",
            111: "/",
            144: "NumLock",
            145: "ScrollLock",
            160: "Shift",
            161: "Shift",
            162: "Control",
            163: "Control",
            164: "Alt",
            165: "Alt",
            173: "-",
            186: ";",
            187: "=",
            188: ",",
            189: "-",
            190: ".",
            191: "/",
            192: "`",
            219: "[",
            220: "\\",
            221: "]",
            222: "'",
            229: "q",
          },
          jh = {
            48: ")",
            49: "!",
            50: "@",
            51: "#",
            52: "$",
            53: "%",
            54: "^",
            55: "&",
            56: "*",
            57: "(",
            59: ":",
            61: "+",
            173: "_",
            186: ":",
            187: "+",
            188: "<",
            189: "_",
            190: ">",
            191: "?",
            192: "~",
            219: "{",
            220: "|",
            221: "}",
            222: '"',
            229: "Q",
          },
          cA =
            typeof navigator < "u" && /Chrome\/(\d+)/.exec(navigator.userAgent),
          VW =
            typeof navigator < "u" && /Apple Computer/.test(navigator.vendor),
          BW = typeof navigator < "u" && /Gecko\/\d+/.test(navigator.userAgent),
          uA = typeof navigator < "u" && /Mac/.test(navigator.platform),
          jW =
            typeof navigator < "u" &&
            /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(
              navigator.userAgent
            ),
          HW = (cA && (uA || +cA[1] < 57)) || (BW && uA),
          Bt = 0;
        Bt < 10;
        Bt++
      )
        _o[48 + Bt] = _o[96 + Bt] = String(Bt);
      for (Bt = 1; Bt <= 24; Bt++) _o[Bt + 111] = "F" + Bt;
      for (Bt = 65; Bt <= 90; Bt++)
        (_o[Bt] = String.fromCharCode(Bt + 32)),
          (jh[Bt] = String.fromCharCode(Bt));
      for (var $v in _o) jh.hasOwnProperty($v) || (jh[$v] = _o[$v]);
      const zW =
        typeof navigator < "u" && /Mac|iP(hone|[oa]d)/.test(navigator.platform);
      function $W(n) {
        let i,
          r,
          o,
          s,
          e = n.split(/-(?!$)/),
          t = e[e.length - 1];
        "Space" == t && (t = " ");
        for (let a = 0; a < e.length - 1; a++) {
          let l = e[a];
          if (/^(cmd|meta|m)$/i.test(l)) s = !0;
          else if (/^a(lt)?$/i.test(l)) i = !0;
          else if (/^(c|ctrl|control)$/i.test(l)) r = !0;
          else if (/^s(hift)?$/i.test(l)) o = !0;
          else {
            if (!/^mod$/i.test(l))
              throw new Error("Unrecognized modifier name: " + l);
            zW ? (s = !0) : (r = !0);
          }
        }
        return (
          i && (t = "Alt-" + t),
          r && (t = "Ctrl-" + t),
          s && (t = "Meta-" + t),
          o && (t = "Shift-" + t),
          t
        );
      }
      function Wv(n, e, t) {
        return (
          e.altKey && (n = "Alt-" + n),
          e.ctrlKey && (n = "Ctrl-" + n),
          e.metaKey && (n = "Meta-" + n),
          !1 !== t && e.shiftKey && (n = "Shift-" + n),
          n
        );
      }
      function dA(n) {
        let e = (function WW(n) {
          let e = Object.create(null);
          for (let t in n) e[$W(t)] = n[t];
          return e;
        })(n);
        return function (t, i) {
          let s,
            r = (function UW(n) {
              var t =
                (!(
                  (HW && (n.ctrlKey || n.altKey || n.metaKey)) ||
                  ((VW || jW) && n.shiftKey && n.key && 1 == n.key.length)
                ) &&
                  n.key) ||
                (n.shiftKey ? jh : _o)[n.keyCode] ||
                n.key ||
                "Unidentified";
              return (
                "Esc" == t && (t = "Escape"),
                "Del" == t && (t = "Delete"),
                "Left" == t && (t = "ArrowLeft"),
                "Up" == t && (t = "ArrowUp"),
                "Right" == t && (t = "ArrowRight"),
                "Down" == t && (t = "ArrowDown"),
                t
              );
            })(i),
            o = 1 == r.length && " " != r,
            a = e[Wv(r, i, !o)];
          if (a && a(t.state, t.dispatch, t)) return !0;
          if (
            o &&
            (i.shiftKey || i.altKey || i.metaKey || r.charCodeAt(0) > 127) &&
            (s = _o[i.keyCode]) &&
            s != r
          ) {
            let l = e[Wv(s, i, !0)];
            if (l && l(t.state, t.dispatch, t)) return !0;
          } else if (o && i.shiftKey) {
            let l = e[Wv(r, i, !0)];
            if (l && l(t.state, t.dispatch, t)) return !0;
          }
          return !1;
        };
      }
      const Gv = (n, e) =>
          !n.selection.empty &&
          (e && e(n.tr.deleteSelection().scrollIntoView()), !0),
        hA = (n, e, t) => {
          let { $cursor: i } = n.selection;
          if (!i || (t ? !t.endOfTextblock("backward", n) : i.parentOffset > 0))
            return !1;
          let r = pA(i);
          if (!r) {
            let s = i.blockRange(),
              a = s && Ia(s);
            return null != a && (e && e(n.tr.lift(s, a).scrollIntoView()), !0);
          }
          let o = r.nodeBefore;
          if (!o.type.spec.isolating && EA(n, r, e)) return !0;
          if (
            0 == i.parent.content.size &&
            (Va(o, "end") || Y.isSelectable(o))
          ) {
            let s = uv(n.doc, i.before(), i.after(), P.empty);
            if (s && s.slice.size < s.to - s.from) {
              if (e) {
                let a = n.tr.step(s);
                a.setSelection(
                  Va(o, "end")
                    ? ce.findFrom(a.doc.resolve(a.mapping.map(r.pos, -1)), -1)
                    : Y.create(a.doc, r.pos - o.nodeSize)
                ),
                  e(a.scrollIntoView());
              }
              return !0;
            }
          }
          return !(
            !o.isAtom ||
            r.depth != i.depth - 1 ||
            (e && e(n.tr.delete(r.pos - o.nodeSize, r.pos).scrollIntoView()), 0)
          );
        };
      function Va(n, e, t = !1) {
        for (let i = n; i; i = "start" == e ? i.firstChild : i.lastChild) {
          if (i.isTextblock) return !0;
          if (t && 1 != i.childCount) return !1;
        }
        return !1;
      }
      const fA = (n, e, t) => {
        let { $head: i, empty: r } = n.selection,
          o = i;
        if (!r) return !1;
        if (i.parent.isTextblock) {
          if (t ? !t.endOfTextblock("backward", n) : i.parentOffset > 0)
            return !1;
          o = pA(i);
        }
        let s = o && o.nodeBefore;
        return !(
          !s ||
          !Y.isSelectable(s) ||
          (e &&
            e(
              n.tr
                .setSelection(Y.create(n.doc, o.pos - s.nodeSize))
                .scrollIntoView()
            ),
          0)
        );
      };
      function pA(n) {
        if (!n.parent.type.spec.isolating)
          for (let e = n.depth - 1; e >= 0; e--) {
            if (n.index(e) > 0) return n.doc.resolve(n.before(e + 1));
            if (n.node(e).type.spec.isolating) break;
          }
        return null;
      }
      const gA = (n, e, t) => {
          let { $cursor: i } = n.selection;
          if (
            !i ||
            (t
              ? !t.endOfTextblock("forward", n)
              : i.parentOffset < i.parent.content.size)
          )
            return !1;
          let r = yA(i);
          if (!r) return !1;
          let o = r.nodeAfter;
          if (EA(n, r, e)) return !0;
          if (
            0 == i.parent.content.size &&
            (Va(o, "start") || Y.isSelectable(o))
          ) {
            let s = uv(n.doc, i.before(), i.after(), P.empty);
            if (s && s.slice.size < s.to - s.from) {
              if (e) {
                let a = n.tr.step(s);
                a.setSelection(
                  Va(o, "start")
                    ? ce.findFrom(a.doc.resolve(a.mapping.map(r.pos)), 1)
                    : Y.create(a.doc, a.mapping.map(r.pos))
                ),
                  e(a.scrollIntoView());
              }
              return !0;
            }
          }
          return !(
            !o.isAtom ||
            r.depth != i.depth - 1 ||
            (e && e(n.tr.delete(r.pos, r.pos + o.nodeSize).scrollIntoView()), 0)
          );
        },
        mA = (n, e, t) => {
          let { $head: i, empty: r } = n.selection,
            o = i;
          if (!r) return !1;
          if (i.parent.isTextblock) {
            if (
              t
                ? !t.endOfTextblock("forward", n)
                : i.parentOffset < i.parent.content.size
            )
              return !1;
            o = yA(i);
          }
          let s = o && o.nodeAfter;
          return !(
            !s ||
            !Y.isSelectable(s) ||
            (e && e(n.tr.setSelection(Y.create(n.doc, o.pos)).scrollIntoView()),
            0)
          );
        };
      function yA(n) {
        if (!n.parent.type.spec.isolating)
          for (let e = n.depth - 1; e >= 0; e--) {
            let t = n.node(e);
            if (n.index(e) + 1 < t.childCount)
              return n.doc.resolve(n.after(e + 1));
            if (t.type.spec.isolating) break;
          }
        return null;
      }
      const vA = (n, e) => {
        let { $head: t, $anchor: i } = n.selection;
        return !(
          !t.parent.type.spec.code ||
          !t.sameParent(i) ||
          (e && e(n.tr.insertText("\n").scrollIntoView()), 0)
        );
      };
      function qv(n) {
        for (let e = 0; e < n.edgeCount; e++) {
          let { type: t } = n.edge(e);
          if (t.isTextblock && !t.hasRequiredAttrs()) return t;
        }
        return null;
      }
      const _A = (n, e) => {
          let { $head: t, $anchor: i } = n.selection;
          if (!t.parent.type.spec.code || !t.sameParent(i)) return !1;
          let r = t.node(-1),
            o = t.indexAfter(-1),
            s = qv(r.contentMatchAt(o));
          if (!s || !r.canReplaceWith(o, o, s)) return !1;
          if (e) {
            let a = t.after(),
              l = n.tr.replaceWith(a, a, s.createAndFill());
            l.setSelection(ce.near(l.doc.resolve(a), 1)), e(l.scrollIntoView());
          }
          return !0;
        },
        bA = (n, e) => {
          let t = n.selection,
            { $from: i, $to: r } = t;
          if (
            t instanceof Bn ||
            i.parent.inlineContent ||
            r.parent.inlineContent
          )
            return !1;
          let o = qv(r.parent.contentMatchAt(r.indexAfter()));
          if (!o || !o.isTextblock) return !1;
          if (e) {
            let s = (!i.parentOffset && r.index() < r.parent.childCount ? i : r)
                .pos,
              a = n.tr.insert(s, o.createAndFill());
            a.setSelection(ue.create(a.doc, s + 1)), e(a.scrollIntoView());
          }
          return !0;
        },
        DA = (n, e) => {
          let { $cursor: t } = n.selection;
          if (!t || t.parent.content.size) return !1;
          if (t.depth > 1 && t.after() != t.end(-1)) {
            let o = t.before();
            if (Tr(n.doc, o)) return e && e(n.tr.split(o).scrollIntoView()), !0;
          }
          let i = t.blockRange(),
            r = i && Ia(i);
          return null != r && (e && e(n.tr.lift(i, r).scrollIntoView()), !0);
        };
      function EA(n, e, t) {
        let o,
          s,
          i = e.nodeBefore,
          r = e.nodeAfter;
        if (i.type.spec.isolating || r.type.spec.isolating) return !1;
        if (
          (function ZW(n, e, t) {
            let i = e.nodeBefore,
              r = e.nodeAfter,
              o = e.index();
            return !(
              !(i && r && i.type.compatibleContent(r.type)) ||
              (!i.content.size && e.parent.canReplace(o - 1, o)
                ? (t &&
                    t(n.tr.delete(e.pos - i.nodeSize, e.pos).scrollIntoView()),
                  0)
                : !e.parent.canReplace(o, o + 1) ||
                  (!r.isTextblock && !wc(n.doc, e.pos)) ||
                  (t &&
                    t(
                      n.tr
                        .clearIncompatible(
                          e.pos,
                          i.type,
                          i.contentMatchAt(i.childCount)
                        )
                        .join(e.pos)
                        .scrollIntoView()
                    ),
                  0))
            );
          })(n, e, t)
        )
          return !0;
        let a = e.parent.canReplace(e.index(), e.index() + 1);
        if (
          a &&
          (o = (s = i.contentMatchAt(i.childCount)).findWrapping(r.type)) &&
          s.matchType(o[0] || r.type).validEnd
        ) {
          if (t) {
            let d = e.pos + r.nodeSize,
              h = I.empty;
            for (let g = o.length - 1; g >= 0; g--)
              h = I.from(o[g].create(null, h));
            h = I.from(i.copy(h));
            let f = n.tr.step(
                new Rt(e.pos - 1, d, e.pos, d, new P(h, 1, 0), o.length, !0)
              ),
              p = d + 2 * o.length;
            wc(f.doc, p) && f.join(p), t(f.scrollIntoView());
          }
          return !0;
        }
        let l = ce.findFrom(e, 1),
          c = l && l.$from.blockRange(l.$to),
          u = c && Ia(c);
        if (null != u && u >= e.depth)
          return t && t(n.tr.lift(c, u).scrollIntoView()), !0;
        if (a && Va(r, "start", !0) && Va(i, "end")) {
          let d = i,
            h = [];
          for (; h.push(d), !d.isTextblock; ) d = d.lastChild;
          let f = r,
            p = 1;
          for (; !f.isTextblock; f = f.firstChild) p++;
          if (d.canReplace(d.childCount, d.childCount, f.content)) {
            if (t) {
              let g = I.empty;
              for (let v = h.length - 1; v >= 0; v--) g = I.from(h[v].copy(g));
              t(
                n.tr
                  .step(
                    new Rt(
                      e.pos - h.length,
                      e.pos + r.nodeSize,
                      e.pos + p,
                      e.pos + r.nodeSize - p,
                      new P(g, h.length, 0),
                      0,
                      !0
                    )
                  )
                  .scrollIntoView()
              );
            }
            return !0;
          }
        }
        return !1;
      }
      function wA(n) {
        return function (e, t) {
          let i = e.selection,
            r = n < 0 ? i.$from : i.$to,
            o = r.depth;
          for (; r.node(o).isInline; ) {
            if (!o) return !1;
            o--;
          }
          return (
            !!r.node(o).isTextblock &&
            (t &&
              t(
                e.tr.setSelection(
                  ue.create(e.doc, n < 0 ? r.start(o) : r.end(o))
                )
              ),
            !0)
          );
        };
      }
      const SA = wA(-1),
        MA = wA(1);
      function IA(n, e = null) {
        return function (t, i) {
          let { from: r, to: o } = t.selection,
            s = !1;
          return (
            t.doc.nodesBetween(r, o, (a, l) => {
              if (s) return !1;
              if (a.isTextblock && !a.hasMarkup(n, e))
                if (a.type == n) s = !0;
                else {
                  let c = t.doc.resolve(l),
                    u = c.index();
                  s = c.parent.canReplaceWith(u, u + 1, n);
                }
            }),
            !!s && (i && i(t.tr.setBlockType(r, o, n, e).scrollIntoView()), !0)
          );
        };
      }
      function Kv(...n) {
        return function (e, t, i) {
          for (let r = 0; r < n.length; r++) if (n[r](e, t, i)) return !0;
          return !1;
        };
      }
      let Yv = Kv(Gv, hA, fA),
        TA = Kv(Gv, gA, mA);
      const bo = {
          Enter: Kv(vA, bA, DA, (n, e) => {
            let { $from: t, $to: i } = n.selection;
            if (n.selection instanceof Y && n.selection.node.isBlock)
              return !(
                !t.parentOffset ||
                !Tr(n.doc, t.pos) ||
                (e && e(n.tr.split(t.pos).scrollIntoView()), 0)
              );
            if (!t.parent.isBlock) return !1;
            if (e) {
              let r = i.parentOffset == i.parent.content.size,
                o = n.tr;
              (n.selection instanceof ue || n.selection instanceof Bn) &&
                o.deleteSelection();
              let s =
                  0 == t.depth
                    ? null
                    : qv(t.node(-1).contentMatchAt(t.indexAfter(-1))),
                a = r && s ? [{ type: s }] : void 0,
                l = Tr(o.doc, o.mapping.map(t.pos), 1, a);
              if (
                (!a &&
                  !l &&
                  Tr(
                    o.doc,
                    o.mapping.map(t.pos),
                    1,
                    s ? [{ type: s }] : void 0
                  ) &&
                  (s && (a = [{ type: s }]), (l = !0)),
                l &&
                  (o.split(o.mapping.map(t.pos), 1, a),
                  !r && !t.parentOffset && t.parent.type != s))
              ) {
                let c = o.mapping.map(t.before()),
                  u = o.doc.resolve(c);
                s &&
                  t.node(-1).canReplaceWith(u.index(), u.index() + 1, s) &&
                  o.setNodeMarkup(o.mapping.map(t.before()), s);
              }
              e(o.scrollIntoView());
            }
            return !0;
          }),
          "Mod-Enter": _A,
          Backspace: Yv,
          "Mod-Backspace": Yv,
          "Shift-Backspace": Yv,
          Delete: TA,
          "Mod-Delete": TA,
          "Mod-a": (n, e) => (e && e(n.tr.setSelection(new Bn(n.doc))), !0),
        },
        e5 = {
          "Ctrl-h": bo.Backspace,
          "Alt-Backspace": bo["Mod-Backspace"],
          "Ctrl-d": bo.Delete,
          "Ctrl-Alt-Backspace": bo["Mod-Delete"],
          "Alt-Delete": bo["Mod-Delete"],
          "Alt-d": bo["Mod-Delete"],
          "Ctrl-a": SA,
          "Ctrl-e": MA,
        };
      for (let n in bo) e5[n] = bo[n];
      function Hh(n) {
        const { state: e, transaction: t } = n;
        let { selection: i } = t,
          { doc: r } = t,
          { storedMarks: o } = t;
        return {
          ...e,
          apply: e.apply.bind(e),
          applyTransaction: e.applyTransaction.bind(e),
          filterTransaction: e.filterTransaction,
          plugins: e.plugins,
          schema: e.schema,
          reconfigure: e.reconfigure.bind(e),
          toJSON: e.toJSON.bind(e),
          get storedMarks() {
            return o;
          },
          get selection() {
            return i;
          },
          get doc() {
            return r;
          },
          get tr() {
            return (i = t.selection), (r = t.doc), (o = t.storedMarks), t;
          },
        };
      }
      typeof navigator < "u"
        ? /Mac|iP(hone|[oa]d)/.test(navigator.platform)
        : typeof os < "u" && os.platform && os.platform();
      class Uh {
        constructor(e) {
          (this.editor = e.editor),
            (this.rawCommands = this.editor.extensionManager.commands),
            (this.customState = e.state);
        }
        get hasCustomState() {
          return !!this.customState;
        }
        get state() {
          return this.customState || this.editor.state;
        }
        get commands() {
          const { rawCommands: e, editor: t, state: i } = this,
            { view: r } = t,
            { tr: o } = i,
            s = this.buildProps(o);
          return Object.fromEntries(
            Object.entries(e).map(([a, l]) => [
              a,
              (...u) => {
                const d = l(...u)(s);
                return (
                  !o.getMeta("preventDispatch") &&
                    !this.hasCustomState &&
                    r.dispatch(o),
                  d
                );
              },
            ])
          );
        }
        get chain() {
          return () => this.createChain();
        }
        get can() {
          return () => this.createCan();
        }
        createChain(e, t = !0) {
          const { rawCommands: i, editor: r, state: o } = this,
            { view: s } = r,
            a = [],
            l = !!e,
            c = e || o.tr,
            d = {
              ...Object.fromEntries(
                Object.entries(i).map(([h, f]) => [
                  h,
                  (...g) => {
                    const m = this.buildProps(c, t),
                      v = f(...g)(m);
                    return a.push(v), d;
                  },
                ])
              ),
              run: () => (
                !l &&
                  t &&
                  !c.getMeta("preventDispatch") &&
                  !this.hasCustomState &&
                  s.dispatch(c),
                a.every((h) => !0 === h)
              ),
            };
          return d;
        }
        createCan(e) {
          const { rawCommands: t, state: i } = this,
            r = void 0,
            o = e || i.tr,
            s = this.buildProps(o, r);
          return {
            ...Object.fromEntries(
              Object.entries(t).map(([l, c]) => [
                l,
                (...u) => c(...u)({ ...s, dispatch: r }),
              ])
            ),
            chain: () => this.createChain(o, r),
          };
        }
        buildProps(e, t = !0) {
          const { rawCommands: i, editor: r, state: o } = this,
            { view: s } = r;
          o.storedMarks && e.setStoredMarks(o.storedMarks);
          const a = {
            tr: e,
            editor: r,
            view: s,
            state: Hh({ state: o, transaction: e }),
            dispatch: t ? () => {} : void 0,
            chain: () => this.createChain(e),
            can: () => this.createCan(e),
            get commands() {
              return Object.fromEntries(
                Object.entries(i).map(([l, c]) => [l, (...u) => c(...u)(a)])
              );
            },
          };
          return a;
        }
      }
      function L(n, e, t) {
        return void 0 === n.config[e] && n.parent
          ? L(n.parent, e, t)
          : "function" == typeof n.config[e]
          ? n.config[e].bind({
              ...t,
              parent: n.parent ? L(n.parent, e, t) : null,
            })
          : n.config[e];
      }
      function zh(n) {
        return {
          baseExtensions: n.filter((r) => "extension" === r.type),
          nodeExtensions: n.filter((r) => "node" === r.type),
          markExtensions: n.filter((r) => "mark" === r.type),
        };
      }
      function xA(n) {
        const e = [],
          { nodeExtensions: t, markExtensions: i } = zh(n),
          r = [...t, ...i],
          o = {
            default: null,
            rendered: !0,
            renderHTML: null,
            parseHTML: null,
            keepOnSplit: !0,
            isRequired: !1,
          };
        return (
          n.forEach((s) => {
            const l = L(s, "addGlobalAttributes", {
              name: s.name,
              options: s.options,
              storage: s.storage,
            });
            l &&
              l().forEach((u) => {
                u.types.forEach((d) => {
                  Object.entries(u.attributes).forEach(([h, f]) => {
                    e.push({ type: d, name: h, attribute: { ...o, ...f } });
                  });
                });
              });
          }),
          r.forEach((s) => {
            const l = L(s, "addAttributes", {
              name: s.name,
              options: s.options,
              storage: s.storage,
            });
            if (!l) return;
            const c = l();
            Object.entries(c).forEach(([u, d]) => {
              const h = { ...o, ...d };
              d.isRequired && void 0 === d.default && delete h.default,
                e.push({ type: s.name, name: u, attribute: h });
            });
          }),
          e
        );
      }
      function Pt(n, e) {
        if ("string" == typeof n) {
          if (!e.nodes[n])
            throw Error(
              `There is no node type named '${n}'. Maybe you forgot to add the extension?`
            );
          return e.nodes[n];
        }
        return n;
      }
      function _t(...n) {
        return n
          .filter((e) => !!e)
          .reduce((e, t) => {
            const i = { ...e };
            return (
              Object.entries(t).forEach(([r, o]) => {
                i[r] = i[r]
                  ? "class" === r
                    ? [i[r], o].join(" ")
                    : "style" === r
                    ? [i[r], o].join("; ")
                    : o
                  : o;
              }),
              i
            );
          }, {});
      }
      function Qv(n, e) {
        return e
          .filter((t) => t.attribute.rendered)
          .map((t) =>
            t.attribute.renderHTML
              ? t.attribute.renderHTML(n.attrs) || {}
              : { [t.name]: n.attrs[t.name] }
          )
          .reduce((t, i) => _t(t, i), {});
      }
      function AA(n) {
        return "function" == typeof n;
      }
      function de(n, e, ...t) {
        return AA(n) ? (e ? n.bind(e)(...t) : n(...t)) : n;
      }
      function OA(n, e) {
        return n.style
          ? n
          : {
              ...n,
              getAttrs: (t) => {
                const i = n.getAttrs ? n.getAttrs(t) : n.attrs;
                if (!1 === i) return !1;
                const r = e.reduce((o, s) => {
                  const a = s.attribute.parseHTML
                    ? s.attribute.parseHTML(t)
                    : (function m5(n) {
                        return "string" != typeof n
                          ? n
                          : n.match(/^[+-]?(?:\d*\.)?\d+$/)
                          ? Number(n)
                          : "true" === n || ("false" !== n && n);
                      })(t.getAttribute(s.name));
                  return null == a ? o : { ...o, [s.name]: a };
                }, {});
                return { ...i, ...r };
              },
            };
      }
      function kA(n) {
        return Object.fromEntries(
          Object.entries(n).filter(
            ([e, t]) =>
              ("attrs" !== e ||
                !(function g5(n = {}) {
                  return (
                    0 === Object.keys(n).length && n.constructor === Object
                  );
                })(t)) &&
              null != t
          )
        );
      }
      function Jv(n, e) {
        return e.nodes[n] || e.marks[n] || null;
      }
      function RA(n, e) {
        return Array.isArray(e)
          ? e.some((t) => ("string" == typeof t ? t : t.name) === n.name)
          : e;
      }
      function Xv(n) {
        return "[object RegExp]" === Object.prototype.toString.call(n);
      }
      class Rc {
        constructor(e) {
          (this.find = e.find), (this.handler = e.handler);
        }
      }
      function e_(n) {
        var e;
        const { editor: t, from: i, to: r, text: o, rules: s, plugin: a } = n,
          { view: l } = t;
        if (l.composing) return !1;
        const c = l.state.doc.resolve(i);
        if (
          c.parent.type.spec.code ||
          (null !== (e = c.nodeBefore || c.nodeAfter) &&
            void 0 !== e &&
            e.marks.find((h) => h.type.spec.code))
        )
          return !1;
        let u = !1;
        const d =
          ((n, e = 500) => {
            let t = "";
            return (
              n.parent.nodesBetween(
                Math.max(0, n.parentOffset - e),
                n.parentOffset,
                (i, r, o, s) => {
                  var a, l, c;
                  t +=
                    (null === (l = (a = i.type.spec).toText) || void 0 === l
                      ? void 0
                      : l.call(a, { node: i, pos: r, parent: o, index: s })) ||
                    (null === (c = n.nodeBefore) || void 0 === c
                      ? void 0
                      : c.text) ||
                    "%leaf%";
                }
              ),
              t
            );
          })(c) + o;
        return (
          s.forEach((h) => {
            if (u) return;
            const f = ((n, e) => {
              if (Xv(e)) return e.exec(n);
              const t = e(n);
              if (!t) return null;
              const i = [];
              return (
                i.push(t.text),
                (i.index = t.index),
                (i.input = n),
                (i.data = t.data),
                t.replaceWith &&
                  (t.text.includes(t.replaceWith) ||
                    console.warn(
                      '[tiptap warn]: "inputRuleMatch.replaceWith" must be part of "inputRuleMatch.text".'
                    ),
                  i.push(t.replaceWith)),
                i
              );
            })(d, h.find);
            if (!f) return;
            const p = l.state.tr,
              g = Hh({ state: l.state, transaction: p }),
              m = { from: i - (f[0].length - o.length), to: r },
              {
                commands: v,
                chain: _,
                can: b,
              } = new Uh({ editor: t, state: g });
            null ===
              h.handler({
                state: g,
                range: m,
                match: f,
                commands: v,
                chain: _,
                can: b,
              }) ||
              !p.steps.length ||
              (p.setMeta(a, { transform: p, from: i, to: r, text: o }),
              l.dispatch(p),
              (u = !0));
          }),
          u
        );
      }
      function _5(n) {
        const { editor: e, rules: t } = n,
          i = new Qe({
            state: {
              init: () => null,
              apply: (r, o) =>
                r.getMeta(i) || (r.selectionSet || r.docChanged ? null : o),
            },
            props: {
              handleTextInput: (r, o, s, a) =>
                e_({ editor: e, from: o, to: s, text: a, rules: t, plugin: i }),
              handleDOMEvents: {
                compositionend: (r) => (
                  setTimeout(() => {
                    const { $cursor: o } = r.state.selection;
                    o &&
                      e_({
                        editor: e,
                        from: o.pos,
                        to: o.pos,
                        text: "",
                        rules: t,
                        plugin: i,
                      });
                  }),
                  !1
                ),
              },
              handleKeyDown(r, o) {
                if ("Enter" !== o.key) return !1;
                const { $cursor: s } = r.state.selection;
                return (
                  !!s &&
                  e_({
                    editor: e,
                    from: s.pos,
                    to: s.pos,
                    text: "\n",
                    rules: t,
                    plugin: i,
                  })
                );
              },
            },
            isInputRules: !0,
          });
        return i;
      }
      class t_ {
        constructor(e) {
          (this.find = e.find), (this.handler = e.handler);
        }
      }
      function E5(n) {
        const { editor: e, rules: t } = n;
        let i = null,
          r = !1,
          o = !1;
        return t.map(
          (a) =>
            new Qe({
              view(l) {
                const c = (u) => {
                  var d;
                  i =
                    null !== (d = l.dom.parentElement) &&
                    void 0 !== d &&
                    d.contains(u.target)
                      ? l.dom.parentElement
                      : null;
                };
                return (
                  window.addEventListener("dragstart", c),
                  {
                    destroy() {
                      window.removeEventListener("dragstart", c);
                    },
                  }
                );
              },
              props: {
                handleDOMEvents: {
                  drop: (l) => ((o = i === l.dom.parentElement), !1),
                  paste: (l, c) => {
                    var u;
                    const d =
                      null === (u = c.clipboardData) || void 0 === u
                        ? void 0
                        : u.getData("text/html");
                    return (r = !!d?.includes("data-pm-slice")), !1;
                  },
                },
              },
              appendTransaction: (l, c, u) => {
                const d = l[0],
                  h = "paste" === d.getMeta("uiEvent") && !r,
                  f = "drop" === d.getMeta("uiEvent") && !o;
                if (!h && !f) return;
                const p = c.doc.content.findDiffStart(u.doc.content),
                  g = c.doc.content.findDiffEnd(u.doc.content);
                if (
                  !(function b5(n) {
                    return "number" == typeof n;
                  })(p) ||
                  !g ||
                  p === g.b
                )
                  return;
                const m = u.tr,
                  v = Hh({ state: u, transaction: m });
                return (function C5(n) {
                  const { editor: e, state: t, from: i, to: r, rule: o } = n,
                    {
                      commands: s,
                      chain: a,
                      can: l,
                    } = new Uh({ editor: e, state: t }),
                    c = [];
                  return (
                    t.doc.nodesBetween(i, r, (d, h) => {
                      if (!d.isTextblock || d.type.spec.code) return;
                      const f = Math.max(i, h),
                        p = Math.min(r, h + d.content.size);
                      ((n, e) => {
                        if (Xv(e)) return [...n.matchAll(e)];
                        const t = e(n);
                        return t
                          ? t.map((i) => {
                              const r = [];
                              return (
                                r.push(i.text),
                                (r.index = i.index),
                                (r.input = n),
                                (r.data = i.data),
                                i.replaceWith &&
                                  (i.text.includes(i.replaceWith) ||
                                    console.warn(
                                      '[tiptap warn]: "pasteRuleMatch.replaceWith" must be part of "pasteRuleMatch.text".'
                                    ),
                                  r.push(i.replaceWith)),
                                r
                              );
                            })
                          : [];
                      })(
                        d.textBetween(f - h, p - h, void 0, "\ufffc"),
                        o.find
                      ).forEach((v) => {
                        if (void 0 === v.index) return;
                        const _ = f + v.index + 1,
                          b = _ + v[0].length,
                          y = {
                            from: t.tr.mapping.map(_),
                            to: t.tr.mapping.map(b),
                          },
                          D = o.handler({
                            state: t,
                            range: y,
                            match: v,
                            commands: s,
                            chain: a,
                            can: l,
                          });
                        c.push(D);
                      });
                    }),
                    c.every((d) => null !== d)
                  );
                })({
                  editor: e,
                  state: v,
                  from: Math.max(p - 1, 0),
                  to: g.b,
                  rule: a,
                }) && m.steps.length
                  ? m
                  : void 0;
              },
            })
        );
      }
      class fs {
        constructor(e, t) {
          (this.splittableMarks = []),
            (this.editor = t),
            (this.extensions = fs.resolve(e)),
            (this.schema = (function NA(n) {
              var e;
              const t = xA(n),
                { nodeExtensions: i, markExtensions: r } = zh(n),
                o =
                  null === (e = i.find((l) => L(l, "topNode"))) || void 0 === e
                    ? void 0
                    : e.name,
                s = Object.fromEntries(
                  i.map((l) => {
                    const c = t.filter((m) => m.type === l.name),
                      u = {
                        name: l.name,
                        options: l.options,
                        storage: l.storage,
                      },
                      h = kA({
                        ...n.reduce((m, v) => {
                          const _ = L(v, "extendNodeSchema", u);
                          return { ...m, ...(_ ? _(l) : {}) };
                        }, {}),
                        content: de(L(l, "content", u)),
                        marks: de(L(l, "marks", u)),
                        group: de(L(l, "group", u)),
                        inline: de(L(l, "inline", u)),
                        atom: de(L(l, "atom", u)),
                        selectable: de(L(l, "selectable", u)),
                        draggable: de(L(l, "draggable", u)),
                        code: de(L(l, "code", u)),
                        defining: de(L(l, "defining", u)),
                        isolating: de(L(l, "isolating", u)),
                        attrs: Object.fromEntries(
                          c.map((m) => {
                            var v;
                            return [
                              m.name,
                              {
                                default:
                                  null === (v = m?.attribute) || void 0 === v
                                    ? void 0
                                    : v.default,
                              },
                            ];
                          })
                        ),
                      }),
                      f = de(L(l, "parseHTML", u));
                    f && (h.parseDOM = f.map((m) => OA(m, c)));
                    const p = L(l, "renderHTML", u);
                    p &&
                      (h.toDOM = (m) =>
                        p({ node: m, HTMLAttributes: Qv(m, c) }));
                    const g = L(l, "renderText", u);
                    return g && (h.toText = g), [l.name, h];
                  })
                ),
                a = Object.fromEntries(
                  r.map((l) => {
                    const c = t.filter((g) => g.type === l.name),
                      u = {
                        name: l.name,
                        options: l.options,
                        storage: l.storage,
                      },
                      h = kA({
                        ...n.reduce((g, m) => {
                          const v = L(m, "extendMarkSchema", u);
                          return { ...g, ...(v ? v(l) : {}) };
                        }, {}),
                        inclusive: de(L(l, "inclusive", u)),
                        excludes: de(L(l, "excludes", u)),
                        group: de(L(l, "group", u)),
                        spanning: de(L(l, "spanning", u)),
                        code: de(L(l, "code", u)),
                        attrs: Object.fromEntries(
                          c.map((g) => {
                            var m;
                            return [
                              g.name,
                              {
                                default:
                                  null === (m = g?.attribute) || void 0 === m
                                    ? void 0
                                    : m.default,
                              },
                            ];
                          })
                        ),
                      }),
                      f = de(L(l, "parseHTML", u));
                    f && (h.parseDOM = f.map((g) => OA(g, c)));
                    const p = L(l, "renderHTML", u);
                    return (
                      p &&
                        (h.toDOM = (g) =>
                          p({ mark: g, HTMLAttributes: Qv(g, c) })),
                      [l.name, h]
                    );
                  })
                );
              return new L$({ topNode: o, nodes: s, marks: a });
            })(this.extensions)),
            this.extensions.forEach((i) => {
              var r;
              this.editor.extensionStorage[i.name] = i.storage;
              const o = {
                name: i.name,
                options: i.options,
                storage: i.storage,
                editor: this.editor,
                type: Jv(i.name, this.schema),
              };
              "mark" === i.type &&
                (null === (r = de(L(i, "keepOnSplit", o))) ||
                  void 0 === r ||
                  r) &&
                this.splittableMarks.push(i.name);
              const s = L(i, "onBeforeCreate", o);
              s && this.editor.on("beforeCreate", s);
              const a = L(i, "onCreate", o);
              a && this.editor.on("create", a);
              const l = L(i, "onUpdate", o);
              l && this.editor.on("update", l);
              const c = L(i, "onSelectionUpdate", o);
              c && this.editor.on("selectionUpdate", c);
              const u = L(i, "onTransaction", o);
              u && this.editor.on("transaction", u);
              const d = L(i, "onFocus", o);
              d && this.editor.on("focus", d);
              const h = L(i, "onBlur", o);
              h && this.editor.on("blur", h);
              const f = L(i, "onDestroy", o);
              f && this.editor.on("destroy", f);
            });
        }
        static resolve(e) {
          const t = fs.sort(fs.flatten(e)),
            i = (function w5(n) {
              const e = n.filter((t, i) => n.indexOf(t) !== i);
              return [...new Set(e)];
            })(t.map((r) => r.name));
          return (
            i.length &&
              console.warn(
                `[tiptap warn]: Duplicate extension names found: [${i
                  .map((r) => `'${r}'`)
                  .join(", ")}]. This can lead to issues.`
              ),
            t
          );
        }
        static flatten(e) {
          return e
            .map((t) => {
              const r = L(t, "addExtensions", {
                name: t.name,
                options: t.options,
                storage: t.storage,
              });
              return r ? [t, ...this.flatten(r())] : t;
            })
            .flat(10);
        }
        static sort(e) {
          return e.sort((i, r) => {
            const o = L(i, "priority") || 100,
              s = L(r, "priority") || 100;
            return o > s ? -1 : o < s ? 1 : 0;
          });
        }
        get commands() {
          return this.extensions.reduce((e, t) => {
            const r = L(t, "addCommands", {
              name: t.name,
              options: t.options,
              storage: t.storage,
              editor: this.editor,
              type: Jv(t.name, this.schema),
            });
            return r ? { ...e, ...r() } : e;
          }, {});
        }
        get plugins() {
          const { editor: e } = this,
            t = fs.sort([...this.extensions].reverse()),
            i = [],
            r = [],
            o = t
              .map((s) => {
                const a = {
                    name: s.name,
                    options: s.options,
                    storage: s.storage,
                    editor: e,
                    type: Jv(s.name, this.schema),
                  },
                  l = [],
                  c = L(s, "addKeyboardShortcuts", a);
                if (c) {
                  const p = (function GW(n) {
                    return new Qe({ props: { handleKeyDown: dA(n) } });
                  })(
                    Object.fromEntries(
                      Object.entries(c()).map(([g, m]) => [
                        g,
                        () => m({ editor: e }),
                      ])
                    )
                  );
                  l.push(p);
                }
                const u = L(s, "addInputRules", a);
                RA(s, e.options.enableInputRules) && u && i.push(...u());
                const d = L(s, "addPasteRules", a);
                RA(s, e.options.enablePasteRules) && d && r.push(...d());
                const h = L(s, "addProseMirrorPlugins", a);
                if (h) {
                  const f = h();
                  l.push(...f);
                }
                return l;
              })
              .flat();
          return [
            _5({ editor: e, rules: i }),
            ...E5({ editor: e, rules: r }),
            ...o,
          ];
        }
        get attributes() {
          return xA(this.extensions);
        }
        get nodeViews() {
          const { editor: e } = this,
            { nodeExtensions: t } = zh(this.extensions);
          return Object.fromEntries(
            t
              .filter((i) => !!L(i, "addNodeView"))
              .map((i) => {
                const r = this.attributes.filter((l) => l.type === i.name),
                  o = {
                    name: i.name,
                    options: i.options,
                    storage: i.storage,
                    editor: e,
                    type: Pt(i.name, this.schema),
                  },
                  s = L(i, "addNodeView", o);
                return s
                  ? [
                      i.name,
                      (l, c, u, d) => {
                        const h = Qv(l, r);
                        return s()({
                          editor: e,
                          node: l,
                          getPos: u,
                          decorations: d,
                          HTMLAttributes: h,
                          extension: i,
                        });
                      },
                    ]
                  : [];
              })
          );
        }
      }
      function n_(n) {
        return (
          "Object" ===
            (function S5(n) {
              return Object.prototype.toString.call(n).slice(8, -1);
            })(n) &&
          n.constructor === Object &&
          Object.getPrototypeOf(n) === Object.prototype
        );
      }
      function $h(n, e) {
        const t = { ...n };
        return (
          n_(n) &&
            n_(e) &&
            Object.keys(e).forEach((i) => {
              n_(e[i])
                ? i in n
                  ? (t[i] = $h(n[i], e[i]))
                  : Object.assign(t, { [i]: e[i] })
                : Object.assign(t, { [i]: e[i] });
            }),
          t
        );
      }
      class bt {
        constructor(e = {}) {
          (this.type = "extension"),
            (this.name = "extension"),
            (this.parent = null),
            (this.child = null),
            (this.config = { name: this.name, defaultOptions: {} }),
            (this.config = { ...this.config, ...e }),
            (this.name = this.config.name),
            e.defaultOptions &&
              console.warn(
                `[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`
              ),
            (this.options = this.config.defaultOptions),
            this.config.addOptions &&
              (this.options = de(L(this, "addOptions", { name: this.name }))),
            (this.storage =
              de(
                L(this, "addStorage", {
                  name: this.name,
                  options: this.options,
                })
              ) || {});
        }
        static create(e = {}) {
          return new bt(e);
        }
        configure(e = {}) {
          const t = this.extend();
          return (
            (t.options = $h(this.options, e)),
            (t.storage = de(
              L(t, "addStorage", { name: t.name, options: t.options })
            )),
            t
          );
        }
        extend(e = {}) {
          const t = new bt(e);
          return (
            (t.parent = this),
            (this.child = t),
            (t.name = e.name ? e.name : t.parent.name),
            e.defaultOptions &&
              console.warn(
                `[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${t.name}".`
              ),
            (t.options = de(L(t, "addOptions", { name: t.name }))),
            (t.storage = de(
              L(t, "addStorage", { name: t.name, options: t.options })
            )),
            t
          );
        }
      }
      function PA(n, e, t) {
        const { from: i, to: r } = e,
          { blockSeparator: o = "\n\n", textSerializers: s = {} } = t || {};
        let a = "",
          l = !0;
        return (
          n.nodesBetween(i, r, (c, u, d, h) => {
            var f;
            const p = s?.[c.type.name];
            p
              ? (c.isBlock && !l && ((a += o), (l = !0)),
                d &&
                  (a += p({ node: c, pos: u, parent: d, index: h, range: e })))
              : c.isText
              ? ((a +=
                  null === (f = c?.text) || void 0 === f
                    ? void 0
                    : f.slice(Math.max(i, u) - u, r - u)),
                (l = !1))
              : c.isBlock && !l && ((a += o), (l = !0));
          }),
          a
        );
      }
      function i_(n) {
        return Object.fromEntries(
          Object.entries(n.nodes)
            .filter(([, e]) => e.spec.toText)
            .map(([e, t]) => [e, t.spec.toText])
        );
      }
      const M5 = bt.create({
        name: "clipboardTextSerializer",
        addProseMirrorPlugins() {
          return [
            new Qe({
              key: new It("clipboardTextSerializer"),
              props: {
                clipboardTextSerializer: () => {
                  const { editor: n } = this,
                    { state: e, schema: t } = n,
                    { doc: i, selection: r } = e,
                    { ranges: o } = r;
                  return PA(
                    i,
                    {
                      from: Math.min(...o.map((u) => u.$from.pos)),
                      to: Math.max(...o.map((u) => u.$to.pos)),
                    },
                    { textSerializers: i_(t) }
                  );
                },
              },
            }),
          ];
        },
      });
      function Wh(n, e, t = { strict: !0 }) {
        const i = Object.keys(e);
        return (
          !i.length ||
          i.every((r) =>
            t.strict
              ? e[r] === n[r]
              : Xv(e[r])
              ? e[r].test(n[r])
              : e[r] === n[r]
          )
        );
      }
      function r_(n, e, t = {}) {
        return n.find((i) => i.type === e && Wh(i.attrs, t));
      }
      function L5(n, e, t = {}) {
        return !!r_(n, e, t);
      }
      function o_(n, e, t = {}) {
        if (!n || !e) return;
        let i = n.parent.childAfter(n.parentOffset);
        if (
          (n.parentOffset === i.offset &&
            0 !== i.offset &&
            (i = n.parent.childBefore(n.parentOffset)),
          !i.node)
        )
          return;
        const r = r_([...i.node.marks], e, t);
        if (!r) return;
        let o = i.index,
          s = n.start() + i.offset,
          a = o + 1,
          l = s + i.node.nodeSize;
        for (
          r_([...i.node.marks], e, t);
          o > 0 && r.isInSet(n.parent.child(o - 1).marks);

        )
          (o -= 1), (s -= n.parent.child(o).nodeSize);
        for (
          ;
          a < n.parent.childCount && L5([...n.parent.child(a).marks], e, t);

        )
          (l += n.parent.child(a).nodeSize), (a += 1);
        return { from: s, to: l };
      }
      function Do(n, e) {
        if ("string" == typeof n) {
          if (!e.marks[n])
            throw Error(
              `There is no mark type named '${n}'. Maybe you forgot to add the extension?`
            );
          return e.marks[n];
        }
        return n;
      }
      function FA(n) {
        return (
          n &&
          "object" == typeof n &&
          !Array.isArray(n) &&
          !(function j5(n) {
            var e;
            return (
              "class" ===
              (null === (e = n.constructor) || void 0 === e
                ? void 0
                : e.toString().substring(0, 5))
            );
          })(n)
        );
      }
      function s_(n) {
        return FA(n) && n instanceof ue;
      }
      function Ar(n = 0, e = 0, t = 0) {
        return Math.min(Math.max(n, e), t);
      }
      function LA(n, e = null) {
        if (!e) return null;
        const t = ce.atStart(n),
          i = ce.atEnd(n);
        if ("start" === e || !0 === e) return t;
        if ("end" === e) return i;
        const r = t.from,
          o = i.to;
        return "all" === e
          ? ue.create(n, Ar(0, r, o), Ar(n.content.size, r, o))
          : ue.create(n, Ar(e, r, o), Ar(e, r, o));
      }
      function Gh() {
        return (
          [
            "iPad Simulator",
            "iPhone Simulator",
            "iPod Simulator",
            "iPad",
            "iPhone",
            "iPod",
          ].includes(navigator.platform) ||
          (navigator.userAgent.includes("Mac") && "ontouchend" in document)
        );
      }
      function a_(n) {
        const e = `<body>${n}</body>`;
        return new window.DOMParser().parseFromString(e, "text/html").body;
      }
      function qh(n, e, t) {
        if (
          ((t = { slice: !0, parseOptions: {}, ...t }),
          "object" == typeof n && null !== n)
        )
          try {
            return Array.isArray(n)
              ? I.fromArray(n.map((i) => e.nodeFromJSON(i)))
              : e.nodeFromJSON(n);
          } catch (i) {
            return (
              console.warn(
                "[tiptap warn]: Invalid content.",
                "Passed value:",
                n,
                "Error:",
                i
              ),
              qh("", e, t)
            );
          }
        if ("string" == typeof n) {
          const i = Sa.fromSchema(e);
          return t.slice
            ? i.parseSlice(a_(n), t.parseOptions).content
            : i.parse(a_(n), t.parseOptions);
        }
        return qh("", e, t);
      }
      function VA() {
        return typeof navigator < "u" && /Mac/.test(navigator.platform);
      }
      function Pc(n, e, t = {}) {
        const { from: i, to: r, empty: o } = n.selection,
          s = e ? Pt(e, n.schema) : null,
          a = [];
        n.doc.nodesBetween(i, r, (d, h) => {
          if (d.isText) return;
          const f = Math.max(i, h),
            p = Math.min(r, h + d.nodeSize);
          a.push({ node: d, from: f, to: p });
        });
        const l = r - i,
          c = a
            .filter((d) => !s || s.name === d.node.type.name)
            .filter((d) => Wh(d.node.attrs, t, { strict: !1 }));
        return o ? !!c.length : c.reduce((d, h) => d + h.to - h.from, 0) >= l;
      }
      function Kh(n, e) {
        return e.nodes[n] ? "node" : e.marks[n] ? "mark" : null;
      }
      function BA(n, e) {
        const t = "string" == typeof e ? [e] : e;
        return Object.keys(n).reduce(
          (i, r) => (t.includes(r) || (i[r] = n[r]), i),
          {}
        );
      }
      function jA(n, e, t = {}) {
        return qh(n, e, { slice: !1, parseOptions: t });
      }
      function HA(n, e) {
        const t = Do(e, n.schema),
          { from: i, to: r, empty: o } = n.selection,
          s = [];
        o
          ? (n.storedMarks && s.push(...n.storedMarks),
            s.push(...n.selection.$head.marks()))
          : n.doc.nodesBetween(i, r, (l) => {
              s.push(...l.marks);
            });
        const a = s.find((l) => l.type.name === t.name);
        return a ? { ...a.attrs } : {};
      }
      function Yh(n, e, t) {
        return Object.fromEntries(
          Object.entries(t).filter(([i]) => {
            const r = n.find((o) => o.type === e && o.name === i);
            return !!r && r.attribute.keepOnSplit;
          })
        );
      }
      function UA(n, e) {
        const t =
          n.storedMarks ||
          (n.selection.$to.parentOffset && n.selection.$from.marks());
        if (t) {
          const i = t.filter((r) => e?.includes(r.type.name));
          n.tr.ensureMarks(i);
        }
      }
      function l_(n) {
        return (e) =>
          (function _6(n, e) {
            for (let t = n.depth; t > 0; t -= 1) {
              const i = n.node(t);
              if (e(i))
                return {
                  pos: t > 0 ? n.before(t) : 0,
                  start: n.start(t),
                  depth: t,
                  node: i,
                };
            }
          })(e.$from, n);
      }
      function zA(n, e) {
        const { nodeExtensions: t } = zh(e),
          i = t.find((s) => s.name === n);
        if (!i) return !1;
        const o = de(
          L(i, "group", {
            name: i.name,
            options: i.options,
            storage: i.storage,
          })
        );
        return "string" == typeof o && o.split(" ").includes("list");
      }
      const $A = (n, e) => {
          const t = l_((s) => s.type === e)(n.selection);
          if (!t) return !0;
          const i = n.doc.resolve(Math.max(0, t.pos - 1)).before(t.depth);
          if (void 0 === i) return !0;
          const r = n.doc.nodeAt(i);
          return (
            t.node.type === r?.type && wc(n.doc, t.pos) && n.join(t.pos), !0
          );
        },
        WA = (n, e) => {
          const t = l_((s) => s.type === e)(n.selection);
          if (!t) return !0;
          const i = n.doc.resolve(t.start).after(t.depth);
          if (void 0 === i) return !0;
          const r = n.doc.nodeAt(i);
          return t.node.type === r?.type && wc(n.doc, i) && n.join(i), !0;
        };
      function c_(n, e, t = {}) {
        const { empty: i, ranges: r } = n.selection,
          o = e ? Do(e, n.schema) : null;
        if (i)
          return !!(n.storedMarks || n.selection.$from.marks())
            .filter((d) => !o || o.name === d.type.name)
            .find((d) => Wh(d.attrs, t, { strict: !1 }));
        let s = 0;
        const a = [];
        if (
          (r.forEach(({ $from: d, $to: h }) => {
            const f = d.pos,
              p = h.pos;
            n.doc.nodesBetween(f, p, (g, m) => {
              if (!g.isText && !g.marks.length) return;
              const v = Math.max(f, m),
                _ = Math.min(p, m + g.nodeSize);
              (s += _ - v),
                a.push(...g.marks.map((y) => ({ mark: y, from: v, to: _ })));
            });
          }),
          0 === s)
        )
          return !1;
        const l = a
            .filter((d) => !o || o.name === d.mark.type.name)
            .filter((d) => Wh(d.mark.attrs, t, { strict: !1 }))
            .reduce((d, h) => d + h.to - h.from, 0),
          c = a
            .filter((d) => !o || (d.mark.type !== o && d.mark.type.excludes(o)))
            .reduce((d, h) => d + h.to - h.from, 0);
        return (l > 0 ? l + c : l) >= s;
      }
      var D6 = Object.freeze({
        __proto__: null,
        blur:
          () =>
          ({ editor: n, view: e }) => (
            requestAnimationFrame(() => {
              var t;
              n.isDestroyed ||
                (e.dom.blur(),
                null === (t = window?.getSelection()) ||
                  void 0 === t ||
                  t.removeAllRanges());
            }),
            !0
          ),
        clearContent:
          (n = !1) =>
          ({ commands: e }) =>
            e.setContent("", n),
        clearNodes:
          () =>
          ({ state: n, tr: e, dispatch: t }) => {
            const { selection: i } = e,
              { ranges: r } = i;
            return (
              t &&
                r.forEach(({ $from: o, $to: s }) => {
                  n.doc.nodesBetween(o.pos, s.pos, (a, l) => {
                    if (a.type.isText) return;
                    const { doc: c, mapping: u } = e,
                      d = c.resolve(u.map(l)),
                      h = c.resolve(u.map(l + a.nodeSize)),
                      f = d.blockRange(h);
                    if (!f) return;
                    const p = Ia(f);
                    if (a.type.isTextblock) {
                      const { defaultType: g } = d.parent.contentMatchAt(
                        d.index()
                      );
                      e.setNodeMarkup(f.start, g);
                    }
                    (p || 0 === p) && e.lift(f, p);
                  });
                }),
              !0
            );
          },
        command: (n) => (e) => n(e),
        createParagraphNear:
          () =>
          ({ state: n, dispatch: e }) =>
            bA(n, e),
        deleteNode:
          (n) =>
          ({ tr: e, state: t, dispatch: i }) => {
            const r = Pt(n, t.schema),
              o = e.selection.$anchor;
            for (let s = o.depth; s > 0; s -= 1)
              if (o.node(s).type === r) {
                if (i) {
                  const l = o.before(s),
                    c = o.after(s);
                  e.delete(l, c).scrollIntoView();
                }
                return !0;
              }
            return !1;
          },
        deleteRange:
          (n) =>
          ({ tr: e, dispatch: t }) => {
            const { from: i, to: r } = n;
            return t && e.delete(i, r), !0;
          },
        deleteSelection:
          () =>
          ({ state: n, dispatch: e }) =>
            Gv(n, e),
        enter:
          () =>
          ({ commands: n }) =>
            n.keyboardShortcut("Enter"),
        exitCode:
          () =>
          ({ state: n, dispatch: e }) =>
            _A(n, e),
        extendMarkRange:
          (n, e = {}) =>
          ({ tr: t, state: i, dispatch: r }) => {
            const o = Do(n, i.schema),
              { doc: s, selection: a } = t,
              { $from: l, from: c, to: u } = a;
            if (r) {
              const d = o_(l, o, e);
              if (d && d.from <= c && d.to >= u) {
                const h = ue.create(s, d.from, d.to);
                t.setSelection(h);
              }
            }
            return !0;
          },
        first: (n) => (e) => {
          const t = "function" == typeof n ? n(e) : n;
          for (let i = 0; i < t.length; i += 1) if (t[i](e)) return !0;
          return !1;
        },
        focus:
          (n = null, e = {}) =>
          ({ editor: t, view: i, tr: r, dispatch: o }) => {
            e = { scrollIntoView: !0, ...e };
            const s = () => {
              Gh() && i.dom.focus(),
                requestAnimationFrame(() => {
                  t.isDestroyed ||
                    (i.focus(),
                    e?.scrollIntoView && t.commands.scrollIntoView());
                });
            };
            if ((i.hasFocus() && null === n) || !1 === n) return !0;
            if (o && null === n && !s_(t.state.selection)) return s(), !0;
            const a = LA(r.doc, n) || t.state.selection,
              l = t.state.selection.eq(a);
            return (
              o &&
                (l || r.setSelection(a),
                l && r.storedMarks && r.setStoredMarks(r.storedMarks),
                s()),
              !0
            );
          },
        forEach: (n, e) => (t) => n.every((i, r) => e(i, { ...t, index: r })),
        insertContent:
          (n, e) =>
          ({ tr: t, commands: i }) =>
            i.insertContentAt(
              { from: t.selection.from, to: t.selection.to },
              n,
              e
            ),
        insertContentAt:
          (n, e, t) =>
          ({ tr: i, dispatch: r, editor: o }) => {
            if (r) {
              t = { parseOptions: {}, updateSelection: !0, ...t };
              const s = qh(e, o.schema, {
                parseOptions: { preserveWhitespace: "full", ...t.parseOptions },
              });
              if ("<>" === s.toString()) return !0;
              let { from: a, to: l } =
                  "number" == typeof n ? { from: n, to: n } : n,
                c = !0,
                u = !0;
              if (
                ((((n) => n.toString().startsWith("<"))(s) ? s : [s]).forEach(
                  (h) => {
                    h.check(),
                      (c = !!c && h.isText && 0 === h.marks.length),
                      (u = !!u && h.isBlock);
                  }
                ),
                a === l && u)
              ) {
                const { parent: h } = i.doc.resolve(a);
                h.isTextblock &&
                  !h.type.spec.code &&
                  !h.childCount &&
                  ((a -= 1), (l += 1));
              }
              c ? i.insertText(e, a, l) : i.replaceWith(a, l, s),
                t.updateSelection &&
                  (function $5(n, e, t) {
                    const i = n.steps.length - 1;
                    if (i < e) return;
                    const r = n.steps[i];
                    if (!(r instanceof Jt || r instanceof Rt)) return;
                    let s = 0;
                    n.mapping.maps[i].forEach((a, l, c, u) => {
                      0 === s && (s = u);
                    }),
                      n.setSelection(ce.near(n.doc.resolve(s), t));
                  })(i, i.steps.length - 1, -1);
            }
            return !0;
          },
        joinBackward:
          () =>
          ({ state: n, dispatch: e }) =>
            hA(n, e),
        joinForward:
          () =>
          ({ state: n, dispatch: e }) =>
            gA(n, e),
        keyboardShortcut:
          (n) =>
          ({ editor: e, view: t, tr: i, dispatch: r }) => {
            const o = (function Y5(n) {
                const e = n.split(/-(?!$)/);
                let i,
                  r,
                  o,
                  s,
                  t = e[e.length - 1];
                "Space" === t && (t = " ");
                for (let a = 0; a < e.length - 1; a += 1) {
                  const l = e[a];
                  if (/^(cmd|meta|m)$/i.test(l)) s = !0;
                  else if (/^a(lt)?$/i.test(l)) i = !0;
                  else if (/^(c|ctrl|control)$/i.test(l)) r = !0;
                  else if (/^s(hift)?$/i.test(l)) o = !0;
                  else {
                    if (!/^mod$/i.test(l))
                      throw new Error(`Unrecognized modifier name: ${l}`);
                    Gh() || VA() ? (s = !0) : (r = !0);
                  }
                }
                return (
                  i && (t = `Alt-${t}`),
                  r && (t = `Ctrl-${t}`),
                  s && (t = `Meta-${t}`),
                  o && (t = `Shift-${t}`),
                  t
                );
              })(n).split(/-(?!$)/),
              s = o.find((c) => !["Alt", "Ctrl", "Meta", "Shift"].includes(c)),
              a = new KeyboardEvent("keydown", {
                key: "Space" === s ? " " : s,
                altKey: o.includes("Alt"),
                ctrlKey: o.includes("Ctrl"),
                metaKey: o.includes("Meta"),
                shiftKey: o.includes("Shift"),
                bubbles: !0,
                cancelable: !0,
              });
            return (
              e
                .captureTransaction(() => {
                  t.someProp("handleKeyDown", (c) => c(t, a));
                })
                ?.steps.forEach((c) => {
                  const u = c.map(i.mapping);
                  u && r && i.maybeStep(u);
                }),
              !0
            );
          },
        lift:
          (n, e = {}) =>
          ({ state: t, dispatch: i }) =>
            !!Pc(t, Pt(n, t.schema), e) &&
            ((n, e) => {
              let { $from: t, $to: i } = n.selection,
                r = t.blockRange(i),
                o = r && Ia(r);
              return (
                null != o && (e && e(n.tr.lift(r, o).scrollIntoView()), !0)
              );
            })(t, i),
        liftEmptyBlock:
          () =>
          ({ state: n, dispatch: e }) =>
            DA(n, e),
        liftListItem:
          (n) =>
          ({ state: e, dispatch: t }) =>
            (function u5(n) {
              return function (e, t) {
                let { $from: i, $to: r } = e.selection,
                  o = i.blockRange(
                    r,
                    (s) => s.childCount > 0 && s.firstChild.type == n
                  );
                return (
                  !!o &&
                  (!t ||
                    (i.node(o.depth - 1).type == n
                      ? (function d5(n, e, t, i) {
                          let r = n.tr,
                            o = i.end,
                            s = i.$to.end(i.depth);
                          return (
                            o < s &&
                              (r.step(
                                new Rt(
                                  o - 1,
                                  s,
                                  o,
                                  s,
                                  new P(
                                    I.from(t.create(null, i.parent.copy())),
                                    1,
                                    0
                                  ),
                                  1,
                                  !0
                                )
                              ),
                              (i = new wh(
                                r.doc.resolve(i.$from.pos),
                                r.doc.resolve(s),
                                i.depth
                              ))),
                            e(r.lift(i, Ia(i)).scrollIntoView()),
                            !0
                          );
                        })(e, t, n, o)
                      : (function h5(n, e, t) {
                          let i = n.tr,
                            r = t.parent;
                          for (
                            let f = t.end, p = t.endIndex - 1, g = t.startIndex;
                            p > g;
                            p--
                          )
                            (f -= r.child(p).nodeSize), i.delete(f - 1, f + 1);
                          let o = i.doc.resolve(t.start),
                            s = o.nodeAfter;
                          if (
                            i.mapping.map(t.end) !=
                            t.start + o.nodeAfter.nodeSize
                          )
                            return !1;
                          let a = 0 == t.startIndex,
                            l = t.endIndex == r.childCount,
                            c = o.node(-1),
                            u = o.index(-1);
                          if (
                            !c.canReplace(
                              u + (a ? 0 : 1),
                              u + 1,
                              s.content.append(l ? I.empty : I.from(r))
                            )
                          )
                            return !1;
                          let d = o.pos,
                            h = d + s.nodeSize;
                          return (
                            i.step(
                              new Rt(
                                d - (a ? 1 : 0),
                                h + (l ? 1 : 0),
                                d + 1,
                                h - 1,
                                new P(
                                  (a
                                    ? I.empty
                                    : I.from(r.copy(I.empty))
                                  ).append(
                                    l ? I.empty : I.from(r.copy(I.empty))
                                  ),
                                  a ? 0 : 1,
                                  l ? 0 : 1
                                ),
                                a ? 0 : 1
                              )
                            ),
                            e(i.scrollIntoView()),
                            !0
                          );
                        })(e, t, o)))
                );
              };
            })(Pt(n, e.schema))(e, t),
        newlineInCode:
          () =>
          ({ state: n, dispatch: e }) =>
            vA(n, e),
        resetAttributes:
          (n, e) =>
          ({ tr: t, state: i, dispatch: r }) => {
            let o = null,
              s = null;
            const a = Kh("string" == typeof n ? n : n.name, i.schema);
            return (
              !!a &&
              ("node" === a && (o = Pt(n, i.schema)),
              "mark" === a && (s = Do(n, i.schema)),
              r &&
                t.selection.ranges.forEach((l) => {
                  i.doc.nodesBetween(l.$from.pos, l.$to.pos, (c, u) => {
                    o &&
                      o === c.type &&
                      t.setNodeMarkup(u, void 0, BA(c.attrs, e)),
                      s &&
                        c.marks.length &&
                        c.marks.forEach((d) => {
                          s === d.type &&
                            t.addMark(
                              u,
                              u + c.nodeSize,
                              s.create(BA(d.attrs, e))
                            );
                        });
                  });
                }),
              !0)
            );
          },
        scrollIntoView:
          () =>
          ({ tr: n, dispatch: e }) => (e && n.scrollIntoView(), !0),
        selectAll:
          () =>
          ({ tr: n, commands: e }) =>
            e.setTextSelection({ from: 0, to: n.doc.content.size }),
        selectNodeBackward:
          () =>
          ({ state: n, dispatch: e }) =>
            fA(n, e),
        selectNodeForward:
          () =>
          ({ state: n, dispatch: e }) =>
            mA(n, e),
        selectParentNode:
          () =>
          ({ state: n, dispatch: e }) =>
            ((n, e) => {
              let r,
                { $from: t, to: i } = n.selection,
                o = t.sharedDepth(i);
              return (
                0 != o &&
                ((r = t.before(o)),
                e && e(n.tr.setSelection(Y.create(n.doc, r))),
                !0)
              );
            })(n, e),
        selectTextblockEnd:
          () =>
          ({ state: n, dispatch: e }) =>
            MA(n, e),
        selectTextblockStart:
          () =>
          ({ state: n, dispatch: e }) =>
            SA(n, e),
        setContent:
          (n, e = !1, t = {}) =>
          ({ tr: i, editor: r, dispatch: o }) => {
            const { doc: s } = i,
              a = jA(n, r.schema, t);
            return (
              o &&
                i
                  .replaceWith(0, s.content.size, a)
                  .setMeta("preventUpdate", !e),
              !0
            );
          },
        setMark:
          (n, e = {}) =>
          ({ tr: t, state: i, dispatch: r }) => {
            const { selection: o } = t,
              { empty: s, ranges: a } = o,
              l = Do(n, i.schema);
            if (r)
              if (s) {
                const c = HA(i, l);
                t.addStoredMark(l.create({ ...c, ...e }));
              } else
                a.forEach((c) => {
                  const u = c.$from.pos,
                    d = c.$to.pos;
                  i.doc.nodesBetween(u, d, (h, f) => {
                    const p = Math.max(f, u),
                      g = Math.min(f + h.nodeSize, d);
                    h.marks.find((v) => v.type === l)
                      ? h.marks.forEach((v) => {
                          l === v.type &&
                            t.addMark(p, g, l.create({ ...v.attrs, ...e }));
                        })
                      : t.addMark(p, g, l.create(e));
                  });
                });
            return !0;
          },
        setMeta:
          (n, e) =>
          ({ tr: t }) => (t.setMeta(n, e), !0),
        setNode:
          (n, e = {}) =>
          ({ state: t, dispatch: i, chain: r }) => {
            const o = Pt(n, t.schema);
            return o.isTextblock
              ? r()
                  .command(({ commands: s }) => !!IA(o, e)(t) || s.clearNodes())
                  .command(({ state: s }) => IA(o, e)(s, i))
                  .run()
              : (console.warn(
                  '[tiptap warn]: Currently "setNode()" only supports text block nodes.'
                ),
                !1);
          },
        setNodeSelection:
          (n) =>
          ({ tr: e, dispatch: t }) => {
            if (t) {
              const { doc: i } = e,
                r = ce.atStart(i).from,
                o = ce.atEnd(i).to,
                s = Ar(n, r, o),
                a = Y.create(i, s);
              e.setSelection(a);
            }
            return !0;
          },
        setTextSelection:
          (n) =>
          ({ tr: e, dispatch: t }) => {
            if (t) {
              const { doc: i } = e,
                { from: r, to: o } =
                  "number" == typeof n ? { from: n, to: n } : n,
                s = ue.atStart(i).from,
                a = ue.atEnd(i).to,
                l = Ar(r, s, a),
                c = Ar(o, s, a),
                u = ue.create(i, l, c);
              e.setSelection(u);
            }
            return !0;
          },
        sinkListItem:
          (n) =>
          ({ state: e, dispatch: t }) =>
            (function f5(n) {
              return function (e, t) {
                let { $from: i, $to: r } = e.selection,
                  o = i.blockRange(
                    r,
                    (c) => c.childCount > 0 && c.firstChild.type == n
                  );
                if (!o) return !1;
                let s = o.startIndex;
                if (0 == s) return !1;
                let a = o.parent,
                  l = a.child(s - 1);
                if (l.type != n) return !1;
                if (t) {
                  let c = l.lastChild && l.lastChild.type == a.type,
                    u = I.from(c ? n.create() : null),
                    d = new P(
                      I.from(n.create(null, I.from(a.type.create(null, u)))),
                      c ? 3 : 1,
                      0
                    ),
                    h = o.start,
                    f = o.end;
                  t(
                    e.tr
                      .step(new Rt(h - (c ? 3 : 1), f, h, f, d, 1, !0))
                      .scrollIntoView()
                  );
                }
                return !0;
              };
            })(Pt(n, e.schema))(e, t),
        splitBlock:
          ({ keepMarks: n = !0 } = {}) =>
          ({ tr: e, state: t, dispatch: i, editor: r }) => {
            const { selection: o, doc: s } = e,
              { $from: a, $to: l } = o,
              u = Yh(
                r.extensionManager.attributes,
                a.node().type.name,
                a.node().attrs
              );
            if (o instanceof Y && o.node.isBlock)
              return !(
                !a.parentOffset ||
                !Tr(s, a.pos) ||
                (i &&
                  (n && UA(t, r.extensionManager.splittableMarks),
                  e.split(a.pos).scrollIntoView()),
                0)
              );
            if (!a.parent.isBlock) return !1;
            if (i) {
              const d = l.parentOffset === l.parent.content.size;
              o instanceof ue && e.deleteSelection();
              const h =
                0 === a.depth
                  ? void 0
                  : (function m6(n) {
                      for (let e = 0; e < n.edgeCount; e += 1) {
                        const { type: t } = n.edge(e);
                        if (t.isTextblock && !t.hasRequiredAttrs()) return t;
                      }
                      return null;
                    })(a.node(-1).contentMatchAt(a.indexAfter(-1)));
              let f = d && h ? [{ type: h, attrs: u }] : void 0,
                p = Tr(e.doc, e.mapping.map(a.pos), 1, f);
              if (
                (!f &&
                  !p &&
                  Tr(
                    e.doc,
                    e.mapping.map(a.pos),
                    1,
                    h ? [{ type: h }] : void 0
                  ) &&
                  ((p = !0), (f = h ? [{ type: h, attrs: u }] : void 0)),
                p &&
                  (e.split(e.mapping.map(a.pos), 1, f),
                  h && !d && !a.parentOffset && a.parent.type !== h))
              ) {
                const g = e.mapping.map(a.before()),
                  m = e.doc.resolve(g);
                a.node(-1).canReplaceWith(m.index(), m.index() + 1, h) &&
                  e.setNodeMarkup(e.mapping.map(a.before()), h);
              }
              n && UA(t, r.extensionManager.splittableMarks),
                e.scrollIntoView();
            }
            return !0;
          },
        splitListItem:
          (n) =>
          ({ tr: e, state: t, dispatch: i, editor: r }) => {
            var o;
            const s = Pt(n, t.schema),
              { $from: a, $to: l } = t.selection,
              c = t.selection.node;
            if ((c && c.isBlock) || a.depth < 2 || !a.sameParent(l)) return !1;
            const u = a.node(-1);
            if (u.type !== s) return !1;
            const d = r.extensionManager.attributes;
            if (
              0 === a.parent.content.size &&
              a.node(-1).childCount === a.indexAfter(-1)
            ) {
              if (
                2 === a.depth ||
                a.node(-3).type !== s ||
                a.index(-2) !== a.node(-2).childCount - 1
              )
                return !1;
              if (i) {
                let m = I.empty;
                const v = a.index(-1) ? 1 : a.index(-2) ? 2 : 3;
                for (let R = a.depth - v; R >= a.depth - 3; R -= 1)
                  m = I.from(a.node(R).copy(m));
                const _ =
                    a.indexAfter(-1) < a.node(-2).childCount
                      ? 1
                      : a.indexAfter(-2) < a.node(-3).childCount
                      ? 2
                      : 3,
                  b = Yh(d, a.node().type.name, a.node().attrs),
                  y =
                    (null === (o = s.contentMatch.defaultType) || void 0 === o
                      ? void 0
                      : o.createAndFill(b)) || void 0;
                m = m.append(I.from(s.createAndFill(null, y) || void 0));
                const D = a.before(a.depth - (v - 1));
                e.replace(D, a.after(-_), new P(m, 4 - v, 0));
                let C = -1;
                e.doc.nodesBetween(D, e.doc.content.size, (R, S) => {
                  if (C > -1) return !1;
                  R.isTextblock && 0 === R.content.size && (C = S + 1);
                }),
                  C > -1 && e.setSelection(ue.near(e.doc.resolve(C))),
                  e.scrollIntoView();
              }
              return !0;
            }
            const h =
                l.pos === a.end() ? u.contentMatchAt(0).defaultType : null,
              f = Yh(d, u.type.name, u.attrs),
              p = Yh(d, a.node().type.name, a.node().attrs);
            e.delete(a.pos, l.pos);
            const g = h
              ? [
                  { type: s, attrs: f },
                  { type: h, attrs: p },
                ]
              : [{ type: s, attrs: f }];
            return (
              !!Tr(e.doc, a.pos, 2) &&
              (i && e.split(a.pos, 2, g).scrollIntoView(), !0)
            );
          },
        toggleList:
          (n, e) =>
          ({
            editor: t,
            tr: i,
            state: r,
            dispatch: o,
            chain: s,
            commands: a,
            can: l,
          }) => {
            const { extensions: c } = t.extensionManager,
              u = Pt(n, r.schema),
              d = Pt(e, r.schema),
              { selection: h } = r,
              { $from: f, $to: p } = h,
              g = f.blockRange(p);
            if (!g) return !1;
            const m = l_((v) => zA(v.type.name, c))(h);
            if (g.depth >= 1 && m && g.depth - m.depth <= 1) {
              if (m.node.type === u) return a.liftListItem(d);
              if (
                zA(m.node.type.name, c) &&
                u.validContent(m.node.content) &&
                o
              )
                return s()
                  .command(() => (i.setNodeMarkup(m.pos, u), !0))
                  .command(() => $A(i, u))
                  .command(() => WA(i, u))
                  .run();
            }
            return s()
              .command(() => !!l().wrapInList(u) || a.clearNodes())
              .wrapInList(u)
              .command(() => $A(i, u))
              .command(() => WA(i, u))
              .run();
          },
        toggleMark:
          (n, e = {}, t = {}) =>
          ({ state: i, commands: r }) => {
            const { extendEmptyMarkRange: o = !1 } = t,
              s = Do(n, i.schema);
            return c_(i, s, e)
              ? r.unsetMark(s, { extendEmptyMarkRange: o })
              : r.setMark(s, e);
          },
        toggleNode:
          (n, e, t = {}) =>
          ({ state: i, commands: r }) => {
            const o = Pt(n, i.schema),
              s = Pt(e, i.schema);
            return Pc(i, o, t) ? r.setNode(s) : r.setNode(o, t);
          },
        toggleWrap:
          (n, e = {}) =>
          ({ state: t, commands: i }) => {
            const r = Pt(n, t.schema);
            return Pc(t, r, e) ? i.lift(r) : i.wrapIn(r, e);
          },
        undoInputRule:
          () =>
          ({ state: n, dispatch: e }) => {
            const t = n.plugins;
            for (let i = 0; i < t.length; i += 1) {
              const r = t[i];
              let o;
              if (r.spec.isInputRules && (o = r.getState(n))) {
                if (e) {
                  const s = n.tr,
                    a = o.transform;
                  for (let l = a.steps.length - 1; l >= 0; l -= 1)
                    s.step(a.steps[l].invert(a.docs[l]));
                  if (o.text) {
                    const l = s.doc.resolve(o.from).marks();
                    s.replaceWith(o.from, o.to, n.schema.text(o.text, l));
                  } else s.delete(o.from, o.to);
                }
                return !0;
              }
            }
            return !1;
          },
        unsetAllMarks:
          () =>
          ({ tr: n, dispatch: e }) => {
            const { selection: t } = n,
              { empty: i, ranges: r } = t;
            return (
              i ||
                (e &&
                  r.forEach((o) => {
                    n.removeMark(o.$from.pos, o.$to.pos);
                  })),
              !0
            );
          },
        unsetMark:
          (n, e = {}) =>
          ({ tr: t, state: i, dispatch: r }) => {
            var o;
            const { extendEmptyMarkRange: s = !1 } = e,
              { selection: a } = t,
              l = Do(n, i.schema),
              { $from: c, empty: u, ranges: d } = a;
            if (!r) return !0;
            if (u && s) {
              let { from: h, to: f } = a;
              const p =
                  null === (o = c.marks().find((m) => m.type === l)) ||
                  void 0 === o
                    ? void 0
                    : o.attrs,
                g = o_(c, l, p);
              g && ((h = g.from), (f = g.to)), t.removeMark(h, f, l);
            } else
              d.forEach((h) => {
                t.removeMark(h.$from.pos, h.$to.pos, l);
              });
            return t.removeStoredMark(l), !0;
          },
        updateAttributes:
          (n, e = {}) =>
          ({ tr: t, state: i, dispatch: r }) => {
            let o = null,
              s = null;
            const a = Kh("string" == typeof n ? n : n.name, i.schema);
            return (
              !!a &&
              ("node" === a && (o = Pt(n, i.schema)),
              "mark" === a && (s = Do(n, i.schema)),
              r &&
                t.selection.ranges.forEach((l) => {
                  const c = l.$from.pos,
                    u = l.$to.pos;
                  i.doc.nodesBetween(c, u, (d, h) => {
                    o &&
                      o === d.type &&
                      t.setNodeMarkup(h, void 0, { ...d.attrs, ...e }),
                      s &&
                        d.marks.length &&
                        d.marks.forEach((f) => {
                          if (s === f.type) {
                            const p = Math.max(h, c),
                              g = Math.min(h + d.nodeSize, u);
                            t.addMark(p, g, s.create({ ...f.attrs, ...e }));
                          }
                        });
                  });
                }),
              !0)
            );
          },
        wrapIn:
          (n, e = {}) =>
          ({ state: t, dispatch: i }) =>
            (function QW(n, e = null) {
              return function (t, i) {
                let { $from: r, $to: o } = t.selection,
                  s = r.blockRange(o),
                  a = s && cv(s, n, e);
                return !!a && (i && i(t.tr.wrap(s, a).scrollIntoView()), !0);
              };
            })(Pt(n, t.schema), e)(t, i),
        wrapInList:
          (n, e = {}) =>
          ({ state: t, dispatch: i }) =>
            (function l5(n, e = null) {
              return function (t, i) {
                let { $from: r, $to: o } = t.selection,
                  s = r.blockRange(o),
                  a = !1,
                  l = s;
                if (!s) return !1;
                if (
                  s.depth >= 2 &&
                  r.node(s.depth - 1).type.compatibleContent(n) &&
                  0 == s.startIndex
                ) {
                  if (0 == r.index(s.depth - 1)) return !1;
                  let u = t.doc.resolve(s.start - 2);
                  (l = new wh(u, u, s.depth)),
                    s.endIndex < s.parent.childCount &&
                      (s = new wh(r, t.doc.resolve(o.end(s.depth)), s.depth)),
                    (a = !0);
                }
                let c = cv(l, n, e, s);
                return (
                  !!c &&
                  (i &&
                    i(
                      (function c5(n, e, t, i, r) {
                        let o = I.empty;
                        for (let u = t.length - 1; u >= 0; u--)
                          o = I.from(t[u].type.create(t[u].attrs, o));
                        n.step(
                          new Rt(
                            e.start - (i ? 2 : 0),
                            e.end,
                            e.start,
                            e.end,
                            new P(o, 0, 0),
                            t.length,
                            !0
                          )
                        );
                        let s = 0;
                        for (let u = 0; u < t.length; u++)
                          t[u].type == r && (s = u + 1);
                        let a = t.length - s,
                          l = e.start + t.length - (i ? 2 : 0),
                          c = e.parent;
                        for (
                          let u = e.startIndex, d = e.endIndex, h = !0;
                          u < d;
                          u++, h = !1
                        )
                          !h &&
                            Tr(n.doc, l, a) &&
                            (n.split(l, a), (l += 2 * a)),
                            (l += c.child(u).nodeSize);
                        return n;
                      })(t.tr, s, c, a, n).scrollIntoView()
                    ),
                  !0)
                );
              };
            })(Pt(n, t.schema), e)(t, i),
      });
      const C6 = bt.create({
          name: "commands",
          addCommands: () => ({ ...D6 }),
        }),
        E6 = bt.create({
          name: "editable",
          addProseMirrorPlugins() {
            return [
              new Qe({
                key: new It("editable"),
                props: { editable: () => this.editor.options.editable },
              }),
            ];
          },
        }),
        w6 = bt.create({
          name: "focusEvents",
          addProseMirrorPlugins() {
            const { editor: n } = this;
            return [
              new Qe({
                key: new It("focusEvents"),
                props: {
                  handleDOMEvents: {
                    focus: (e, t) => {
                      n.isFocused = !0;
                      const i = n.state.tr
                        .setMeta("focus", { event: t })
                        .setMeta("addToHistory", !1);
                      return e.dispatch(i), !1;
                    },
                    blur: (e, t) => {
                      n.isFocused = !1;
                      const i = n.state.tr
                        .setMeta("blur", { event: t })
                        .setMeta("addToHistory", !1);
                      return e.dispatch(i), !1;
                    },
                  },
                },
              }),
            ];
          },
        }),
        S6 = bt.create({
          name: "keymap",
          addKeyboardShortcuts() {
            const n = () =>
                this.editor.commands.first(({ commands: s }) => [
                  () => s.undoInputRule(),
                  () =>
                    s.command(({ tr: a }) => {
                      const { selection: l, doc: c } = a,
                        { empty: u, $anchor: d } = l,
                        { pos: h, parent: f } = d,
                        p = ce.atStart(c).from === h;
                      return (
                        !(
                          !(u && p && f.type.isTextblock) ||
                          f.textContent.length
                        ) && s.clearNodes()
                      );
                    }),
                  () => s.deleteSelection(),
                  () => s.joinBackward(),
                  () => s.selectNodeBackward(),
                ]),
              e = () =>
                this.editor.commands.first(({ commands: s }) => [
                  () => s.deleteSelection(),
                  () => s.joinForward(),
                  () => s.selectNodeForward(),
                ]),
              i = {
                Enter: () =>
                  this.editor.commands.first(({ commands: s }) => [
                    () => s.newlineInCode(),
                    () => s.createParagraphNear(),
                    () => s.liftEmptyBlock(),
                    () => s.splitBlock(),
                  ]),
                "Mod-Enter": () => this.editor.commands.exitCode(),
                Backspace: n,
                "Mod-Backspace": n,
                "Shift-Backspace": n,
                Delete: e,
                "Mod-Delete": e,
                "Mod-a": () => this.editor.commands.selectAll(),
              },
              r = { ...i },
              o = {
                ...i,
                "Ctrl-h": n,
                "Alt-Backspace": n,
                "Ctrl-d": e,
                "Ctrl-Alt-Backspace": e,
                "Alt-Delete": e,
                "Alt-d": e,
                "Ctrl-a": () => this.editor.commands.selectTextblockStart(),
                "Ctrl-e": () => this.editor.commands.selectTextblockEnd(),
              };
            return Gh() || VA() ? o : r;
          },
          addProseMirrorPlugins() {
            return [
              new Qe({
                key: new It("clearDocument"),
                appendTransaction: (n, e, t) => {
                  if (!n.some((p) => p.docChanged) || e.doc.eq(t.doc)) return;
                  const { empty: r, from: o, to: s } = e.selection,
                    a = ce.atStart(e.doc).from,
                    l = ce.atEnd(e.doc).to,
                    c = o === a && s === l,
                    u =
                      0 ===
                      t.doc.textBetween(0, t.doc.content.size, " ", " ").length;
                  if (r || !c || !u) return;
                  const d = t.tr,
                    h = Hh({ state: t, transaction: d }),
                    { commands: f } = new Uh({ editor: this.editor, state: h });
                  return f.clearNodes(), d.steps.length ? d : void 0;
                },
              }),
            ];
          },
        }),
        M6 = bt.create({
          name: "tabindex",
          addProseMirrorPlugins() {
            return [
              new Qe({
                key: new It("tabindex"),
                props: {
                  attributes: this.editor.isEditable ? { tabindex: "0" } : {},
                },
              }),
            ];
          },
        });
      var I6 = Object.freeze({
        __proto__: null,
        ClipboardTextSerializer: M5,
        Commands: C6,
        Editable: E6,
        FocusEvents: w6,
        Keymap: S6,
        Tabindex: M6,
      });
      function GA(n, e) {
        const t = Kh("string" == typeof e ? e : e.name, n.schema);
        return "node" === t
          ? (function T6(n, e) {
              const t = Pt(e, n.schema),
                { from: i, to: r } = n.selection,
                o = [];
              n.doc.nodesBetween(i, r, (a) => {
                o.push(a);
              });
              const s = o.reverse().find((a) => a.type.name === t.name);
              return s ? { ...s.attrs } : {};
            })(n, e)
          : "mark" === t
          ? HA(n, e)
          : {};
      }
      class N6 extends class p5 {
        constructor() {
          this.callbacks = {};
        }
        on(e, t) {
          return (
            this.callbacks[e] || (this.callbacks[e] = []),
            this.callbacks[e].push(t),
            this
          );
        }
        emit(e, ...t) {
          const i = this.callbacks[e];
          return i && i.forEach((r) => r.apply(this, t)), this;
        }
        off(e, t) {
          const i = this.callbacks[e];
          return (
            i &&
              (t
                ? (this.callbacks[e] = i.filter((r) => r !== t))
                : delete this.callbacks[e]),
            this
          );
        }
        removeAllListeners() {
          this.callbacks = {};
        }
      } {
        constructor(e = {}) {
          super(),
            (this.isFocused = !1),
            (this.extensionStorage = {}),
            (this.options = {
              element: document.createElement("div"),
              content: "",
              injectCSS: !0,
              injectNonce: void 0,
              extensions: [],
              autofocus: !1,
              editable: !0,
              editorProps: {},
              parseOptions: {},
              enableInputRules: !0,
              enablePasteRules: !0,
              enableCoreExtensions: !0,
              onBeforeCreate: () => null,
              onCreate: () => null,
              onUpdate: () => null,
              onSelectionUpdate: () => null,
              onTransaction: () => null,
              onFocus: () => null,
              onBlur: () => null,
              onDestroy: () => null,
            }),
            (this.isCapturingTransaction = !1),
            (this.capturedTransaction = null),
            this.setOptions(e),
            this.createExtensionManager(),
            this.createCommandManager(),
            this.createSchema(),
            this.on("beforeCreate", this.options.onBeforeCreate),
            this.emit("beforeCreate", { editor: this }),
            this.createView(),
            this.injectCSS(),
            this.on("create", this.options.onCreate),
            this.on("update", this.options.onUpdate),
            this.on("selectionUpdate", this.options.onSelectionUpdate),
            this.on("transaction", this.options.onTransaction),
            this.on("focus", this.options.onFocus),
            this.on("blur", this.options.onBlur),
            this.on("destroy", this.options.onDestroy),
            window.setTimeout(() => {
              this.isDestroyed ||
                (this.commands.focus(this.options.autofocus),
                this.emit("create", { editor: this }));
            }, 0);
        }
        get storage() {
          return this.extensionStorage;
        }
        get commands() {
          return this.commandManager.commands;
        }
        chain() {
          return this.commandManager.chain();
        }
        can() {
          return this.commandManager.can();
        }
        injectCSS() {
          this.options.injectCSS &&
            document &&
            (this.css = (function k6(n, e) {
              const t = document.querySelector("style[data-tiptap-style]");
              if (null !== t) return t;
              const i = document.createElement("style");
              return (
                e && i.setAttribute("nonce", e),
                i.setAttribute("data-tiptap-style", ""),
                (i.innerHTML = n),
                document.getElementsByTagName("head")[0].appendChild(i),
                i
              );
            })(
              '.ProseMirror {\n  position: relative;\n}\n\n.ProseMirror {\n  word-wrap: break-word;\n  white-space: pre-wrap;\n  white-space: break-spaces;\n  -webkit-font-variant-ligatures: none;\n  font-variant-ligatures: none;\n  font-feature-settings: "liga" 0; /* the above doesn\'t seem to work in Edge */\n}\n\n.ProseMirror [contenteditable="false"] {\n  white-space: normal;\n}\n\n.ProseMirror [contenteditable="false"] [contenteditable="true"] {\n  white-space: pre-wrap;\n}\n\n.ProseMirror pre {\n  white-space: pre-wrap;\n}\n\nimg.ProseMirror-separator {\n  display: inline !important;\n  border: none !important;\n  margin: 0 !important;\n  width: 1px !important;\n  height: 1px !important;\n}\n\n.ProseMirror-gapcursor {\n  display: none;\n  pointer-events: none;\n  position: absolute;\n  margin: 0;\n}\n\n.ProseMirror-gapcursor:after {\n  content: "";\n  display: block;\n  position: absolute;\n  top: -2px;\n  width: 20px;\n  border-top: 1px solid black;\n  animation: ProseMirror-cursor-blink 1.1s steps(2, start) infinite;\n}\n\n@keyframes ProseMirror-cursor-blink {\n  to {\n    visibility: hidden;\n  }\n}\n\n.ProseMirror-hideselection *::selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection *::-moz-selection {\n  background: transparent;\n}\n\n.ProseMirror-hideselection * {\n  caret-color: transparent;\n}\n\n.ProseMirror-focused .ProseMirror-gapcursor {\n  display: block;\n}\n\n.tippy-box[data-animation=fade][data-state=hidden] {\n  opacity: 0\n}',
              this.options.injectNonce
            ));
        }
        setOptions(e = {}) {
          (this.options = { ...this.options, ...e }),
            this.view &&
              this.state &&
              !this.isDestroyed &&
              (this.options.editorProps &&
                this.view.setProps(this.options.editorProps),
              this.view.updateState(this.state));
        }
        setEditable(e) {
          this.setOptions({ editable: e });
        }
        get isEditable() {
          return this.options.editable && this.view && this.view.editable;
        }
        get state() {
          return this.view.state;
        }
        registerPlugin(e, t) {
          const i = AA(t)
              ? t(e, [...this.state.plugins])
              : [...this.state.plugins, e],
            r = this.state.reconfigure({ plugins: i });
          this.view.updateState(r);
        }
        unregisterPlugin(e) {
          if (this.isDestroyed) return;
          const t = "string" == typeof e ? `${e}$` : e.key,
            i = this.state.reconfigure({
              plugins: this.state.plugins.filter((r) => !r.key.startsWith(t)),
            });
          this.view.updateState(i);
        }
        createExtensionManager() {
          const t = [
            ...(this.options.enableCoreExtensions ? Object.values(I6) : []),
            ...this.options.extensions,
          ].filter((i) => ["extension", "node", "mark"].includes(i?.type));
          this.extensionManager = new fs(t, this);
        }
        createCommandManager() {
          this.commandManager = new Uh({ editor: this });
        }
        createSchema() {
          this.schema = this.extensionManager.schema;
        }
        createView() {
          const e = jA(
              this.options.content,
              this.schema,
              this.options.parseOptions
            ),
            t = LA(e, this.options.autofocus);
          this.view = new PW(this.options.element, {
            ...this.options.editorProps,
            dispatchTransaction: this.dispatchTransaction.bind(this),
            state: Aa.create({ doc: e, selection: t || void 0 }),
          });
          const i = this.state.reconfigure({
            plugins: this.extensionManager.plugins,
          });
          this.view.updateState(i),
            this.createNodeViews(),
            (this.view.dom.editor = this);
        }
        createNodeViews() {
          this.view.setProps({ nodeViews: this.extensionManager.nodeViews });
        }
        captureTransaction(e) {
          (this.isCapturingTransaction = !0),
            e(),
            (this.isCapturingTransaction = !1);
          const t = this.capturedTransaction;
          return (this.capturedTransaction = null), t;
        }
        dispatchTransaction(e) {
          if (this.isCapturingTransaction)
            return this.capturedTransaction
              ? void e.steps.forEach((s) => {
                  var a;
                  return null === (a = this.capturedTransaction) || void 0 === a
                    ? void 0
                    : a.step(s);
                })
              : void (this.capturedTransaction = e);
          const t = this.state.apply(e),
            i = !this.state.selection.eq(t.selection);
          this.view.updateState(t),
            this.emit("transaction", { editor: this, transaction: e }),
            i && this.emit("selectionUpdate", { editor: this, transaction: e });
          const r = e.getMeta("focus"),
            o = e.getMeta("blur");
          r &&
            this.emit("focus", {
              editor: this,
              event: r.event,
              transaction: e,
            }),
            o &&
              this.emit("blur", {
                editor: this,
                event: o.event,
                transaction: e,
              }),
            e.docChanged &&
              !e.getMeta("preventUpdate") &&
              this.emit("update", { editor: this, transaction: e });
        }
        getAttributes(e) {
          return GA(this.state, e);
        }
        isActive(e, t) {
          return (function x6(n, e, t = {}) {
            if (!e) return Pc(n, null, t) || c_(n, null, t);
            const i = Kh(e, n.schema);
            return "node" === i ? Pc(n, e, t) : "mark" === i && c_(n, e, t);
          })(
            this.state,
            "string" == typeof e ? e : null,
            "string" == typeof e ? t : e
          );
        }
        getJSON() {
          return this.state.doc.toJSON();
        }
        getHTML() {
          return (function qA(n, e) {
            const t = Zi.fromSchema(e).serializeFragment(n),
              r = document.implementation
                .createHTMLDocument()
                .createElement("div");
            return r.appendChild(t), r.innerHTML;
          })(this.state.doc.content, this.schema);
        }
        getText(e) {
          const { blockSeparator: t = "\n\n", textSerializers: i = {} } =
            e || {};
          return (function KA(n, e) {
            return PA(n, { from: 0, to: n.content.size }, e);
          })(this.state.doc, {
            blockSeparator: t,
            textSerializers: { ...i, ...i_(this.schema) },
          });
        }
        get isEmpty() {
          return (function A6(n) {
            var e;
            const t =
                null === (e = n.type.createAndFill()) || void 0 === e
                  ? void 0
                  : e.toJSON(),
              i = n.toJSON();
            return JSON.stringify(t) === JSON.stringify(i);
          })(this.state.doc);
        }
        getCharacterCount() {
          return (
            console.warn(
              '[tiptap warn]: "editor.getCharacterCount()" is deprecated. Please use "editor.storage.characterCount.characters()" instead.'
            ),
            this.state.doc.content.size - 2
          );
        }
        destroy() {
          this.emit("destroy"),
            this.view && this.view.destroy(),
            this.removeAllListeners();
        }
        get isDestroyed() {
          var e;
          return !(null !== (e = this.view) && void 0 !== e && e.docView);
        }
      }
      function Zh(n, e, t) {
        const i = [];
        return (
          n === e
            ? t
                .resolve(n)
                .marks()
                .forEach((r) => {
                  const s = o_(t.resolve(n - 1), r.type);
                  !s || i.push({ mark: r, ...s });
                })
            : t.nodesBetween(n, e, (r, o) => {
                i.push(
                  ...r.marks.map((s) => ({
                    from: o,
                    to: o + r.nodeSize,
                    mark: s,
                  }))
                );
              }),
          i
        );
      }
      function YA(n) {
        return FA(n) && n instanceof Y;
      }
      function Fc(n, e, t) {
        const r = n.state.doc.content.size,
          o = Ar(e, 0, r),
          s = Ar(t, 0, r),
          a = n.coordsAtPos(o),
          l = n.coordsAtPos(s, -1),
          c = Math.min(a.top, l.top),
          u = Math.max(a.bottom, l.bottom),
          d = Math.min(a.left, l.left),
          h = Math.max(a.right, l.right),
          v = {
            top: c,
            bottom: u,
            left: d,
            right: h,
            width: h - d,
            height: u - c,
            x: d,
            y: c,
          };
        return { ...v, toJSON: () => v };
      }
      function ps(n) {
        return new Rc({
          find: n.find,
          handler: ({ state: e, range: t, match: i }) => {
            const r = de(n.getAttributes, void 0, i);
            if (!1 === r || null === r) return null;
            const { tr: o } = e,
              s = i[i.length - 1],
              a = i[0];
            let l = t.to;
            if (s) {
              const c = a.search(/\S/),
                u = t.from + a.indexOf(s),
                d = u + s.length;
              if (
                Zh(t.from, t.to, e.doc)
                  .filter((f) =>
                    f.mark.type.excluded.find(
                      (g) => g === n.type && g !== f.mark.type
                    )
                  )
                  .filter((f) => f.to > u).length
              )
                return null;
              d < t.to && o.delete(d, t.to),
                u > t.from && o.delete(t.from + c, u),
                (l = t.from + c + s.length),
                o.addMark(t.from + c, l, n.type.create(r || {})),
                o.removeStoredMark(n.type);
            }
          },
        });
      }
      function j6(n) {
        return new Rc({
          find: n.find,
          handler: ({ state: e, range: t, match: i }) => {
            const r = de(n.getAttributes, void 0, i) || {},
              { tr: o } = e,
              s = t.from;
            let a = t.to;
            if (i[1]) {
              let c = s + i[0].lastIndexOf(i[1]);
              c > a ? (c = a) : (a = c + i[1].length),
                o.insertText(i[0][i[0].length - 1], s + i[0].length - 1),
                o.replaceWith(c, a, n.type.create(r));
            } else i[0] && o.replaceWith(s, a, n.type.create(r));
          },
        });
      }
      function d_(n) {
        return new Rc({
          find: n.find,
          handler: ({ state: e, range: t, match: i }) => {
            const r = e.doc.resolve(t.from),
              o = de(n.getAttributes, void 0, i) || {};
            if (
              !r.node(-1).canReplaceWith(r.index(-1), r.indexAfter(-1), n.type)
            )
              return null;
            e.tr.delete(t.from, t.to).setBlockType(t.from, t.from, n.type, o);
          },
        });
      }
      function h_(n) {
        return new Rc({
          find: n.find,
          handler: ({ state: e, range: t, match: i }) => {
            const r = de(n.getAttributes, void 0, i) || {},
              o = e.tr.delete(t.from, t.to),
              a = o.doc.resolve(t.from).blockRange(),
              l = a && cv(a, n.type, r);
            if (!l) return null;
            o.wrap(a, l);
            const c = o.doc.resolve(t.from - 1).nodeBefore;
            c &&
              c.type === n.type &&
              wc(o.doc, t.from - 1) &&
              (!n.joinPredicate || n.joinPredicate(i, c)) &&
              o.join(t.from - 1);
          },
        });
      }
      class nr {
        constructor(e = {}) {
          (this.type = "mark"),
            (this.name = "mark"),
            (this.parent = null),
            (this.child = null),
            (this.config = { name: this.name, defaultOptions: {} }),
            (this.config = { ...this.config, ...e }),
            (this.name = this.config.name),
            e.defaultOptions &&
              console.warn(
                `[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`
              ),
            (this.options = this.config.defaultOptions),
            this.config.addOptions &&
              (this.options = de(L(this, "addOptions", { name: this.name }))),
            (this.storage =
              de(
                L(this, "addStorage", {
                  name: this.name,
                  options: this.options,
                })
              ) || {});
        }
        static create(e = {}) {
          return new nr(e);
        }
        configure(e = {}) {
          const t = this.extend();
          return (
            (t.options = $h(this.options, e)),
            (t.storage = de(
              L(t, "addStorage", { name: t.name, options: t.options })
            )),
            t
          );
        }
        extend(e = {}) {
          const t = new nr(e);
          return (
            (t.parent = this),
            (this.child = t),
            (t.name = e.name ? e.name : t.parent.name),
            e.defaultOptions &&
              console.warn(
                `[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${t.name}".`
              ),
            (t.options = de(L(t, "addOptions", { name: t.name }))),
            (t.storage = de(
              L(t, "addStorage", { name: t.name, options: t.options })
            )),
            t
          );
        }
      }
      class en {
        constructor(e = {}) {
          (this.type = "node"),
            (this.name = "node"),
            (this.parent = null),
            (this.child = null),
            (this.config = { name: this.name, defaultOptions: {} }),
            (this.config = { ...this.config, ...e }),
            (this.name = this.config.name),
            e.defaultOptions &&
              console.warn(
                `[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${this.name}".`
              ),
            (this.options = this.config.defaultOptions),
            this.config.addOptions &&
              (this.options = de(L(this, "addOptions", { name: this.name }))),
            (this.storage =
              de(
                L(this, "addStorage", {
                  name: this.name,
                  options: this.options,
                })
              ) || {});
        }
        static create(e = {}) {
          return new en(e);
        }
        configure(e = {}) {
          const t = this.extend();
          return (
            (t.options = $h(this.options, e)),
            (t.storage = de(
              L(t, "addStorage", { name: t.name, options: t.options })
            )),
            t
          );
        }
        extend(e = {}) {
          const t = new en(e);
          return (
            (t.parent = this),
            (this.child = t),
            (t.name = e.name ? e.name : t.parent.name),
            e.defaultOptions &&
              console.warn(
                `[tiptap warn]: BREAKING CHANGE: "defaultOptions" is deprecated. Please use "addOptions" instead. Found in extension: "${t.name}".`
              ),
            (t.options = de(L(t, "addOptions", { name: t.name }))),
            (t.storage = de(
              L(t, "addStorage", { name: t.name, options: t.options })
            )),
            t
          );
        }
      }
      function Co(n) {
        return new t_({
          find: n.find,
          handler: ({ state: e, range: t, match: i }) => {
            const r = de(n.getAttributes, void 0, i);
            if (!1 === r || null === r) return null;
            const { tr: o } = e,
              s = i[i.length - 1],
              a = i[0];
            let l = t.to;
            if (s) {
              const c = a.search(/\S/),
                u = t.from + a.indexOf(s),
                d = u + s.length;
              if (
                Zh(t.from, t.to, e.doc)
                  .filter((f) =>
                    f.mark.type.excluded.find(
                      (g) => g === n.type && g !== f.mark.type
                    )
                  )
                  .filter((f) => f.to > u).length
              )
                return null;
              d < t.to && o.delete(d, t.to),
                u > t.from && o.delete(t.from + c, u),
                (l = t.from + c + s.length),
                o.addMark(t.from + c, l, n.type.create(r || {})),
                o.removeStoredMark(n.type);
            }
          },
        });
      }
      const z6 = /^\s*>\s$/,
        $6 = en.create({
          name: "blockquote",
          addOptions: () => ({ HTMLAttributes: {} }),
          content: "block+",
          group: "block",
          defining: !0,
          parseHTML: () => [{ tag: "blockquote" }],
          renderHTML({ HTMLAttributes: n }) {
            return ["blockquote", _t(this.options.HTMLAttributes, n), 0];
          },
          addCommands() {
            return {
              setBlockquote:
                () =>
                ({ commands: n }) =>
                  n.wrapIn(this.name),
              toggleBlockquote:
                () =>
                ({ commands: n }) =>
                  n.toggleWrap(this.name),
              unsetBlockquote:
                () =>
                ({ commands: n }) =>
                  n.lift(this.name),
            };
          },
          addKeyboardShortcuts() {
            return {
              "Mod-Shift-b": () => this.editor.commands.toggleBlockquote(),
            };
          },
          addInputRules() {
            return [h_({ find: z6, type: this.type })];
          },
        }),
        W6 = /(?:^|\s)((?:\*\*)((?:[^*]+))(?:\*\*))$/,
        G6 = /(?:^|\s)((?:\*\*)((?:[^*]+))(?:\*\*))/g,
        q6 = /(?:^|\s)((?:__)((?:[^__]+))(?:__))$/,
        K6 = /(?:^|\s)((?:__)((?:[^__]+))(?:__))/g,
        Y6 = nr.create({
          name: "bold",
          addOptions: () => ({ HTMLAttributes: {} }),
          parseHTML: () => [
            { tag: "strong" },
            {
              tag: "b",
              getAttrs: (n) => "normal" !== n.style.fontWeight && null,
            },
            {
              style: "font-weight",
              getAttrs: (n) => /^(bold(er)?|[5-9]\d{2,})$/.test(n) && null,
            },
          ],
          renderHTML({ HTMLAttributes: n }) {
            return ["strong", _t(this.options.HTMLAttributes, n), 0];
          },
          addCommands() {
            return {
              setBold:
                () =>
                ({ commands: n }) =>
                  n.setMark(this.name),
              toggleBold:
                () =>
                ({ commands: n }) =>
                  n.toggleMark(this.name),
              unsetBold:
                () =>
                ({ commands: n }) =>
                  n.unsetMark(this.name),
            };
          },
          addKeyboardShortcuts() {
            return {
              "Mod-b": () => this.editor.commands.toggleBold(),
              "Mod-B": () => this.editor.commands.toggleBold(),
            };
          },
          addInputRules() {
            return [
              ps({ find: W6, type: this.type }),
              ps({ find: q6, type: this.type }),
            ];
          },
          addPasteRules() {
            return [
              Co({ find: G6, type: this.type }),
              Co({ find: K6, type: this.type }),
            ];
          },
        }),
        Z6 = /^\s*([-+*])\s$/,
        Q6 = en.create({
          name: "bulletList",
          addOptions: () => ({ itemTypeName: "listItem", HTMLAttributes: {} }),
          group: "block list",
          content() {
            return `${this.options.itemTypeName}+`;
          },
          parseHTML: () => [{ tag: "ul" }],
          renderHTML({ HTMLAttributes: n }) {
            return ["ul", _t(this.options.HTMLAttributes, n), 0];
          },
          addCommands() {
            return {
              toggleBulletList:
                () =>
                ({ commands: n }) =>
                  n.toggleList(this.name, this.options.itemTypeName),
            };
          },
          addKeyboardShortcuts() {
            return {
              "Mod-Shift-8": () => this.editor.commands.toggleBulletList(),
            };
          },
          addInputRules() {
            return [h_({ find: Z6, type: this.type })];
          },
        }),
        J6 = /(?:^|\s)((?:`)((?:[^`]+))(?:`))$/,
        X6 = /(?:^|\s)((?:`)((?:[^`]+))(?:`))/g,
        eG = nr.create({
          name: "code",
          addOptions: () => ({ HTMLAttributes: {} }),
          excludes: "_",
          code: !0,
          parseHTML: () => [{ tag: "code" }],
          renderHTML({ HTMLAttributes: n }) {
            return ["code", _t(this.options.HTMLAttributes, n), 0];
          },
          addCommands() {
            return {
              setCode:
                () =>
                ({ commands: n }) =>
                  n.setMark(this.name),
              toggleCode:
                () =>
                ({ commands: n }) =>
                  n.toggleMark(this.name),
              unsetCode:
                () =>
                ({ commands: n }) =>
                  n.unsetMark(this.name),
            };
          },
          addKeyboardShortcuts() {
            return { "Mod-e": () => this.editor.commands.toggleCode() };
          },
          addInputRules() {
            return [ps({ find: J6, type: this.type })];
          },
          addPasteRules() {
            return [Co({ find: X6, type: this.type })];
          },
        }),
        tG = /^```([a-z]+)?[\s\n]$/,
        nG = /^~~~([a-z]+)?[\s\n]$/,
        iG = en.create({
          name: "codeBlock",
          addOptions: () => ({
            languageClassPrefix: "language-",
            exitOnTripleEnter: !0,
            exitOnArrowDown: !0,
            HTMLAttributes: {},
          }),
          content: "text*",
          marks: "",
          group: "block",
          code: !0,
          defining: !0,
          addAttributes() {
            return {
              language: {
                default: null,
                parseHTML: (n) => {
                  var e;
                  const { languageClassPrefix: t } = this.options;
                  return (
                    [
                      ...((null === (e = n.firstElementChild) || void 0 === e
                        ? void 0
                        : e.classList) || []),
                    ]
                      .filter((s) => s.startsWith(t))
                      .map((s) => s.replace(t, ""))[0] || null
                  );
                },
                rendered: !1,
              },
            };
          },
          parseHTML: () => [{ tag: "pre", preserveWhitespace: "full" }],
          renderHTML({ node: n, HTMLAttributes: e }) {
            return [
              "pre",
              _t(this.options.HTMLAttributes, e),
              [
                "code",
                {
                  class: n.attrs.language
                    ? this.options.languageClassPrefix + n.attrs.language
                    : null,
                },
                0,
              ],
            ];
          },
          addCommands() {
            return {
              setCodeBlock:
                (n) =>
                ({ commands: e }) =>
                  e.setNode(this.name, n),
              toggleCodeBlock:
                (n) =>
                ({ commands: e }) =>
                  e.toggleNode(this.name, "paragraph", n),
            };
          },
          addKeyboardShortcuts() {
            return {
              "Mod-Alt-c": () => this.editor.commands.toggleCodeBlock(),
              Backspace: () => {
                const { empty: n, $anchor: e } = this.editor.state.selection;
                return (
                  !(!n || e.parent.type.name !== this.name) &&
                  !(1 !== e.pos && e.parent.textContent.length) &&
                  this.editor.commands.clearNodes()
                );
              },
              Enter: ({ editor: n }) => {
                if (!this.options.exitOnTripleEnter) return !1;
                const { state: e } = n,
                  { selection: t } = e,
                  { $from: i, empty: r } = t;
                if (!r || i.parent.type !== this.type) return !1;
                const o = i.parentOffset === i.parent.nodeSize - 2,
                  s = i.parent.textContent.endsWith("\n\n");
                return (
                  !(!o || !s) &&
                  n
                    .chain()
                    .command(({ tr: a }) => (a.delete(i.pos - 2, i.pos), !0))
                    .exitCode()
                    .run()
                );
              },
              ArrowDown: ({ editor: n }) => {
                if (!this.options.exitOnArrowDown) return !1;
                const { state: e } = n,
                  { selection: t, doc: i } = e,
                  { $from: r, empty: o } = t;
                if (
                  !o ||
                  r.parent.type !== this.type ||
                  r.parentOffset !== r.parent.nodeSize - 2
                )
                  return !1;
                const a = r.after();
                return void 0 !== a && !i.nodeAt(a) && n.commands.exitCode();
              },
            };
          },
          addInputRules() {
            return [
              d_({
                find: tG,
                type: this.type,
                getAttributes: (n) => ({ language: n[1] }),
              }),
              d_({
                find: nG,
                type: this.type,
                getAttributes: (n) => ({ language: n[1] }),
              }),
            ];
          },
          addProseMirrorPlugins() {
            return [
              new Qe({
                key: new It("codeBlockVSCodeHandler"),
                props: {
                  handlePaste: (n, e) => {
                    if (
                      !e.clipboardData ||
                      this.editor.isActive(this.type.name)
                    )
                      return !1;
                    const t = e.clipboardData.getData("text/plain"),
                      i = e.clipboardData.getData("vscode-editor-data"),
                      o = (i ? JSON.parse(i) : void 0)?.mode;
                    if (!t || !o) return !1;
                    const { tr: s } = n.state;
                    return (
                      s.replaceSelectionWith(this.type.create({ language: o })),
                      s.setSelection(
                        ue.near(
                          s.doc.resolve(Math.max(0, s.selection.from - 2))
                        )
                      ),
                      s.insertText(t.replace(/\r\n?/g, "\n")),
                      s.setMeta("paste", !0),
                      n.dispatch(s),
                      !0
                    );
                  },
                },
              }),
            ];
          },
        }),
        rG = en.create({ name: "doc", topNode: !0, content: "block+" });
      function oG(n = {}) {
        return new Qe({ view: (e) => new sG(e, n) });
      }
      class sG {
        constructor(e, t) {
          (this.editorView = e),
            (this.cursorPos = null),
            (this.element = null),
            (this.timeout = -1),
            (this.width = t.width || 1),
            (this.color = t.color || "black"),
            (this.class = t.class),
            (this.handlers = ["dragover", "dragend", "drop", "dragleave"].map(
              (i) => {
                let r = (o) => {
                  this[i](o);
                };
                return e.dom.addEventListener(i, r), { name: i, handler: r };
              }
            ));
        }
        destroy() {
          this.handlers.forEach(({ name: e, handler: t }) =>
            this.editorView.dom.removeEventListener(e, t)
          );
        }
        update(e, t) {
          null != this.cursorPos &&
            t.doc != e.state.doc &&
            (this.cursorPos > e.state.doc.content.size
              ? this.setCursor(null)
              : this.updateOverlay());
        }
        setCursor(e) {
          e != this.cursorPos &&
            ((this.cursorPos = e),
            null == e
              ? (this.element.parentNode.removeChild(this.element),
                (this.element = null))
              : this.updateOverlay());
        }
        updateOverlay() {
          let t,
            e = this.editorView.state.doc.resolve(this.cursorPos);
          if (!e.parent.inlineContent) {
            let s = e.nodeBefore,
              a = e.nodeAfter;
            if (s || a) {
              let l = this.editorView
                  .nodeDOM(this.cursorPos - (s ? s.nodeSize : 0))
                  .getBoundingClientRect(),
                c = s ? l.bottom : l.top;
              s &&
                a &&
                (c =
                  (c +
                    this.editorView
                      .nodeDOM(this.cursorPos)
                      .getBoundingClientRect().top) /
                  2),
                (t = {
                  left: l.left,
                  right: l.right,
                  top: c - this.width / 2,
                  bottom: c + this.width / 2,
                });
            }
          }
          if (!t) {
            let s = this.editorView.coordsAtPos(this.cursorPos);
            t = {
              left: s.left - this.width / 2,
              right: s.left + this.width / 2,
              top: s.top,
              bottom: s.bottom,
            };
          }
          let r,
            o,
            i = this.editorView.dom.offsetParent;
          if (
            (this.element ||
              ((this.element = i.appendChild(document.createElement("div"))),
              this.class && (this.element.className = this.class),
              (this.element.style.cssText =
                "position: absolute; z-index: 50; pointer-events: none; background-color: " +
                this.color)),
            !i ||
              (i == document.body && "static" == getComputedStyle(i).position))
          )
            (r = -pageXOffset), (o = -pageYOffset);
          else {
            let s = i.getBoundingClientRect();
            (r = s.left - i.scrollLeft), (o = s.top - i.scrollTop);
          }
          (this.element.style.left = t.left - r + "px"),
            (this.element.style.top = t.top - o + "px"),
            (this.element.style.width = t.right - t.left + "px"),
            (this.element.style.height = t.bottom - t.top + "px");
        }
        scheduleRemoval(e) {
          clearTimeout(this.timeout),
            (this.timeout = setTimeout(() => this.setCursor(null), e));
        }
        dragover(e) {
          if (!this.editorView.editable) return;
          let t = this.editorView.posAtCoords({
              left: e.clientX,
              top: e.clientY,
            }),
            i =
              t && t.inside >= 0 && this.editorView.state.doc.nodeAt(t.inside),
            r = i && i.type.spec.disableDropCursor,
            o = "function" == typeof r ? r(this.editorView, t) : r;
          if (t && !o) {
            let s = t.pos;
            if (
              this.editorView.dragging &&
              this.editorView.dragging.slice &&
              ((s = UT(
                this.editorView.state.doc,
                s,
                this.editorView.dragging.slice
              )),
              null == s)
            )
              return this.setCursor(null);
            this.setCursor(s), this.scheduleRemoval(5e3);
          }
        }
        dragend() {
          this.scheduleRemoval(20);
        }
        drop() {
          this.scheduleRemoval(20);
        }
        dragleave(e) {
          (e.target == this.editorView.dom ||
            !this.editorView.dom.contains(e.relatedTarget)) &&
            this.setCursor(null);
        }
      }
      const aG = bt.create({
        name: "dropCursor",
        addOptions: () => ({ color: "currentColor", width: 1, class: void 0 }),
        addProseMirrorPlugins() {
          return [oG(this.options)];
        },
      });
      class ct extends ce {
        constructor(e) {
          super(e, e);
        }
        map(e, t) {
          let i = e.resolve(t.map(this.head));
          return ct.valid(i) ? new ct(i) : ce.near(i);
        }
        content() {
          return P.empty;
        }
        eq(e) {
          return e instanceof ct && e.head == this.head;
        }
        toJSON() {
          return { type: "gapcursor", pos: this.head };
        }
        static fromJSON(e, t) {
          if ("number" != typeof t.pos)
            throw new RangeError("Invalid input for GapCursor.fromJSON");
          return new ct(e.resolve(t.pos));
        }
        getBookmark() {
          return new f_(this.anchor);
        }
        static valid(e) {
          let t = e.parent;
          if (
            t.isTextblock ||
            !(function lG(n) {
              for (let e = n.depth; e >= 0; e--) {
                let t = n.index(e),
                  i = n.node(e);
                if (0 != t)
                  for (let r = i.child(t - 1); ; r = r.lastChild) {
                    if (
                      (0 == r.childCount && !r.inlineContent) ||
                      r.isAtom ||
                      r.type.spec.isolating
                    )
                      return !0;
                    if (r.inlineContent) return !1;
                  }
                else if (i.type.spec.isolating) return !0;
              }
              return !0;
            })(e) ||
            !(function cG(n) {
              for (let e = n.depth; e >= 0; e--) {
                let t = n.indexAfter(e),
                  i = n.node(e);
                if (t != i.childCount)
                  for (let r = i.child(t); ; r = r.firstChild) {
                    if (
                      (0 == r.childCount && !r.inlineContent) ||
                      r.isAtom ||
                      r.type.spec.isolating
                    )
                      return !0;
                    if (r.inlineContent) return !1;
                  }
                else if (i.type.spec.isolating) return !0;
              }
              return !0;
            })(e)
          )
            return !1;
          let i = t.type.spec.allowGapCursor;
          if (null != i) return i;
          let r = t.contentMatchAt(e.index()).defaultType;
          return r && r.isTextblock;
        }
        static findGapCursorFrom(e, t, i = !1) {
          e: for (;;) {
            if (!i && ct.valid(e)) return e;
            let r = e.pos,
              o = null;
            for (let s = e.depth; ; s--) {
              let a = e.node(s);
              if (t > 0 ? e.indexAfter(s) < a.childCount : e.index(s) > 0) {
                o = a.child(t > 0 ? e.indexAfter(s) : e.index(s) - 1);
                break;
              }
              if (0 == s) return null;
              r += t;
              let l = e.doc.resolve(r);
              if (ct.valid(l)) return l;
            }
            for (;;) {
              let s = t > 0 ? o.firstChild : o.lastChild;
              if (!s) {
                if (o.isAtom && !o.isText && !Y.isSelectable(o)) {
                  (e = e.doc.resolve(r + o.nodeSize * t)), (i = !1);
                  continue e;
                }
                break;
              }
              (o = s), (r += t);
              let a = e.doc.resolve(r);
              if (ct.valid(a)) return a;
            }
            return null;
          }
        }
      }
      (ct.prototype.visible = !1),
        (ct.findFrom = ct.findGapCursorFrom),
        ce.jsonID("gapcursor", ct);
      class f_ {
        constructor(e) {
          this.pos = e;
        }
        map(e) {
          return new f_(e.map(this.pos));
        }
        resolve(e) {
          let t = e.resolve(this.pos);
          return ct.valid(t) ? new ct(t) : ce.near(t);
        }
      }
      const dG = dA({
        ArrowLeft: Qh("horiz", -1),
        ArrowRight: Qh("horiz", 1),
        ArrowUp: Qh("vert", -1),
        ArrowDown: Qh("vert", 1),
      });
      function Qh(n, e) {
        const t =
          "vert" == n ? (e > 0 ? "down" : "up") : e > 0 ? "right" : "left";
        return function (i, r, o) {
          let s = i.selection,
            a = e > 0 ? s.$to : s.$from,
            l = s.empty;
          if (s instanceof ue) {
            if (!o.endOfTextblock(t) || 0 == a.depth) return !1;
            (l = !1), (a = i.doc.resolve(e > 0 ? a.after() : a.before()));
          }
          let c = ct.findGapCursorFrom(a, e, l);
          return !!c && (r && r(i.tr.setSelection(new ct(c))), !0);
        };
      }
      function hG(n, e, t) {
        if (!n || !n.editable) return !1;
        let i = n.state.doc.resolve(e);
        if (!ct.valid(i)) return !1;
        let r = n.posAtCoords({ left: t.clientX, top: t.clientY });
        return !(
          (r &&
            r.inside > -1 &&
            Y.isSelectable(n.state.doc.nodeAt(r.inside))) ||
          (n.dispatch(n.state.tr.setSelection(new ct(i))), 0)
        );
      }
      function fG(n, e) {
        if (
          "insertCompositionText" != e.inputType ||
          !(n.state.selection instanceof ct)
        )
          return !1;
        let { $from: t } = n.state.selection,
          i = t.parent
            .contentMatchAt(t.index())
            .findWrapping(n.state.schema.nodes.text);
        if (!i) return !1;
        let r = I.empty;
        for (let s = i.length - 1; s >= 0; s--)
          r = I.from(i[s].createAndFill(null, r));
        let o = n.state.tr.replace(t.pos, t.pos, new P(r, 0, 0));
        return (
          o.setSelection(ue.near(o.doc.resolve(t.pos + 1))), n.dispatch(o), !1
        );
      }
      function pG(n) {
        if (!(n.selection instanceof ct)) return null;
        let e = document.createElement("div");
        return (
          (e.className = "ProseMirror-gapcursor"),
          vt.create(n.doc, [
            pn.widget(n.selection.head, e, { key: "gapcursor" }),
          ])
        );
      }
      const gG = bt.create({
          name: "gapCursor",
          addProseMirrorPlugins: () => [
            new Qe({
              props: {
                decorations: pG,
                createSelectionBetween: (n, e, t) =>
                  e.pos == t.pos && ct.valid(t) ? new ct(t) : null,
                handleClick: hG,
                handleKeyDown: dG,
                handleDOMEvents: { beforeinput: fG },
              },
            }),
          ],
          extendNodeSchema(n) {
            var e;
            return {
              allowGapCursor:
                null !==
                  (e = de(
                    L(n, "allowGapCursor", {
                      name: n.name,
                      options: n.options,
                      storage: n.storage,
                    })
                  )) && void 0 !== e
                  ? e
                  : null,
            };
          },
        }),
        mG = en.create({
          name: "hardBreak",
          addOptions: () => ({ keepMarks: !0, HTMLAttributes: {} }),
          inline: !0,
          group: "inline",
          selectable: !1,
          parseHTML: () => [{ tag: "br" }],
          renderHTML({ HTMLAttributes: n }) {
            return ["br", _t(this.options.HTMLAttributes, n)];
          },
          renderText: () => "\n",
          addCommands() {
            return {
              setHardBreak:
                () =>
                ({ commands: n, chain: e, state: t, editor: i }) =>
                  n.first([
                    () => n.exitCode(),
                    () =>
                      n.command(() => {
                        const { selection: r, storedMarks: o } = t;
                        if (r.$from.parent.type.spec.isolating) return !1;
                        const { keepMarks: s } = this.options,
                          { splittableMarks: a } = i.extensionManager,
                          l = o || (r.$to.parentOffset && r.$from.marks());
                        return e()
                          .insertContent({ type: this.name })
                          .command(({ tr: c, dispatch: u }) => {
                            if (u && l && s) {
                              const d = l.filter((h) =>
                                a.includes(h.type.name)
                              );
                              c.ensureMarks(d);
                            }
                            return !0;
                          })
                          .run();
                      }),
                  ]),
            };
          },
          addKeyboardShortcuts() {
            return {
              "Mod-Enter": () => this.editor.commands.setHardBreak(),
              "Shift-Enter": () => this.editor.commands.setHardBreak(),
            };
          },
        }),
        yG = en.create({
          name: "heading",
          addOptions: () => ({
            levels: [1, 2, 3, 4, 5, 6],
            HTMLAttributes: {},
          }),
          content: "inline*",
          group: "block",
          defining: !0,
          addAttributes: () => ({ level: { default: 1, rendered: !1 } }),
          parseHTML() {
            return this.options.levels.map((n) => ({
              tag: `h${n}`,
              attrs: { level: n },
            }));
          },
          renderHTML({ node: n, HTMLAttributes: e }) {
            return [
              `h${
                this.options.levels.includes(n.attrs.level)
                  ? n.attrs.level
                  : this.options.levels[0]
              }`,
              _t(this.options.HTMLAttributes, e),
              0,
            ];
          },
          addCommands() {
            return {
              setHeading:
                (n) =>
                ({ commands: e }) =>
                  !!this.options.levels.includes(n.level) &&
                  e.setNode(this.name, n),
              toggleHeading:
                (n) =>
                ({ commands: e }) =>
                  !!this.options.levels.includes(n.level) &&
                  e.toggleNode(this.name, "paragraph", n),
            };
          },
          addKeyboardShortcuts() {
            return this.options.levels.reduce(
              (n, e) => ({
                ...n,
                [`Mod-Alt-${e}`]: () =>
                  this.editor.commands.toggleHeading({ level: e }),
              }),
              {}
            );
          },
          addInputRules() {
            return this.options.levels.map((n) =>
              d_({
                find: new RegExp(`^(#{1,${n}})\\s$`),
                type: this.type,
                getAttributes: { level: n },
              })
            );
          },
        });
      var jt = function () {};
      (jt.prototype.append = function (e) {
        return e.length
          ? ((e = jt.from(e)),
            (!this.length && e) ||
              (e.length < 200 && this.leafAppend(e)) ||
              (this.length < 200 && e.leafPrepend(this)) ||
              this.appendInner(e))
          : this;
      }),
        (jt.prototype.prepend = function (e) {
          return e.length ? jt.from(e).append(this) : this;
        }),
        (jt.prototype.appendInner = function (e) {
          return new vG(this, e);
        }),
        (jt.prototype.slice = function (e, t) {
          return (
            void 0 === e && (e = 0),
            void 0 === t && (t = this.length),
            e >= t
              ? jt.empty
              : this.sliceInner(Math.max(0, e), Math.min(this.length, t))
          );
        }),
        (jt.prototype.get = function (e) {
          if (!(e < 0 || e >= this.length)) return this.getInner(e);
        }),
        (jt.prototype.forEach = function (e, t, i) {
          void 0 === t && (t = 0),
            void 0 === i && (i = this.length),
            t <= i
              ? this.forEachInner(e, t, i, 0)
              : this.forEachInvertedInner(e, t, i, 0);
        }),
        (jt.prototype.map = function (e, t, i) {
          void 0 === t && (t = 0), void 0 === i && (i = this.length);
          var r = [];
          return (
            this.forEach(
              function (o, s) {
                return r.push(e(o, s));
              },
              t,
              i
            ),
            r
          );
        }),
        (jt.from = function (e) {
          return e instanceof jt ? e : e && e.length ? new ZA(e) : jt.empty;
        });
      var ZA = (function (n) {
        function e(i) {
          n.call(this), (this.values = i);
        }
        n && (e.__proto__ = n),
          ((e.prototype = Object.create(n && n.prototype)).constructor = e);
        var t = { length: { configurable: !0 }, depth: { configurable: !0 } };
        return (
          (e.prototype.flatten = function () {
            return this.values;
          }),
          (e.prototype.sliceInner = function (r, o) {
            return 0 == r && o == this.length
              ? this
              : new e(this.values.slice(r, o));
          }),
          (e.prototype.getInner = function (r) {
            return this.values[r];
          }),
          (e.prototype.forEachInner = function (r, o, s, a) {
            for (var l = o; l < s; l++)
              if (!1 === r(this.values[l], a + l)) return !1;
          }),
          (e.prototype.forEachInvertedInner = function (r, o, s, a) {
            for (var l = o - 1; l >= s; l--)
              if (!1 === r(this.values[l], a + l)) return !1;
          }),
          (e.prototype.leafAppend = function (r) {
            if (this.length + r.length <= 200)
              return new e(this.values.concat(r.flatten()));
          }),
          (e.prototype.leafPrepend = function (r) {
            if (this.length + r.length <= 200)
              return new e(r.flatten().concat(this.values));
          }),
          (t.length.get = function () {
            return this.values.length;
          }),
          (t.depth.get = function () {
            return 0;
          }),
          Object.defineProperties(e.prototype, t),
          e
        );
      })(jt);
      jt.empty = new ZA([]);
      var vG = (function (n) {
        function e(t, i) {
          n.call(this),
            (this.left = t),
            (this.right = i),
            (this.length = t.length + i.length),
            (this.depth = Math.max(t.depth, i.depth) + 1);
        }
        return (
          n && (e.__proto__ = n),
          ((e.prototype = Object.create(n && n.prototype)).constructor = e),
          (e.prototype.flatten = function () {
            return this.left.flatten().concat(this.right.flatten());
          }),
          (e.prototype.getInner = function (i) {
            return i < this.left.length
              ? this.left.get(i)
              : this.right.get(i - this.left.length);
          }),
          (e.prototype.forEachInner = function (i, r, o, s) {
            var a = this.left.length;
            if (
              (r < a &&
                !1 === this.left.forEachInner(i, r, Math.min(o, a), s)) ||
              (o > a &&
                !1 ===
                  this.right.forEachInner(
                    i,
                    Math.max(r - a, 0),
                    Math.min(this.length, o) - a,
                    s + a
                  ))
            )
              return !1;
          }),
          (e.prototype.forEachInvertedInner = function (i, r, o, s) {
            var a = this.left.length;
            if (
              (r > a &&
                !1 ===
                  this.right.forEachInvertedInner(
                    i,
                    r - a,
                    Math.max(o, a) - a,
                    s + a
                  )) ||
              (o < a &&
                !1 === this.left.forEachInvertedInner(i, Math.min(r, a), o, s))
            )
              return !1;
          }),
          (e.prototype.sliceInner = function (i, r) {
            if (0 == i && r == this.length) return this;
            var o = this.left.length;
            return r <= o
              ? this.left.slice(i, r)
              : i >= o
              ? this.right.slice(i - o, r - o)
              : this.left.slice(i, o).append(this.right.slice(0, r - o));
          }),
          (e.prototype.leafAppend = function (i) {
            var r = this.right.leafAppend(i);
            if (r) return new e(this.left, r);
          }),
          (e.prototype.leafPrepend = function (i) {
            var r = this.left.leafPrepend(i);
            if (r) return new e(r, this.right);
          }),
          (e.prototype.appendInner = function (i) {
            return this.left.depth >= Math.max(this.right.depth, i.depth) + 1
              ? new e(this.left, new e(this.right, i))
              : new e(this, i);
          }),
          e
        );
      })(jt);
      const QA = jt;
      class wi {
        constructor(e, t) {
          (this.items = e), (this.eventCount = t);
        }
        popEvent(e, t) {
          if (0 == this.eventCount) return null;
          let r,
            o,
            i = this.items.length;
          for (; ; i--)
            if (this.items.get(i - 1).selection) {
              --i;
              break;
            }
          t &&
            ((r = this.remapping(i, this.items.length)), (o = r.maps.length));
          let a,
            l,
            s = e.tr,
            c = [],
            u = [];
          return (
            this.items.forEach(
              (d, h) => {
                if (!d.step)
                  return (
                    r || ((r = this.remapping(i, h + 1)), (o = r.maps.length)),
                    o--,
                    void u.push(d)
                  );
                if (r) {
                  u.push(new ir(d.map));
                  let p,
                    f = d.step.map(r.slice(o));
                  f &&
                    s.maybeStep(f).doc &&
                    ((p = s.mapping.maps[s.mapping.maps.length - 1]),
                    c.push(new ir(p, void 0, void 0, c.length + u.length))),
                    o--,
                    p && r.appendMap(p, o);
                } else s.maybeStep(d.step);
                return d.selection
                  ? ((a = r ? d.selection.map(r.slice(o)) : d.selection),
                    (l = new wi(
                      this.items.slice(0, i).append(u.reverse().concat(c)),
                      this.eventCount - 1
                    )),
                    !1)
                  : void 0;
              },
              this.items.length,
              0
            ),
            { remaining: l, transform: s, selection: a }
          );
        }
        addTransform(e, t, i, r) {
          let o = [],
            s = this.eventCount,
            a = this.items,
            l = !r && a.length ? a.get(a.length - 1) : null;
          for (let u = 0; u < e.steps.length; u++) {
            let f,
              d = e.steps[u].invert(e.docs[u]),
              h = new ir(e.mapping.maps[u], d, t);
            (f = l && l.merge(h)) &&
              ((h = f), u ? o.pop() : (a = a.slice(0, a.length - 1))),
              o.push(h),
              t && (s++, (t = void 0)),
              r || (l = h);
          }
          let c = s - i.depth;
          return (
            c > CG &&
              ((a = (function DG(n, e) {
                let t;
                return (
                  n.forEach((i, r) => {
                    if (i.selection && 0 == e--) return (t = r), !1;
                  }),
                  n.slice(t)
                );
              })(a, c)),
              (s -= c)),
            new wi(a.append(o), s)
          );
        }
        remapping(e, t) {
          let i = new Ma();
          return (
            this.items.forEach(
              (r, o) => {
                i.appendMap(
                  r.map,
                  null != r.mirrorOffset && o - r.mirrorOffset >= e
                    ? i.maps.length - r.mirrorOffset
                    : void 0
                );
              },
              e,
              t
            ),
            i
          );
        }
        addMaps(e) {
          return 0 == this.eventCount
            ? this
            : new wi(
                this.items.append(e.map((t) => new ir(t))),
                this.eventCount
              );
        }
        rebased(e, t) {
          if (!this.eventCount) return this;
          let i = [],
            r = Math.max(0, this.items.length - t),
            o = e.mapping,
            s = e.steps.length,
            a = this.eventCount;
          this.items.forEach((h) => {
            h.selection && a--;
          }, r);
          let l = t;
          this.items.forEach((h) => {
            let f = o.getMirror(--l);
            if (null == f) return;
            s = Math.min(s, f);
            let p = o.maps[f];
            if (h.step) {
              let g = e.steps[f].invert(e.docs[f]),
                m = h.selection && h.selection.map(o.slice(l + 1, f));
              m && a++, i.push(new ir(p, g, m));
            } else i.push(new ir(p));
          }, r);
          let c = [];
          for (let h = t; h < s; h++) c.push(new ir(o.maps[h]));
          let u = this.items.slice(0, r).append(c).append(i),
            d = new wi(u, a);
          return (
            d.emptyItemCount() > 500 &&
              (d = d.compress(this.items.length - i.length)),
            d
          );
        }
        emptyItemCount() {
          let e = 0;
          return (
            this.items.forEach((t) => {
              t.step || e++;
            }),
            e
          );
        }
        compress(e = this.items.length) {
          let t = this.remapping(0, e),
            i = t.maps.length,
            r = [],
            o = 0;
          return (
            this.items.forEach(
              (s, a) => {
                if (a >= e) r.push(s), s.selection && o++;
                else if (s.step) {
                  let l = s.step.map(t.slice(i)),
                    c = l && l.getMap();
                  if ((i--, c && t.appendMap(c, i), l)) {
                    let u = s.selection && s.selection.map(t.slice(i));
                    u && o++;
                    let h,
                      d = new ir(c.invert(), l, u),
                      f = r.length - 1;
                    (h = r.length && r[f].merge(d)) ? (r[f] = h) : r.push(d);
                  }
                } else s.map && i--;
              },
              this.items.length,
              0
            ),
            new wi(QA.from(r.reverse()), o)
          );
        }
      }
      wi.empty = new wi(QA.empty, 0);
      class ir {
        constructor(e, t, i, r) {
          (this.map = e),
            (this.step = t),
            (this.selection = i),
            (this.mirrorOffset = r);
        }
        merge(e) {
          if (this.step && e.step && !e.selection) {
            let t = e.step.merge(this.step);
            if (t) return new ir(t.getMap().invert(), t, this.selection);
          }
        }
      }
      class Eo {
        constructor(e, t, i, r) {
          (this.done = e),
            (this.undone = t),
            (this.prevRanges = i),
            (this.prevTime = r);
        }
      }
      const CG = 20;
      function JA(n) {
        let e = [];
        return n.forEach((t, i, r, o) => e.push(r, o)), e;
      }
      function p_(n, e) {
        if (!n) return null;
        let t = [];
        for (let i = 0; i < n.length; i += 2) {
          let r = e.map(n[i], 1),
            o = e.map(n[i + 1], -1);
          r <= o && t.push(r, o);
        }
        return t;
      }
      function XA(n, e, t, i) {
        let r = Xh(e),
          o = rr.get(e).spec.config,
          s = (i ? n.undone : n.done).popEvent(e, r);
        if (!s) return;
        let a = s.selection.resolve(s.transform.doc),
          l = (i ? n.done : n.undone).addTransform(
            s.transform,
            e.selection.getBookmark(),
            o,
            r
          ),
          c = new Eo(i ? l : s.remaining, i ? s.remaining : l, null, 0);
        t(
          s.transform
            .setSelection(a)
            .setMeta(rr, { redo: i, historyState: c })
            .scrollIntoView()
        );
      }
      let g_ = !1,
        eO = null;
      function Xh(n) {
        let e = n.plugins;
        if (eO != e) {
          (g_ = !1), (eO = e);
          for (let t = 0; t < e.length; t++)
            if (e[t].spec.historyPreserveItems) {
              g_ = !0;
              break;
            }
        }
        return g_;
      }
      const rr = new It("history"),
        tO = new It("closeHistory");
      function SG(n = {}) {
        return new Qe({
          key: rr,
          state: {
            init: () => new Eo(wi.empty, wi.empty, null, 0),
            apply: (e, t, i) =>
              (function EG(n, e, t, i) {
                let o,
                  r = t.getMeta(rr);
                if (r) return r.historyState;
                t.getMeta(tO) && (n = new Eo(n.done, n.undone, null, 0));
                let s = t.getMeta("appendedTransaction");
                if (0 == t.steps.length) return n;
                if (s && s.getMeta(rr))
                  return s.getMeta(rr).redo
                    ? new Eo(
                        n.done.addTransform(t, void 0, i, Xh(e)),
                        n.undone,
                        JA(t.mapping.maps[t.steps.length - 1]),
                        n.prevTime
                      )
                    : new Eo(
                        n.done,
                        n.undone.addTransform(t, void 0, i, Xh(e)),
                        null,
                        n.prevTime
                      );
                if (
                  !1 === t.getMeta("addToHistory") ||
                  (s && !1 === s.getMeta("addToHistory"))
                )
                  return (o = t.getMeta("rebased"))
                    ? new Eo(
                        n.done.rebased(t, o),
                        n.undone.rebased(t, o),
                        p_(n.prevRanges, t.mapping),
                        n.prevTime
                      )
                    : new Eo(
                        n.done.addMaps(t.mapping.maps),
                        n.undone.addMaps(t.mapping.maps),
                        p_(n.prevRanges, t.mapping),
                        n.prevTime
                      );
                {
                  let a =
                      0 == n.prevTime ||
                      (!s &&
                        (n.prevTime < (t.time || 0) - i.newGroupDelay ||
                          !(function wG(n, e) {
                            if (!e) return !1;
                            if (!n.docChanged) return !0;
                            let t = !1;
                            return (
                              n.mapping.maps[0].forEach((i, r) => {
                                for (let o = 0; o < e.length; o += 2)
                                  i <= e[o + 1] && r >= e[o] && (t = !0);
                              }),
                              t
                            );
                          })(t, n.prevRanges))),
                    l = s
                      ? p_(n.prevRanges, t.mapping)
                      : JA(t.mapping.maps[t.steps.length - 1]);
                  return new Eo(
                    n.done.addTransform(
                      t,
                      a ? e.selection.getBookmark() : void 0,
                      i,
                      Xh(e)
                    ),
                    wi.empty,
                    l,
                    t.time
                  );
                }
              })(t, i, e, n),
          },
          config: (n = {
            depth: n.depth || 100,
            newGroupDelay: n.newGroupDelay || 500,
          }),
          props: {
            handleDOMEvents: {
              beforeinput(e, t) {
                let i = t.inputType,
                  r = "historyUndo" == i ? nO : "historyRedo" == i ? iO : null;
                return !!r && (t.preventDefault(), r(e.state, e.dispatch));
              },
            },
          },
        });
      }
      const nO = (n, e) => {
          let t = rr.getState(n);
          return !(!t || 0 == t.done.eventCount || (e && XA(t, n, e, !1), 0));
        },
        iO = (n, e) => {
          let t = rr.getState(n);
          return !(!t || 0 == t.undone.eventCount || (e && XA(t, n, e, !0), 0));
        },
        MG = bt.create({
          name: "history",
          addOptions: () => ({ depth: 100, newGroupDelay: 500 }),
          addCommands: () => ({
            undo:
              () =>
              ({ state: n, dispatch: e }) =>
                nO(n, e),
            redo:
              () =>
              ({ state: n, dispatch: e }) =>
                iO(n, e),
          }),
          addProseMirrorPlugins() {
            return [SG(this.options)];
          },
          addKeyboardShortcuts() {
            return {
              "Mod-z": () => this.editor.commands.undo(),
              "Mod-y": () => this.editor.commands.redo(),
              "Shift-Mod-z": () => this.editor.commands.redo(),
              "Mod-\u044f": () => this.editor.commands.undo(),
              "Shift-Mod-\u044f": () => this.editor.commands.redo(),
            };
          },
        }),
        IG = en.create({
          name: "horizontalRule",
          addOptions: () => ({ HTMLAttributes: {} }),
          group: "block",
          parseHTML: () => [{ tag: "hr" }],
          renderHTML({ HTMLAttributes: n }) {
            return ["hr", _t(this.options.HTMLAttributes, n)];
          },
          addCommands() {
            return {
              setHorizontalRule:
                () =>
                ({ chain: n }) =>
                  n()
                    .insertContent({ type: this.name })
                    .command(({ tr: e, dispatch: t }) => {
                      var i;
                      if (t) {
                        const { $to: r } = e.selection,
                          o = r.end();
                        if (r.nodeAfter)
                          e.setSelection(ue.create(e.doc, r.pos));
                        else {
                          const s =
                            null ===
                              (i = r.parent.type.contentMatch.defaultType) ||
                            void 0 === i
                              ? void 0
                              : i.create();
                          s &&
                            (e.insert(o, s),
                            e.setSelection(ue.create(e.doc, o)));
                        }
                        e.scrollIntoView();
                      }
                      return !0;
                    })
                    .run(),
            };
          },
          addInputRules() {
            return [
              j6({ find: /^(?:---|\u2014-|___\s|\*\*\*\s)$/, type: this.type }),
            ];
          },
        }),
        TG = /(?:^|\s)((?:\*)((?:[^*]+))(?:\*))$/,
        xG = /(?:^|\s)((?:\*)((?:[^*]+))(?:\*))/g,
        AG = /(?:^|\s)((?:_)((?:[^_]+))(?:_))$/,
        OG = /(?:^|\s)((?:_)((?:[^_]+))(?:_))/g,
        kG = nr.create({
          name: "italic",
          addOptions: () => ({ HTMLAttributes: {} }),
          parseHTML: () => [
            { tag: "em" },
            {
              tag: "i",
              getAttrs: (n) => "normal" !== n.style.fontStyle && null,
            },
            { style: "font-style=italic" },
          ],
          renderHTML({ HTMLAttributes: n }) {
            return ["em", _t(this.options.HTMLAttributes, n), 0];
          },
          addCommands() {
            return {
              setItalic:
                () =>
                ({ commands: n }) =>
                  n.setMark(this.name),
              toggleItalic:
                () =>
                ({ commands: n }) =>
                  n.toggleMark(this.name),
              unsetItalic:
                () =>
                ({ commands: n }) =>
                  n.unsetMark(this.name),
            };
          },
          addKeyboardShortcuts() {
            return {
              "Mod-i": () => this.editor.commands.toggleItalic(),
              "Mod-I": () => this.editor.commands.toggleItalic(),
            };
          },
          addInputRules() {
            return [
              ps({ find: TG, type: this.type }),
              ps({ find: AG, type: this.type }),
            ];
          },
          addPasteRules() {
            return [
              Co({ find: xG, type: this.type }),
              Co({ find: OG, type: this.type }),
            ];
          },
        }),
        NG = en.create({
          name: "listItem",
          addOptions: () => ({ HTMLAttributes: {} }),
          content: "paragraph block*",
          defining: !0,
          parseHTML: () => [{ tag: "li" }],
          renderHTML({ HTMLAttributes: n }) {
            return ["li", _t(this.options.HTMLAttributes, n), 0];
          },
          addKeyboardShortcuts() {
            return {
              Enter: () => this.editor.commands.splitListItem(this.name),
              Tab: () => this.editor.commands.sinkListItem(this.name),
              "Shift-Tab": () => this.editor.commands.liftListItem(this.name),
            };
          },
        }),
        RG = /^(\d+)\.\s$/,
        PG = en.create({
          name: "orderedList",
          addOptions: () => ({ itemTypeName: "listItem", HTMLAttributes: {} }),
          group: "block list",
          content() {
            return `${this.options.itemTypeName}+`;
          },
          addAttributes: () => ({
            start: {
              default: 1,
              parseHTML: (n) =>
                n.hasAttribute("start")
                  ? parseInt(n.getAttribute("start") || "", 10)
                  : 1,
            },
          }),
          parseHTML: () => [{ tag: "ol" }],
          renderHTML({ HTMLAttributes: n }) {
            const { start: e, ...t } = n;
            return 1 === e
              ? ["ol", _t(this.options.HTMLAttributes, t), 0]
              : ["ol", _t(this.options.HTMLAttributes, n), 0];
          },
          addCommands() {
            return {
              toggleOrderedList:
                () =>
                ({ commands: n }) =>
                  n.toggleList(this.name, this.options.itemTypeName),
            };
          },
          addKeyboardShortcuts() {
            return {
              "Mod-Shift-7": () => this.editor.commands.toggleOrderedList(),
            };
          },
          addInputRules() {
            return [
              h_({
                find: RG,
                type: this.type,
                getAttributes: (n) => ({ start: +n[1] }),
                joinPredicate: (n, e) => e.childCount + e.attrs.start === +n[1],
              }),
            ];
          },
        }),
        FG = en.create({
          name: "paragraph",
          priority: 1e3,
          addOptions: () => ({ HTMLAttributes: {} }),
          group: "block",
          content: "inline*",
          parseHTML: () => [{ tag: "p" }],
          renderHTML({ HTMLAttributes: n }) {
            return ["p", _t(this.options.HTMLAttributes, n), 0];
          },
          addCommands() {
            return {
              setParagraph:
                () =>
                ({ commands: n }) =>
                  n.setNode(this.name),
            };
          },
          addKeyboardShortcuts() {
            return { "Mod-Alt-0": () => this.editor.commands.setParagraph() };
          },
        }),
        LG = /(?:^|\s)((?:~~)((?:[^~]+))(?:~~))$/,
        VG = /(?:^|\s)((?:~~)((?:[^~]+))(?:~~))/g,
        BG = nr.create({
          name: "strike",
          addOptions: () => ({ HTMLAttributes: {} }),
          parseHTML: () => [
            { tag: "s" },
            { tag: "del" },
            { tag: "strike" },
            {
              style: "text-decoration",
              consuming: !1,
              getAttrs: (n) => !!n.includes("line-through") && {},
            },
          ],
          renderHTML({ HTMLAttributes: n }) {
            return ["s", _t(this.options.HTMLAttributes, n), 0];
          },
          addCommands() {
            return {
              setStrike:
                () =>
                ({ commands: n }) =>
                  n.setMark(this.name),
              toggleStrike:
                () =>
                ({ commands: n }) =>
                  n.toggleMark(this.name),
              unsetStrike:
                () =>
                ({ commands: n }) =>
                  n.unsetMark(this.name),
            };
          },
          addKeyboardShortcuts() {
            return { "Mod-Shift-x": () => this.editor.commands.toggleStrike() };
          },
          addInputRules() {
            return [ps({ find: LG, type: this.type })];
          },
          addPasteRules() {
            return [Co({ find: VG, type: this.type })];
          },
        }),
        jG = en.create({ name: "text", group: "inline" }),
        HG = bt.create({
          name: "starterKit",
          addExtensions() {
            var n, e, t, i, r, o, s, a, l, c, u, d, h, f, p, g, m, v;
            const _ = [];
            return (
              !1 !== this.options.blockquote &&
                _.push(
                  $6.configure(
                    null === (n = this.options) || void 0 === n
                      ? void 0
                      : n.blockquote
                  )
                ),
              !1 !== this.options.bold &&
                _.push(
                  Y6.configure(
                    null === (e = this.options) || void 0 === e
                      ? void 0
                      : e.bold
                  )
                ),
              !1 !== this.options.bulletList &&
                _.push(
                  Q6.configure(
                    null === (t = this.options) || void 0 === t
                      ? void 0
                      : t.bulletList
                  )
                ),
              !1 !== this.options.code &&
                _.push(
                  eG.configure(
                    null === (i = this.options) || void 0 === i
                      ? void 0
                      : i.code
                  )
                ),
              !1 !== this.options.codeBlock &&
                _.push(
                  iG.configure(
                    null === (r = this.options) || void 0 === r
                      ? void 0
                      : r.codeBlock
                  )
                ),
              !1 !== this.options.document &&
                _.push(
                  rG.configure(
                    null === (o = this.options) || void 0 === o
                      ? void 0
                      : o.document
                  )
                ),
              !1 !== this.options.dropcursor &&
                _.push(
                  aG.configure(
                    null === (s = this.options) || void 0 === s
                      ? void 0
                      : s.dropcursor
                  )
                ),
              !1 !== this.options.gapcursor &&
                _.push(
                  gG.configure(
                    null === (a = this.options) || void 0 === a
                      ? void 0
                      : a.gapcursor
                  )
                ),
              !1 !== this.options.hardBreak &&
                _.push(
                  mG.configure(
                    null === (l = this.options) || void 0 === l
                      ? void 0
                      : l.hardBreak
                  )
                ),
              !1 !== this.options.heading &&
                _.push(
                  yG.configure(
                    null === (c = this.options) || void 0 === c
                      ? void 0
                      : c.heading
                  )
                ),
              !1 !== this.options.history &&
                _.push(
                  MG.configure(
                    null === (u = this.options) || void 0 === u
                      ? void 0
                      : u.history
                  )
                ),
              !1 !== this.options.horizontalRule &&
                _.push(
                  IG.configure(
                    null === (d = this.options) || void 0 === d
                      ? void 0
                      : d.horizontalRule
                  )
                ),
              !1 !== this.options.italic &&
                _.push(
                  kG.configure(
                    null === (h = this.options) || void 0 === h
                      ? void 0
                      : h.italic
                  )
                ),
              !1 !== this.options.listItem &&
                _.push(
                  NG.configure(
                    null === (f = this.options) || void 0 === f
                      ? void 0
                      : f.listItem
                  )
                ),
              !1 !== this.options.orderedList &&
                _.push(
                  PG.configure(
                    null === (p = this.options) || void 0 === p
                      ? void 0
                      : p.orderedList
                  )
                ),
              !1 !== this.options.paragraph &&
                _.push(
                  FG.configure(
                    null === (g = this.options) || void 0 === g
                      ? void 0
                      : g.paragraph
                  )
                ),
              !1 !== this.options.strike &&
                _.push(
                  BG.configure(
                    null === (m = this.options) || void 0 === m
                      ? void 0
                      : m.strike
                  )
                ),
              !1 !== this.options.text &&
                _.push(
                  jG.configure(
                    null === (v = this.options) || void 0 === v
                      ? void 0
                      : v.text
                  )
                ),
              _
            );
          },
        }),
        UG = bt.create({
          name: "placeholder",
          addOptions: () => ({
            emptyEditorClass: "is-editor-empty",
            emptyNodeClass: "is-empty",
            placeholder: "Write something \u2026",
            showOnlyWhenEditable: !0,
            showOnlyCurrent: !0,
            includeChildren: !1,
          }),
          addProseMirrorPlugins() {
            return [
              new Qe({
                props: {
                  decorations: ({ doc: n, selection: e }) => {
                    const t =
                        this.editor.isEditable ||
                        !this.options.showOnlyWhenEditable,
                      { anchor: i } = e,
                      r = [];
                    return t
                      ? (n.descendants((o, s) => {
                          const a = i >= s && i <= s + o.nodeSize;
                          if (
                            (a || !this.options.showOnlyCurrent) &&
                            !o.isLeaf &&
                            !o.childCount
                          ) {
                            const c = [this.options.emptyNodeClass];
                            this.editor.isEmpty &&
                              c.push(this.options.emptyEditorClass);
                            const u = pn.node(s, s + o.nodeSize, {
                              class: c.join(" "),
                              "data-placeholder":
                                "function" == typeof this.options.placeholder
                                  ? this.options.placeholder({
                                      editor: this.editor,
                                      node: o,
                                      pos: s,
                                      hasAnchor: a,
                                    })
                                  : this.options.placeholder,
                            });
                            r.push(u);
                          }
                          return this.options.includeChildren;
                        }),
                        vt.create(n, r))
                      : null;
                  },
                },
              }),
            ];
          },
        });
      function ne(...n) {
        let e = n[n.length - 1];
        return xs(e) ? (n.pop(), hp(n, e)) : fp(n);
      }
      class Si extends _e {
        constructor(e) {
          super(), (this._value = e);
        }
        get value() {
          return this.getValue();
        }
        _subscribe(e) {
          const t = super._subscribe(e);
          return t && !t.closed && e.next(this._value), t;
        }
        getValue() {
          if (this.hasError) throw this.thrownError;
          if (this.closed) throw new Fo();
          return this._value;
        }
        next(e) {
          super.next((this._value = e));
        }
      }
      class zG extends Be {
        notifyNext(e, t, i, r, o) {
          this.destination.next(t);
        }
        notifyError(e, t) {
          this.destination.error(e);
        }
        notifyComplete(e) {
          this.destination.complete();
        }
      }
      class $G extends Be {
        constructor(e, t, i) {
          super(),
            (this.parent = e),
            (this.outerValue = t),
            (this.outerIndex = i),
            (this.index = 0);
        }
        _next(e) {
          this.parent.notifyNext(
            this.outerValue,
            e,
            this.outerIndex,
            this.index++,
            this
          );
        }
        _error(e) {
          this.parent.notifyError(e, this), this.unsubscribe();
        }
        _complete() {
          this.parent.notifyComplete(this), this.unsubscribe();
        }
      }
      function WG(n, e, t, i, r = new $G(n, t, i)) {
        if (!r.closed) return e instanceof je ? e.subscribe(r) : dp(e)(r);
      }
      const rO = {};
      function oO(...n) {
        let e, t;
        return (
          xs(n[n.length - 1]) && (t = n.pop()),
          "function" == typeof n[n.length - 1] && (e = n.pop()),
          1 === n.length && cl(n[0]) && (n = n[0]),
          fp(n, t).lift(new GG(e))
        );
      }
      class GG {
        constructor(e) {
          this.resultSelector = e;
        }
        call(e, t) {
          return t.subscribe(new qG(e, this.resultSelector));
        }
      }
      class qG extends zG {
        constructor(e, t) {
          super(e),
            (this.resultSelector = t),
            (this.active = 0),
            (this.values = []),
            (this.observables = []);
        }
        _next(e) {
          this.values.push(rO), this.observables.push(e);
        }
        _complete() {
          const e = this.observables,
            t = e.length;
          if (0 === t) this.destination.complete();
          else {
            (this.active = t), (this.toRespond = t);
            for (let i = 0; i < t; i++) this.add(WG(this, e[i], void 0, i));
          }
        }
        notifyComplete(e) {
          0 == (this.active -= 1) && this.destination.complete();
        }
        notifyNext(e, t, i) {
          const r = this.values,
            s = this.toRespond
              ? r[i] === rO
                ? --this.toRespond
                : this.toRespond
              : 0;
          (r[i] = t),
            0 === s &&
              (this.resultSelector
                ? this._tryResultSelector(r)
                : this.destination.next(r.slice()));
        }
        _tryResultSelector(e) {
          let t;
          try {
            t = this.resultSelector.apply(this, e);
          } catch (i) {
            return void this.destination.error(i);
          }
          this.destination.next(t);
        }
      }
      function gs(n, e) {
        return new je(
          e
            ? (t) => e.schedule(KG, 0, { error: n, subscriber: t })
            : (t) => t.error(n)
        );
      }
      function KG({ error: n, subscriber: e }) {
        e.error(n);
      }
      const Lc = (() => {
        function n() {
          return (
            Error.call(this),
            (this.message = "no elements in sequence"),
            (this.name = "EmptyError"),
            this
          );
        }
        return (n.prototype = Object.create(Error.prototype)), n;
      })();
      function m_(...n) {
        return (function YG() {
          return As(1);
        })()(ne(...n));
      }
      const Ba = new je((n) => n.complete());
      function ef(n) {
        return n
          ? (function ZG(n) {
              return new je((e) => n.schedule(() => e.complete()));
            })(n)
          : Ba;
      }
      function sO(n) {
        return new je((e) => {
          let t;
          try {
            t = n();
          } catch (r) {
            return void e.error(r);
          }
          return (t ? xt(t) : ef()).subscribe(e);
        });
      }
      function or(n, e) {
        return "function" == typeof e
          ? (t) =>
              t.pipe(
                or((i, r) => xt(n(i, r)).pipe(ye((o, s) => e(i, o, r, s))))
              )
          : (t) => t.lift(new QG(n));
      }
      class QG {
        constructor(e) {
          this.project = e;
        }
        call(e, t) {
          return t.subscribe(new JG(e, this.project));
        }
      }
      class JG extends hl {
        constructor(e, t) {
          super(e), (this.project = t), (this.index = 0);
        }
        _next(e) {
          let t;
          const i = this.index++;
          try {
            t = this.project(e, i);
          } catch (r) {
            return void this.destination.error(r);
          }
          this._innerSub(t);
        }
        _innerSub(e) {
          const t = this.innerSubscription;
          t && t.unsubscribe();
          const i = new dl(this),
            r = this.destination;
          r.add(i),
            (this.innerSubscription = fl(e, i)),
            this.innerSubscription !== i && r.add(this.innerSubscription);
        }
        _complete() {
          const { innerSubscription: e } = this;
          (!e || e.closed) && super._complete(), this.unsubscribe();
        }
        _unsubscribe() {
          this.innerSubscription = void 0;
        }
        notifyComplete() {
          (this.innerSubscription = void 0),
            this.isStopped && super._complete();
        }
        notifyNext(e) {
          this.destination.next(e);
        }
      }
      const aO = (() => {
        function n() {
          return (
            Error.call(this),
            (this.message = "argument out of range"),
            (this.name = "ArgumentOutOfRangeError"),
            this
          );
        }
        return (n.prototype = Object.create(Error.prototype)), n;
      })();
      function wo(n) {
        return (e) => (0 === n ? ef() : e.lift(new XG(n)));
      }
      class XG {
        constructor(e) {
          if (((this.total = e), this.total < 0)) throw new aO();
        }
        call(e, t) {
          return t.subscribe(new eq(e, this.total));
        }
      }
      class eq extends Be {
        constructor(e, t) {
          super(e), (this.total = t), (this.count = 0);
        }
        _next(e) {
          const t = this.total,
            i = ++this.count;
          i <= t &&
            (this.destination.next(e),
            i === t && (this.destination.complete(), this.unsubscribe()));
        }
      }
      function lO(n, e) {
        let t = !1;
        return (
          arguments.length >= 2 && (t = !0),
          function (r) {
            return r.lift(new nq(n, e, t));
          }
        );
      }
      class nq {
        constructor(e, t, i = !1) {
          (this.accumulator = e), (this.seed = t), (this.hasSeed = i);
        }
        call(e, t) {
          return t.subscribe(
            new iq(e, this.accumulator, this.seed, this.hasSeed)
          );
        }
      }
      class iq extends Be {
        constructor(e, t, i, r) {
          super(e),
            (this.accumulator = t),
            (this._seed = i),
            (this.hasSeed = r),
            (this.index = 0);
        }
        get seed() {
          return this._seed;
        }
        set seed(e) {
          (this.hasSeed = !0), (this._seed = e);
        }
        _next(e) {
          if (this.hasSeed) return this._tryNext(e);
          (this.seed = e), this.destination.next(e);
        }
        _tryNext(e) {
          const t = this.index++;
          let i;
          try {
            i = this.accumulator(this.seed, e, t);
          } catch (r) {
            this.destination.error(r);
          }
          (this.seed = i), this.destination.next(i);
        }
      }
      function ms(n) {
        return function (t) {
          const i = new rq(n),
            r = t.lift(i);
          return (i.caught = r);
        };
      }
      class rq {
        constructor(e) {
          this.selector = e;
        }
        call(e, t) {
          return t.subscribe(new oq(e, this.selector, this.caught));
        }
      }
      class oq extends hl {
        constructor(e, t, i) {
          super(e), (this.selector = t), (this.caught = i);
        }
        error(e) {
          if (!this.isStopped) {
            let t;
            try {
              t = this.selector(e, this.caught);
            } catch (o) {
              return void super.error(o);
            }
            this._unsubscribeAndRecycle();
            const i = new dl(this);
            this.add(i);
            const r = fl(t, i);
            r !== i && this.add(r);
          }
        }
      }
      function ja(n, e) {
        return zt(n, e, 1);
      }
      function y_(n) {
        return function (t) {
          return 0 === n ? ef() : t.lift(new sq(n));
        };
      }
      class sq {
        constructor(e) {
          if (((this.total = e), this.total < 0)) throw new aO();
        }
        call(e, t) {
          return t.subscribe(new aq(e, this.total));
        }
      }
      class aq extends Be {
        constructor(e, t) {
          super(e),
            (this.total = t),
            (this.ring = new Array()),
            (this.count = 0);
        }
        _next(e) {
          const t = this.ring,
            i = this.total,
            r = this.count++;
          t.length < i ? t.push(e) : (t[r % i] = e);
        }
        _complete() {
          const e = this.destination;
          let t = this.count;
          if (t > 0) {
            const i = this.count >= this.total ? this.total : this.count,
              r = this.ring;
            for (let o = 0; o < i; o++) {
              const s = t++ % i;
              e.next(r[s]);
            }
          }
          e.complete();
        }
      }
      function cO(n = uq) {
        return (e) => e.lift(new lq(n));
      }
      class lq {
        constructor(e) {
          this.errorFactory = e;
        }
        call(e, t) {
          return t.subscribe(new cq(e, this.errorFactory));
        }
      }
      class cq extends Be {
        constructor(e, t) {
          super(e), (this.errorFactory = t), (this.hasValue = !1);
        }
        _next(e) {
          (this.hasValue = !0), this.destination.next(e);
        }
        _complete() {
          if (this.hasValue) return this.destination.complete();
          {
            let e;
            try {
              e = this.errorFactory();
            } catch (t) {
              e = t;
            }
            this.destination.error(e);
          }
        }
      }
      function uq() {
        return new Lc();
      }
      function v_(n = null) {
        return (e) => e.lift(new dq(n));
      }
      class dq {
        constructor(e) {
          this.defaultValue = e;
        }
        call(e, t) {
          return t.subscribe(new hq(e, this.defaultValue));
        }
      }
      class hq extends Be {
        constructor(e, t) {
          super(e), (this.defaultValue = t), (this.isEmpty = !0);
        }
        _next(e) {
          (this.isEmpty = !1), this.destination.next(e);
        }
        _complete() {
          this.isEmpty && this.destination.next(this.defaultValue),
            this.destination.complete();
        }
      }
      function ys(n, e) {
        const t = arguments.length >= 2;
        return (i) =>
          i.pipe(
            n ? ao((r, o) => n(r, o, i)) : Eu,
            wo(1),
            t ? v_(e) : cO(() => new Lc())
          );
      }
      class gq {
        constructor(e) {
          this.value = e;
        }
        call(e, t) {
          return t.subscribe(new mq(e, this.value));
        }
      }
      class mq extends Be {
        constructor(e, t) {
          super(e), (this.value = t);
        }
        _next(e) {
          this.destination.next(this.value);
        }
      }
      function __(n) {
        return (e) => e.lift(new yq(n));
      }
      class yq {
        constructor(e) {
          this.callback = e;
        }
        call(e, t) {
          return t.subscribe(new vq(e, this.callback));
        }
      }
      class vq extends Be {
        constructor(e, t) {
          super(e), this.add(new Te(t));
        }
      }
      class Or {
        constructor(e, t) {
          (this.id = e), (this.url = t);
        }
      }
      class b_ extends Or {
        constructor(e, t, i = "imperative", r = null) {
          super(e, t),
            (this.type = 0),
            (this.navigationTrigger = i),
            (this.restoredState = r);
        }
        toString() {
          return `NavigationStart(id: ${this.id}, url: '${this.url}')`;
        }
      }
      class Vc extends Or {
        constructor(e, t, i) {
          super(e, t), (this.urlAfterRedirects = i), (this.type = 1);
        }
        toString() {
          return `NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')`;
        }
      }
      class uO extends Or {
        constructor(e, t, i) {
          super(e, t), (this.reason = i), (this.type = 2);
        }
        toString() {
          return `NavigationCancel(id: ${this.id}, url: '${this.url}')`;
        }
      }
      class _q extends Or {
        constructor(e, t, i) {
          super(e, t), (this.error = i), (this.type = 3);
        }
        toString() {
          return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})`;
        }
      }
      class bq extends Or {
        constructor(e, t, i, r) {
          super(e, t),
            (this.urlAfterRedirects = i),
            (this.state = r),
            (this.type = 4);
        }
        toString() {
          return `RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;
        }
      }
      class Dq extends Or {
        constructor(e, t, i, r) {
          super(e, t),
            (this.urlAfterRedirects = i),
            (this.state = r),
            (this.type = 7);
        }
        toString() {
          return `GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;
        }
      }
      class Cq extends Or {
        constructor(e, t, i, r, o) {
          super(e, t),
            (this.urlAfterRedirects = i),
            (this.state = r),
            (this.shouldActivate = o),
            (this.type = 8);
        }
        toString() {
          return `GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})`;
        }
      }
      class Eq extends Or {
        constructor(e, t, i, r) {
          super(e, t),
            (this.urlAfterRedirects = i),
            (this.state = r),
            (this.type = 5);
        }
        toString() {
          return `ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;
        }
      }
      class wq extends Or {
        constructor(e, t, i, r) {
          super(e, t),
            (this.urlAfterRedirects = i),
            (this.state = r),
            (this.type = 6);
        }
        toString() {
          return `ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})`;
        }
      }
      class Sq {
        constructor(e) {
          (this.route = e), (this.type = 9);
        }
        toString() {
          return `RouteConfigLoadStart(path: ${this.route.path})`;
        }
      }
      class Mq {
        constructor(e) {
          (this.route = e), (this.type = 10);
        }
        toString() {
          return `RouteConfigLoadEnd(path: ${this.route.path})`;
        }
      }
      class Iq {
        constructor(e) {
          (this.snapshot = e), (this.type = 11);
        }
        toString() {
          return `ChildActivationStart(path: '${
            (this.snapshot.routeConfig && this.snapshot.routeConfig.path) || ""
          }')`;
        }
      }
      class Tq {
        constructor(e) {
          (this.snapshot = e), (this.type = 12);
        }
        toString() {
          return `ChildActivationEnd(path: '${
            (this.snapshot.routeConfig && this.snapshot.routeConfig.path) || ""
          }')`;
        }
      }
      class xq {
        constructor(e) {
          (this.snapshot = e), (this.type = 13);
        }
        toString() {
          return `ActivationStart(path: '${
            (this.snapshot.routeConfig && this.snapshot.routeConfig.path) || ""
          }')`;
        }
      }
      class Aq {
        constructor(e) {
          (this.snapshot = e), (this.type = 14);
        }
        toString() {
          return `ActivationEnd(path: '${
            (this.snapshot.routeConfig && this.snapshot.routeConfig.path) || ""
          }')`;
        }
      }
      class dO {
        constructor(e, t, i) {
          (this.routerEvent = e),
            (this.position = t),
            (this.anchor = i),
            (this.type = 15);
        }
        toString() {
          return `Scroll(anchor: '${this.anchor}', position: '${
            this.position ? `${this.position[0]}, ${this.position[1]}` : null
          }')`;
        }
      }
      const fe = "primary";
      class kq {
        constructor(e) {
          this.params = e || {};
        }
        has(e) {
          return Object.prototype.hasOwnProperty.call(this.params, e);
        }
        get(e) {
          if (this.has(e)) {
            const t = this.params[e];
            return Array.isArray(t) ? t[0] : t;
          }
          return null;
        }
        getAll(e) {
          if (this.has(e)) {
            const t = this.params[e];
            return Array.isArray(t) ? t : [t];
          }
          return [];
        }
        get keys() {
          return Object.keys(this.params);
        }
      }
      function Ha(n) {
        return new kq(n);
      }
      const hO = "ngNavigationCancelingError";
      function D_(n) {
        const e = Error("NavigationCancelingError: " + n);
        return (e[hO] = !0), e;
      }
      function Rq(n, e, t) {
        const i = t.path.split("/");
        if (
          i.length > n.length ||
          ("full" === t.pathMatch && (e.hasChildren() || i.length < n.length))
        )
          return null;
        const r = {};
        for (let o = 0; o < i.length; o++) {
          const s = i[o],
            a = n[o];
          if (s.startsWith(":")) r[s.substring(1)] = a;
          else if (s !== a.path) return null;
        }
        return { consumed: n.slice(0, i.length), posParams: r };
      }
      function sr(n, e) {
        const t = n ? Object.keys(n) : void 0,
          i = e ? Object.keys(e) : void 0;
        if (!t || !i || t.length != i.length) return !1;
        let r;
        for (let o = 0; o < t.length; o++)
          if (((r = t[o]), !fO(n[r], e[r]))) return !1;
        return !0;
      }
      function fO(n, e) {
        if (Array.isArray(n) && Array.isArray(e)) {
          if (n.length !== e.length) return !1;
          const t = [...n].sort(),
            i = [...e].sort();
          return t.every((r, o) => i[o] === r);
        }
        return n === e;
      }
      function pO(n) {
        return Array.prototype.concat.apply([], n);
      }
      function gO(n) {
        return n.length > 0 ? n[n.length - 1] : null;
      }
      function Ht(n, e) {
        for (const t in n) n.hasOwnProperty(t) && e(n[t], t);
      }
      function Mi(n) {
        return fm(n) ? n : zl(n) ? xt(Promise.resolve(n)) : ne(n);
      }
      const Lq = {
          exact: function vO(n, e, t) {
            if (
              !_s(n.segments, e.segments) ||
              !tf(n.segments, e.segments, t) ||
              n.numberOfChildren !== e.numberOfChildren
            )
              return !1;
            for (const i in e.children)
              if (!n.children[i] || !vO(n.children[i], e.children[i], t))
                return !1;
            return !0;
          },
          subset: _O,
        },
        mO = {
          exact: function Vq(n, e) {
            return sr(n, e);
          },
          subset: function Bq(n, e) {
            return (
              Object.keys(e).length <= Object.keys(n).length &&
              Object.keys(e).every((t) => fO(n[t], e[t]))
            );
          },
          ignored: () => !0,
        };
      function yO(n, e, t) {
        return (
          Lq[t.paths](n.root, e.root, t.matrixParams) &&
          mO[t.queryParams](n.queryParams, e.queryParams) &&
          !("exact" === t.fragment && n.fragment !== e.fragment)
        );
      }
      function _O(n, e, t) {
        return bO(n, e, e.segments, t);
      }
      function bO(n, e, t, i) {
        if (n.segments.length > t.length) {
          const r = n.segments.slice(0, t.length);
          return !(!_s(r, t) || e.hasChildren() || !tf(r, t, i));
        }
        if (n.segments.length === t.length) {
          if (!_s(n.segments, t) || !tf(n.segments, t, i)) return !1;
          for (const r in e.children)
            if (!n.children[r] || !_O(n.children[r], e.children[r], i))
              return !1;
          return !0;
        }
        {
          const r = t.slice(0, n.segments.length),
            o = t.slice(n.segments.length);
          return (
            !!(_s(n.segments, r) && tf(n.segments, r, i) && n.children[fe]) &&
            bO(n.children[fe], e, o, i)
          );
        }
      }
      function tf(n, e, t) {
        return e.every((i, r) => mO[t](n[r].parameters, i.parameters));
      }
      class vs {
        constructor(e, t, i) {
          (this.root = e), (this.queryParams = t), (this.fragment = i);
        }
        get queryParamMap() {
          return (
            this._queryParamMap || (this._queryParamMap = Ha(this.queryParams)),
            this._queryParamMap
          );
        }
        toString() {
          return Uq.serialize(this);
        }
      }
      class me {
        constructor(e, t) {
          (this.segments = e),
            (this.children = t),
            (this.parent = null),
            Ht(t, (i, r) => (i.parent = this));
        }
        hasChildren() {
          return this.numberOfChildren > 0;
        }
        get numberOfChildren() {
          return Object.keys(this.children).length;
        }
        toString() {
          return nf(this);
        }
      }
      class Bc {
        constructor(e, t) {
          (this.path = e), (this.parameters = t);
        }
        get parameterMap() {
          return (
            this._parameterMap || (this._parameterMap = Ha(this.parameters)),
            this._parameterMap
          );
        }
        toString() {
          return SO(this);
        }
      }
      function _s(n, e) {
        return n.length === e.length && n.every((t, i) => t.path === e[i].path);
      }
      class DO {}
      class CO {
        parse(e) {
          const t = new Qq(e);
          return new vs(
            t.parseRootSegment(),
            t.parseQueryParams(),
            t.parseFragment()
          );
        }
        serialize(e) {
          const t = `/${jc(e.root, !0)}`,
            i = (function Wq(n) {
              const e = Object.keys(n)
                .map((t) => {
                  const i = n[t];
                  return Array.isArray(i)
                    ? i.map((r) => `${rf(t)}=${rf(r)}`).join("&")
                    : `${rf(t)}=${rf(i)}`;
                })
                .filter((t) => !!t);
              return e.length ? `?${e.join("&")}` : "";
            })(e.queryParams),
            r =
              "string" == typeof e.fragment
                ? `#${(function zq(n) {
                    return encodeURI(n);
                  })(e.fragment)}`
                : "";
          return `${t}${i}${r}`;
        }
      }
      const Uq = new CO();
      function nf(n) {
        return n.segments.map((e) => SO(e)).join("/");
      }
      function jc(n, e) {
        if (!n.hasChildren()) return nf(n);
        if (e) {
          const t = n.children[fe] ? jc(n.children[fe], !1) : "",
            i = [];
          return (
            Ht(n.children, (r, o) => {
              o !== fe && i.push(`${o}:${jc(r, !1)}`);
            }),
            i.length > 0 ? `${t}(${i.join("//")})` : t
          );
        }
        {
          const t = (function Hq(n, e) {
            let t = [];
            return (
              Ht(n.children, (i, r) => {
                r === fe && (t = t.concat(e(i, r)));
              }),
              Ht(n.children, (i, r) => {
                r !== fe && (t = t.concat(e(i, r)));
              }),
              t
            );
          })(n, (i, r) =>
            r === fe ? [jc(n.children[fe], !1)] : [`${r}:${jc(i, !1)}`]
          );
          return 1 === Object.keys(n.children).length && null != n.children[fe]
            ? `${nf(n)}/${t[0]}`
            : `${nf(n)}/(${t.join("//")})`;
        }
      }
      function EO(n) {
        return encodeURIComponent(n)
          .replace(/%40/g, "@")
          .replace(/%3A/gi, ":")
          .replace(/%24/g, "$")
          .replace(/%2C/gi, ",");
      }
      function rf(n) {
        return EO(n).replace(/%3B/gi, ";");
      }
      function C_(n) {
        return EO(n)
          .replace(/\(/g, "%28")
          .replace(/\)/g, "%29")
          .replace(/%26/gi, "&");
      }
      function sf(n) {
        return decodeURIComponent(n);
      }
      function wO(n) {
        return sf(n.replace(/\+/g, "%20"));
      }
      function SO(n) {
        return `${C_(n.path)}${(function $q(n) {
          return Object.keys(n)
            .map((e) => `;${C_(e)}=${C_(n[e])}`)
            .join("");
        })(n.parameters)}`;
      }
      const Gq = /^[^\/()?;=#]+/;
      function af(n) {
        const e = n.match(Gq);
        return e ? e[0] : "";
      }
      const qq = /^[^=?&#]+/,
        Yq = /^[^&#]+/;
      class Qq {
        constructor(e) {
          (this.url = e), (this.remaining = e);
        }
        parseRootSegment() {
          return (
            this.consumeOptional("/"),
            "" === this.remaining ||
            this.peekStartsWith("?") ||
            this.peekStartsWith("#")
              ? new me([], {})
              : new me([], this.parseChildren())
          );
        }
        parseQueryParams() {
          const e = {};
          if (this.consumeOptional("?"))
            do {
              this.parseQueryParam(e);
            } while (this.consumeOptional("&"));
          return e;
        }
        parseFragment() {
          return this.consumeOptional("#")
            ? decodeURIComponent(this.remaining)
            : null;
        }
        parseChildren() {
          if ("" === this.remaining) return {};
          this.consumeOptional("/");
          const e = [];
          for (
            this.peekStartsWith("(") || e.push(this.parseSegment());
            this.peekStartsWith("/") &&
            !this.peekStartsWith("//") &&
            !this.peekStartsWith("/(");

          )
            this.capture("/"), e.push(this.parseSegment());
          let t = {};
          this.peekStartsWith("/(") &&
            (this.capture("/"), (t = this.parseParens(!0)));
          let i = {};
          return (
            this.peekStartsWith("(") && (i = this.parseParens(!1)),
            (e.length > 0 || Object.keys(t).length > 0) &&
              (i[fe] = new me(e, t)),
            i
          );
        }
        parseSegment() {
          const e = af(this.remaining);
          if ("" === e && this.peekStartsWith(";"))
            throw new Error(
              `Empty path url segment cannot have parameters: '${this.remaining}'.`
            );
          return this.capture(e), new Bc(sf(e), this.parseMatrixParams());
        }
        parseMatrixParams() {
          const e = {};
          for (; this.consumeOptional(";"); ) this.parseParam(e);
          return e;
        }
        parseParam(e) {
          const t = af(this.remaining);
          if (!t) return;
          this.capture(t);
          let i = "";
          if (this.consumeOptional("=")) {
            const r = af(this.remaining);
            r && ((i = r), this.capture(i));
          }
          e[sf(t)] = sf(i);
        }
        parseQueryParam(e) {
          const t = (function Kq(n) {
            const e = n.match(qq);
            return e ? e[0] : "";
          })(this.remaining);
          if (!t) return;
          this.capture(t);
          let i = "";
          if (this.consumeOptional("=")) {
            const s = (function Zq(n) {
              const e = n.match(Yq);
              return e ? e[0] : "";
            })(this.remaining);
            s && ((i = s), this.capture(i));
          }
          const r = wO(t),
            o = wO(i);
          if (e.hasOwnProperty(r)) {
            let s = e[r];
            Array.isArray(s) || ((s = [s]), (e[r] = s)), s.push(o);
          } else e[r] = o;
        }
        parseParens(e) {
          const t = {};
          for (
            this.capture("(");
            !this.consumeOptional(")") && this.remaining.length > 0;

          ) {
            const i = af(this.remaining),
              r = this.remaining[i.length];
            if ("/" !== r && ")" !== r && ";" !== r)
              throw new Error(`Cannot parse url '${this.url}'`);
            let o;
            i.indexOf(":") > -1
              ? ((o = i.slice(0, i.indexOf(":"))),
                this.capture(o),
                this.capture(":"))
              : e && (o = fe);
            const s = this.parseChildren();
            (t[o] = 1 === Object.keys(s).length ? s[fe] : new me([], s)),
              this.consumeOptional("//");
          }
          return t;
        }
        peekStartsWith(e) {
          return this.remaining.startsWith(e);
        }
        consumeOptional(e) {
          return (
            !!this.peekStartsWith(e) &&
            ((this.remaining = this.remaining.substring(e.length)), !0)
          );
        }
        capture(e) {
          if (!this.consumeOptional(e)) throw new Error(`Expected "${e}".`);
        }
      }
      class MO {
        constructor(e) {
          this._root = e;
        }
        get root() {
          return this._root.value;
        }
        parent(e) {
          const t = this.pathFromRoot(e);
          return t.length > 1 ? t[t.length - 2] : null;
        }
        children(e) {
          const t = E_(e, this._root);
          return t ? t.children.map((i) => i.value) : [];
        }
        firstChild(e) {
          const t = E_(e, this._root);
          return t && t.children.length > 0 ? t.children[0].value : null;
        }
        siblings(e) {
          const t = w_(e, this._root);
          return t.length < 2
            ? []
            : t[t.length - 2].children
                .map((r) => r.value)
                .filter((r) => r !== e);
        }
        pathFromRoot(e) {
          return w_(e, this._root).map((t) => t.value);
        }
      }
      function E_(n, e) {
        if (n === e.value) return e;
        for (const t of e.children) {
          const i = E_(n, t);
          if (i) return i;
        }
        return null;
      }
      function w_(n, e) {
        if (n === e.value) return [e];
        for (const t of e.children) {
          const i = w_(n, t);
          if (i.length) return i.unshift(e), i;
        }
        return [];
      }
      class kr {
        constructor(e, t) {
          (this.value = e), (this.children = t);
        }
        toString() {
          return `TreeNode(${this.value})`;
        }
      }
      function Ua(n) {
        const e = {};
        return n && n.children.forEach((t) => (e[t.value.outlet] = t)), e;
      }
      class IO extends MO {
        constructor(e, t) {
          super(e), (this.snapshot = t), S_(this, e);
        }
        toString() {
          return this.snapshot.toString();
        }
      }
      function TO(n, e) {
        const t = (function Jq(n, e) {
            const s = new lf([], {}, {}, "", {}, fe, e, null, n.root, -1, {});
            return new AO("", new kr(s, []));
          })(n, e),
          i = new Si([new Bc("", {})]),
          r = new Si({}),
          o = new Si({}),
          s = new Si({}),
          a = new Si(""),
          l = new za(i, r, s, a, o, fe, e, t.root);
        return (l.snapshot = t.root), new IO(new kr(l, []), t);
      }
      class za {
        constructor(e, t, i, r, o, s, a, l) {
          (this.url = e),
            (this.params = t),
            (this.queryParams = i),
            (this.fragment = r),
            (this.data = o),
            (this.outlet = s),
            (this.component = a),
            (this._futureSnapshot = l);
        }
        get routeConfig() {
          return this._futureSnapshot.routeConfig;
        }
        get root() {
          return this._routerState.root;
        }
        get parent() {
          return this._routerState.parent(this);
        }
        get firstChild() {
          return this._routerState.firstChild(this);
        }
        get children() {
          return this._routerState.children(this);
        }
        get pathFromRoot() {
          return this._routerState.pathFromRoot(this);
        }
        get paramMap() {
          return (
            this._paramMap ||
              (this._paramMap = this.params.pipe(ye((e) => Ha(e)))),
            this._paramMap
          );
        }
        get queryParamMap() {
          return (
            this._queryParamMap ||
              (this._queryParamMap = this.queryParams.pipe(ye((e) => Ha(e)))),
            this._queryParamMap
          );
        }
        toString() {
          return this.snapshot
            ? this.snapshot.toString()
            : `Future(${this._futureSnapshot})`;
        }
      }
      function xO(n, e = "emptyOnly") {
        const t = n.pathFromRoot;
        let i = 0;
        if ("always" !== e)
          for (i = t.length - 1; i >= 1; ) {
            const r = t[i],
              o = t[i - 1];
            if (r.routeConfig && "" === r.routeConfig.path) i--;
            else {
              if (o.component) break;
              i--;
            }
          }
        return (function Xq(n) {
          return n.reduce(
            (e, t) => ({
              params: { ...e.params, ...t.params },
              data: { ...e.data, ...t.data },
              resolve: {
                ...t.data,
                ...e.resolve,
                ...t.routeConfig?.data,
                ...t._resolvedData,
              },
            }),
            { params: {}, data: {}, resolve: {} }
          );
        })(t.slice(i));
      }
      class lf {
        constructor(e, t, i, r, o, s, a, l, c, u, d, h) {
          (this.url = e),
            (this.params = t),
            (this.queryParams = i),
            (this.fragment = r),
            (this.data = o),
            (this.outlet = s),
            (this.component = a),
            (this.routeConfig = l),
            (this._urlSegment = c),
            (this._lastPathIndex = u),
            (this._correctedLastPathIndex = h ?? u),
            (this._resolve = d);
        }
        get root() {
          return this._routerState.root;
        }
        get parent() {
          return this._routerState.parent(this);
        }
        get firstChild() {
          return this._routerState.firstChild(this);
        }
        get children() {
          return this._routerState.children(this);
        }
        get pathFromRoot() {
          return this._routerState.pathFromRoot(this);
        }
        get paramMap() {
          return (
            this._paramMap || (this._paramMap = Ha(this.params)), this._paramMap
          );
        }
        get queryParamMap() {
          return (
            this._queryParamMap || (this._queryParamMap = Ha(this.queryParams)),
            this._queryParamMap
          );
        }
        toString() {
          return `Route(url:'${this.url
            .map((i) => i.toString())
            .join("/")}', path:'${
            this.routeConfig ? this.routeConfig.path : ""
          }')`;
        }
      }
      class AO extends MO {
        constructor(e, t) {
          super(t), (this.url = e), S_(this, t);
        }
        toString() {
          return OO(this._root);
        }
      }
      function S_(n, e) {
        (e.value._routerState = n), e.children.forEach((t) => S_(n, t));
      }
      function OO(n) {
        const e =
          n.children.length > 0 ? ` { ${n.children.map(OO).join(", ")} } ` : "";
        return `${n.value}${e}`;
      }
      function M_(n) {
        if (n.snapshot) {
          const e = n.snapshot,
            t = n._futureSnapshot;
          (n.snapshot = t),
            sr(e.queryParams, t.queryParams) ||
              n.queryParams.next(t.queryParams),
            e.fragment !== t.fragment && n.fragment.next(t.fragment),
            sr(e.params, t.params) || n.params.next(t.params),
            (function Pq(n, e) {
              if (n.length !== e.length) return !1;
              for (let t = 0; t < n.length; ++t) if (!sr(n[t], e[t])) return !1;
              return !0;
            })(e.url, t.url) || n.url.next(t.url),
            sr(e.data, t.data) || n.data.next(t.data);
        } else
          (n.snapshot = n._futureSnapshot), n.data.next(n._futureSnapshot.data);
      }
      function I_(n, e) {
        const t =
          sr(n.params, e.params) &&
          (function jq(n, e) {
            return (
              _s(n, e) && n.every((t, i) => sr(t.parameters, e[i].parameters))
            );
          })(n.url, e.url);
        return (
          t &&
          !(!n.parent != !e.parent) &&
          (!n.parent || I_(n.parent, e.parent))
        );
      }
      function Hc(n, e, t) {
        if (t && n.shouldReuseRoute(e.value, t.value.snapshot)) {
          const i = t.value;
          i._futureSnapshot = e.value;
          const r = (function t9(n, e, t) {
            return e.children.map((i) => {
              for (const r of t.children)
                if (n.shouldReuseRoute(i.value, r.value.snapshot))
                  return Hc(n, i, r);
              return Hc(n, i);
            });
          })(n, e, t);
          return new kr(i, r);
        }
        {
          if (n.shouldAttach(e.value)) {
            const o = n.retrieve(e.value);
            if (null !== o) {
              const s = o.route;
              return (
                (s.value._futureSnapshot = e.value),
                (s.children = e.children.map((a) => Hc(n, a))),
                s
              );
            }
          }
          const i = (function n9(n) {
              return new za(
                new Si(n.url),
                new Si(n.params),
                new Si(n.queryParams),
                new Si(n.fragment),
                new Si(n.data),
                n.outlet,
                n.component,
                n
              );
            })(e.value),
            r = e.children.map((o) => Hc(n, o));
          return new kr(i, r);
        }
      }
      function cf(n) {
        return (
          "object" == typeof n && null != n && !n.outlets && !n.segmentPath
        );
      }
      function Uc(n) {
        return "object" == typeof n && null != n && n.outlets;
      }
      function T_(n, e, t, i, r) {
        let o = {};
        if (
          (i &&
            Ht(i, (a, l) => {
              o[l] = Array.isArray(a) ? a.map((c) => `${c}`) : `${a}`;
            }),
          n === e)
        )
          return new vs(t, o, r);
        const s = kO(n, e, t);
        return new vs(s, o, r);
      }
      function kO(n, e, t) {
        const i = {};
        return (
          Ht(n.children, (r, o) => {
            i[o] = r === e ? t : kO(r, e, t);
          }),
          new me(n.segments, i)
        );
      }
      class NO {
        constructor(e, t, i) {
          if (
            ((this.isAbsolute = e),
            (this.numberOfDoubleDots = t),
            (this.commands = i),
            e && i.length > 0 && cf(i[0]))
          )
            throw new Error("Root segment cannot have matrix parameters");
          const r = i.find(Uc);
          if (r && r !== gO(i))
            throw new Error("{outlets:{}} has to be the last command");
        }
        toRoot() {
          return (
            this.isAbsolute &&
            1 === this.commands.length &&
            "/" == this.commands[0]
          );
        }
      }
      class x_ {
        constructor(e, t, i) {
          (this.segmentGroup = e), (this.processChildren = t), (this.index = i);
        }
      }
      function RO(n, e, t) {
        if (
          (n || (n = new me([], {})),
          0 === n.segments.length && n.hasChildren())
        )
          return uf(n, e, t);
        const i = (function l9(n, e, t) {
            let i = 0,
              r = e;
            const o = { match: !1, pathIndex: 0, commandIndex: 0 };
            for (; r < n.segments.length; ) {
              if (i >= t.length) return o;
              const s = n.segments[r],
                a = t[i];
              if (Uc(a)) break;
              const l = `${a}`,
                c = i < t.length - 1 ? t[i + 1] : null;
              if (r > 0 && void 0 === l) break;
              if (l && c && "object" == typeof c && void 0 === c.outlets) {
                if (!FO(l, c, s)) return o;
                i += 2;
              } else {
                if (!FO(l, {}, s)) return o;
                i++;
              }
              r++;
            }
            return { match: !0, pathIndex: r, commandIndex: i };
          })(n, e, t),
          r = t.slice(i.commandIndex);
        if (i.match && i.pathIndex < n.segments.length) {
          const o = new me(n.segments.slice(0, i.pathIndex), {});
          return (
            (o.children[fe] = new me(
              n.segments.slice(i.pathIndex),
              n.children
            )),
            uf(o, 0, r)
          );
        }
        return i.match && 0 === r.length
          ? new me(n.segments, {})
          : i.match && !n.hasChildren()
          ? A_(n, e, t)
          : i.match
          ? uf(n, 0, r)
          : A_(n, e, t);
      }
      function uf(n, e, t) {
        if (0 === t.length) return new me(n.segments, {});
        {
          const i = (function a9(n) {
              return Uc(n[0]) ? n[0].outlets : { [fe]: n };
            })(t),
            r = {};
          return (
            Ht(i, (o, s) => {
              "string" == typeof o && (o = [o]),
                null !== o && (r[s] = RO(n.children[s], e, o));
            }),
            Ht(n.children, (o, s) => {
              void 0 === i[s] && (r[s] = o);
            }),
            new me(n.segments, r)
          );
        }
      }
      function A_(n, e, t) {
        const i = n.segments.slice(0, e);
        let r = 0;
        for (; r < t.length; ) {
          const o = t[r];
          if (Uc(o)) {
            const l = c9(o.outlets);
            return new me(i, l);
          }
          if (0 === r && cf(t[0])) {
            i.push(new Bc(n.segments[e].path, PO(t[0]))), r++;
            continue;
          }
          const s = Uc(o) ? o.outlets[fe] : `${o}`,
            a = r < t.length - 1 ? t[r + 1] : null;
          s && a && cf(a)
            ? (i.push(new Bc(s, PO(a))), (r += 2))
            : (i.push(new Bc(s, {})), r++);
        }
        return new me(i, {});
      }
      function c9(n) {
        const e = {};
        return (
          Ht(n, (t, i) => {
            "string" == typeof t && (t = [t]),
              null !== t && (e[i] = A_(new me([], {}), 0, t));
          }),
          e
        );
      }
      function PO(n) {
        const e = {};
        return Ht(n, (t, i) => (e[i] = `${t}`)), e;
      }
      function FO(n, e, t) {
        return n == t.path && sr(e, t.parameters);
      }
      class u9 {
        constructor() {
          (this.outlet = null),
            (this.route = null),
            (this.resolver = null),
            (this.injector = null),
            (this.children = new zc()),
            (this.attachRef = null);
        }
      }
      class zc {
        constructor() {
          this.contexts = new Map();
        }
        onChildOutletCreated(e, t) {
          const i = this.getOrCreateContext(e);
          (i.outlet = t), this.contexts.set(e, i);
        }
        onChildOutletDestroyed(e) {
          const t = this.getContext(e);
          t && ((t.outlet = null), (t.attachRef = null));
        }
        onOutletDeactivated() {
          const e = this.contexts;
          return (this.contexts = new Map()), e;
        }
        onOutletReAttached(e) {
          this.contexts = e;
        }
        getOrCreateContext(e) {
          let t = this.getContext(e);
          return t || ((t = new u9()), this.contexts.set(e, t)), t;
        }
        getContext(e) {
          return this.contexts.get(e) || null;
        }
      }
      let LO = (() => {
        class n {
          constructor(t, i, r, o, s) {
            (this.parentContexts = t),
              (this.location = i),
              (this.changeDetector = o),
              (this.environmentInjector = s),
              (this.activated = null),
              (this._activatedRoute = null),
              (this.activateEvents = new Ie()),
              (this.deactivateEvents = new Ie()),
              (this.attachEvents = new Ie()),
              (this.detachEvents = new Ie()),
              (this.name = r || fe),
              t.onChildOutletCreated(this.name, this);
          }
          ngOnDestroy() {
            this.parentContexts.getContext(this.name)?.outlet === this &&
              this.parentContexts.onChildOutletDestroyed(this.name);
          }
          ngOnInit() {
            if (!this.activated) {
              const t = this.parentContexts.getContext(this.name);
              t &&
                t.route &&
                (t.attachRef
                  ? this.attach(t.attachRef, t.route)
                  : this.activateWith(t.route, t.injector));
            }
          }
          get isActivated() {
            return !!this.activated;
          }
          get component() {
            if (!this.activated) throw new Error("Outlet is not activated");
            return this.activated.instance;
          }
          get activatedRoute() {
            if (!this.activated) throw new Error("Outlet is not activated");
            return this._activatedRoute;
          }
          get activatedRouteData() {
            return this._activatedRoute
              ? this._activatedRoute.snapshot.data
              : {};
          }
          detach() {
            if (!this.activated) throw new Error("Outlet is not activated");
            this.location.detach();
            const t = this.activated;
            return (
              (this.activated = null),
              (this._activatedRoute = null),
              this.detachEvents.emit(t.instance),
              t
            );
          }
          attach(t, i) {
            (this.activated = t),
              (this._activatedRoute = i),
              this.location.insert(t.hostView),
              this.attachEvents.emit(t.instance);
          }
          deactivate() {
            if (this.activated) {
              const t = this.component;
              this.activated.destroy(),
                (this.activated = null),
                (this._activatedRoute = null),
                this.deactivateEvents.emit(t);
            }
          }
          activateWith(t, i) {
            if (this.isActivated)
              throw new Error("Cannot activate an already activated outlet");
            this._activatedRoute = t;
            const r = this.location,
              s = t._futureSnapshot.component,
              a = this.parentContexts.getOrCreateContext(this.name).children,
              l = new d9(t, a, r.injector);
            if (
              i &&
              (function h9(n) {
                return !!n.resolveComponentFactory;
              })(i)
            ) {
              const c = i.resolveComponentFactory(s);
              this.activated = r.createComponent(c, r.length, l);
            } else
              this.activated = r.createComponent(s, {
                index: r.length,
                injector: l,
                environmentInjector: i ?? this.environmentInjector,
              });
            this.changeDetector.markForCheck(),
              this.activateEvents.emit(this.activated.instance);
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(
              w(zc),
              w(Yn),
              (function El(n) {
                return (function MR(n, e) {
                  if ("class" === e) return n.classes;
                  if ("style" === e) return n.styles;
                  const t = n.attrs;
                  if (t) {
                    const i = t.length;
                    let r = 0;
                    for (; r < i; ) {
                      const o = t[r];
                      if (gD(o)) break;
                      if (0 === o) r += 2;
                      else if ("number" == typeof o)
                        for (r++; r < i && "string" == typeof t[r]; ) r++;
                      else {
                        if (o === e) return t[r + 1];
                        r += 2;
                      }
                    }
                  }
                  return null;
                })(Ct(), n);
              })("name"),
              w(Zo),
              w(Go)
            );
          }),
          (n.ɵdir = q({
            type: n,
            selectors: [["router-outlet"]],
            outputs: {
              activateEvents: "activate",
              deactivateEvents: "deactivate",
              attachEvents: "attach",
              detachEvents: "detach",
            },
            exportAs: ["outlet"],
          })),
          n
        );
      })();
      class d9 {
        constructor(e, t, i) {
          (this.route = e), (this.childContexts = t), (this.parent = i);
        }
        get(e, t) {
          return e === za
            ? this.route
            : e === zc
            ? this.childContexts
            : this.parent.get(e, t);
        }
      }
      let VO = (() => {
        class n {}
        return (
          (n.ɵfac = function (t) {
            return new (t || n)();
          }),
          (n.ɵcmp = ht({
            type: n,
            selectors: [["ng-component"]],
            decls: 1,
            vars: 0,
            template: function (t, i) {
              1 & t && Lt(0, "router-outlet");
            },
            dependencies: [LO],
            encapsulation: 2,
          })),
          n
        );
      })();
      function BO(n, e) {
        return (
          n.providers &&
            !n._injector &&
            (n._injector = wd(n.providers, e, `Route: ${n.path}`)),
          n._injector ?? e
        );
      }
      function k_(n) {
        const e = n.children && n.children.map(k_),
          t = e ? { ...n, children: e } : { ...n };
        return (
          !t.component &&
            !t.loadComponent &&
            (e || t.loadChildren) &&
            t.outlet &&
            t.outlet !== fe &&
            (t.component = VO),
          t
        );
      }
      function ti(n) {
        return n.outlet || fe;
      }
      function jO(n, e) {
        const t = n.filter((i) => ti(i) === e);
        return t.push(...n.filter((i) => ti(i) !== e)), t;
      }
      function HO(n) {
        if (!n) return null;
        if (n.routeConfig?._injector) return n.routeConfig._injector;
        for (let e = n.parent; e; e = e.parent) {
          const t = e.routeConfig;
          if (t?._loadedInjector) return t._loadedInjector;
          if (t?._injector) return t._injector;
        }
        return null;
      }
      class y9 {
        constructor(e, t, i, r) {
          (this.routeReuseStrategy = e),
            (this.futureState = t),
            (this.currState = i),
            (this.forwardEvent = r);
        }
        activate(e) {
          const t = this.futureState._root,
            i = this.currState ? this.currState._root : null;
          this.deactivateChildRoutes(t, i, e),
            M_(this.futureState.root),
            this.activateChildRoutes(t, i, e);
        }
        deactivateChildRoutes(e, t, i) {
          const r = Ua(t);
          e.children.forEach((o) => {
            const s = o.value.outlet;
            this.deactivateRoutes(o, r[s], i), delete r[s];
          }),
            Ht(r, (o, s) => {
              this.deactivateRouteAndItsChildren(o, i);
            });
        }
        deactivateRoutes(e, t, i) {
          const r = e.value,
            o = t ? t.value : null;
          if (r === o)
            if (r.component) {
              const s = i.getContext(r.outlet);
              s && this.deactivateChildRoutes(e, t, s.children);
            } else this.deactivateChildRoutes(e, t, i);
          else o && this.deactivateRouteAndItsChildren(t, i);
        }
        deactivateRouteAndItsChildren(e, t) {
          e.value.component &&
          this.routeReuseStrategy.shouldDetach(e.value.snapshot)
            ? this.detachAndStoreRouteSubtree(e, t)
            : this.deactivateRouteAndOutlet(e, t);
        }
        detachAndStoreRouteSubtree(e, t) {
          const i = t.getContext(e.value.outlet),
            r = i && e.value.component ? i.children : t,
            o = Ua(e);
          for (const s of Object.keys(o))
            this.deactivateRouteAndItsChildren(o[s], r);
          if (i && i.outlet) {
            const s = i.outlet.detach(),
              a = i.children.onOutletDeactivated();
            this.routeReuseStrategy.store(e.value.snapshot, {
              componentRef: s,
              route: e,
              contexts: a,
            });
          }
        }
        deactivateRouteAndOutlet(e, t) {
          const i = t.getContext(e.value.outlet),
            r = i && e.value.component ? i.children : t,
            o = Ua(e);
          for (const s of Object.keys(o))
            this.deactivateRouteAndItsChildren(o[s], r);
          i &&
            i.outlet &&
            (i.outlet.deactivate(),
            i.children.onOutletDeactivated(),
            (i.attachRef = null),
            (i.resolver = null),
            (i.route = null));
        }
        activateChildRoutes(e, t, i) {
          const r = Ua(t);
          e.children.forEach((o) => {
            this.activateRoutes(o, r[o.value.outlet], i),
              this.forwardEvent(new Aq(o.value.snapshot));
          }),
            e.children.length && this.forwardEvent(new Tq(e.value.snapshot));
        }
        activateRoutes(e, t, i) {
          const r = e.value,
            o = t ? t.value : null;
          if ((M_(r), r === o))
            if (r.component) {
              const s = i.getOrCreateContext(r.outlet);
              this.activateChildRoutes(e, t, s.children);
            } else this.activateChildRoutes(e, t, i);
          else if (r.component) {
            const s = i.getOrCreateContext(r.outlet);
            if (this.routeReuseStrategy.shouldAttach(r.snapshot)) {
              const a = this.routeReuseStrategy.retrieve(r.snapshot);
              this.routeReuseStrategy.store(r.snapshot, null),
                s.children.onOutletReAttached(a.contexts),
                (s.attachRef = a.componentRef),
                (s.route = a.route.value),
                s.outlet && s.outlet.attach(a.componentRef, a.route.value),
                M_(a.route.value),
                this.activateChildRoutes(e, null, s.children);
            } else {
              const a = HO(r.snapshot),
                l = a?.get(Qr) ?? null;
              (s.attachRef = null),
                (s.route = r),
                (s.resolver = l),
                (s.injector = a),
                s.outlet && s.outlet.activateWith(r, s.injector),
                this.activateChildRoutes(e, null, s.children);
            }
          } else this.activateChildRoutes(e, null, i);
        }
      }
      function So(n) {
        return "function" == typeof n;
      }
      function bs(n) {
        return n instanceof vs;
      }
      const $c = Symbol("INITIAL_VALUE");
      function Wc() {
        return or((n) =>
          oO(
            n.map((e) =>
              e.pipe(
                wo(1),
                (function tq(...n) {
                  const e = n[n.length - 1];
                  return xs(e)
                    ? (n.pop(), (t) => m_(n, t, e))
                    : (t) => m_(n, t);
                })($c)
              )
            )
          ).pipe(
            lO((e, t) => {
              let i = !1;
              return t.reduce(
                (r, o, s) =>
                  r !== $c
                    ? r
                    : (o === $c && (i = !0),
                      i || (!1 !== o && s !== t.length - 1 && !bs(o)) ? r : o),
                e
              );
            }, $c),
            ao((e) => e !== $c),
            ye((e) => (bs(e) ? e : !0 === e)),
            wo(1)
          )
        );
      }
      const UO = {
        matched: !1,
        consumedSegments: [],
        remainingSegments: [],
        parameters: {},
        positionalParamSegments: {},
      };
      function df(n, e, t) {
        if ("" === e.path)
          return "full" === e.pathMatch && (n.hasChildren() || t.length > 0)
            ? { ...UO }
            : {
                matched: !0,
                consumedSegments: [],
                remainingSegments: t,
                parameters: {},
                positionalParamSegments: {},
              };
        const r = (e.matcher || Rq)(t, n, e);
        if (!r) return { ...UO };
        const o = {};
        Ht(r.posParams, (a, l) => {
          o[l] = a.path;
        });
        const s =
          r.consumed.length > 0
            ? { ...o, ...r.consumed[r.consumed.length - 1].parameters }
            : o;
        return {
          matched: !0,
          consumedSegments: r.consumed,
          remainingSegments: t.slice(r.consumed.length),
          parameters: s,
          positionalParamSegments: r.posParams ?? {},
        };
      }
      function hf(n, e, t, i, r = "corrected") {
        if (
          t.length > 0 &&
          (function S9(n, e, t) {
            return t.some((i) => ff(n, e, i) && ti(i) !== fe);
          })(n, t, i)
        ) {
          const s = new me(
            e,
            (function w9(n, e, t, i) {
              const r = {};
              (r[fe] = i),
                (i._sourceSegment = n),
                (i._segmentIndexShift = e.length);
              for (const o of t)
                if ("" === o.path && ti(o) !== fe) {
                  const s = new me([], {});
                  (s._sourceSegment = n),
                    (s._segmentIndexShift = e.length),
                    (r[ti(o)] = s);
                }
              return r;
            })(n, e, i, new me(t, n.children))
          );
          return (
            (s._sourceSegment = n),
            (s._segmentIndexShift = e.length),
            { segmentGroup: s, slicedSegments: [] }
          );
        }
        if (
          0 === t.length &&
          (function M9(n, e, t) {
            return t.some((i) => ff(n, e, i));
          })(n, t, i)
        ) {
          const s = new me(
            n.segments,
            (function E9(n, e, t, i, r, o) {
              const s = {};
              for (const a of i)
                if (ff(n, t, a) && !r[ti(a)]) {
                  const l = new me([], {});
                  (l._sourceSegment = n),
                    (l._segmentIndexShift =
                      "legacy" === o ? n.segments.length : e.length),
                    (s[ti(a)] = l);
                }
              return { ...r, ...s };
            })(n, e, t, i, n.children, r)
          );
          return (
            (s._sourceSegment = n),
            (s._segmentIndexShift = e.length),
            { segmentGroup: s, slicedSegments: t }
          );
        }
        const o = new me(n.segments, n.children);
        return (
          (o._sourceSegment = n),
          (o._segmentIndexShift = e.length),
          { segmentGroup: o, slicedSegments: t }
        );
      }
      function ff(n, e, t) {
        return (
          (!(n.hasChildren() || e.length > 0) || "full" !== t.pathMatch) &&
          "" === t.path
        );
      }
      function zO(n, e, t, i) {
        return (
          !!(ti(n) === i || (i !== fe && ff(e, t, n))) &&
          ("**" === n.path || df(e, n, t).matched)
        );
      }
      function $O(n, e, t) {
        return 0 === e.length && !n.children[t];
      }
      class pf {
        constructor(e) {
          this.segmentGroup = e || null;
        }
      }
      class WO {
        constructor(e) {
          this.urlTree = e;
        }
      }
      function Gc(n) {
        return gs(new pf(n));
      }
      function GO(n) {
        return gs(new WO(n));
      }
      function I9(n) {
        return gs(
          new Error(
            `Only absolute redirects can have named outlets. redirectTo: '${n}'`
          )
        );
      }
      class A9 {
        constructor(e, t, i, r, o) {
          (this.injector = e),
            (this.configLoader = t),
            (this.urlSerializer = i),
            (this.urlTree = r),
            (this.config = o),
            (this.allowRedirects = !0);
        }
        apply() {
          const e = hf(this.urlTree.root, [], [], this.config).segmentGroup,
            t = new me(e.segments, e.children);
          return this.expandSegmentGroup(this.injector, this.config, t, fe)
            .pipe(
              ye((o) =>
                this.createUrlTree(
                  N_(o),
                  this.urlTree.queryParams,
                  this.urlTree.fragment
                )
              )
            )
            .pipe(
              ms((o) => {
                if (o instanceof WO)
                  return (this.allowRedirects = !1), this.match(o.urlTree);
                throw o instanceof pf ? this.noMatchError(o) : o;
              })
            );
        }
        match(e) {
          return this.expandSegmentGroup(this.injector, this.config, e.root, fe)
            .pipe(
              ye((r) => this.createUrlTree(N_(r), e.queryParams, e.fragment))
            )
            .pipe(
              ms((r) => {
                throw r instanceof pf ? this.noMatchError(r) : r;
              })
            );
        }
        noMatchError(e) {
          return new Error(
            `Cannot match any routes. URL Segment: '${e.segmentGroup}'`
          );
        }
        createUrlTree(e, t, i) {
          const r = e.segments.length > 0 ? new me([], { [fe]: e }) : e;
          return new vs(r, t, i);
        }
        expandSegmentGroup(e, t, i, r) {
          return 0 === i.segments.length && i.hasChildren()
            ? this.expandChildren(e, t, i).pipe(ye((o) => new me([], o)))
            : this.expandSegment(e, i, t, i.segments, r, !0);
        }
        expandChildren(e, t, i) {
          const r = [];
          for (const o of Object.keys(i.children))
            "primary" === o ? r.unshift(o) : r.push(o);
          return xt(r).pipe(
            ja((o) => {
              const s = i.children[o],
                a = jO(t, o);
              return this.expandSegmentGroup(e, a, s, o).pipe(
                ye((l) => ({ segment: l, outlet: o }))
              );
            }),
            lO((o, s) => ((o[s.outlet] = s.segment), o), {}),
            (function fq(n, e) {
              const t = arguments.length >= 2;
              return (i) =>
                i.pipe(
                  n ? ao((r, o) => n(r, o, i)) : Eu,
                  y_(1),
                  t ? v_(e) : cO(() => new Lc())
                );
            })()
          );
        }
        expandSegment(e, t, i, r, o, s) {
          return xt(i).pipe(
            ja((a) =>
              this.expandSegmentAgainstRoute(e, t, i, a, r, o, s).pipe(
                ms((c) => {
                  if (c instanceof pf) return ne(null);
                  throw c;
                })
              )
            ),
            ys((a) => !!a),
            ms((a, l) => {
              if (a instanceof Lc || "EmptyError" === a.name)
                return $O(t, r, o) ? ne(new me([], {})) : Gc(t);
              throw a;
            })
          );
        }
        expandSegmentAgainstRoute(e, t, i, r, o, s, a) {
          return zO(r, t, o, s)
            ? void 0 === r.redirectTo
              ? this.matchSegmentAgainstRoute(e, t, r, o, s)
              : a && this.allowRedirects
              ? this.expandSegmentAgainstRouteUsingRedirect(e, t, i, r, o, s)
              : Gc(t)
            : Gc(t);
        }
        expandSegmentAgainstRouteUsingRedirect(e, t, i, r, o, s) {
          return "**" === r.path
            ? this.expandWildCardWithParamsAgainstRouteUsingRedirect(e, i, r, s)
            : this.expandRegularSegmentAgainstRouteUsingRedirect(
                e,
                t,
                i,
                r,
                o,
                s
              );
        }
        expandWildCardWithParamsAgainstRouteUsingRedirect(e, t, i, r) {
          const o = this.applyRedirectCommands([], i.redirectTo, {});
          return i.redirectTo.startsWith("/")
            ? GO(o)
            : this.lineralizeSegments(i, o).pipe(
                zt((s) => {
                  const a = new me(s, {});
                  return this.expandSegment(e, a, t, s, r, !1);
                })
              );
        }
        expandRegularSegmentAgainstRouteUsingRedirect(e, t, i, r, o, s) {
          const {
            matched: a,
            consumedSegments: l,
            remainingSegments: c,
            positionalParamSegments: u,
          } = df(t, r, o);
          if (!a) return Gc(t);
          const d = this.applyRedirectCommands(l, r.redirectTo, u);
          return r.redirectTo.startsWith("/")
            ? GO(d)
            : this.lineralizeSegments(r, d).pipe(
                zt((h) => this.expandSegment(e, t, i, h.concat(c), s, !1))
              );
        }
        matchSegmentAgainstRoute(e, t, i, r, o) {
          if ("**" === i.path)
            return (
              (e = BO(i, e)),
              i.loadChildren
                ? (i._loadedRoutes
                    ? ne({
                        routes: i._loadedRoutes,
                        injector: i._loadedInjector,
                      })
                    : this.configLoader.loadChildren(e, i)
                  ).pipe(
                    ye(
                      (d) => (
                        (i._loadedRoutes = d.routes),
                        (i._loadedInjector = d.injector),
                        new me(r, {})
                      )
                    )
                  )
                : ne(new me(r, {}))
            );
          const {
            matched: s,
            consumedSegments: a,
            remainingSegments: l,
          } = df(t, i, r);
          return s
            ? ((e = BO(i, e)),
              this.getChildConfig(e, i, r).pipe(
                zt((u) => {
                  const d = u.injector ?? e,
                    h = u.routes,
                    { segmentGroup: f, slicedSegments: p } = hf(t, a, l, h),
                    g = new me(f.segments, f.children);
                  if (0 === p.length && g.hasChildren())
                    return this.expandChildren(d, h, g).pipe(
                      ye((b) => new me(a, b))
                    );
                  if (0 === h.length && 0 === p.length)
                    return ne(new me(a, {}));
                  const m = ti(i) === o;
                  return this.expandSegment(d, g, h, p, m ? fe : o, !0).pipe(
                    ye((_) => new me(a.concat(_.segments), _.children))
                  );
                })
              ))
            : Gc(t);
        }
        getChildConfig(e, t, i) {
          return t.children
            ? ne({ routes: t.children, injector: e })
            : t.loadChildren
            ? void 0 !== t._loadedRoutes
              ? ne({ routes: t._loadedRoutes, injector: t._loadedInjector })
              : this.runCanLoadGuards(e, t, i).pipe(
                  zt((r) =>
                    r
                      ? this.configLoader.loadChildren(e, t).pipe(
                          Vt((o) => {
                            (t._loadedRoutes = o.routes),
                              (t._loadedInjector = o.injector);
                          })
                        )
                      : (function T9(n) {
                          return gs(
                            D_(
                              `Cannot load children because the guard of the route "path: '${n.path}'" returned false`
                            )
                          );
                        })(t)
                  )
                )
            : ne({ routes: [], injector: e });
        }
        runCanLoadGuards(e, t, i) {
          const r = t.canLoad;
          if (!r || 0 === r.length) return ne(!0);
          const o = r.map((s) => {
            const a = e.get(s);
            let l;
            if (
              (function _9(n) {
                return n && So(n.canLoad);
              })(a)
            )
              l = a.canLoad(t, i);
            else {
              if (!So(a)) throw new Error("Invalid CanLoad guard");
              l = a(t, i);
            }
            return Mi(l);
          });
          return ne(o).pipe(
            Wc(),
            Vt((s) => {
              if (!bs(s)) return;
              const a = D_(
                `Redirecting to "${this.urlSerializer.serialize(s)}"`
              );
              throw ((a.url = s), a);
            }),
            ye((s) => !0 === s)
          );
        }
        lineralizeSegments(e, t) {
          let i = [],
            r = t.root;
          for (;;) {
            if (((i = i.concat(r.segments)), 0 === r.numberOfChildren))
              return ne(i);
            if (r.numberOfChildren > 1 || !r.children[fe])
              return I9(e.redirectTo);
            r = r.children[fe];
          }
        }
        applyRedirectCommands(e, t, i) {
          return this.applyRedirectCreatreUrlTree(
            t,
            this.urlSerializer.parse(t),
            e,
            i
          );
        }
        applyRedirectCreatreUrlTree(e, t, i, r) {
          const o = this.createSegmentGroup(e, t.root, i, r);
          return new vs(
            o,
            this.createQueryParams(t.queryParams, this.urlTree.queryParams),
            t.fragment
          );
        }
        createQueryParams(e, t) {
          const i = {};
          return (
            Ht(e, (r, o) => {
              if ("string" == typeof r && r.startsWith(":")) {
                const a = r.substring(1);
                i[o] = t[a];
              } else i[o] = r;
            }),
            i
          );
        }
        createSegmentGroup(e, t, i, r) {
          const o = this.createSegments(e, t.segments, i, r);
          let s = {};
          return (
            Ht(t.children, (a, l) => {
              s[l] = this.createSegmentGroup(e, a, i, r);
            }),
            new me(o, s)
          );
        }
        createSegments(e, t, i, r) {
          return t.map((o) =>
            o.path.startsWith(":")
              ? this.findPosParam(e, o, r)
              : this.findOrReturn(o, i)
          );
        }
        findPosParam(e, t, i) {
          const r = i[t.path.substring(1)];
          if (!r)
            throw new Error(
              `Cannot redirect to '${e}'. Cannot find '${t.path}'.`
            );
          return r;
        }
        findOrReturn(e, t) {
          let i = 0;
          for (const r of t) {
            if (r.path === e.path) return t.splice(i), r;
            i++;
          }
          return e;
        }
      }
      function N_(n) {
        const e = {};
        for (const i of Object.keys(n.children)) {
          const o = N_(n.children[i]);
          (o.segments.length > 0 || o.hasChildren()) && (e[i] = o);
        }
        return (function O9(n) {
          if (1 === n.numberOfChildren && n.children[fe]) {
            const e = n.children[fe];
            return new me(n.segments.concat(e.segments), e.children);
          }
          return n;
        })(new me(n.segments, e));
      }
      class qO {
        constructor(e) {
          (this.path = e), (this.route = this.path[this.path.length - 1]);
        }
      }
      class gf {
        constructor(e, t) {
          (this.component = e), (this.route = t);
        }
      }
      function N9(n, e, t) {
        const i = n._root;
        return qc(i, e ? e._root : null, t, [i.value]);
      }
      function mf(n, e, t) {
        return (HO(e) ?? t).get(n);
      }
      function qc(
        n,
        e,
        t,
        i,
        r = { canDeactivateChecks: [], canActivateChecks: [] }
      ) {
        const o = Ua(e);
        return (
          n.children.forEach((s) => {
            (function P9(
              n,
              e,
              t,
              i,
              r = { canDeactivateChecks: [], canActivateChecks: [] }
            ) {
              const o = n.value,
                s = e ? e.value : null,
                a = t ? t.getContext(n.value.outlet) : null;
              if (s && o.routeConfig === s.routeConfig) {
                const l = (function F9(n, e, t) {
                  if ("function" == typeof t) return t(n, e);
                  switch (t) {
                    case "pathParamsChange":
                      return !_s(n.url, e.url);
                    case "pathParamsOrQueryParamsChange":
                      return (
                        !_s(n.url, e.url) || !sr(n.queryParams, e.queryParams)
                      );
                    case "always":
                      return !0;
                    case "paramsOrQueryParamsChange":
                      return !I_(n, e) || !sr(n.queryParams, e.queryParams);
                    default:
                      return !I_(n, e);
                  }
                })(s, o, o.routeConfig.runGuardsAndResolvers);
                l
                  ? r.canActivateChecks.push(new qO(i))
                  : ((o.data = s.data), (o._resolvedData = s._resolvedData)),
                  qc(n, e, o.component ? (a ? a.children : null) : t, i, r),
                  l &&
                    a &&
                    a.outlet &&
                    a.outlet.isActivated &&
                    r.canDeactivateChecks.push(new gf(a.outlet.component, s));
              } else
                s && Kc(e, a, r),
                  r.canActivateChecks.push(new qO(i)),
                  qc(n, null, o.component ? (a ? a.children : null) : t, i, r);
            })(s, o[s.value.outlet], t, i.concat([s.value]), r),
              delete o[s.value.outlet];
          }),
          Ht(o, (s, a) => Kc(s, t.getContext(a), r)),
          r
        );
      }
      function Kc(n, e, t) {
        const i = Ua(n),
          r = n.value;
        Ht(i, (o, s) => {
          Kc(o, r.component ? (e ? e.children.getContext(s) : null) : e, t);
        }),
          t.canDeactivateChecks.push(
            new gf(
              r.component && e && e.outlet && e.outlet.isActivated
                ? e.outlet.component
                : null,
              r
            )
          );
      }
      class W9 {}
      function YO(n) {
        return new je((e) => e.error(n));
      }
      class q9 {
        constructor(e, t, i, r, o, s) {
          (this.rootComponentType = e),
            (this.config = t),
            (this.urlTree = i),
            (this.url = r),
            (this.paramsInheritanceStrategy = o),
            (this.relativeLinkResolution = s);
        }
        recognize() {
          const e = hf(
              this.urlTree.root,
              [],
              [],
              this.config.filter((s) => void 0 === s.redirectTo),
              this.relativeLinkResolution
            ).segmentGroup,
            t = this.processSegmentGroup(this.config, e, fe);
          if (null === t) return null;
          const i = new lf(
              [],
              Object.freeze({}),
              Object.freeze({ ...this.urlTree.queryParams }),
              this.urlTree.fragment,
              {},
              fe,
              this.rootComponentType,
              null,
              this.urlTree.root,
              -1,
              {}
            ),
            r = new kr(i, t),
            o = new AO(this.url, r);
          return this.inheritParamsAndData(o._root), o;
        }
        inheritParamsAndData(e) {
          const t = e.value,
            i = xO(t, this.paramsInheritanceStrategy);
          (t.params = Object.freeze(i.params)),
            (t.data = Object.freeze(i.data)),
            e.children.forEach((r) => this.inheritParamsAndData(r));
        }
        processSegmentGroup(e, t, i) {
          return 0 === t.segments.length && t.hasChildren()
            ? this.processChildren(e, t)
            : this.processSegment(e, t, t.segments, i);
        }
        processChildren(e, t) {
          const i = [];
          for (const o of Object.keys(t.children)) {
            const s = t.children[o],
              a = jO(e, o),
              l = this.processSegmentGroup(a, s, o);
            if (null === l) return null;
            i.push(...l);
          }
          const r = ZO(i);
          return (
            (function K9(n) {
              n.sort((e, t) =>
                e.value.outlet === fe
                  ? -1
                  : t.value.outlet === fe
                  ? 1
                  : e.value.outlet.localeCompare(t.value.outlet)
              );
            })(r),
            r
          );
        }
        processSegment(e, t, i, r) {
          for (const o of e) {
            const s = this.processSegmentAgainstRoute(o, t, i, r);
            if (null !== s) return s;
          }
          return $O(t, i, r) ? [] : null;
        }
        processSegmentAgainstRoute(e, t, i, r) {
          if (e.redirectTo || !zO(e, t, i, r)) return null;
          let o,
            s = [],
            a = [];
          if ("**" === e.path) {
            const f = i.length > 0 ? gO(i).parameters : {},
              p = JO(t) + i.length;
            o = new lf(
              i,
              f,
              Object.freeze({ ...this.urlTree.queryParams }),
              this.urlTree.fragment,
              e1(e),
              ti(e),
              e.component ?? e._loadedComponent ?? null,
              e,
              QO(t),
              p,
              t1(e),
              p
            );
          } else {
            const f = df(t, e, i);
            if (!f.matched) return null;
            (s = f.consumedSegments), (a = f.remainingSegments);
            const p = JO(t) + s.length;
            o = new lf(
              s,
              f.parameters,
              Object.freeze({ ...this.urlTree.queryParams }),
              this.urlTree.fragment,
              e1(e),
              ti(e),
              e.component ?? e._loadedComponent ?? null,
              e,
              QO(t),
              p,
              t1(e),
              p
            );
          }
          const l = (function Y9(n) {
              return n.children
                ? n.children
                : n.loadChildren
                ? n._loadedRoutes
                : [];
            })(e),
            { segmentGroup: c, slicedSegments: u } = hf(
              t,
              s,
              a,
              l.filter((f) => void 0 === f.redirectTo),
              this.relativeLinkResolution
            );
          if (0 === u.length && c.hasChildren()) {
            const f = this.processChildren(l, c);
            return null === f ? null : [new kr(o, f)];
          }
          if (0 === l.length && 0 === u.length) return [new kr(o, [])];
          const d = ti(e) === r,
            h = this.processSegment(l, c, u, d ? fe : r);
          return null === h ? null : [new kr(o, h)];
        }
      }
      function Z9(n) {
        const e = n.value.routeConfig;
        return e && "" === e.path && void 0 === e.redirectTo;
      }
      function ZO(n) {
        const e = [],
          t = new Set();
        for (const i of n) {
          if (!Z9(i)) {
            e.push(i);
            continue;
          }
          const r = e.find((o) => i.value.routeConfig === o.value.routeConfig);
          void 0 !== r ? (r.children.push(...i.children), t.add(r)) : e.push(i);
        }
        for (const i of t) {
          const r = ZO(i.children);
          e.push(new kr(i.value, r));
        }
        return e.filter((i) => !t.has(i));
      }
      function QO(n) {
        let e = n;
        for (; e._sourceSegment; ) e = e._sourceSegment;
        return e;
      }
      function JO(n) {
        let e = n,
          t = e._segmentIndexShift ?? 0;
        for (; e._sourceSegment; )
          (e = e._sourceSegment), (t += e._segmentIndexShift ?? 0);
        return t - 1;
      }
      function e1(n) {
        return n.data || {};
      }
      function t1(n) {
        return n.resolve || {};
      }
      const R_ = Symbol("RouteTitle");
      function n1(n) {
        return "string" == typeof n.title || null === n.title;
      }
      function P_(n) {
        return or((e) => {
          const t = n(e);
          return t ? xt(t).pipe(ye(() => e)) : ne(e);
        });
      }
      class o7 extends class r7 {
        shouldDetach(e) {
          return !1;
        }
        store(e, t) {}
        shouldAttach(e) {
          return !1;
        }
        retrieve(e) {
          return null;
        }
        shouldReuseRoute(e, t) {
          return e.routeConfig === t.routeConfig;
        }
      } {}
      const F_ = new F("ROUTES");
      let L_ = (() => {
        class n {
          constructor(t, i) {
            (this.injector = t),
              (this.compiler = i),
              (this.componentLoaders = new WeakMap()),
              (this.childrenLoaders = new WeakMap());
          }
          loadComponent(t) {
            if (this.componentLoaders.get(t))
              return this.componentLoaders.get(t);
            if (t._loadedComponent) return ne(t._loadedComponent);
            this.onLoadStartListener && this.onLoadStartListener(t);
            const i = Mi(t.loadComponent()).pipe(
                Vt((o) => {
                  this.onLoadEndListener && this.onLoadEndListener(t),
                    (t._loadedComponent = o);
                }),
                __(() => {
                  this.componentLoaders.delete(t);
                })
              ),
              r = new gp(i, () => new _e()).pipe(Su());
            return this.componentLoaders.set(t, r), r;
          }
          loadChildren(t, i) {
            if (this.childrenLoaders.get(i)) return this.childrenLoaders.get(i);
            if (i._loadedRoutes)
              return ne({
                routes: i._loadedRoutes,
                injector: i._loadedInjector,
              });
            this.onLoadStartListener && this.onLoadStartListener(i);
            const o = this.loadModuleFactoryOrRoutes(i.loadChildren).pipe(
                ye((a) => {
                  this.onLoadEndListener && this.onLoadEndListener(i);
                  let l,
                    c,
                    u = !1;
                  Array.isArray(a)
                    ? (c = a)
                    : ((l = a.create(t).injector),
                      (c = pO(l.get(F_, [], G.Self | G.Optional))));
                  return { routes: c.map(k_), injector: l };
                }),
                __(() => {
                  this.childrenLoaders.delete(i);
                })
              ),
              s = new gp(o, () => new _e()).pipe(Su());
            return this.childrenLoaders.set(i, s), s;
          }
          loadModuleFactoryOrRoutes(t) {
            return Mi(t()).pipe(
              zt((i) =>
                i instanceof _w || Array.isArray(i)
                  ? ne(i)
                  : xt(this.compiler.compileModuleAsync(i))
              )
            );
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(T(pt), T(Hm));
          }),
          (n.ɵprov = j({ token: n, factory: n.ɵfac })),
          n
        );
      })();
      class a7 {
        shouldProcessUrl(e) {
          return !0;
        }
        extract(e) {
          return e;
        }
        merge(e, t) {
          return e;
        }
      }
      function c7(n) {
        throw n;
      }
      function u7(n, e, t) {
        return e.parse("/");
      }
      const d7 = {
          paths: "exact",
          fragment: "ignored",
          matrixParams: "ignored",
          queryParams: "exact",
        },
        h7 = {
          paths: "subset",
          fragment: "ignored",
          matrixParams: "ignored",
          queryParams: "subset",
        };
      let gn = (() => {
        class n {
          constructor(t, i, r, o, s, a, l) {
            (this.rootComponentType = t),
              (this.urlSerializer = i),
              (this.rootContexts = r),
              (this.location = o),
              (this.config = l),
              (this.lastSuccessfulNavigation = null),
              (this.currentNavigation = null),
              (this.disposed = !1),
              (this.navigationId = 0),
              (this.currentPageId = 0),
              (this.isNgZoneEnabled = !1),
              (this.events = new _e()),
              (this.errorHandler = c7),
              (this.malformedUriErrorHandler = u7),
              (this.navigated = !1),
              (this.lastSuccessfulId = -1),
              (this.afterPreactivation = () => ne(void 0)),
              (this.urlHandlingStrategy = new a7()),
              (this.routeReuseStrategy = new o7()),
              (this.onSameUrlNavigation = "ignore"),
              (this.paramsInheritanceStrategy = "emptyOnly"),
              (this.urlUpdateStrategy = "deferred"),
              (this.relativeLinkResolution = "corrected"),
              (this.canceledNavigationResolution = "replace"),
              (this.configLoader = s.get(L_)),
              (this.configLoader.onLoadEndListener = (h) =>
                this.triggerEvent(new Mq(h))),
              (this.configLoader.onLoadStartListener = (h) =>
                this.triggerEvent(new Sq(h))),
              (this.ngModule = s.get(Jr)),
              (this.console = s.get(l2));
            const d = s.get(Ke);
            (this.isNgZoneEnabled = d instanceof Ke && Ke.isInAngularZone()),
              this.resetConfig(l),
              (this.currentUrlTree = (function Fq() {
                return new vs(new me([], {}), {}, null);
              })()),
              (this.rawUrlTree = this.currentUrlTree),
              (this.browserUrlTree = this.currentUrlTree),
              (this.routerState = TO(
                this.currentUrlTree,
                this.rootComponentType
              )),
              (this.transitions = new Si({
                id: 0,
                targetPageId: 0,
                currentUrlTree: this.currentUrlTree,
                currentRawUrl: this.currentUrlTree,
                extractedUrl: this.urlHandlingStrategy.extract(
                  this.currentUrlTree
                ),
                urlAfterRedirects: this.urlHandlingStrategy.extract(
                  this.currentUrlTree
                ),
                rawUrl: this.currentUrlTree,
                extras: {},
                resolve: null,
                reject: null,
                promise: Promise.resolve(!0),
                source: "imperative",
                restoredState: null,
                currentSnapshot: this.routerState.snapshot,
                targetSnapshot: null,
                currentRouterState: this.routerState,
                targetRouterState: null,
                guards: { canActivateChecks: [], canDeactivateChecks: [] },
                guardsResult: null,
              })),
              (this.navigations = this.setupNavigations(this.transitions)),
              this.processNavigations();
          }
          get browserPageId() {
            return this.location.getState()?.ɵrouterPageId;
          }
          setupNavigations(t) {
            const i = this.events;
            return t.pipe(
              ao((r) => 0 !== r.id),
              ye((r) => ({
                ...r,
                extractedUrl: this.urlHandlingStrategy.extract(r.rawUrl),
              })),
              or((r) => {
                let o = !1,
                  s = !1;
                return ne(r).pipe(
                  Vt((a) => {
                    this.currentNavigation = {
                      id: a.id,
                      initialUrl: a.rawUrl,
                      extractedUrl: a.extractedUrl,
                      trigger: a.source,
                      extras: a.extras,
                      previousNavigation: this.lastSuccessfulNavigation
                        ? {
                            ...this.lastSuccessfulNavigation,
                            previousNavigation: null,
                          }
                        : null,
                    };
                  }),
                  or((a) => {
                    const l = this.browserUrlTree.toString(),
                      c =
                        !this.navigated ||
                        a.extractedUrl.toString() !== l ||
                        l !== this.currentUrlTree.toString();
                    if (
                      ("reload" === this.onSameUrlNavigation || c) &&
                      this.urlHandlingStrategy.shouldProcessUrl(a.rawUrl)
                    )
                      return (
                        o1(a.source) && (this.browserUrlTree = a.extractedUrl),
                        ne(a).pipe(
                          or((d) => {
                            const h = this.transitions.getValue();
                            return (
                              i.next(
                                new b_(
                                  d.id,
                                  this.serializeUrl(d.extractedUrl),
                                  d.source,
                                  d.restoredState
                                )
                              ),
                              h !== this.transitions.getValue()
                                ? Ba
                                : Promise.resolve(d)
                            );
                          }),
                          (function k9(n, e, t, i) {
                            return or((r) =>
                              (function x9(n, e, t, i, r) {
                                return new A9(n, e, t, i, r).apply();
                              })(n, e, t, r.extractedUrl, i).pipe(
                                ye((o) => ({ ...r, urlAfterRedirects: o }))
                              )
                            );
                          })(
                            this.ngModule.injector,
                            this.configLoader,
                            this.urlSerializer,
                            this.config
                          ),
                          Vt((d) => {
                            this.currentNavigation = {
                              ...this.currentNavigation,
                              finalUrl: d.urlAfterRedirects,
                            };
                          }),
                          (function Q9(n, e, t, i, r) {
                            return zt((o) =>
                              (function G9(
                                n,
                                e,
                                t,
                                i,
                                r = "emptyOnly",
                                o = "legacy"
                              ) {
                                try {
                                  const s = new q9(
                                    n,
                                    e,
                                    t,
                                    i,
                                    r,
                                    o
                                  ).recognize();
                                  return null === s ? YO(new W9()) : ne(s);
                                } catch (s) {
                                  return YO(s);
                                }
                              })(
                                n,
                                e,
                                o.urlAfterRedirects,
                                t(o.urlAfterRedirects),
                                i,
                                r
                              ).pipe(ye((s) => ({ ...o, targetSnapshot: s })))
                            );
                          })(
                            this.rootComponentType,
                            this.config,
                            (d) => this.serializeUrl(d),
                            this.paramsInheritanceStrategy,
                            this.relativeLinkResolution
                          ),
                          Vt((d) => {
                            if ("eager" === this.urlUpdateStrategy) {
                              if (!d.extras.skipLocationChange) {
                                const f = this.urlHandlingStrategy.merge(
                                  d.urlAfterRedirects,
                                  d.rawUrl
                                );
                                this.setBrowserUrl(f, d);
                              }
                              this.browserUrlTree = d.urlAfterRedirects;
                            }
                            const h = new bq(
                              d.id,
                              this.serializeUrl(d.extractedUrl),
                              this.serializeUrl(d.urlAfterRedirects),
                              d.targetSnapshot
                            );
                            i.next(h);
                          })
                        )
                      );
                    if (
                      c &&
                      this.rawUrlTree &&
                      this.urlHandlingStrategy.shouldProcessUrl(this.rawUrlTree)
                    ) {
                      const {
                          id: h,
                          extractedUrl: f,
                          source: p,
                          restoredState: g,
                          extras: m,
                        } = a,
                        v = new b_(h, this.serializeUrl(f), p, g);
                      i.next(v);
                      const _ = TO(f, this.rootComponentType).snapshot;
                      return ne({
                        ...a,
                        targetSnapshot: _,
                        urlAfterRedirects: f,
                        extras: {
                          ...m,
                          skipLocationChange: !1,
                          replaceUrl: !1,
                        },
                      });
                    }
                    return (this.rawUrlTree = a.rawUrl), a.resolve(null), Ba;
                  }),
                  Vt((a) => {
                    const l = new Dq(
                      a.id,
                      this.serializeUrl(a.extractedUrl),
                      this.serializeUrl(a.urlAfterRedirects),
                      a.targetSnapshot
                    );
                    this.triggerEvent(l);
                  }),
                  ye((a) => ({
                    ...a,
                    guards: N9(
                      a.targetSnapshot,
                      a.currentSnapshot,
                      this.rootContexts
                    ),
                  })),
                  (function L9(n, e) {
                    return zt((t) => {
                      const {
                        targetSnapshot: i,
                        currentSnapshot: r,
                        guards: {
                          canActivateChecks: o,
                          canDeactivateChecks: s,
                        },
                      } = t;
                      return 0 === s.length && 0 === o.length
                        ? ne({ ...t, guardsResult: !0 })
                        : (function V9(n, e, t, i) {
                            return xt(n).pipe(
                              zt((r) =>
                                (function $9(n, e, t, i, r) {
                                  const o =
                                    e && e.routeConfig
                                      ? e.routeConfig.canDeactivate
                                      : null;
                                  return o && 0 !== o.length
                                    ? ne(
                                        o.map((a) => {
                                          const l = mf(a, e, r);
                                          let c;
                                          if (
                                            (function C9(n) {
                                              return n && So(n.canDeactivate);
                                            })(l)
                                          )
                                            c = Mi(l.canDeactivate(n, e, t, i));
                                          else {
                                            if (!So(l))
                                              throw new Error(
                                                "Invalid CanDeactivate guard"
                                              );
                                            c = Mi(l(n, e, t, i));
                                          }
                                          return c.pipe(ys());
                                        })
                                      ).pipe(Wc())
                                    : ne(!0);
                                })(r.component, r.route, t, e, i)
                              ),
                              ys((r) => !0 !== r, !0)
                            );
                          })(s, i, r, n).pipe(
                            zt((a) =>
                              a &&
                              (function v9(n) {
                                return "boolean" == typeof n;
                              })(a)
                                ? (function B9(n, e, t, i) {
                                    return xt(e).pipe(
                                      ja((r) =>
                                        m_(
                                          (function H9(n, e) {
                                            return (
                                              null !== n && e && e(new Iq(n)),
                                              ne(!0)
                                            );
                                          })(r.route.parent, i),
                                          (function j9(n, e) {
                                            return (
                                              null !== n && e && e(new xq(n)),
                                              ne(!0)
                                            );
                                          })(r.route, i),
                                          (function z9(n, e, t) {
                                            const i = e[e.length - 1],
                                              o = e
                                                .slice(0, e.length - 1)
                                                .reverse()
                                                .map((s) =>
                                                  (function R9(n) {
                                                    const e = n.routeConfig
                                                      ? n.routeConfig
                                                          .canActivateChild
                                                      : null;
                                                    return e && 0 !== e.length
                                                      ? { node: n, guards: e }
                                                      : null;
                                                  })(s)
                                                )
                                                .filter((s) => null !== s)
                                                .map((s) =>
                                                  sO(() =>
                                                    ne(
                                                      s.guards.map((l) => {
                                                        const c = mf(
                                                          l,
                                                          s.node,
                                                          t
                                                        );
                                                        let u;
                                                        if (
                                                          (function D9(n) {
                                                            return (
                                                              n &&
                                                              So(
                                                                n.canActivateChild
                                                              )
                                                            );
                                                          })(c)
                                                        )
                                                          u = Mi(
                                                            c.canActivateChild(
                                                              i,
                                                              n
                                                            )
                                                          );
                                                        else {
                                                          if (!So(c))
                                                            throw new Error(
                                                              "Invalid CanActivateChild guard"
                                                            );
                                                          u = Mi(c(i, n));
                                                        }
                                                        return u.pipe(ys());
                                                      })
                                                    ).pipe(Wc())
                                                  )
                                                );
                                            return ne(o).pipe(Wc());
                                          })(n, r.path, t),
                                          (function U9(n, e, t) {
                                            const i = e.routeConfig
                                              ? e.routeConfig.canActivate
                                              : null;
                                            if (!i || 0 === i.length)
                                              return ne(!0);
                                            const r = i.map((o) =>
                                              sO(() => {
                                                const s = mf(o, e, t);
                                                let a;
                                                if (
                                                  (function b9(n) {
                                                    return (
                                                      n && So(n.canActivate)
                                                    );
                                                  })(s)
                                                )
                                                  a = Mi(s.canActivate(e, n));
                                                else {
                                                  if (!So(s))
                                                    throw new Error(
                                                      "Invalid CanActivate guard"
                                                    );
                                                  a = Mi(s(e, n));
                                                }
                                                return a.pipe(ys());
                                              })
                                            );
                                            return ne(r).pipe(Wc());
                                          })(n, r.route, t)
                                        )
                                      ),
                                      ys((r) => !0 !== r, !0)
                                    );
                                  })(i, o, n, e)
                                : ne(a)
                            ),
                            ye((a) => ({ ...t, guardsResult: a }))
                          );
                    });
                  })(this.ngModule.injector, (a) => this.triggerEvent(a)),
                  Vt((a) => {
                    if (bs(a.guardsResult)) {
                      const c = D_(
                        `Redirecting to "${this.serializeUrl(a.guardsResult)}"`
                      );
                      throw ((c.url = a.guardsResult), c);
                    }
                    const l = new Cq(
                      a.id,
                      this.serializeUrl(a.extractedUrl),
                      this.serializeUrl(a.urlAfterRedirects),
                      a.targetSnapshot,
                      !!a.guardsResult
                    );
                    this.triggerEvent(l);
                  }),
                  ao(
                    (a) =>
                      !!a.guardsResult ||
                      (this.restoreHistory(a),
                      this.cancelNavigationTransition(a, ""),
                      !1)
                  ),
                  P_((a) => {
                    if (a.guards.canActivateChecks.length)
                      return ne(a).pipe(
                        Vt((l) => {
                          const c = new Eq(
                            l.id,
                            this.serializeUrl(l.extractedUrl),
                            this.serializeUrl(l.urlAfterRedirects),
                            l.targetSnapshot
                          );
                          this.triggerEvent(c);
                        }),
                        or((l) => {
                          let c = !1;
                          return ne(l).pipe(
                            (function J9(n, e) {
                              return zt((t) => {
                                const {
                                  targetSnapshot: i,
                                  guards: { canActivateChecks: r },
                                } = t;
                                if (!r.length) return ne(t);
                                let o = 0;
                                return xt(r).pipe(
                                  ja((s) =>
                                    (function X9(n, e, t, i) {
                                      const r = n.routeConfig,
                                        o = n._resolve;
                                      return (
                                        void 0 !== r?.title &&
                                          !n1(r) &&
                                          (o[R_] = r.title),
                                        (function e7(n, e, t, i) {
                                          const r = (function t7(n) {
                                            return [
                                              ...Object.keys(n),
                                              ...Object.getOwnPropertySymbols(
                                                n
                                              ),
                                            ];
                                          })(n);
                                          if (0 === r.length) return ne({});
                                          const o = {};
                                          return xt(r).pipe(
                                            zt((s) =>
                                              (function n7(n, e, t, i) {
                                                const r = mf(n, e, i);
                                                return Mi(
                                                  r.resolve
                                                    ? r.resolve(e, t)
                                                    : r(e, t)
                                                );
                                              })(n[s], e, t, i).pipe(
                                                ys(),
                                                Vt((a) => {
                                                  o[s] = a;
                                                })
                                              )
                                            ),
                                            y_(1),
                                            (function pq(n) {
                                              return (e) => e.lift(new gq(n));
                                            })(o),
                                            ms((s) =>
                                              s instanceof Lc ? Ba : gs(s)
                                            )
                                          );
                                        })(o, n, e, i).pipe(
                                          ye(
                                            (s) => (
                                              (n._resolvedData = s),
                                              (n.data = xO(n, t).resolve),
                                              r &&
                                                n1(r) &&
                                                (n.data[R_] = r.title),
                                              null
                                            )
                                          )
                                        )
                                      );
                                    })(s.route, i, n, e)
                                  ),
                                  Vt(() => o++),
                                  y_(1),
                                  zt((s) => (o === r.length ? ne(t) : Ba))
                                );
                              });
                            })(
                              this.paramsInheritanceStrategy,
                              this.ngModule.injector
                            ),
                            Vt({
                              next: () => (c = !0),
                              complete: () => {
                                c ||
                                  (this.restoreHistory(l),
                                  this.cancelNavigationTransition(
                                    l,
                                    "At least one route resolver didn't emit any value."
                                  ));
                              },
                            })
                          );
                        }),
                        Vt((l) => {
                          const c = new wq(
                            l.id,
                            this.serializeUrl(l.extractedUrl),
                            this.serializeUrl(l.urlAfterRedirects),
                            l.targetSnapshot
                          );
                          this.triggerEvent(c);
                        })
                      );
                  }),
                  P_(() => this.afterPreactivation()),
                  P_((a) => {
                    const l = (c) => {
                      const u = [];
                      c.routeConfig?.loadComponent &&
                        !c.routeConfig._loadedComponent &&
                        u.push(
                          this.configLoader.loadComponent(c.routeConfig).pipe(
                            Vt((d) => {
                              c.component = d;
                            }),
                            ye(() => {})
                          )
                        );
                      for (const d of c.children) u.push(...l(d));
                      return u;
                    };
                    return oO(l(a.targetSnapshot.root)).pipe(v_(), wo(1));
                  }),
                  ye((a) => {
                    const l = (function e9(n, e, t) {
                      const i = Hc(n, e._root, t ? t._root : void 0);
                      return new IO(i, e);
                    })(
                      this.routeReuseStrategy,
                      a.targetSnapshot,
                      a.currentRouterState
                    );
                    return { ...a, targetRouterState: l };
                  }),
                  Vt((a) => {
                    (this.currentUrlTree = a.urlAfterRedirects),
                      (this.rawUrlTree = this.urlHandlingStrategy.merge(
                        a.urlAfterRedirects,
                        a.rawUrl
                      )),
                      (this.routerState = a.targetRouterState),
                      "deferred" === this.urlUpdateStrategy &&
                        (a.extras.skipLocationChange ||
                          this.setBrowserUrl(this.rawUrlTree, a),
                        (this.browserUrlTree = a.urlAfterRedirects));
                  }),
                  ((n, e, t) =>
                    ye(
                      (i) => (
                        new y9(
                          e,
                          i.targetRouterState,
                          i.currentRouterState,
                          t
                        ).activate(n),
                        i
                      )
                    ))(this.rootContexts, this.routeReuseStrategy, (a) =>
                    this.triggerEvent(a)
                  ),
                  Vt({
                    next() {
                      o = !0;
                    },
                    complete() {
                      o = !0;
                    },
                  }),
                  __(() => {
                    o ||
                      s ||
                      this.cancelNavigationTransition(
                        r,
                        `Navigation ID ${r.id} is not equal to the current navigation id ${this.navigationId}`
                      ),
                      this.currentNavigation?.id === r.id &&
                        (this.currentNavigation = null);
                  }),
                  ms((a) => {
                    if (
                      ((s = !0),
                      (function Nq(n) {
                        return n && n[hO];
                      })(a))
                    ) {
                      const l = bs(a.url);
                      l || ((this.navigated = !0), this.restoreHistory(r, !0));
                      const c = new uO(
                        r.id,
                        this.serializeUrl(r.extractedUrl),
                        a.message
                      );
                      if ((i.next(c), l)) {
                        const u = this.urlHandlingStrategy.merge(
                            a.url,
                            this.rawUrlTree
                          ),
                          d = {
                            skipLocationChange: r.extras.skipLocationChange,
                            replaceUrl:
                              "eager" === this.urlUpdateStrategy ||
                              o1(r.source),
                          };
                        this.scheduleNavigation(u, "imperative", null, d, {
                          resolve: r.resolve,
                          reject: r.reject,
                          promise: r.promise,
                        });
                      } else r.resolve(!1);
                    } else {
                      this.restoreHistory(r, !0);
                      const l = new _q(
                        r.id,
                        this.serializeUrl(r.extractedUrl),
                        a
                      );
                      i.next(l);
                      try {
                        r.resolve(this.errorHandler(a));
                      } catch (c) {
                        r.reject(c);
                      }
                    }
                    return Ba;
                  })
                );
              })
            );
          }
          resetRootComponentType(t) {
            (this.rootComponentType = t),
              (this.routerState.root.component = this.rootComponentType);
          }
          setTransition(t) {
            this.transitions.next({ ...this.transitions.value, ...t });
          }
          initialNavigation() {
            this.setUpLocationChangeListener(),
              0 === this.navigationId &&
                this.navigateByUrl(this.location.path(!0), { replaceUrl: !0 });
          }
          setUpLocationChangeListener() {
            this.locationSubscription ||
              (this.locationSubscription = this.location.subscribe((t) => {
                const i = "popstate" === t.type ? "popstate" : "hashchange";
                "popstate" === i &&
                  setTimeout(() => {
                    const r = { replaceUrl: !0 },
                      o = t.state?.navigationId ? t.state : null;
                    if (o) {
                      const a = { ...o };
                      delete a.navigationId,
                        delete a.ɵrouterPageId,
                        0 !== Object.keys(a).length && (r.state = a);
                    }
                    const s = this.parseUrl(t.url);
                    this.scheduleNavigation(s, i, o, r);
                  }, 0);
              }));
          }
          get url() {
            return this.serializeUrl(this.currentUrlTree);
          }
          getCurrentNavigation() {
            return this.currentNavigation;
          }
          triggerEvent(t) {
            this.events.next(t);
          }
          resetConfig(t) {
            (this.config = t.map(k_)),
              (this.navigated = !1),
              (this.lastSuccessfulId = -1);
          }
          ngOnDestroy() {
            this.dispose();
          }
          dispose() {
            this.transitions.complete(),
              this.locationSubscription &&
                (this.locationSubscription.unsubscribe(),
                (this.locationSubscription = void 0)),
              (this.disposed = !0);
          }
          createUrlTree(t, i = {}) {
            const {
                relativeTo: r,
                queryParams: o,
                fragment: s,
                queryParamsHandling: a,
                preserveFragment: l,
              } = i,
              c = r || this.routerState.root,
              u = l ? this.currentUrlTree.fragment : s;
            let d = null;
            switch (a) {
              case "merge":
                d = { ...this.currentUrlTree.queryParams, ...o };
                break;
              case "preserve":
                d = this.currentUrlTree.queryParams;
                break;
              default:
                d = o || null;
            }
            return (
              null !== d && (d = this.removeEmptyProps(d)),
              (function i9(n, e, t, i, r) {
                if (0 === t.length) return T_(e.root, e.root, e.root, i, r);
                const o = (function r9(n) {
                  if ("string" == typeof n[0] && 1 === n.length && "/" === n[0])
                    return new NO(!0, 0, n);
                  let e = 0,
                    t = !1;
                  const i = n.reduce((r, o, s) => {
                    if ("object" == typeof o && null != o) {
                      if (o.outlets) {
                        const a = {};
                        return (
                          Ht(o.outlets, (l, c) => {
                            a[c] = "string" == typeof l ? l.split("/") : l;
                          }),
                          [...r, { outlets: a }]
                        );
                      }
                      if (o.segmentPath) return [...r, o.segmentPath];
                    }
                    return "string" != typeof o
                      ? [...r, o]
                      : 0 === s
                      ? (o.split("/").forEach((a, l) => {
                          (0 == l && "." === a) ||
                            (0 == l && "" === a
                              ? (t = !0)
                              : ".." === a
                              ? e++
                              : "" != a && r.push(a));
                        }),
                        r)
                      : [...r, o];
                  }, []);
                  return new NO(t, e, i);
                })(t);
                return o.toRoot()
                  ? T_(e.root, e.root, new me([], {}), i, r)
                  : (function s(l) {
                      const c = (function o9(n, e, t, i) {
                          return n.isAbsolute
                            ? new x_(e.root, !0, 0)
                            : -1 === i
                            ? new x_(t, t === e.root, 0)
                            : (function s9(n, e, t) {
                                let i = n,
                                  r = e,
                                  o = t;
                                for (; o > r; ) {
                                  if (((o -= r), (i = i.parent), !i))
                                    throw new Error("Invalid number of '../'");
                                  r = i.segments.length;
                                }
                                return new x_(i, !1, r - o);
                              })(
                                t,
                                i + (cf(n.commands[0]) ? 0 : 1),
                                n.numberOfDoubleDots
                              );
                        })(o, e, n.snapshot?._urlSegment, l),
                        u = c.processChildren
                          ? uf(c.segmentGroup, c.index, o.commands)
                          : RO(c.segmentGroup, c.index, o.commands);
                      return T_(e.root, c.segmentGroup, u, i, r);
                    })(n.snapshot?._lastPathIndex);
              })(c, this.currentUrlTree, t, d, u ?? null)
            );
          }
          navigateByUrl(t, i = { skipLocationChange: !1 }) {
            const r = bs(t) ? t : this.parseUrl(t),
              o = this.urlHandlingStrategy.merge(r, this.rawUrlTree);
            return this.scheduleNavigation(o, "imperative", null, i);
          }
          navigate(t, i = { skipLocationChange: !1 }) {
            return (
              (function f7(n) {
                for (let e = 0; e < n.length; e++) {
                  const t = n[e];
                  if (null == t)
                    throw new Error(
                      `The requested path contains ${t} segment at index ${e}`
                    );
                }
              })(t),
              this.navigateByUrl(this.createUrlTree(t, i), i)
            );
          }
          serializeUrl(t) {
            return this.urlSerializer.serialize(t);
          }
          parseUrl(t) {
            let i;
            try {
              i = this.urlSerializer.parse(t);
            } catch (r) {
              i = this.malformedUriErrorHandler(r, this.urlSerializer, t);
            }
            return i;
          }
          isActive(t, i) {
            let r;
            if (((r = !0 === i ? { ...d7 } : !1 === i ? { ...h7 } : i), bs(t)))
              return yO(this.currentUrlTree, t, r);
            const o = this.parseUrl(t);
            return yO(this.currentUrlTree, o, r);
          }
          removeEmptyProps(t) {
            return Object.keys(t).reduce((i, r) => {
              const o = t[r];
              return null != o && (i[r] = o), i;
            }, {});
          }
          processNavigations() {
            this.navigations.subscribe(
              (t) => {
                (this.navigated = !0),
                  (this.lastSuccessfulId = t.id),
                  (this.currentPageId = t.targetPageId),
                  this.events.next(
                    new Vc(
                      t.id,
                      this.serializeUrl(t.extractedUrl),
                      this.serializeUrl(this.currentUrlTree)
                    )
                  ),
                  (this.lastSuccessfulNavigation = this.currentNavigation),
                  this.titleStrategy?.updateTitle(this.routerState.snapshot),
                  t.resolve(!0);
              },
              (t) => {
                this.console.warn(`Unhandled Navigation Error: ${t}`);
              }
            );
          }
          scheduleNavigation(t, i, r, o, s) {
            if (this.disposed) return Promise.resolve(!1);
            let a, l, c;
            s
              ? ((a = s.resolve), (l = s.reject), (c = s.promise))
              : (c = new Promise((h, f) => {
                  (a = h), (l = f);
                }));
            const u = ++this.navigationId;
            let d;
            return (
              "computed" === this.canceledNavigationResolution
                ? (0 === this.currentPageId && (r = this.location.getState()),
                  (d =
                    r && r.ɵrouterPageId
                      ? r.ɵrouterPageId
                      : o.replaceUrl || o.skipLocationChange
                      ? this.browserPageId ?? 0
                      : (this.browserPageId ?? 0) + 1))
                : (d = 0),
              this.setTransition({
                id: u,
                targetPageId: d,
                source: i,
                restoredState: r,
                currentUrlTree: this.currentUrlTree,
                currentRawUrl: this.rawUrlTree,
                rawUrl: t,
                extras: o,
                resolve: a,
                reject: l,
                promise: c,
                currentSnapshot: this.routerState.snapshot,
                currentRouterState: this.routerState,
              }),
              c.catch((h) => Promise.reject(h))
            );
          }
          setBrowserUrl(t, i) {
            const r = this.urlSerializer.serialize(t),
              o = {
                ...i.extras.state,
                ...this.generateNgRouterState(i.id, i.targetPageId),
              };
            this.location.isCurrentPathEqualTo(r) || i.extras.replaceUrl
              ? this.location.replaceState(r, "", o)
              : this.location.go(r, "", o);
          }
          restoreHistory(t, i = !1) {
            if ("computed" === this.canceledNavigationResolution) {
              const r = this.currentPageId - t.targetPageId;
              ("popstate" !== t.source &&
                "eager" !== this.urlUpdateStrategy &&
                this.currentUrlTree !== this.currentNavigation?.finalUrl) ||
              0 === r
                ? this.currentUrlTree === this.currentNavigation?.finalUrl &&
                  0 === r &&
                  (this.resetState(t),
                  (this.browserUrlTree = t.currentUrlTree),
                  this.resetUrlToCurrentUrlTree())
                : this.location.historyGo(r);
            } else
              "replace" === this.canceledNavigationResolution &&
                (i && this.resetState(t), this.resetUrlToCurrentUrlTree());
          }
          resetState(t) {
            (this.routerState = t.currentRouterState),
              (this.currentUrlTree = t.currentUrlTree),
              (this.rawUrlTree = this.urlHandlingStrategy.merge(
                this.currentUrlTree,
                t.rawUrl
              ));
          }
          resetUrlToCurrentUrlTree() {
            this.location.replaceState(
              this.urlSerializer.serialize(this.rawUrlTree),
              "",
              this.generateNgRouterState(
                this.lastSuccessfulId,
                this.currentPageId
              )
            );
          }
          cancelNavigationTransition(t, i) {
            const r = new uO(t.id, this.serializeUrl(t.extractedUrl), i);
            this.triggerEvent(r), t.resolve(!1);
          }
          generateNgRouterState(t, i) {
            return "computed" === this.canceledNavigationResolution
              ? { navigationId: t, ɵrouterPageId: i }
              : { navigationId: t };
          }
        }
        return (
          (n.ɵfac = function (t) {
            Vg();
          }),
          (n.ɵprov = j({ token: n, factory: n.ɵfac })),
          n
        );
      })();
      function o1(n) {
        return "imperative" !== n;
      }
      class s1 {
        buildTitle(e) {
          let t,
            i = e.root;
          for (; void 0 !== i; )
            (t = this.getResolvedTitleForRoute(i) ?? t),
              (i = i.children.find((r) => r.outlet === fe));
          return t;
        }
        getResolvedTitleForRoute(e) {
          return e.data[R_];
        }
      }
      let m7 = (() => {
        class n extends s1 {
          constructor(t) {
            super(), (this.title = t);
          }
          updateTitle(t) {
            const i = this.buildTitle(t);
            void 0 !== i && this.title.setTitle(i);
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(T(yM));
          }),
          (n.ɵprov = j({ token: n, factory: n.ɵfac, providedIn: "root" })),
          n
        );
      })();
      class a1 {}
      let l1 = (() => {
        class n {
          constructor(t, i, r, o, s) {
            (this.router = t),
              (this.injector = r),
              (this.preloadingStrategy = o),
              (this.loader = s);
          }
          setUpPreloading() {
            this.subscription = this.router.events
              .pipe(
                ao((t) => t instanceof Vc),
                ja(() => this.preload())
              )
              .subscribe(() => {});
          }
          preload() {
            return this.processRoutes(this.injector, this.router.config);
          }
          ngOnDestroy() {
            this.subscription && this.subscription.unsubscribe();
          }
          processRoutes(t, i) {
            const r = [];
            for (const o of i) {
              o.providers &&
                !o._injector &&
                (o._injector = wd(o.providers, t, `Route: ${o.path}`));
              const s = o._injector ?? t,
                a = o._loadedInjector ?? s;
              (o.loadChildren && !o._loadedRoutes) ||
              (o.loadComponent && !o._loadedComponent)
                ? r.push(this.preloadConfig(s, o))
                : (o.children || o._loadedRoutes) &&
                  r.push(this.processRoutes(a, o.children ?? o._loadedRoutes));
            }
            return xt(r).pipe(As());
          }
          preloadConfig(t, i) {
            return this.preloadingStrategy.preload(i, () => {
              let r;
              r =
                i.loadChildren && void 0 === i.canLoad
                  ? this.loader.loadChildren(t, i)
                  : ne(null);
              const o = r.pipe(
                zt((s) =>
                  null === s
                    ? ne(void 0)
                    : ((i._loadedRoutes = s.routes),
                      (i._loadedInjector = s.injector),
                      this.processRoutes(s.injector ?? t, s.routes))
                )
              );
              return i.loadComponent && !i._loadedComponent
                ? xt([o, this.loader.loadComponent(i)]).pipe(As())
                : o;
            });
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(T(gn), T(Hm), T(Go), T(a1), T(L_));
          }),
          (n.ɵprov = j({ token: n, factory: n.ɵfac })),
          n
        );
      })();
      const c1 = new F("");
      let y7 = (() => {
        class n {
          constructor(t, i, r = {}) {
            (this.router = t),
              (this.viewportScroller = i),
              (this.options = r),
              (this.lastId = 0),
              (this.lastSource = "imperative"),
              (this.restoredId = 0),
              (this.store = {}),
              (r.scrollPositionRestoration =
                r.scrollPositionRestoration || "disabled"),
              (r.anchorScrolling = r.anchorScrolling || "disabled");
          }
          init() {
            "disabled" !== this.options.scrollPositionRestoration &&
              this.viewportScroller.setHistoryScrollRestoration("manual"),
              (this.routerEventsSubscription = this.createScrollEvents()),
              (this.scrollEventsSubscription = this.consumeScrollEvents());
          }
          createScrollEvents() {
            return this.router.events.subscribe((t) => {
              t instanceof b_
                ? ((this.store[this.lastId] =
                    this.viewportScroller.getScrollPosition()),
                  (this.lastSource = t.navigationTrigger),
                  (this.restoredId = t.restoredState
                    ? t.restoredState.navigationId
                    : 0))
                : t instanceof Vc &&
                  ((this.lastId = t.id),
                  this.scheduleScrollEvent(
                    t,
                    this.router.parseUrl(t.urlAfterRedirects).fragment
                  ));
            });
          }
          consumeScrollEvents() {
            return this.router.events.subscribe((t) => {
              t instanceof dO &&
                (t.position
                  ? "top" === this.options.scrollPositionRestoration
                    ? this.viewportScroller.scrollToPosition([0, 0])
                    : "enabled" === this.options.scrollPositionRestoration &&
                      this.viewportScroller.scrollToPosition(t.position)
                  : t.anchor && "enabled" === this.options.anchorScrolling
                  ? this.viewportScroller.scrollToAnchor(t.anchor)
                  : "disabled" !== this.options.scrollPositionRestoration &&
                    this.viewportScroller.scrollToPosition([0, 0]));
            });
          }
          scheduleScrollEvent(t, i) {
            this.router.triggerEvent(
              new dO(
                t,
                "popstate" === this.lastSource
                  ? this.store[this.restoredId]
                  : null,
                i
              )
            );
          }
          ngOnDestroy() {
            this.routerEventsSubscription &&
              this.routerEventsSubscription.unsubscribe(),
              this.scrollEventsSubscription &&
                this.scrollEventsSubscription.unsubscribe();
          }
        }
        return (
          (n.ɵfac = function (t) {
            Vg();
          }),
          (n.ɵprov = j({ token: n, factory: n.ɵfac })),
          n
        );
      })();
      const j_ = new F("ROUTER_CONFIGURATION", {
          providedIn: "root",
          factory: () => ({}),
        }),
        u1 = new F("ROUTER_FORROOT_GUARD"),
        d1 = new F(""),
        v7 = [
          ty,
          { provide: DO, useClass: CO },
          {
            provide: gn,
            useFactory: function w7(n, e, t, i, r, o, s = {}, a, l, c, u) {
              const d = new gn(null, n, e, t, i, r, pO(o));
              return (
                c && (d.urlHandlingStrategy = c),
                u && (d.routeReuseStrategy = u),
                (d.titleStrategy = l ?? a),
                (function S7(n, e) {
                  n.errorHandler && (e.errorHandler = n.errorHandler),
                    n.malformedUriErrorHandler &&
                      (e.malformedUriErrorHandler = n.malformedUriErrorHandler),
                    n.onSameUrlNavigation &&
                      (e.onSameUrlNavigation = n.onSameUrlNavigation),
                    n.paramsInheritanceStrategy &&
                      (e.paramsInheritanceStrategy =
                        n.paramsInheritanceStrategy),
                    n.relativeLinkResolution &&
                      (e.relativeLinkResolution = n.relativeLinkResolution),
                    n.urlUpdateStrategy &&
                      (e.urlUpdateStrategy = n.urlUpdateStrategy),
                    n.canceledNavigationResolution &&
                      (e.canceledNavigationResolution =
                        n.canceledNavigationResolution);
                })(s, d),
                d
              );
            },
            deps: [
              DO,
              zc,
              ty,
              pt,
              Hm,
              F_,
              j_,
              m7,
              [s1, new Gr()],
              [class s7 {}, new Gr()],
              [class i7 {}, new Gr()],
            ],
          },
          zc,
          {
            provide: za,
            useFactory: function M7(n) {
              return n.routerState.root;
            },
            deps: [gn],
          },
          L_,
        ];
      function _7() {
        return new uS("Router", gn);
      }
      let h1 = (() => {
        class n {
          constructor(t, i) {}
          static forRoot(t, i) {
            return {
              ngModule: n,
              providers: [
                v7,
                [],
                f1(t),
                {
                  provide: u1,
                  useFactory: E7,
                  deps: [[gn, new Gr(), new Al()]],
                },
                { provide: j_, useValue: i || {} },
                i?.useHash
                  ? { provide: Jo, useClass: Q2 }
                  : { provide: Jo, useClass: RS },
                {
                  provide: c1,
                  useFactory: () => {
                    const n = Uo(gn),
                      e = Uo(hU),
                      t = Uo(j_);
                    return (
                      t.scrollOffset && e.setOffset(t.scrollOffset),
                      new y7(n, e, t)
                    );
                  },
                },
                i?.preloadingStrategy ? N7(i.preloadingStrategy) : [],
                { provide: uS, multi: !0, useFactory: _7 },
                i?.initialNavigation ? T7(i) : [],
                [
                  { provide: p1, useFactory: I7 },
                  { provide: oS, multi: !0, useExisting: p1 },
                ],
              ],
            };
          }
          static forChild(t) {
            return { ngModule: n, providers: [f1(t)] };
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(T(u1, 8), T(gn, 8));
          }),
          (n.ɵmod = rt({ type: n })),
          (n.ɵinj = Xe({})),
          n
        );
      })();
      function E7(n) {
        return "guarded";
      }
      function f1(n) {
        return [
          { provide: kR, multi: !0, useValue: n },
          { provide: F_, multi: !0, useValue: n },
        ];
      }
      function I7() {
        const n = Uo(pt);
        return (e) => {
          const t = n.get(Da);
          if (e !== t.components[0]) return;
          const i = n.get(gn),
            r = n.get(g1);
          null === n.get(H_, null, G.Optional) && i.initialNavigation(),
            n.get(d1, null, G.Optional)?.setUpPreloading(),
            n.get(c1, null, G.Optional)?.init(),
            i.resetRootComponentType(t.componentTypes[0]),
            r.next(),
            r.complete();
        };
      }
      const p1 = new F("");
      function T7(n) {
        return [
          "disabled" === n.initialNavigation
            ? [
                {
                  provide: xd,
                  multi: !0,
                  useFactory: () => {
                    const n = Uo(gn);
                    return () => {
                      n.setUpLocationChangeListener();
                    };
                  },
                },
                { provide: H_, useValue: "disabled" },
              ]
            : [],
          "enabledBlocking" === n.initialNavigation
            ? [
                { provide: H_, useValue: "enabledBlocking" },
                {
                  provide: xd,
                  multi: !0,
                  deps: [pt],
                  useFactory: (n) => {
                    const e = n.get(K2, Promise.resolve(null));
                    let t = !1;
                    return () =>
                      e.then(
                        () =>
                          new Promise((i) => {
                            const r = n.get(gn),
                              o = n.get(g1);
                            (r.afterPreactivation = () =>
                              t ? ne(void 0) : ((t = !0), i(!0), o)),
                              r.initialNavigation();
                          })
                      );
                  },
                },
              ]
            : [],
        ];
      }
      const g1 = new F("", { factory: () => new _e() }),
        H_ = new F("");
      function N7(n) {
        return [
          l1,
          { provide: d1, useExisting: l1 },
          { provide: a1, useExisting: n },
        ];
      }
      let m1 = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = rt({ type: n })),
            (n.ɵinj = Xe({ imports: [bi] })),
            n
          );
        })(),
        oK = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = rt({ type: n })),
            (n.ɵinj = Xe({ imports: [bi, h1, hh, m1, h1, m1] })),
            n
          );
        })();
      function sK(n, e) {
        1 & n && Kt(0);
      }
      function aK(n, e) {
        if (
          (1 & n &&
            (H(0, "div", 8), Cr(1, 1), U(2, sK, 1, 0, "ng-container", 6), z()),
          2 & n)
        ) {
          const t = V();
          O(2), A("ngTemplateOutlet", t.headerTemplate);
        }
      }
      function lK(n, e) {
        1 & n && Kt(0);
      }
      function cK(n, e) {
        if (
          (1 & n &&
            (H(0, "div", 9), ze(1), U(2, lK, 1, 0, "ng-container", 6), z()),
          2 & n)
        ) {
          const t = V();
          O(1),
            Zr(" ", t.header, " "),
            O(1),
            A("ngTemplateOutlet", t.titleTemplate);
        }
      }
      function uK(n, e) {
        1 & n && Kt(0);
      }
      function dK(n, e) {
        if (
          (1 & n &&
            (H(0, "div", 10), ze(1), U(2, uK, 1, 0, "ng-container", 6), z()),
          2 & n)
        ) {
          const t = V();
          O(1),
            Zr(" ", t.subheader, " "),
            O(1),
            A("ngTemplateOutlet", t.subtitleTemplate);
        }
      }
      function hK(n, e) {
        1 & n && Kt(0);
      }
      function fK(n, e) {
        1 & n && Kt(0);
      }
      function pK(n, e) {
        if (
          (1 & n &&
            (H(0, "div", 11), Cr(1, 2), U(2, fK, 1, 0, "ng-container", 6), z()),
          2 & n)
        ) {
          const t = V();
          O(2), A("ngTemplateOutlet", t.footerTemplate);
        }
      }
      const gK = ["*", [["p-header"]], [["p-footer"]]],
        mK = ["*", "p-header", "p-footer"];
      let yK = (() => {
          class n {
            constructor(t) {
              this.el = t;
            }
            ngAfterContentInit() {
              this.templates.forEach((t) => {
                switch (t.getType()) {
                  case "header":
                    this.headerTemplate = t.template;
                    break;
                  case "title":
                    this.titleTemplate = t.template;
                    break;
                  case "subtitle":
                    this.subtitleTemplate = t.template;
                    break;
                  case "content":
                  default:
                    this.contentTemplate = t.template;
                    break;
                  case "footer":
                    this.footerTemplate = t.template;
                }
              });
            }
            getBlockableElement() {
              return this.el.nativeElement.children[0];
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(w(ut));
            }),
            (n.ɵcmp = ht({
              type: n,
              selectors: [["p-card"]],
              contentQueries: function (t, i, r) {
                if (
                  (1 & t && (qi(r, NI, 5), qi(r, RI, 5), qi(r, $y, 4)), 2 & t)
                ) {
                  let o;
                  bn((o = Dn())) && (i.headerFacet = o.first),
                    bn((o = Dn())) && (i.footerFacet = o.first),
                    bn((o = Dn())) && (i.templates = o);
                }
              },
              hostAttrs: [1, "p-element"],
              inputs: {
                header: "header",
                subheader: "subheader",
                style: "style",
                styleClass: "styleClass",
              },
              ngContentSelectors: mK,
              decls: 9,
              vars: 9,
              consts: [
                [3, "ngClass", "ngStyle"],
                ["class", "p-card-header", 4, "ngIf"],
                [1, "p-card-body"],
                ["class", "p-card-title", 4, "ngIf"],
                ["class", "p-card-subtitle", 4, "ngIf"],
                [1, "p-card-content"],
                [4, "ngTemplateOutlet"],
                ["class", "p-card-footer", 4, "ngIf"],
                [1, "p-card-header"],
                [1, "p-card-title"],
                [1, "p-card-subtitle"],
                [1, "p-card-footer"],
              ],
              template: function (t, i) {
                1 & t &&
                  (da(gK),
                  H(0, "div", 0),
                  U(1, aK, 3, 1, "div", 1),
                  H(2, "div", 2),
                  U(3, cK, 3, 2, "div", 3),
                  U(4, dK, 3, 2, "div", 4),
                  H(5, "div", 5),
                  Cr(6),
                  U(7, hK, 1, 0, "ng-container", 6),
                  z(),
                  U(8, pK, 3, 1, "div", 7),
                  z()()),
                  2 & t &&
                    (yd(i.styleClass),
                    A("ngClass", "p-card p-component")("ngStyle", i.style),
                    O(1),
                    A("ngIf", i.headerFacet || i.headerTemplate),
                    O(2),
                    A("ngIf", i.header || i.titleTemplate),
                    O(1),
                    A("ngIf", i.subheader || i.subtitleTemplate),
                    O(3),
                    A("ngTemplateOutlet", i.contentTemplate),
                    O(1),
                    A("ngIf", i.footerFacet || i.footerTemplate));
              },
              dependencies: [sc, to, py, fy],
              styles: [".p-card-header img{width:100%}\n"],
              encapsulation: 2,
              changeDetection: 0,
            })),
            n
          );
        })(),
        vK = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = rt({ type: n })),
            (n.ɵinj = Xe({ imports: [bi, fc] })),
            n
          );
        })();
      function yf(...n) {
        const e = n.length;
        if (0 === e) throw new Error("list of properties cannot be empty.");
        return (t) =>
          ye(
            (function _K(n, e) {
              return (i) => {
                let r = i;
                for (let o = 0; o < e; o++) {
                  const s = r?.[n[o]];
                  if (void 0 === s) return;
                  r = s;
                }
                return r;
              };
            })(n, e)
          )(t);
      }
      class v1 {}
      class _1 {}
      class Ii {
        constructor(e) {
          (this.normalizedNames = new Map()),
            (this.lazyUpdate = null),
            e
              ? (this.lazyInit =
                  "string" == typeof e
                    ? () => {
                        (this.headers = new Map()),
                          e.split("\n").forEach((t) => {
                            const i = t.indexOf(":");
                            if (i > 0) {
                              const r = t.slice(0, i),
                                o = r.toLowerCase(),
                                s = t.slice(i + 1).trim();
                              this.maybeSetNormalizedName(r, o),
                                this.headers.has(o)
                                  ? this.headers.get(o).push(s)
                                  : this.headers.set(o, [s]);
                            }
                          });
                      }
                    : () => {
                        (this.headers = new Map()),
                          Object.keys(e).forEach((t) => {
                            let i = e[t];
                            const r = t.toLowerCase();
                            "string" == typeof i && (i = [i]),
                              i.length > 0 &&
                                (this.headers.set(r, i),
                                this.maybeSetNormalizedName(t, r));
                          });
                      })
              : (this.headers = new Map());
        }
        has(e) {
          return this.init(), this.headers.has(e.toLowerCase());
        }
        get(e) {
          this.init();
          const t = this.headers.get(e.toLowerCase());
          return t && t.length > 0 ? t[0] : null;
        }
        keys() {
          return this.init(), Array.from(this.normalizedNames.values());
        }
        getAll(e) {
          return this.init(), this.headers.get(e.toLowerCase()) || null;
        }
        append(e, t) {
          return this.clone({ name: e, value: t, op: "a" });
        }
        set(e, t) {
          return this.clone({ name: e, value: t, op: "s" });
        }
        delete(e, t) {
          return this.clone({ name: e, value: t, op: "d" });
        }
        maybeSetNormalizedName(e, t) {
          this.normalizedNames.has(t) || this.normalizedNames.set(t, e);
        }
        init() {
          this.lazyInit &&
            (this.lazyInit instanceof Ii
              ? this.copyFrom(this.lazyInit)
              : this.lazyInit(),
            (this.lazyInit = null),
            this.lazyUpdate &&
              (this.lazyUpdate.forEach((e) => this.applyUpdate(e)),
              (this.lazyUpdate = null)));
        }
        copyFrom(e) {
          e.init(),
            Array.from(e.headers.keys()).forEach((t) => {
              this.headers.set(t, e.headers.get(t)),
                this.normalizedNames.set(t, e.normalizedNames.get(t));
            });
        }
        clone(e) {
          const t = new Ii();
          return (
            (t.lazyInit =
              this.lazyInit && this.lazyInit instanceof Ii
                ? this.lazyInit
                : this),
            (t.lazyUpdate = (this.lazyUpdate || []).concat([e])),
            t
          );
        }
        applyUpdate(e) {
          const t = e.name.toLowerCase();
          switch (e.op) {
            case "a":
            case "s":
              let i = e.value;
              if (("string" == typeof i && (i = [i]), 0 === i.length)) return;
              this.maybeSetNormalizedName(e.name, t);
              const r = ("a" === e.op ? this.headers.get(t) : void 0) || [];
              r.push(...i), this.headers.set(t, r);
              break;
            case "d":
              const o = e.value;
              if (o) {
                let s = this.headers.get(t);
                if (!s) return;
                (s = s.filter((a) => -1 === o.indexOf(a))),
                  0 === s.length
                    ? (this.headers.delete(t), this.normalizedNames.delete(t))
                    : this.headers.set(t, s);
              } else this.headers.delete(t), this.normalizedNames.delete(t);
          }
        }
        forEach(e) {
          this.init(),
            Array.from(this.normalizedNames.keys()).forEach((t) =>
              e(this.normalizedNames.get(t), this.headers.get(t))
            );
        }
      }
      class bK {
        encodeKey(e) {
          return b1(e);
        }
        encodeValue(e) {
          return b1(e);
        }
        decodeKey(e) {
          return decodeURIComponent(e);
        }
        decodeValue(e) {
          return decodeURIComponent(e);
        }
      }
      const CK = /%(\d[a-f0-9])/gi,
        EK = {
          40: "@",
          "3A": ":",
          24: "$",
          "2C": ",",
          "3B": ";",
          "3D": "=",
          "3F": "?",
          "2F": "/",
        };
      function b1(n) {
        return encodeURIComponent(n).replace(CK, (e, t) => EK[t] ?? e);
      }
      function vf(n) {
        return `${n}`;
      }
      class Mo {
        constructor(e = {}) {
          if (
            ((this.updates = null),
            (this.cloneFrom = null),
            (this.encoder = e.encoder || new bK()),
            e.fromString)
          ) {
            if (e.fromObject)
              throw new Error("Cannot specify both fromString and fromObject.");
            this.map = (function DK(n, e) {
              const t = new Map();
              return (
                n.length > 0 &&
                  n
                    .replace(/^\?/, "")
                    .split("&")
                    .forEach((r) => {
                      const o = r.indexOf("="),
                        [s, a] =
                          -1 == o
                            ? [e.decodeKey(r), ""]
                            : [
                                e.decodeKey(r.slice(0, o)),
                                e.decodeValue(r.slice(o + 1)),
                              ],
                        l = t.get(s) || [];
                      l.push(a), t.set(s, l);
                    }),
                t
              );
            })(e.fromString, this.encoder);
          } else
            e.fromObject
              ? ((this.map = new Map()),
                Object.keys(e.fromObject).forEach((t) => {
                  const i = e.fromObject[t],
                    r = Array.isArray(i) ? i.map(vf) : [vf(i)];
                  this.map.set(t, r);
                }))
              : (this.map = null);
        }
        has(e) {
          return this.init(), this.map.has(e);
        }
        get(e) {
          this.init();
          const t = this.map.get(e);
          return t ? t[0] : null;
        }
        getAll(e) {
          return this.init(), this.map.get(e) || null;
        }
        keys() {
          return this.init(), Array.from(this.map.keys());
        }
        append(e, t) {
          return this.clone({ param: e, value: t, op: "a" });
        }
        appendAll(e) {
          const t = [];
          return (
            Object.keys(e).forEach((i) => {
              const r = e[i];
              Array.isArray(r)
                ? r.forEach((o) => {
                    t.push({ param: i, value: o, op: "a" });
                  })
                : t.push({ param: i, value: r, op: "a" });
            }),
            this.clone(t)
          );
        }
        set(e, t) {
          return this.clone({ param: e, value: t, op: "s" });
        }
        delete(e, t) {
          return this.clone({ param: e, value: t, op: "d" });
        }
        toString() {
          return (
            this.init(),
            this.keys()
              .map((e) => {
                const t = this.encoder.encodeKey(e);
                return this.map
                  .get(e)
                  .map((i) => t + "=" + this.encoder.encodeValue(i))
                  .join("&");
              })
              .filter((e) => "" !== e)
              .join("&")
          );
        }
        clone(e) {
          const t = new Mo({ encoder: this.encoder });
          return (
            (t.cloneFrom = this.cloneFrom || this),
            (t.updates = (this.updates || []).concat(e)),
            t
          );
        }
        init() {
          null === this.map && (this.map = new Map()),
            null !== this.cloneFrom &&
              (this.cloneFrom.init(),
              this.cloneFrom
                .keys()
                .forEach((e) => this.map.set(e, this.cloneFrom.map.get(e))),
              this.updates.forEach((e) => {
                switch (e.op) {
                  case "a":
                  case "s":
                    const t =
                      ("a" === e.op ? this.map.get(e.param) : void 0) || [];
                    t.push(vf(e.value)), this.map.set(e.param, t);
                    break;
                  case "d":
                    if (void 0 === e.value) {
                      this.map.delete(e.param);
                      break;
                    }
                    {
                      let i = this.map.get(e.param) || [];
                      const r = i.indexOf(vf(e.value));
                      -1 !== r && i.splice(r, 1),
                        i.length > 0
                          ? this.map.set(e.param, i)
                          : this.map.delete(e.param);
                    }
                }
              }),
              (this.cloneFrom = this.updates = null));
        }
      }
      class wK {
        constructor() {
          this.map = new Map();
        }
        set(e, t) {
          return this.map.set(e, t), this;
        }
        get(e) {
          return (
            this.map.has(e) || this.map.set(e, e.defaultValue()),
            this.map.get(e)
          );
        }
        delete(e) {
          return this.map.delete(e), this;
        }
        has(e) {
          return this.map.has(e);
        }
        keys() {
          return this.map.keys();
        }
      }
      function D1(n) {
        return typeof ArrayBuffer < "u" && n instanceof ArrayBuffer;
      }
      function C1(n) {
        return typeof Blob < "u" && n instanceof Blob;
      }
      function E1(n) {
        return typeof FormData < "u" && n instanceof FormData;
      }
      class Yc {
        constructor(e, t, i, r) {
          let o;
          if (
            ((this.url = t),
            (this.body = null),
            (this.reportProgress = !1),
            (this.withCredentials = !1),
            (this.responseType = "json"),
            (this.method = e.toUpperCase()),
            (function SK(n) {
              switch (n) {
                case "DELETE":
                case "GET":
                case "HEAD":
                case "OPTIONS":
                case "JSONP":
                  return !1;
                default:
                  return !0;
              }
            })(this.method) || r
              ? ((this.body = void 0 !== i ? i : null), (o = r))
              : (o = i),
            o &&
              ((this.reportProgress = !!o.reportProgress),
              (this.withCredentials = !!o.withCredentials),
              o.responseType && (this.responseType = o.responseType),
              o.headers && (this.headers = o.headers),
              o.context && (this.context = o.context),
              o.params && (this.params = o.params)),
            this.headers || (this.headers = new Ii()),
            this.context || (this.context = new wK()),
            this.params)
          ) {
            const s = this.params.toString();
            if (0 === s.length) this.urlWithParams = t;
            else {
              const a = t.indexOf("?");
              this.urlWithParams =
                t + (-1 === a ? "?" : a < t.length - 1 ? "&" : "") + s;
            }
          } else (this.params = new Mo()), (this.urlWithParams = t);
        }
        serializeBody() {
          return null === this.body
            ? null
            : D1(this.body) ||
              C1(this.body) ||
              E1(this.body) ||
              (function MK(n) {
                return (
                  typeof URLSearchParams < "u" && n instanceof URLSearchParams
                );
              })(this.body) ||
              "string" == typeof this.body
            ? this.body
            : this.body instanceof Mo
            ? this.body.toString()
            : "object" == typeof this.body ||
              "boolean" == typeof this.body ||
              Array.isArray(this.body)
            ? JSON.stringify(this.body)
            : this.body.toString();
        }
        detectContentTypeHeader() {
          return null === this.body || E1(this.body)
            ? null
            : C1(this.body)
            ? this.body.type || null
            : D1(this.body)
            ? null
            : "string" == typeof this.body
            ? "text/plain"
            : this.body instanceof Mo
            ? "application/x-www-form-urlencoded;charset=UTF-8"
            : "object" == typeof this.body ||
              "number" == typeof this.body ||
              "boolean" == typeof this.body
            ? "application/json"
            : null;
        }
        clone(e = {}) {
          const t = e.method || this.method,
            i = e.url || this.url,
            r = e.responseType || this.responseType,
            o = void 0 !== e.body ? e.body : this.body,
            s =
              void 0 !== e.withCredentials
                ? e.withCredentials
                : this.withCredentials,
            a =
              void 0 !== e.reportProgress
                ? e.reportProgress
                : this.reportProgress;
          let l = e.headers || this.headers,
            c = e.params || this.params;
          const u = e.context ?? this.context;
          return (
            void 0 !== e.setHeaders &&
              (l = Object.keys(e.setHeaders).reduce(
                (d, h) => d.set(h, e.setHeaders[h]),
                l
              )),
            e.setParams &&
              (c = Object.keys(e.setParams).reduce(
                (d, h) => d.set(h, e.setParams[h]),
                c
              )),
            new Yc(t, i, o, {
              params: c,
              headers: l,
              context: u,
              reportProgress: a,
              responseType: r,
              withCredentials: s,
            })
          );
        }
      }
      var Dt = (() => (
        ((Dt = Dt || {})[(Dt.Sent = 0)] = "Sent"),
        (Dt[(Dt.UploadProgress = 1)] = "UploadProgress"),
        (Dt[(Dt.ResponseHeader = 2)] = "ResponseHeader"),
        (Dt[(Dt.DownloadProgress = 3)] = "DownloadProgress"),
        (Dt[(Dt.Response = 4)] = "Response"),
        (Dt[(Dt.User = 5)] = "User"),
        Dt
      ))();
      class U_ {
        constructor(e, t = 200, i = "OK") {
          (this.headers = e.headers || new Ii()),
            (this.status = void 0 !== e.status ? e.status : t),
            (this.statusText = e.statusText || i),
            (this.url = e.url || null),
            (this.ok = this.status >= 200 && this.status < 300);
        }
      }
      class z_ extends U_ {
        constructor(e = {}) {
          super(e), (this.type = Dt.ResponseHeader);
        }
        clone(e = {}) {
          return new z_({
            headers: e.headers || this.headers,
            status: void 0 !== e.status ? e.status : this.status,
            statusText: e.statusText || this.statusText,
            url: e.url || this.url || void 0,
          });
        }
      }
      class _f extends U_ {
        constructor(e = {}) {
          super(e),
            (this.type = Dt.Response),
            (this.body = void 0 !== e.body ? e.body : null);
        }
        clone(e = {}) {
          return new _f({
            body: void 0 !== e.body ? e.body : this.body,
            headers: e.headers || this.headers,
            status: void 0 !== e.status ? e.status : this.status,
            statusText: e.statusText || this.statusText,
            url: e.url || this.url || void 0,
          });
        }
      }
      class w1 extends U_ {
        constructor(e) {
          super(e, 0, "Unknown Error"),
            (this.name = "HttpErrorResponse"),
            (this.ok = !1),
            (this.message =
              this.status >= 200 && this.status < 300
                ? `Http failure during parsing for ${e.url || "(unknown url)"}`
                : `Http failure response for ${e.url || "(unknown url)"}: ${
                    e.status
                  } ${e.statusText}`),
            (this.error = e.error || null);
        }
      }
      function $_(n, e) {
        return {
          body: e,
          headers: n.headers,
          context: n.context,
          observe: n.observe,
          params: n.params,
          reportProgress: n.reportProgress,
          responseType: n.responseType,
          withCredentials: n.withCredentials,
        };
      }
      let bf = (() => {
        class n {
          constructor(t) {
            this.handler = t;
          }
          request(t, i, r = {}) {
            let o;
            if (t instanceof Yc) o = t;
            else {
              let l, c;
              (l = r.headers instanceof Ii ? r.headers : new Ii(r.headers)),
                r.params &&
                  (c =
                    r.params instanceof Mo
                      ? r.params
                      : new Mo({ fromObject: r.params })),
                (o = new Yc(t, i, void 0 !== r.body ? r.body : null, {
                  headers: l,
                  context: r.context,
                  params: c,
                  reportProgress: r.reportProgress,
                  responseType: r.responseType || "json",
                  withCredentials: r.withCredentials,
                }));
            }
            const s = ne(o).pipe(ja((l) => this.handler.handle(l)));
            if (t instanceof Yc || "events" === r.observe) return s;
            const a = s.pipe(ao((l) => l instanceof _f));
            switch (r.observe || "body") {
              case "body":
                switch (o.responseType) {
                  case "arraybuffer":
                    return a.pipe(
                      ye((l) => {
                        if (null !== l.body && !(l.body instanceof ArrayBuffer))
                          throw new Error("Response is not an ArrayBuffer.");
                        return l.body;
                      })
                    );
                  case "blob":
                    return a.pipe(
                      ye((l) => {
                        if (null !== l.body && !(l.body instanceof Blob))
                          throw new Error("Response is not a Blob.");
                        return l.body;
                      })
                    );
                  case "text":
                    return a.pipe(
                      ye((l) => {
                        if (null !== l.body && "string" != typeof l.body)
                          throw new Error("Response is not a string.");
                        return l.body;
                      })
                    );
                  default:
                    return a.pipe(ye((l) => l.body));
                }
              case "response":
                return a;
              default:
                throw new Error(
                  `Unreachable: unhandled observe type ${r.observe}}`
                );
            }
          }
          delete(t, i = {}) {
            return this.request("DELETE", t, i);
          }
          get(t, i = {}) {
            return this.request("GET", t, i);
          }
          head(t, i = {}) {
            return this.request("HEAD", t, i);
          }
          jsonp(t, i) {
            return this.request("JSONP", t, {
              params: new Mo().append(i, "JSONP_CALLBACK"),
              observe: "body",
              responseType: "json",
            });
          }
          options(t, i = {}) {
            return this.request("OPTIONS", t, i);
          }
          patch(t, i, r = {}) {
            return this.request("PATCH", t, $_(r, i));
          }
          post(t, i, r = {}) {
            return this.request("POST", t, $_(r, i));
          }
          put(t, i, r = {}) {
            return this.request("PUT", t, $_(r, i));
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(T(v1));
          }),
          (n.ɵprov = j({ token: n, factory: n.ɵfac })),
          n
        );
      })();
      class S1 {
        constructor(e, t) {
          (this.next = e), (this.interceptor = t);
        }
        handle(e) {
          return this.interceptor.intercept(e, this.next);
        }
      }
      const M1 = new F("HTTP_INTERCEPTORS");
      let IK = (() => {
        class n {
          intercept(t, i) {
            return i.handle(t);
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)();
          }),
          (n.ɵprov = j({ token: n, factory: n.ɵfac })),
          n
        );
      })();
      const TK = /^\)\]\}',?\n/;
      let I1 = (() => {
        class n {
          constructor(t) {
            this.xhrFactory = t;
          }
          handle(t) {
            if ("JSONP" === t.method)
              throw new Error(
                "Attempted to construct Jsonp request without HttpClientJsonpModule installed."
              );
            return new je((i) => {
              const r = this.xhrFactory.build();
              if (
                (r.open(t.method, t.urlWithParams),
                t.withCredentials && (r.withCredentials = !0),
                t.headers.forEach((f, p) => r.setRequestHeader(f, p.join(","))),
                t.headers.has("Accept") ||
                  r.setRequestHeader(
                    "Accept",
                    "application/json, text/plain, */*"
                  ),
                !t.headers.has("Content-Type"))
              ) {
                const f = t.detectContentTypeHeader();
                null !== f && r.setRequestHeader("Content-Type", f);
              }
              if (t.responseType) {
                const f = t.responseType.toLowerCase();
                r.responseType = "json" !== f ? f : "text";
              }
              const o = t.serializeBody();
              let s = null;
              const a = () => {
                  if (null !== s) return s;
                  const f = r.statusText || "OK",
                    p = new Ii(r.getAllResponseHeaders()),
                    g =
                      (function xK(n) {
                        return "responseURL" in n && n.responseURL
                          ? n.responseURL
                          : /^X-Request-URL:/m.test(n.getAllResponseHeaders())
                          ? n.getResponseHeader("X-Request-URL")
                          : null;
                      })(r) || t.url;
                  return (
                    (s = new z_({
                      headers: p,
                      status: r.status,
                      statusText: f,
                      url: g,
                    })),
                    s
                  );
                },
                l = () => {
                  let { headers: f, status: p, statusText: g, url: m } = a(),
                    v = null;
                  204 !== p &&
                    (v = typeof r.response > "u" ? r.responseText : r.response),
                    0 === p && (p = v ? 200 : 0);
                  let _ = p >= 200 && p < 300;
                  if ("json" === t.responseType && "string" == typeof v) {
                    const b = v;
                    v = v.replace(TK, "");
                    try {
                      v = "" !== v ? JSON.parse(v) : null;
                    } catch (y) {
                      (v = b), _ && ((_ = !1), (v = { error: y, text: v }));
                    }
                  }
                  _
                    ? (i.next(
                        new _f({
                          body: v,
                          headers: f,
                          status: p,
                          statusText: g,
                          url: m || void 0,
                        })
                      ),
                      i.complete())
                    : i.error(
                        new w1({
                          error: v,
                          headers: f,
                          status: p,
                          statusText: g,
                          url: m || void 0,
                        })
                      );
                },
                c = (f) => {
                  const { url: p } = a(),
                    g = new w1({
                      error: f,
                      status: r.status || 0,
                      statusText: r.statusText || "Unknown Error",
                      url: p || void 0,
                    });
                  i.error(g);
                };
              let u = !1;
              const d = (f) => {
                  u || (i.next(a()), (u = !0));
                  let p = { type: Dt.DownloadProgress, loaded: f.loaded };
                  f.lengthComputable && (p.total = f.total),
                    "text" === t.responseType &&
                      !!r.responseText &&
                      (p.partialText = r.responseText),
                    i.next(p);
                },
                h = (f) => {
                  let p = { type: Dt.UploadProgress, loaded: f.loaded };
                  f.lengthComputable && (p.total = f.total), i.next(p);
                };
              return (
                r.addEventListener("load", l),
                r.addEventListener("error", c),
                r.addEventListener("timeout", c),
                r.addEventListener("abort", c),
                t.reportProgress &&
                  (r.addEventListener("progress", d),
                  null !== o &&
                    r.upload &&
                    r.upload.addEventListener("progress", h)),
                r.send(o),
                i.next({ type: Dt.Sent }),
                () => {
                  r.removeEventListener("error", c),
                    r.removeEventListener("abort", c),
                    r.removeEventListener("load", l),
                    r.removeEventListener("timeout", c),
                    t.reportProgress &&
                      (r.removeEventListener("progress", d),
                      null !== o &&
                        r.upload &&
                        r.upload.removeEventListener("progress", h)),
                    r.readyState !== r.DONE && r.abort();
                }
              );
            });
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(T(tM));
          }),
          (n.ɵprov = j({ token: n, factory: n.ɵfac })),
          n
        );
      })();
      const W_ = new F("XSRF_COOKIE_NAME"),
        G_ = new F("XSRF_HEADER_NAME");
      class T1 {}
      let AK = (() => {
          class n {
            constructor(t, i, r) {
              (this.doc = t),
                (this.platform = i),
                (this.cookieName = r),
                (this.lastCookieString = ""),
                (this.lastToken = null),
                (this.parseCount = 0);
            }
            getToken() {
              if ("server" === this.platform) return null;
              const t = this.doc.cookie || "";
              return (
                t !== this.lastCookieString &&
                  (this.parseCount++,
                  (this.lastToken = $S(t, this.cookieName)),
                  (this.lastCookieString = t)),
                this.lastToken
              );
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(T(gt), T(Od), T(W_));
            }),
            (n.ɵprov = j({ token: n, factory: n.ɵfac })),
            n
          );
        })(),
        q_ = (() => {
          class n {
            constructor(t, i) {
              (this.tokenService = t), (this.headerName = i);
            }
            intercept(t, i) {
              const r = t.url.toLowerCase();
              if (
                "GET" === t.method ||
                "HEAD" === t.method ||
                r.startsWith("http://") ||
                r.startsWith("https://")
              )
                return i.handle(t);
              const o = this.tokenService.getToken();
              return (
                null !== o &&
                  !t.headers.has(this.headerName) &&
                  (t = t.clone({ headers: t.headers.set(this.headerName, o) })),
                i.handle(t)
              );
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(T(T1), T(G_));
            }),
            (n.ɵprov = j({ token: n, factory: n.ɵfac })),
            n
          );
        })(),
        OK = (() => {
          class n {
            constructor(t, i) {
              (this.backend = t), (this.injector = i), (this.chain = null);
            }
            handle(t) {
              if (null === this.chain) {
                const i = this.injector.get(M1, []);
                this.chain = i.reduceRight(
                  (r, o) => new S1(r, o),
                  this.backend
                );
              }
              return this.chain.handle(t);
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(T(_1), T(pt));
            }),
            (n.ɵprov = j({ token: n, factory: n.ɵfac })),
            n
          );
        })(),
        kK = (() => {
          class n {
            static disable() {
              return {
                ngModule: n,
                providers: [{ provide: q_, useClass: IK }],
              };
            }
            static withOptions(t = {}) {
              return {
                ngModule: n,
                providers: [
                  t.cookieName ? { provide: W_, useValue: t.cookieName } : [],
                  t.headerName ? { provide: G_, useValue: t.headerName } : [],
                ],
              };
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = rt({ type: n })),
            (n.ɵinj = Xe({
              providers: [
                q_,
                { provide: M1, useExisting: q_, multi: !0 },
                { provide: T1, useClass: AK },
                { provide: W_, useValue: "XSRF-TOKEN" },
                { provide: G_, useValue: "X-XSRF-TOKEN" },
              ],
            })),
            n
          );
        })(),
        NK = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = rt({ type: n })),
            (n.ɵinj = Xe({
              providers: [
                bf,
                { provide: v1, useClass: OK },
                I1,
                { provide: _1, useExisting: I1 },
              ],
              imports: [
                kK.withOptions({
                  cookieName: "XSRF-TOKEN",
                  headerName: "X-XSRF-TOKEN",
                }),
              ],
            })),
            n
          );
        })(),
        x1 = (() => {
          class n {
            constructor(t) {
              this.http = t;
            }
            get defaultHeaders() {
              const t = new Ii();
              return (
                t.set("Accept", "*/*").set("Content-Type", "application/json"),
                t
              );
            }
            getContentTypes(t = "", i = "") {
              return this.http
                .post("/api/v1/contenttype/_filter", {
                  filter: { types: i, query: t },
                  orderBy: "name",
                  direction: "ASC",
                  perPage: 40,
                })
                .pipe(yf("entity"));
            }
            getContentlets({ contentType: t, filter: i, currentLanguage: r }) {
              return this.http
                .post("/api/content/_search", {
                  query: `+contentType:${t} +languageId:${r} +deleted:false +working:true +catchall:*${i}* `,
                  sort: "modDate desc",
                  offset: 0,
                  limit: 40,
                })
                .pipe(yf("entity", "jsonObjectView", "contentlets"));
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(T(bf));
            }),
            (n.ɵprov = j({ token: n, factory: n.ɵfac })),
            n
          );
        })();
      class PK {
        getQueryParams() {
          const e = window.location.search.substring(1).split("&"),
            t = new Map();
          return (
            e.forEach((i) => {
              const r = i.split("=");
              t.set(r[0], r[1]);
            }),
            t
          );
        }
        getQueryStringParam(e) {
          let t = null;
          const r = new RegExp(
            "[?&]" + e.replace(/[\[\]]/g, "\\$&") + "(=([^&#]*)|&|#|$)"
          ).exec(window.location.href);
          return (
            r && r[2] && (t = decodeURIComponent(r[2].replace(/\+/g, " "))), t
          );
        }
      }
      let A1 = (() => {
          class n {
            getLine(t, i) {
              let r = null;
              if (t) {
                const o = t.split("\n");
                r = o && o.length > i ? o[i] : null;
              }
              return r;
            }
            camelize(t) {
              return t
                .replace(/(?:^\w|[A-Z]|\b\w)/g, (i, r) =>
                  0 === r ? i.toLowerCase() : i.toUpperCase()
                )
                .replace(/\s+/g, "");
            }
            titleCase(t) {
              return `${t.charAt(0).toLocaleUpperCase()}${t.slice(1)}`;
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵprov = j({ token: n, factory: n.ɵfac })),
            n
          );
        })(),
        LK = (() => {
          class n {
            constructor(t) {
              (this.stringUtils = t),
                (this.showLogs = !0),
                (this.httpRequestUtils = new PK()),
                (this.showLogs = this.shouldShowLogs()),
                this.showLogs &&
                  console.info(
                    "Setting the logger --\x3e Developer mode logger on"
                  );
            }
            info(t, ...i) {
              i && i.length > 0
                ? console.info(this.wrapMessage(t), i)
                : console.info(this.wrapMessage(t));
            }
            error(t, ...i) {
              i && i.length > 0
                ? console.error(this.wrapMessage(t), i)
                : console.error(this.wrapMessage(t));
            }
            warn(t, ...i) {
              i && i.length > 0
                ? console.warn(this.wrapMessage(t), i)
                : console.warn(this.wrapMessage(t));
            }
            debug(t, ...i) {
              i && i.length > 0
                ? console.debug(this.wrapMessage(t), i)
                : console.debug(this.wrapMessage(t));
            }
            shouldShowLogs() {
              this.httpRequestUtils.getQueryStringParam("devMode");
              return !0;
            }
            wrapMessage(t) {
              return this.showLogs ? t : this.getCaller() + ">> " + t;
            }
            getCaller() {
              let t = "unknown";
              try {
                throw new Error();
              } catch (i) {
                t = this.cleanCaller(this.stringUtils.getLine(i.stack, 4));
              }
              return t;
            }
            cleanCaller(t) {
              return t ? t.trim().substr(3) : "unknown";
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(T(A1));
            }),
            (n.ɵprov = j({ token: n, factory: n.ɵfac })),
            n
          );
        })(),
        zK = (() => {
          class n {
            constructor() {
              (this.iconPath = "./src/assets/images/icons"),
                (this.dotCMSURLKey = "siteURLJWT");
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵprov = j({ token: n, factory: n.ɵfac })),
            n
          );
        })(),
        Zc = class {
          constructor(e) {
            this.iconPath = e.iconPath;
          }
          displayErrorMessage(e) {
            this.displayMessage("Error", e, "error");
          }
          displaySuccessMessage(e) {
            this.displayMessage("Success", e, "success");
          }
          displayInfoMessage(e) {
            this.displayMessage("Info", e, "info");
          }
          displayMessage(e, t, i) {
            let r;
            return (
              (r = new Notification(i, {
                body: t,
                icon: this.iconPath + "/" + i + ".png",
              })),
              r
            );
          }
        };
      function R1(n, e, t, i, r, o, s) {
        try {
          var a = n[o](s),
            l = a.value;
        } catch (c) {
          return void t(c);
        }
        a.done ? e(l) : Promise.resolve(l).then(i, r);
      }
      function P1(n) {
        return function () {
          var e = this,
            t = arguments;
          return new Promise(function (i, r) {
            var o = n.apply(e, t);
            function s(l) {
              R1(o, i, r, s, a, "next", l);
            }
            function a(l) {
              R1(o, i, r, s, a, "throw", l);
            }
            s(void 0);
          });
        };
      }
      (Zc.ɵprov = j({ token: Zc, factory: Zc.ɵfac })),
        (Zc = (function BK(n, e, t, i) {
          var s,
            r = arguments.length,
            o =
              r < 3
                ? e
                : null === i
                ? (i = Object.getOwnPropertyDescriptor(e, t))
                : i;
          if (
            "object" == typeof Reflect &&
            "function" == typeof Reflect.decorate
          )
            o = Reflect.decorate(n, e, t, i);
          else
            for (var a = n.length - 1; a >= 0; a--)
              (s = n[a]) &&
                (o = (r < 3 ? s(o) : r > 3 ? s(e, t, o) : s(e, t)) || o);
          return r > 3 && o && Object.defineProperty(e, t, o), o;
        })(
          [
            Ju("config"),
            (function jK(n, e) {
              if (
                "object" == typeof Reflect &&
                "function" == typeof Reflect.metadata
              )
                return Reflect.metadata(n, e);
            })("design:paramtypes", [zK]),
          ],
          Zc
        ));
      const F1 = {
          500: "500 Internal Server Error",
          400: "400 Bad Request",
          401: "401 Unauthorized Error",
        },
        L1 = "/api/v1/temp";
      function V1(n, e) {
        let t = "";
        try {
          t = n.message || F1[e];
        } catch {
          t = F1[e || 500];
        }
        return { message: t, status: 500 | e };
      }
      let B1 = (() => {
          class n {
            constructor(t) {
              this.http = t;
            }
            publishContent(t, i) {
              return this.setTempResource(t, i).pipe(
                or((r) => {
                  const o = Array.isArray(r) ? r : [r],
                    s = [];
                  return (
                    o.forEach((a) => {
                      s.push({
                        baseType: "dotAsset",
                        asset: a.id,
                        hostFolder: "",
                        indexPolicy: "WAIT_FOR",
                      });
                    }),
                    this.http
                      .post(
                        "/api/v1/workflow/actions/default/fire/PUBLISH",
                        JSON.stringify({ contentlets: s }),
                        {
                          headers: {
                            Origin: window.location.hostname,
                            "Content-Type": "application/json;charset=UTF-8",
                          },
                        }
                      )
                      .pipe(yf("entity", "results"))
                  );
                }),
                ms((r) => gs(r))
              );
            }
            setTempResource(t, i) {
              return xt(
                (function $K({ file: n, progressCallBack: e, maxSize: t }) {
                  return "string" == typeof n
                    ? (function WK(n) {
                        return fetch(`${L1}/byUrl`, {
                          method: "POST",
                          headers: {
                            "Content-Type": "application/json",
                            Origin: window.location.hostname,
                          },
                          body: JSON.stringify({ remoteUrl: n }),
                        }).then(
                          (function () {
                            var t = P1(function* (i) {
                              if (200 === i.status)
                                return (yield i.json()).tempFiles[0];
                              throw V1(yield i.json(), i.status);
                            });
                            return function (i) {
                              return t.apply(this, arguments);
                            };
                          })()
                        );
                      })(n)
                    : (function GK({
                        file: n,
                        progressCallBack: e,
                        maxSize: t,
                      }) {
                        let i = L1;
                        i += t ? `?maxFileLength=${t}` : "";
                        const r = new FormData();
                        return (
                          (Array.isArray(n) ? n : [n]).forEach((s) =>
                            r.append("files", s)
                          ),
                          (function qK(n, e, t) {
                            return new Promise((i, r) => {
                              const o = new XMLHttpRequest();
                              o.open(e.method || "get", n);
                              for (const s in e.headers || {})
                                o.setRequestHeader(s, e.headers[s]);
                              (o.onload = () => i(o)),
                                (o.onerror = r),
                                o.upload &&
                                  t &&
                                  (o.upload.onprogress = (s) => {
                                    t((s.loaded / s.total) * 100);
                                  }),
                                o.send(e.body);
                            });
                          })(i, { method: "POST", headers: {}, body: r }, e)
                            .then((s) => {
                              if (200 === s.status) {
                                const a = JSON.parse(s.response).tempFiles;
                                return a.length > 1 ? a : a[0];
                              }
                              throw s;
                            })
                            .catch((s) => {
                              throw V1(JSON.parse(s.response), s.status);
                            })
                        );
                      })({ file: n, progressCallBack: e, maxSize: t });
                })({ file: t, progressCallBack: () => {}, maxSize: i })
              );
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(T(bf));
            }),
            (n.ɵprov = j({ token: n, factory: n.ɵfac })),
            n
          );
        })(),
        YK = (() => {
          class n {}
          return (
            (n.ɵfac = function (t) {
              return new (t || n)();
            }),
            (n.ɵmod = rt({ type: n })),
            (n.ɵinj = Xe({
              providers: [x1, B1, LK, A1],
              imports: [bi, TI, vK, oK],
            })),
            n
          );
        })(),
        ZK = (() => {
          class n {
            constructor(t) {
              this.http = t;
            }
            get defaultHeaders() {
              const t = new Ii();
              return (
                t.set("Accept", "*/*").set("Content-Type", "application/json"),
                t
              );
            }
            getLanguages() {
              return this.languages
                ? ne(this.languages)
                : this.http
                    .get("/api/v2/languages", { headers: this.defaultHeaders })
                    .pipe(
                      yf("entity"),
                      ye((t) => {
                        const i = this.getDotLanguageObject(t);
                        return (this.languages = i), i;
                      })
                    );
            }
            getDotLanguageObject(t) {
              return t.reduce((i, r) => Object.assign(i, { [r.id]: r }), {});
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(T(bf));
            }),
            (n.ɵprov = j({ token: n, factory: n.ɵfac, providedIn: "root" })),
            n
          );
        })();
      function QK(n, e) {
        if ((1 & n && (H(0, "i", 6), ze(1), z()), 2 & n)) {
          const t = V();
          O(1), _n(t.url);
        }
      }
      function JK(n, e) {
        1 & n && Lt(0, "dot-contentlet-thumbnail", 8),
          2 & n &&
            A("contentlet", V(2).data.contentlet)("width", 42)("height", 42)(
              "iconSize",
              "42px"
            );
      }
      function XK(n, e) {
        if ((1 & n && U(0, JK, 1, 4, "dot-contentlet-thumbnail", 7), 2 & n)) {
          const t = V(),
            i = Dr(9);
          A("ngIf", null == t.data ? null : t.data.contentlet)("ngIfElse", i);
        }
      }
      function eY(n, e) {
        if (
          (1 & n &&
            (H(0, "div", 9),
            Lt(1, "dot-state-icon", 10),
            H(2, "dot-badge", 11),
            ze(3),
            z()()),
          2 & n)
        ) {
          const t = V();
          O(1),
            A("state", t.data.contentlet),
            O(2),
            _n(t.data.contentlet.language);
        }
      }
      function tY(n, e) {
        1 & n && Lt(0, "img", 12), 2 & n && A("src", V().url, qr);
      }
      let j1 = (() => {
        class n {
          constructor(t) {
            (this.element = t),
              (this.role = "list-item"),
              (this.tabindex = "-1"),
              (this.label = ""),
              (this.url = ""),
              (this.data = null),
              (this.icon = !1);
          }
          ngOnInit() {
            this.icon = this.icon =
              "string" == typeof this.url && !(this.url.split("/").length > 1);
          }
          getLabel() {
            return this.element.nativeElement.innerText;
          }
          focus() {
            this.element.nativeElement.style = "background: #eee";
          }
          unfocus() {
            this.element.nativeElement.style = "";
          }
          scrollIntoView() {
            this.isIntoView() ||
              this.element.nativeElement.scrollIntoView(this.alignToTop());
          }
          isIntoView() {
            const { bottom: t, top: i } =
                this.element.nativeElement.getBoundingClientRect(),
              r =
                this.element.nativeElement.parentElement.getBoundingClientRect();
            return i >= r.top && t <= r.bottom;
          }
          alignToTop() {
            const { top: t } =
                this.element.nativeElement.getBoundingClientRect(),
              { top: i } =
                this.element.nativeElement.parentElement.getBoundingClientRect();
            return t < i;
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(w(ut));
          }),
          (n.ɵcmp = ht({
            type: n,
            selectors: [["dotcms-suggestions-list-item"]],
            hostVars: 3,
            hostBindings: function (t, i) {
              2 & t &&
                Ln("role", i.role)("tabindex", i.tabindex)(
                  "data-index",
                  i.index
                );
            },
            inputs: {
              index: "index",
              command: "command",
              label: "label",
              url: "url",
              data: "data",
            },
            decls: 10,
            vars: 6,
            consts: [
              [1, "icon-wrapper"],
              ["class", "material-icons", 4, "ngIf", "ngIfElse"],
              ["thumbnail", ""],
              [1, "data-wrapper"],
              ["class", "state", 4, "ngIf"],
              ["image", ""],
              [1, "material-icons"],
              [
                3,
                "contentlet",
                "width",
                "height",
                "iconSize",
                4,
                "ngIf",
                "ngIfElse",
              ],
              [3, "contentlet", "width", "height", "iconSize"],
              [1, "state"],
              ["size", "16px", 3, "state"],
              ["bordered", "true"],
              ["alt", "", 3, "src"],
            ],
            template: function (t, i) {
              if (
                (1 & t &&
                  (H(0, "div", 0),
                  U(1, QK, 2, 1, "i", 1),
                  U(2, XK, 1, 2, "ng-template", null, 2, Xr),
                  z(),
                  H(4, "div", 3)(5, "span"),
                  ze(6),
                  z(),
                  U(7, eY, 4, 2, "div", 4),
                  z(),
                  U(8, tY, 1, 1, "ng-template", null, 5, Xr)),
                2 & t)
              ) {
                const r = Dr(3);
                $l("dot-contentlet", null == i.data ? null : i.data.contentlet),
                  O(1),
                  A("ngIf", i.icon)("ngIfElse", r),
                  O(5),
                  _n(i.label),
                  O(1),
                  A("ngIf", null == i.data ? null : i.data.contentlet);
              }
            },
            dependencies: [to],
            styles: [
              "[_nghost-%COMP%]{box-sizing:border-box;display:flex;gap:16px;padding:4px 8px;background-color:#fff;cursor:pointer;align-items:center}.icon-wrapper[_ngcontent-%COMP%]{align-items:center;border:solid 1px lightgrey;display:flex;flex-basis:32px;flex-shrink:0;height:32px;justify-content:center;width:32px}.icon-wrapper[_ngcontent-%COMP%]   dot-contentlet-thumbnail[_ngcontent-%COMP%]{align-items:center;display:block;position:relative;width:42px;height:42px}.icon-wrapper.dot-contentlet[_ngcontent-%COMP%]{width:42px;height:42px;flex-basis:42px}.data-wrapper[_ngcontent-%COMP%]{overflow:hidden}.data-wrapper[_ngcontent-%COMP%] > span[_ngcontent-%COMP%]{overflow:hidden;display:block;white-space:nowrap;text-overflow:ellipsis}.data-wrapper[_ngcontent-%COMP%]   .state[_ngcontent-%COMP%]{margin-top:8px;display:flex}.data-wrapper[_ngcontent-%COMP%]   .state[_ngcontent-%COMP%]   dot-state-icon[_ngcontent-%COMP%]{margin-right:8px}",
            ],
          })),
          n
        );
      })();
      const nY = ["*"];
      let iY = (() => {
        class n {
          ngAfterContentInit() {
            this.keyManager = new zI(this.items).withWrap();
          }
          updateSelection(t) {
            this.keyManager.activeItem && this.keyManager.activeItem.unfocus(),
              this.keyManager.onKeydown(t),
              this.keyManager.activeItem.scrollIntoView();
          }
          execCommand() {
            this.keyManager.activeItem.command();
          }
          setFirstItemActive() {
            this.keyManager.activeItem?.unfocus(),
              this.keyManager.setFirstItemActive(),
              this.keyManager.activeItem?.focus();
          }
          resetKeyManager() {
            (this.keyManager = new zI(this.items).withWrap()),
              setTimeout(() => {
                this.setFirstItemActive();
              }, 0);
          }
          updateActiveItem(t) {
            this.keyManager.activeItem?.unfocus(),
              this.keyManager.setActiveItem(t);
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)();
          }),
          (n.ɵcmp = ht({
            type: n,
            selectors: [["dotcms-suggestion-list"]],
            contentQueries: function (t, i, r) {
              if ((1 & t && qi(r, j1, 4), 2 & t)) {
                let o;
                bn((o = Dn())) && (i.items = o);
              }
            },
            ngContentSelectors: nY,
            decls: 1,
            vars: 0,
            template: function (t, i) {
              1 & t && (da(), Cr(0));
            },
          })),
          n
        );
      })();
      const rY = ["list"];
      function oY(n, e) {
        if (1 & n) {
          const t = Ui();
          H(0, "dotcms-suggestions-list-item", 7),
            Oe("mousedown", function (r) {
              const s = Ot(t).$implicit;
              return kt(V(2).onMouseDown(r, s));
            })("mouseenter", function (r) {
              return Ot(t), kt(V(2).onMouseEnter(r));
            }),
            z();
        }
        if (2 & n) {
          const t = e.$implicit,
            i = e.index;
          A("command", t.command)("index", i)("label", t.label)("url", t.icon)(
            "data",
            t.data
          );
        }
      }
      function sY(n, e) {
        if (1 & n) {
          const t = Ui();
          H(0, "div", 3),
            Oe("mousedown", function (r) {
              return Ot(t), kt(V().onMouseDownHandler(r));
            }),
            H(1, "h3"),
            ze(2),
            z(),
            H(3, "dotcms-suggestion-list", 4, 5),
            U(5, oY, 1, 5, "dotcms-suggestions-list-item", 6),
            z()();
        }
        if (2 & n) {
          const t = V();
          O(2), _n(t.title), O(3), A("ngForOf", t.items);
        }
      }
      function aY(n, e) {
        if (1 & n) {
          const t = Ui();
          H(0, "div", 8),
            Lt(1, "p", 9),
            H(2, "button", 3),
            Oe("mousedown", function (r) {
              return Ot(t), kt(V().handleBackButton(r));
            }),
            ze(3, "Back"),
            z()();
        }
        if (2 & n) {
          const t = V();
          O(1), A("innerHTML", t.title, sg);
        }
      }
      function lY(n, e) {
        if ((1 & n && (H(0, "div", 8), Lt(1, "p", 9), z()), 2 & n)) {
          const t = V();
          O(1), A("innerHTML", t.noResultsMessage, sg);
        }
      }
      var tn = (() => (
        (function (n) {
          (n.BLOCK = "block"),
            (n.CONTENTTYPE = "contentType"),
            (n.CONTENT = "content");
        })(tn || (tn = {})),
        tn
      ))();
      let H1 = (() => {
        class n {
          constructor(t, i, r) {
            (this.suggestionsService = t),
              (this.dotLanguageService = i),
              (this.cd = r),
              (this.items = []),
              (this.title = "Select a block"),
              (this.noResultsMessage = "No Results"),
              (this.isOpen = !1),
              (this.currentLanguage = Bk),
              (this.allowedContentTypes = ""),
              (this.clearFilter = new Ie()),
              (this.mouseMove = !0),
              (this.isFilterActive = !1);
          }
          onMousemove() {
            this.mouseMove = !0;
          }
          ngOnInit() {
            0 === this.items?.length &&
              ((this.items = Nk),
              this.items.forEach((t) => {
                t.command = () => {
                  this.clearFilter.emit(tn.BLOCK),
                    t.id.includes("heading")
                      ? this.onSelection({
                          type: { name: "heading", ...t.attributes },
                        })
                      : this.onSelection({ type: { name: t.id } });
                };
              }),
              (this.items = [
                {
                  label: "Contentlets",
                  icon: "receipt",
                  command: () => {
                    this.clearFilter.emit(tn.CONTENTTYPE),
                      this.loadContentTypes();
                  },
                },
                ...this.items,
              ])),
              (this.initialItems = this.items),
              (this.itemsLoaded = tn.BLOCK),
              this.dotLanguageService
                .getLanguages()
                .pipe(wo(1))
                .subscribe((t) => (this.dotLangs = t));
          }
          ngAfterViewInit() {
            this.setFirstItemActive();
          }
          execCommand() {
            this.items.length
              ? this.list.execCommand()
              : this.handleBackButton(new MouseEvent("click"));
          }
          updateSelection(t) {
            this.list.updateSelection(t), (this.mouseMove = !1);
          }
          setFirstItemActive() {
            this.list?.setFirstItemActive();
          }
          updateActiveItem(t) {
            this.list.updateActiveItem(t);
          }
          resetKeyManager() {
            this.list?.resetKeyManager();
          }
          onMouseDownHandler(t) {
            t.preventDefault();
          }
          onMouseEnter(t) {
            if (!this.mouseMove) return;
            t.preventDefault();
            const i = Number(t.target.dataset.index);
            this.updateActiveItem(i);
          }
          onMouseDown(t, i) {
            t.preventDefault(), i.command();
          }
          handleBackButton(t) {
            t.preventDefault(),
              t.stopPropagation(),
              (this.itemsLoaded =
                this.itemsLoaded === tn.CONTENT ? tn.CONTENTTYPE : tn.BLOCK),
              this.filterItems();
          }
          filterItems(t = "") {
            switch (this.itemsLoaded) {
              case tn.BLOCK:
                this.items = this.initialItems.filter((i) =>
                  i.label.toLowerCase().includes(t.trim().toLowerCase())
                );
                break;
              case tn.CONTENTTYPE:
                this.loadContentTypes(t);
                break;
              case tn.CONTENT:
                this.loadContentlets(this.selectedContentType, t);
            }
            (this.isFilterActive = !!t.length), this.setFirstItemActive();
          }
          loadContentTypes(t = "") {
            this.suggestionsService
              .getContentTypes(t, this.allowedContentTypes)
              .pipe(
                ye((i) =>
                  i.map((r) => ({
                    label: r.name,
                    icon: r.icon,
                    command: () => {
                      (this.selectedContentType = r),
                        (this.itemsLoaded = tn.CONTENT),
                        this.loadContentlets(r),
                        this.clearFilter.emit(tn.CONTENT);
                    },
                  }))
                ),
                wo(1)
              )
              .subscribe((i) => {
                (this.items = i),
                  (this.itemsLoaded = tn.CONTENTTYPE),
                  this.items.length
                    ? ((this.title = "Select a content type"),
                      this.cd.detectChanges(),
                      this.resetKeyManager())
                    : ((this.title = "No results"), this.cd.detectChanges()),
                  this.cd.detectChanges(),
                  this.resetKeyManager();
              });
          }
          loadContentlets(t, i = "") {
            this.suggestionsService
              .getContentlets({
                contentType: t.variable,
                filter: i,
                currentLanguage: this.currentLanguage,
              })
              .pipe(wo(1))
              .subscribe((r) => {
                (this.items = r.map((o) => {
                  const { languageId: s } = o;
                  return (
                    (o.language = this.getContentletLanguage(s)),
                    {
                      label: o.title,
                      icon: "contentlet/image",
                      data: { contentlet: o },
                      command: () => {
                        this.onSelection({
                          payload: o,
                          type: { name: "dotContent" },
                        });
                      },
                    }
                  );
                })),
                  this.items.length
                    ? ((this.title = "Select a contentlet"),
                      this.cd.detectChanges(),
                      this.resetKeyManager())
                    : ((this.title = `No results for <b>${t.name}</b>`),
                      this.cd.detectChanges());
              });
          }
          getContentletLanguage(t) {
            const { languageCode: i, countryCode: r } = this.dotLangs[t];
            return i && r ? `${i}-${r}` : "";
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(w(x1), w(ZK), w(Zo));
          }),
          (n.ɵcmp = ht({
            type: n,
            selectors: [["dotcms-suggestions"]],
            viewQuery: function (t, i) {
              if ((1 & t && ec(rY, 5), 2 & t)) {
                let r;
                bn((r = Dn())) && (i.list = r.first);
              }
            },
            hostBindings: function (t, i) {
              1 & t &&
                Oe("mousemove", function (o) {
                  return i.onMousemove(o);
                });
            },
            inputs: {
              onSelection: "onSelection",
              items: "items",
              title: "title",
              noResultsMessage: "noResultsMessage",
              isOpen: "isOpen",
              currentLanguage: "currentLanguage",
              allowedContentTypes: "allowedContentTypes",
            },
            outputs: { clearFilter: "clearFilter" },
            decls: 5,
            vars: 2,
            consts: [
              [3, "mousedown", 4, "ngIf", "ngIfElse"],
              ["emptyBlock", ""],
              ["noResults", ""],
              [3, "mousedown"],
              [1, "suggestion-list-container"],
              ["list", ""],
              [
                3,
                "command",
                "index",
                "label",
                "url",
                "data",
                "mousedown",
                "mouseenter",
                4,
                "ngFor",
                "ngForOf",
              ],
              [
                3,
                "command",
                "index",
                "label",
                "url",
                "data",
                "mousedown",
                "mouseenter",
              ],
              [1, "empty"],
              [3, "innerHTML"],
            ],
            template: function (t, i) {
              if (
                (1 & t &&
                  (U(0, sY, 6, 2, "div", 0),
                  U(1, aY, 4, 1, "ng-template", null, 1, Xr),
                  U(3, lY, 2, 1, "ng-template", null, 2, Xr)),
                2 & t)
              ) {
                const r = Dr(2),
                  o = Dr(4);
                A("ngIf", i.items.length)("ngIfElse", i.isFilterActive ? o : r);
              }
            },
            dependencies: [Kd, to, iY, j1],
            styles: [
              '[_nghost-%COMP%]{display:block;min-width:15rem;box-shadow:0 4px 20px #0000001a;padding:8px 0;background:#ffffff;font-family:Roboto,Helvetica,sans-serif,Arial}h3[_ngcontent-%COMP%]{text-transform:uppercase;font-size:16px;margin:.5rem 1rem;color:#999}.suggestion-list-container[_ngcontent-%COMP%]{width:100%;height:100%;max-height:400px;overflow:auto;display:block}.material-icons[_ngcontent-%COMP%]{font-family:Material Icons;font-weight:400;font-style:normal;font-size:24px;line-height:1;letter-spacing:normal;text-transform:none;display:inline-block;white-space:nowrap;word-wrap:normal;direction:ltr;-webkit-font-feature-settings:"liga";-webkit-font-smoothing:antialiased}.empty[_ngcontent-%COMP%]{align-items:center;flex-direction:column;display:flex;justify-content:center;padding:16px;height:240px}button[_ngcontent-%COMP%]{background:none;border-radius:2px;border:0;border:1px solid var(--color-sec);color:var(--color-sec);cursor:pointer;font-size:1rem;font-weight:500;line-height:normal;padding:12px 32px;text-transform:uppercase}.empty[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]:hover, .empty[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]:active, .empty[_ngcontent-%COMP%]   button[_ngcontent-%COMP%]:focus{border-color:var(--color-main);color:var(--color-main)}',
            ],
          })),
          n
        );
      })();
      const cY = function (n) {
        return { "btn-bubble-menu": !0, "btn-active": n };
      };
      let uY = (() => {
        class n {
          constructor() {
            this.active = !1;
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)();
          }),
          (n.ɵcmp = ht({
            type: n,
            selectors: [["dotcms-bubble-menu-button"]],
            inputs: { item: "item", active: "active" },
            decls: 3,
            vars: 4,
            consts: [
              [3, "ngClass"],
              [1, "material-icons"],
            ],
            template: function (t, i) {
              1 & t && (H(0, "button", 0)(1, "span", 1), ze(2), z()()),
                2 & t &&
                  (A("ngClass", Kn(2, cY, i.active)), O(2), _n(i.item.icon));
            },
            dependencies: [sc],
            styles: [
              "[_nghost-%COMP%]{display:flex;align-items:center;justify-content:center}.btn-bubble-menu[_ngcontent-%COMP%]{background:#ffffff;border:none;color:#0a0725;display:flex;justify-content:center;align-items:center;cursor:pointer;width:32px;height:32px;border-radius:2px}.btn-bubble-menu[_ngcontent-%COMP%]:hover{background:#f1f3f4}.btn-bubble-menu.btn-active[_ngcontent-%COMP%]{background:#f1f3f4;color:#0a0725;border:1px solid #b3b1b8}",
            ],
          })),
          n
        );
      })();
      function dY(n, e) {
        if (1 & n) {
          const t = Ui();
          ji(0),
            H(1, "button", 3),
            Oe("click", function () {
              return Ot(t), kt(V().toggleChangeTo.emit());
            }),
            ze(2),
            z(),
            Lt(3, "div", 4),
            Hi();
        }
        if (2 & n) {
          const t = V();
          O(2), _n(t.selected);
        }
      }
      function hY(n, e) {
        1 & n && Lt(0, "div", 4);
      }
      function fY(n, e) {
        if (1 & n) {
          const t = Ui();
          ji(0),
            H(1, "dotcms-bubble-menu-button", 5),
            Oe("click", function () {
              const o = Ot(t).$implicit;
              return kt(V().command.emit(o));
            }),
            z(),
            U(2, hY, 1, 0, "div", 6),
            Hi();
        }
        if (2 & n) {
          const t = e.$implicit;
          O(1), A("active", t.active)("item", t), O(1), A("ngIf", t.divider);
        }
      }
      let pY = (() => {
        class n {
          constructor() {
            (this.items = []),
              (this.command = new Ie()),
              (this.toggleChangeTo = new Ie());
          }
          preventDeSelection(t) {
            t.preventDefault();
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)();
          }),
          (n.ɵcmp = ht({
            type: n,
            selectors: [["dotcms-bubble-menu"]],
            inputs: { items: "items", selected: "selected" },
            outputs: { command: "command", toggleChangeTo: "toggleChangeTo" },
            decls: 3,
            vars: 2,
            consts: [
              ["id", "bubble-menu", 1, "bubble-menu", 3, "mousedown"],
              [4, "ngIf"],
              [4, "ngFor", "ngForOf"],
              [1, "btn-dropdown", 3, "click"],
              [1, "divider"],
              [3, "active", "item", "click"],
              ["class", "divider", 4, "ngIf"],
            ],
            template: function (t, i) {
              1 & t &&
                (H(0, "div", 0),
                Oe("mousedown", function (o) {
                  return i.preventDeSelection(o);
                }),
                U(1, dY, 4, 1, "ng-container", 1),
                U(2, fY, 3, 3, "ng-container", 2),
                z()),
                2 & t &&
                  (O(1), A("ngIf", i.selected), O(1), A("ngForOf", i.items));
            },
            dependencies: [Kd, to, uY],
            styles: [
              '[_nghost-%COMP%]{height:100%;width:100%}.bubble-menu[_ngcontent-%COMP%]{box-sizing:border-box;align-items:center;background:#ffffff;border-radius:2px;box-shadow:0 10px 24px #0003;display:flex;justify-content:center;padding:5.6px;height:40px}.bubble-menu[_ngcontent-%COMP%]   .btn-dropdown[_ngcontent-%COMP%]{background:none;border:none;outline:none;padding:4px;cursor:pointer}.bubble-menu[_ngcontent-%COMP%]   .btn-dropdown[_ngcontent-%COMP%]:hover{background:#f1f3f4}.bubble-menu[_ngcontent-%COMP%]   .btn-dropdown[_ngcontent-%COMP%]:after{content:"";border:solid #0a0725;border-width:0 2px 2px 0;display:inline-block;padding:3.2px;transform:rotate(45deg);margin-left:12px}.bubble-menu[_ngcontent-%COMP%]   .divider[_ngcontent-%COMP%]{border-left:1px solid #f1f3f4;height:100%;margin:0 8px}',
            ],
          })),
          n
        );
      })();
      const mY = new It("suggestion");
      function yY({
        pluginKey: n = mY,
        editor: e,
        char: t = "@",
        allowSpaces: i = !1,
        allowedPrefixes: r = [" "],
        startOfLine: o = !1,
        decorationTag: s = "span",
        decorationClass: a = "suggestion",
        command: l = () => null,
        items: c = () => [],
        render: u = () => ({}),
        allow: d = () => !0,
      }) {
        let h;
        const f = u?.(),
          p = new Qe({
            key: n,
            view() {
              var m,
                g = this;
              return {
                update:
                  ((m = P1(function* (v, _) {
                    var b, y, D, C, R, S, $;
                    const X =
                        null === (b = g.key) || void 0 === b
                          ? void 0
                          : b.getState(_),
                      se =
                        null === (y = g.key) || void 0 === y
                          ? void 0
                          : y.getState(v.state),
                      ve =
                        X.active && se.active && X.range.from !== se.range.from,
                      he = !X.active && se.active,
                      Ge = X.active && !se.active,
                      De = he || ve,
                      Je = !he && !Ge && X.query !== se.query && !ve,
                      it = Ge || ve;
                    if (!De && !Je && !it) return;
                    const Ce = it && !De ? X : se,
                      Ae = document.querySelector(
                        `[data-decoration-id="${Ce.decorationId}"]`
                      );
                    (h = {
                      editor: e,
                      range: Ce.range,
                      query: Ce.query,
                      text: Ce.text,
                      items: [],
                      command: (Tt) => {
                        l({ editor: e, range: Ce.range, props: Tt });
                      },
                      decorationNode: Ae,
                      clientRect: Ae
                        ? () => {
                            var Tt;
                            const { decorationId: ai } =
                              null === (Tt = g.key) || void 0 === Tt
                                ? void 0
                                : Tt.getState(e.state);
                            return (
                              document
                                .querySelector(`[data-decoration-id="${ai}"]`)
                                ?.getBoundingClientRect() || null
                            );
                          }
                        : null,
                    }),
                      De &&
                        (null === (D = f?.onBeforeStart) ||
                          void 0 === D ||
                          D.call(f, h)),
                      Je &&
                        (null === (C = f?.onBeforeUpdate) ||
                          void 0 === C ||
                          C.call(f, h)),
                      (Je || De) &&
                        (h.items = yield c({ editor: e, query: Ce.query })),
                      it &&
                        (null === (R = f?.onExit) ||
                          void 0 === R ||
                          R.call(f, h)),
                      Je &&
                        (null === (S = f?.onUpdate) ||
                          void 0 === S ||
                          S.call(f, h)),
                      De &&
                        (null === ($ = f?.onStart) ||
                          void 0 === $ ||
                          $.call(f, h));
                  })),
                  function (_, b) {
                    return m.apply(this, arguments);
                  }),
                destroy: () => {
                  var m;
                  !h ||
                    null === (m = f?.onExit) ||
                    void 0 === m ||
                    m.call(f, h);
                },
              };
            },
            state: {
              init: () => ({
                active: !1,
                range: { from: 0, to: 0 },
                query: null,
                text: null,
                composing: !1,
              }),
              apply(g, m, v, _) {
                const { isEditable: b } = e,
                  { composing: y } = e.view,
                  { selection: D } = g,
                  { empty: C, from: R } = D,
                  S = { ...m };
                if (((S.composing = y), b && (C || e.view.composing))) {
                  (R < m.range.from || R > m.range.to) &&
                    !y &&
                    !m.composing &&
                    (S.active = !1);
                  const $ = (function gY(n) {
                      var e;
                      const {
                          char: t,
                          allowSpaces: i,
                          allowedPrefixes: r,
                          startOfLine: o,
                          $position: s,
                        } = n,
                        a = (function U6(n) {
                          return n.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
                        })(t),
                        l = new RegExp(`\\s${a}$`),
                        c = o ? "^" : "",
                        u = i
                          ? new RegExp(`${c}${a}.*?(?=\\s${a}|$)`, "gm")
                          : new RegExp(`${c}(?:^)?${a}[^\\s${a}]*`, "gm"),
                        d =
                          (null === (e = s.nodeBefore) || void 0 === e
                            ? void 0
                            : e.isText) && s.nodeBefore.text;
                      if (!d) return null;
                      const h = s.pos - d.length,
                        f = Array.from(d.matchAll(u)).pop();
                      if (!f || void 0 === f.input || void 0 === f.index)
                        return null;
                      const p = f.input.slice(
                          Math.max(0, f.index - 1),
                          f.index
                        ),
                        g = new RegExp(`^[${r?.join("")}\0]?$`).test(p);
                      if (null !== r && !g) return null;
                      const m = h + f.index;
                      let v = m + f[0].length;
                      return (
                        i &&
                          l.test(d.slice(v - 1, v + 1)) &&
                          ((f[0] += " "), (v += 1)),
                        m < s.pos && v >= s.pos
                          ? {
                              range: { from: m, to: v },
                              query: f[0].slice(t.length),
                              text: f[0],
                            }
                          : null
                      );
                    })({
                      char: t,
                      allowSpaces: i,
                      allowedPrefixes: r,
                      startOfLine: o,
                      $position: D.$from,
                    }),
                    X = `id_${Math.floor(4294967295 * Math.random())}`;
                  $ && d({ editor: e, state: _, range: $.range })
                    ? ((S.active = !0),
                      (S.decorationId = m.decorationId ? m.decorationId : X),
                      (S.range = $.range),
                      (S.query = $.query),
                      (S.text = $.text))
                    : (S.active = !1);
                } else S.active = !1;
                return (
                  S.active ||
                    ((S.decorationId = null),
                    (S.range = { from: 0, to: 0 }),
                    (S.query = null),
                    (S.text = null)),
                  S
                );
              },
            },
            props: {
              handleKeyDown(g, m) {
                var v;
                const { active: _, range: b } = p.getState(g.state);
                return (
                  (_ &&
                    (null === (v = f?.onKeyDown) || void 0 === v
                      ? void 0
                      : v.call(f, { view: g, event: m, range: b }))) ||
                  !1
                );
              },
              decorations(g) {
                const { active: m, range: v, decorationId: _ } = p.getState(g);
                return m
                  ? vt.create(g.doc, [
                      pn.inline(v.from, v.to, {
                        nodeName: s,
                        class: a,
                        "data-decoration-id": _,
                      }),
                    ])
                  : null;
              },
            },
          });
        return p;
      }
      function Ti(n) {
        if (null == n) return window;
        if ("[object Window]" !== n.toString()) {
          var e = n.ownerDocument;
          return (e && e.defaultView) || window;
        }
        return n;
      }
      function Wa(n) {
        return n instanceof Ti(n).Element || n instanceof Element;
      }
      function ni(n) {
        return n instanceof Ti(n).HTMLElement || n instanceof HTMLElement;
      }
      function Y_(n) {
        return (
          !(typeof ShadowRoot > "u") &&
          (n instanceof Ti(n).ShadowRoot || n instanceof ShadowRoot)
        );
      }
      var Ds = Math.max,
        Cf = Math.min,
        Ga = Math.round;
      function qa(n, e) {
        void 0 === e && (e = !1);
        var t = n.getBoundingClientRect(),
          i = 1,
          r = 1;
        if (ni(n) && e) {
          var o = n.offsetHeight,
            s = n.offsetWidth;
          s > 0 && (i = Ga(t.width) / s || 1),
            o > 0 && (r = Ga(t.height) / o || 1);
        }
        return {
          width: t.width / i,
          height: t.height / r,
          top: t.top / r,
          right: t.right / i,
          bottom: t.bottom / r,
          left: t.left / i,
          x: t.left / i,
          y: t.top / r,
        };
      }
      function Z_(n) {
        var e = Ti(n);
        return { scrollLeft: e.pageXOffset, scrollTop: e.pageYOffset };
      }
      function lr(n) {
        return n ? (n.nodeName || "").toLowerCase() : null;
      }
      function Io(n) {
        return ((Wa(n) ? n.ownerDocument : n.document) || window.document)
          .documentElement;
      }
      function Q_(n) {
        return qa(Io(n)).left + Z_(n).scrollLeft;
      }
      function Rr(n) {
        return Ti(n).getComputedStyle(n);
      }
      function J_(n) {
        var e = Rr(n);
        return /auto|scroll|overlay|hidden/.test(
          e.overflow + e.overflowY + e.overflowX
        );
      }
      function DY(n, e, t) {
        void 0 === t && (t = !1);
        var i = ni(e),
          r =
            ni(e) &&
            (function bY(n) {
              var e = n.getBoundingClientRect(),
                t = Ga(e.width) / n.offsetWidth || 1,
                i = Ga(e.height) / n.offsetHeight || 1;
              return 1 !== t || 1 !== i;
            })(e),
          o = Io(e),
          s = qa(n, r),
          a = { scrollLeft: 0, scrollTop: 0 },
          l = { x: 0, y: 0 };
        return (
          (i || (!i && !t)) &&
            (("body" !== lr(e) || J_(o)) &&
              (a = (function _Y(n) {
                return n !== Ti(n) && ni(n)
                  ? (function vY(n) {
                      return {
                        scrollLeft: n.scrollLeft,
                        scrollTop: n.scrollTop,
                      };
                    })(n)
                  : Z_(n);
              })(e)),
            ni(e)
              ? (((l = qa(e, !0)).x += e.clientLeft), (l.y += e.clientTop))
              : o && (l.x = Q_(o))),
          {
            x: s.left + a.scrollLeft - l.x,
            y: s.top + a.scrollTop - l.y,
            width: s.width,
            height: s.height,
          }
        );
      }
      function X_(n) {
        var e = qa(n),
          t = n.offsetWidth,
          i = n.offsetHeight;
        return (
          Math.abs(e.width - t) <= 1 && (t = e.width),
          Math.abs(e.height - i) <= 1 && (i = e.height),
          { x: n.offsetLeft, y: n.offsetTop, width: t, height: i }
        );
      }
      function Ef(n) {
        return "html" === lr(n)
          ? n
          : n.assignedSlot || n.parentNode || (Y_(n) ? n.host : null) || Io(n);
      }
      function U1(n) {
        return ["html", "body", "#document"].indexOf(lr(n)) >= 0
          ? n.ownerDocument.body
          : ni(n) && J_(n)
          ? n
          : U1(Ef(n));
      }
      function Qc(n, e) {
        var t;
        void 0 === e && (e = []);
        var i = U1(n),
          r = i === (null == (t = n.ownerDocument) ? void 0 : t.body),
          o = Ti(i),
          s = r ? [o].concat(o.visualViewport || [], J_(i) ? i : []) : i,
          a = e.concat(s);
        return r ? a : a.concat(Qc(Ef(s)));
      }
      function CY(n) {
        return ["table", "td", "th"].indexOf(lr(n)) >= 0;
      }
      function z1(n) {
        return ni(n) && "fixed" !== Rr(n).position ? n.offsetParent : null;
      }
      function Jc(n) {
        for (
          var e = Ti(n), t = z1(n);
          t && CY(t) && "static" === Rr(t).position;

        )
          t = z1(t);
        return t &&
          ("html" === lr(t) ||
            ("body" === lr(t) && "static" === Rr(t).position))
          ? e
          : t ||
              (function EY(n) {
                var e =
                  -1 !== navigator.userAgent.toLowerCase().indexOf("firefox");
                if (
                  -1 !== navigator.userAgent.indexOf("Trident") &&
                  ni(n) &&
                  "fixed" === Rr(n).position
                )
                  return null;
                var r = Ef(n);
                for (
                  Y_(r) && (r = r.host);
                  ni(r) && ["html", "body"].indexOf(lr(r)) < 0;

                ) {
                  var o = Rr(r);
                  if (
                    "none" !== o.transform ||
                    "none" !== o.perspective ||
                    "paint" === o.contain ||
                    -1 !== ["transform", "perspective"].indexOf(o.willChange) ||
                    (e && "filter" === o.willChange) ||
                    (e && o.filter && "none" !== o.filter)
                  )
                    return r;
                  r = r.parentNode;
                }
                return null;
              })(n) ||
              e;
      }
      var Sn = "top",
        ii = "bottom",
        ri = "right",
        Mn = "left",
        eb = "auto",
        Xc = [Sn, ii, ri, Mn],
        Ka = "start",
        eu = "end",
        $1 = "viewport",
        tu = "popper",
        W1 = Xc.reduce(function (n, e) {
          return n.concat([e + "-" + Ka, e + "-" + eu]);
        }, []),
        G1 = [].concat(Xc, [eb]).reduce(function (n, e) {
          return n.concat([e, e + "-" + Ka, e + "-" + eu]);
        }, []),
        PY = [
          "beforeRead",
          "read",
          "afterRead",
          "beforeMain",
          "main",
          "afterMain",
          "beforeWrite",
          "write",
          "afterWrite",
        ];
      function FY(n) {
        var e = new Map(),
          t = new Set(),
          i = [];
        function r(o) {
          t.add(o.name),
            []
              .concat(o.requires || [], o.requiresIfExists || [])
              .forEach(function (a) {
                if (!t.has(a)) {
                  var l = e.get(a);
                  l && r(l);
                }
              }),
            i.push(o);
        }
        return (
          n.forEach(function (o) {
            e.set(o.name, o);
          }),
          n.forEach(function (o) {
            t.has(o.name) || r(o);
          }),
          i
        );
      }
      function VY(n) {
        var e;
        return function () {
          return (
            e ||
              (e = new Promise(function (t) {
                Promise.resolve().then(function () {
                  (e = void 0), t(n());
                });
              })),
            e
          );
        };
      }
      var q1 = { placement: "bottom", modifiers: [], strategy: "absolute" };
      function K1() {
        for (var n = arguments.length, e = new Array(n), t = 0; t < n; t++)
          e[t] = arguments[t];
        return !e.some(function (i) {
          return !(i && "function" == typeof i.getBoundingClientRect);
        });
      }
      function jY(n) {
        void 0 === n && (n = {});
        var t = n.defaultModifiers,
          i = void 0 === t ? [] : t,
          r = n.defaultOptions,
          o = void 0 === r ? q1 : r;
        return function (a, l, c) {
          void 0 === c && (c = o);
          var u = {
              placement: "bottom",
              orderedModifiers: [],
              options: Object.assign({}, q1, o),
              modifiersData: {},
              elements: { reference: a, popper: l },
              attributes: {},
              styles: {},
            },
            d = [],
            h = !1,
            f = {
              state: u,
              setOptions: function (v) {
                var _ = "function" == typeof v ? v(u.options) : v;
                g(),
                  (u.options = Object.assign({}, o, u.options, _)),
                  (u.scrollParents = {
                    reference: Wa(a)
                      ? Qc(a)
                      : a.contextElement
                      ? Qc(a.contextElement)
                      : [],
                    popper: Qc(l),
                  });
                var b = (function LY(n) {
                  var e = FY(n);
                  return PY.reduce(function (t, i) {
                    return t.concat(
                      e.filter(function (r) {
                        return r.phase === i;
                      })
                    );
                  }, []);
                })(
                  (function BY(n) {
                    var e = n.reduce(function (t, i) {
                      var r = t[i.name];
                      return (
                        (t[i.name] = r
                          ? Object.assign({}, r, i, {
                              options: Object.assign({}, r.options, i.options),
                              data: Object.assign({}, r.data, i.data),
                            })
                          : i),
                        t
                      );
                    }, {});
                    return Object.keys(e).map(function (t) {
                      return e[t];
                    });
                  })([].concat(i, u.options.modifiers))
                );
                return (
                  (u.orderedModifiers = b.filter(function (se) {
                    return se.enabled;
                  })),
                  (function p() {
                    u.orderedModifiers.forEach(function (m) {
                      var _ = m.options,
                        y = m.effect;
                      if ("function" == typeof y) {
                        var D = y({
                          state: u,
                          name: m.name,
                          instance: f,
                          options: void 0 === _ ? {} : _,
                        });
                        d.push(D || function () {});
                      }
                    });
                  })(),
                  f.update()
                );
              },
              forceUpdate: function () {
                if (!h) {
                  var v = u.elements,
                    _ = v.reference,
                    b = v.popper;
                  if (K1(_, b)) {
                    (u.rects = {
                      reference: DY(_, Jc(b), "fixed" === u.options.strategy),
                      popper: X_(b),
                    }),
                      (u.reset = !1),
                      (u.placement = u.options.placement),
                      u.orderedModifiers.forEach(function (se) {
                        return (u.modifiersData[se.name] = Object.assign(
                          {},
                          se.data
                        ));
                      });
                    for (var D = 0; D < u.orderedModifiers.length; D++)
                      if (!0 !== u.reset) {
                        var C = u.orderedModifiers[D],
                          R = C.fn,
                          S = C.options;
                        "function" == typeof R &&
                          (u =
                            R({
                              state: u,
                              options: void 0 === S ? {} : S,
                              name: C.name,
                              instance: f,
                            }) || u);
                      } else (u.reset = !1), (D = -1);
                  }
                }
              },
              update: VY(function () {
                return new Promise(function (m) {
                  f.forceUpdate(), m(u);
                });
              }),
              destroy: function () {
                g(), (h = !0);
              },
            };
          if (!K1(a, l)) return f;
          function g() {
            d.forEach(function (m) {
              return m();
            }),
              (d = []);
          }
          return (
            f.setOptions(c).then(function (m) {
              !h && c.onFirstUpdate && c.onFirstUpdate(m);
            }),
            f
          );
        };
      }
      var wf = { passive: !0 };
      const UY = {
        name: "eventListeners",
        enabled: !0,
        phase: "write",
        fn: function () {},
        effect: function HY(n) {
          var e = n.state,
            t = n.instance,
            i = n.options,
            r = i.scroll,
            o = void 0 === r || r,
            s = i.resize,
            a = void 0 === s || s,
            l = Ti(e.elements.popper),
            c = [].concat(e.scrollParents.reference, e.scrollParents.popper);
          return (
            o &&
              c.forEach(function (u) {
                u.addEventListener("scroll", t.update, wf);
              }),
            a && l.addEventListener("resize", t.update, wf),
            function () {
              o &&
                c.forEach(function (u) {
                  u.removeEventListener("scroll", t.update, wf);
                }),
                a && l.removeEventListener("resize", t.update, wf);
            }
          );
        },
        data: {},
      };
      function cr(n) {
        return n.split("-")[0];
      }
      function Ya(n) {
        return n.split("-")[1];
      }
      function tb(n) {
        return ["top", "bottom"].indexOf(n) >= 0 ? "x" : "y";
      }
      function Y1(n) {
        var l,
          e = n.reference,
          t = n.element,
          i = n.placement,
          r = i ? cr(i) : null,
          o = i ? Ya(i) : null,
          s = e.x + e.width / 2 - t.width / 2,
          a = e.y + e.height / 2 - t.height / 2;
        switch (r) {
          case Sn:
            l = { x: s, y: e.y - t.height };
            break;
          case ii:
            l = { x: s, y: e.y + e.height };
            break;
          case ri:
            l = { x: e.x + e.width, y: a };
            break;
          case Mn:
            l = { x: e.x - t.width, y: a };
            break;
          default:
            l = { x: e.x, y: e.y };
        }
        var c = r ? tb(r) : null;
        if (null != c) {
          var u = "y" === c ? "height" : "width";
          switch (o) {
            case Ka:
              l[c] = l[c] - (e[u] / 2 - t[u] / 2);
              break;
            case eu:
              l[c] = l[c] + (e[u] / 2 - t[u] / 2);
          }
        }
        return l;
      }
      const $Y = {
        name: "popperOffsets",
        enabled: !0,
        phase: "read",
        fn: function zY(n) {
          var e = n.state;
          e.modifiersData[n.name] = Y1({
            reference: e.rects.reference,
            element: e.rects.popper,
            strategy: "absolute",
            placement: e.placement,
          });
        },
        data: {},
      };
      var WY = { top: "auto", right: "auto", bottom: "auto", left: "auto" };
      function Z1(n) {
        var e,
          t = n.popper,
          i = n.popperRect,
          r = n.placement,
          o = n.variation,
          s = n.offsets,
          a = n.position,
          l = n.gpuAcceleration,
          c = n.adaptive,
          u = n.roundOffsets,
          d = n.isFixed,
          h = s.x,
          f = void 0 === h ? 0 : h,
          p = s.y,
          g = void 0 === p ? 0 : p,
          m = "function" == typeof u ? u({ x: f, y: g }) : { x: f, y: g };
        (f = m.x), (g = m.y);
        var v = s.hasOwnProperty("x"),
          _ = s.hasOwnProperty("y"),
          b = Mn,
          y = Sn,
          D = window;
        if (c) {
          var C = Jc(t),
            R = "clientHeight",
            S = "clientWidth";
          C === Ti(t) &&
            "static" !== Rr((C = Io(t))).position &&
            "absolute" === a &&
            ((R = "scrollHeight"), (S = "scrollWidth")),
            (r === Sn || ((r === Mn || r === ri) && o === eu)) &&
              ((y = ii),
              (g -=
                (d && C === D && D.visualViewport
                  ? D.visualViewport.height
                  : C[R]) - i.height),
              (g *= l ? 1 : -1)),
            (r !== Mn && ((r !== Sn && r !== ii) || o !== eu)) ||
              ((b = ri),
              (f -=
                (d && C === D && D.visualViewport
                  ? D.visualViewport.width
                  : C[S]) - i.width),
              (f *= l ? 1 : -1));
        }
        var he,
          se = Object.assign({ position: a }, c && WY),
          ve =
            !0 === u
              ? (function GY(n) {
                  var t = n.y,
                    r = window.devicePixelRatio || 1;
                  return { x: Ga(n.x * r) / r || 0, y: Ga(t * r) / r || 0 };
                })({ x: f, y: g })
              : { x: f, y: g };
        return (
          (f = ve.x),
          (g = ve.y),
          Object.assign(
            {},
            se,
            l
              ? (((he = {})[y] = _ ? "0" : ""),
                (he[b] = v ? "0" : ""),
                (he.transform =
                  (D.devicePixelRatio || 1) <= 1
                    ? "translate(" + f + "px, " + g + "px)"
                    : "translate3d(" + f + "px, " + g + "px, 0)"),
                he)
              : (((e = {})[y] = _ ? g + "px" : ""),
                (e[b] = v ? f + "px" : ""),
                (e.transform = ""),
                e)
          )
        );
      }
      const KY = {
          name: "computeStyles",
          enabled: !0,
          phase: "beforeWrite",
          fn: function qY(n) {
            var e = n.state,
              t = n.options,
              i = t.gpuAcceleration,
              r = void 0 === i || i,
              o = t.adaptive,
              s = void 0 === o || o,
              a = t.roundOffsets,
              l = void 0 === a || a,
              u = {
                placement: cr(e.placement),
                variation: Ya(e.placement),
                popper: e.elements.popper,
                popperRect: e.rects.popper,
                gpuAcceleration: r,
                isFixed: "fixed" === e.options.strategy,
              };
            null != e.modifiersData.popperOffsets &&
              (e.styles.popper = Object.assign(
                {},
                e.styles.popper,
                Z1(
                  Object.assign({}, u, {
                    offsets: e.modifiersData.popperOffsets,
                    position: e.options.strategy,
                    adaptive: s,
                    roundOffsets: l,
                  })
                )
              )),
              null != e.modifiersData.arrow &&
                (e.styles.arrow = Object.assign(
                  {},
                  e.styles.arrow,
                  Z1(
                    Object.assign({}, u, {
                      offsets: e.modifiersData.arrow,
                      position: "absolute",
                      adaptive: !1,
                      roundOffsets: l,
                    })
                  )
                )),
              (e.attributes.popper = Object.assign({}, e.attributes.popper, {
                "data-popper-placement": e.placement,
              }));
          },
          data: {},
        },
        Q1 = {
          name: "applyStyles",
          enabled: !0,
          phase: "write",
          fn: function YY(n) {
            var e = n.state;
            Object.keys(e.elements).forEach(function (t) {
              var i = e.styles[t] || {},
                r = e.attributes[t] || {},
                o = e.elements[t];
              !ni(o) ||
                !lr(o) ||
                (Object.assign(o.style, i),
                Object.keys(r).forEach(function (s) {
                  var a = r[s];
                  !1 === a
                    ? o.removeAttribute(s)
                    : o.setAttribute(s, !0 === a ? "" : a);
                }));
            });
          },
          effect: function ZY(n) {
            var e = n.state,
              t = {
                popper: {
                  position: e.options.strategy,
                  left: "0",
                  top: "0",
                  margin: "0",
                },
                arrow: { position: "absolute" },
                reference: {},
              };
            return (
              Object.assign(e.elements.popper.style, t.popper),
              (e.styles = t),
              e.elements.arrow &&
                Object.assign(e.elements.arrow.style, t.arrow),
              function () {
                Object.keys(e.elements).forEach(function (i) {
                  var r = e.elements[i],
                    o = e.attributes[i] || {},
                    a = Object.keys(
                      e.styles.hasOwnProperty(i) ? e.styles[i] : t[i]
                    ).reduce(function (l, c) {
                      return (l[c] = ""), l;
                    }, {});
                  !ni(r) ||
                    !lr(r) ||
                    (Object.assign(r.style, a),
                    Object.keys(o).forEach(function (l) {
                      r.removeAttribute(l);
                    }));
                });
              }
            );
          },
          requires: ["computeStyles"],
        },
        XY = {
          name: "offset",
          enabled: !0,
          phase: "main",
          requires: ["popperOffsets"],
          fn: function JY(n) {
            var e = n.state,
              i = n.name,
              r = n.options.offset,
              o = void 0 === r ? [0, 0] : r,
              s = G1.reduce(function (u, d) {
                return (
                  (u[d] = (function QY(n, e, t) {
                    var i = cr(n),
                      r = [Mn, Sn].indexOf(i) >= 0 ? -1 : 1,
                      o =
                        "function" == typeof t
                          ? t(Object.assign({}, e, { placement: n }))
                          : t,
                      s = o[0],
                      a = o[1];
                    return (
                      (s = s || 0),
                      (a = (a || 0) * r),
                      [Mn, ri].indexOf(i) >= 0 ? { x: a, y: s } : { x: s, y: a }
                    );
                  })(d, e.rects, o)),
                  u
                );
              }, {}),
              a = s[e.placement],
              c = a.y;
            null != e.modifiersData.popperOffsets &&
              ((e.modifiersData.popperOffsets.x += a.x),
              (e.modifiersData.popperOffsets.y += c)),
              (e.modifiersData[i] = s);
          },
        };
      var eZ = { left: "right", right: "left", bottom: "top", top: "bottom" };
      function Sf(n) {
        return n.replace(/left|right|bottom|top/g, function (e) {
          return eZ[e];
        });
      }
      var tZ = { start: "end", end: "start" };
      function J1(n) {
        return n.replace(/start|end/g, function (e) {
          return tZ[e];
        });
      }
      function X1(n, e) {
        var t = e.getRootNode && e.getRootNode();
        if (n.contains(e)) return !0;
        if (t && Y_(t)) {
          var i = e;
          do {
            if (i && n.isSameNode(i)) return !0;
            i = i.parentNode || i.host;
          } while (i);
        }
        return !1;
      }
      function nb(n) {
        return Object.assign({}, n, {
          left: n.x,
          top: n.y,
          right: n.x + n.width,
          bottom: n.y + n.height,
        });
      }
      function ek(n, e) {
        return e === $1
          ? nb(
              (function nZ(n) {
                var e = Ti(n),
                  t = Io(n),
                  i = e.visualViewport,
                  r = t.clientWidth,
                  o = t.clientHeight,
                  s = 0,
                  a = 0;
                return (
                  i &&
                    ((r = i.width),
                    (o = i.height),
                    /^((?!chrome|android).)*safari/i.test(
                      navigator.userAgent
                    ) || ((s = i.offsetLeft), (a = i.offsetTop))),
                  { width: r, height: o, x: s + Q_(n), y: a }
                );
              })(n)
            )
          : Wa(e)
          ? (function rZ(n) {
              var e = qa(n);
              return (
                (e.top = e.top + n.clientTop),
                (e.left = e.left + n.clientLeft),
                (e.bottom = e.top + n.clientHeight),
                (e.right = e.left + n.clientWidth),
                (e.width = n.clientWidth),
                (e.height = n.clientHeight),
                (e.x = e.left),
                (e.y = e.top),
                e
              );
            })(e)
          : nb(
              (function iZ(n) {
                var e,
                  t = Io(n),
                  i = Z_(n),
                  r = null == (e = n.ownerDocument) ? void 0 : e.body,
                  o = Ds(
                    t.scrollWidth,
                    t.clientWidth,
                    r ? r.scrollWidth : 0,
                    r ? r.clientWidth : 0
                  ),
                  s = Ds(
                    t.scrollHeight,
                    t.clientHeight,
                    r ? r.scrollHeight : 0,
                    r ? r.clientHeight : 0
                  ),
                  a = -i.scrollLeft + Q_(n),
                  l = -i.scrollTop;
                return (
                  "rtl" === Rr(r || t).direction &&
                    (a += Ds(t.clientWidth, r ? r.clientWidth : 0) - o),
                  { width: o, height: s, x: a, y: l }
                );
              })(Io(n))
            );
      }
      function nk(n) {
        return Object.assign({}, { top: 0, right: 0, bottom: 0, left: 0 }, n);
      }
      function ik(n, e) {
        return e.reduce(function (t, i) {
          return (t[i] = n), t;
        }, {});
      }
      function nu(n, e) {
        void 0 === e && (e = {});
        var i = e.placement,
          r = void 0 === i ? n.placement : i,
          o = e.boundary,
          s = void 0 === o ? "clippingParents" : o,
          a = e.rootBoundary,
          l = void 0 === a ? $1 : a,
          c = e.elementContext,
          u = void 0 === c ? tu : c,
          d = e.altBoundary,
          h = void 0 !== d && d,
          f = e.padding,
          p = void 0 === f ? 0 : f,
          g = nk("number" != typeof p ? p : ik(p, Xc)),
          v = n.rects.popper,
          _ = n.elements[h ? (u === tu ? "reference" : tu) : u],
          b = (function sZ(n, e, t) {
            var i =
                "clippingParents" === e
                  ? (function oZ(n) {
                      var e = Qc(Ef(n)),
                        i =
                          ["absolute", "fixed"].indexOf(Rr(n).position) >= 0 &&
                          ni(n)
                            ? Jc(n)
                            : n;
                      return Wa(i)
                        ? e.filter(function (r) {
                            return Wa(r) && X1(r, i) && "body" !== lr(r);
                          })
                        : [];
                    })(n)
                  : [].concat(e),
              r = [].concat(i, [t]),
              s = r.reduce(function (a, l) {
                var c = ek(n, l);
                return (
                  (a.top = Ds(c.top, a.top)),
                  (a.right = Cf(c.right, a.right)),
                  (a.bottom = Cf(c.bottom, a.bottom)),
                  (a.left = Ds(c.left, a.left)),
                  a
                );
              }, ek(n, r[0]));
            return (
              (s.width = s.right - s.left),
              (s.height = s.bottom - s.top),
              (s.x = s.left),
              (s.y = s.top),
              s
            );
          })(Wa(_) ? _ : _.contextElement || Io(n.elements.popper), s, l),
          y = qa(n.elements.reference),
          D = Y1({
            reference: y,
            element: v,
            strategy: "absolute",
            placement: r,
          }),
          C = nb(Object.assign({}, v, D)),
          R = u === tu ? C : y,
          S = {
            top: b.top - R.top + g.top,
            bottom: R.bottom - b.bottom + g.bottom,
            left: b.left - R.left + g.left,
            right: R.right - b.right + g.right,
          },
          $ = n.modifiersData.offset;
        if (u === tu && $) {
          var X = $[r];
          Object.keys(S).forEach(function (se) {
            var ve = [ri, ii].indexOf(se) >= 0 ? 1 : -1,
              he = [Sn, ii].indexOf(se) >= 0 ? "y" : "x";
            S[se] += X[he] * ve;
          });
        }
        return S;
      }
      const uZ = {
        name: "flip",
        enabled: !0,
        phase: "main",
        fn: function cZ(n) {
          var e = n.state,
            t = n.options,
            i = n.name;
          if (!e.modifiersData[i]._skip) {
            for (
              var r = t.mainAxis,
                o = void 0 === r || r,
                s = t.altAxis,
                a = void 0 === s || s,
                l = t.fallbackPlacements,
                c = t.padding,
                u = t.boundary,
                d = t.rootBoundary,
                h = t.altBoundary,
                f = t.flipVariations,
                p = void 0 === f || f,
                g = t.allowedAutoPlacements,
                m = e.options.placement,
                v = cr(m),
                b =
                  l ||
                  (v !== m && p
                    ? (function lZ(n) {
                        if (cr(n) === eb) return [];
                        var e = Sf(n);
                        return [J1(n), e, J1(e)];
                      })(m)
                    : [Sf(m)]),
                y = [m].concat(b).reduce(function (Lr, Oi) {
                  return Lr.concat(
                    cr(Oi) === eb
                      ? (function aZ(n, e) {
                          void 0 === e && (e = {});
                          var r = e.boundary,
                            o = e.rootBoundary,
                            s = e.padding,
                            a = e.flipVariations,
                            l = e.allowedAutoPlacements,
                            c = void 0 === l ? G1 : l,
                            u = Ya(e.placement),
                            d = u
                              ? a
                                ? W1
                                : W1.filter(function (p) {
                                    return Ya(p) === u;
                                  })
                              : Xc,
                            h = d.filter(function (p) {
                              return c.indexOf(p) >= 0;
                            });
                          0 === h.length && (h = d);
                          var f = h.reduce(function (p, g) {
                            return (
                              (p[g] = nu(n, {
                                placement: g,
                                boundary: r,
                                rootBoundary: o,
                                padding: s,
                              })[cr(g)]),
                              p
                            );
                          }, {});
                          return Object.keys(f).sort(function (p, g) {
                            return f[p] - f[g];
                          });
                        })(e, {
                          placement: Oi,
                          boundary: u,
                          rootBoundary: d,
                          padding: c,
                          flipVariations: p,
                          allowedAutoPlacements: g,
                        })
                      : Oi
                  );
                }, []),
                D = e.rects.reference,
                C = e.rects.popper,
                R = new Map(),
                S = !0,
                $ = y[0],
                X = 0;
              X < y.length;
              X++
            ) {
              var se = y[X],
                ve = cr(se),
                he = Ya(se) === Ka,
                Ge = [Sn, ii].indexOf(ve) >= 0,
                qe = Ge ? "width" : "height",
                De = nu(e, {
                  placement: se,
                  boundary: u,
                  rootBoundary: d,
                  altBoundary: h,
                  padding: c,
                }),
                Je = Ge ? (he ? ri : Mn) : he ? ii : Sn;
              D[qe] > C[qe] && (Je = Sf(Je));
              var it = Sf(Je),
                Ce = [];
              if (
                (o && Ce.push(De[ve] <= 0),
                a && Ce.push(De[Je] <= 0, De[it] <= 0),
                Ce.every(function (Lr) {
                  return Lr;
                }))
              ) {
                ($ = se), (S = !1);
                break;
              }
              R.set(se, Ce);
            }
            if (S)
              for (
                var Tt = function (Oi) {
                    var Vr = y.find(function (il) {
                      var Br = R.get(il);
                      if (Br)
                        return Br.slice(0, Oi).every(function (rl) {
                          return rl;
                        });
                    });
                    if (Vr) return ($ = Vr), "break";
                  },
                  ai = p ? 3 : 1;
                ai > 0 && "break" !== Tt(ai);
                ai--
              );
            e.placement !== $ &&
              ((e.modifiersData[i]._skip = !0),
              (e.placement = $),
              (e.reset = !0));
          }
        },
        requiresIfExists: ["offset"],
        data: { _skip: !1 },
      };
      function iu(n, e, t) {
        return Ds(n, Cf(e, t));
      }
      const pZ = {
          name: "preventOverflow",
          enabled: !0,
          phase: "main",
          fn: function fZ(n) {
            var e = n.state,
              t = n.options,
              i = n.name,
              r = t.mainAxis,
              o = void 0 === r || r,
              s = t.altAxis,
              a = void 0 !== s && s,
              h = t.tether,
              f = void 0 === h || h,
              p = t.tetherOffset,
              g = void 0 === p ? 0 : p,
              m = nu(e, {
                boundary: t.boundary,
                rootBoundary: t.rootBoundary,
                padding: t.padding,
                altBoundary: t.altBoundary,
              }),
              v = cr(e.placement),
              _ = Ya(e.placement),
              b = !_,
              y = tb(v),
              D = (function dZ(n) {
                return "x" === n ? "y" : "x";
              })(y),
              C = e.modifiersData.popperOffsets,
              R = e.rects.reference,
              S = e.rects.popper,
              $ =
                "function" == typeof g
                  ? g(Object.assign({}, e.rects, { placement: e.placement }))
                  : g,
              X =
                "number" == typeof $
                  ? { mainAxis: $, altAxis: $ }
                  : Object.assign({ mainAxis: 0, altAxis: 0 }, $),
              se = e.modifiersData.offset
                ? e.modifiersData.offset[e.placement]
                : null,
              ve = { x: 0, y: 0 };
            if (C) {
              if (o) {
                var he,
                  Ge = "y" === y ? Sn : Mn,
                  qe = "y" === y ? ii : ri,
                  De = "y" === y ? "height" : "width",
                  Je = C[y],
                  it = Je + m[Ge],
                  Ce = Je - m[qe],
                  Ae = f ? -S[De] / 2 : 0,
                  Tt = _ === Ka ? R[De] : S[De],
                  ai = _ === Ka ? -S[De] : -R[De],
                  Ai = e.elements.arrow,
                  Lr = f && Ai ? X_(Ai) : { width: 0, height: 0 },
                  Oi = e.modifiersData["arrow#persistent"]
                    ? e.modifiersData["arrow#persistent"].padding
                    : { top: 0, right: 0, bottom: 0, left: 0 },
                  Vr = Oi[Ge],
                  il = Oi[qe],
                  Br = iu(0, R[De], Lr[De]),
                  rl = b
                    ? R[De] / 2 - Ae - Br - Vr - X.mainAxis
                    : Tt - Br - Vr - X.mainAxis,
                  No = b
                    ? -R[De] / 2 + Ae + Br + il + X.mainAxis
                    : ai + Br + il + X.mainAxis,
                  ol = e.elements.arrow && Jc(e.elements.arrow),
                  gu = null != (he = se?.[y]) ? he : 0,
                  tp = Je + No - gu,
                  mu = iu(
                    f
                      ? Cf(
                          it,
                          Je +
                            rl -
                            gu -
                            (ol
                              ? "y" === y
                                ? ol.clientTop || 0
                                : ol.clientLeft || 0
                              : 0)
                        )
                      : it,
                    Je,
                    f ? Ds(Ce, tp) : Ce
                  );
                (C[y] = mu), (ve[y] = mu - Je);
              }
              if (a) {
                var yu,
                  jr = C[D],
                  Ro = "y" === D ? "height" : "width",
                  vu = jr + m["x" === y ? Sn : Mn],
                  Is = jr - m["x" === y ? ii : ri],
                  _u = -1 !== [Sn, Mn].indexOf(v),
                  rp = null != (yu = se?.[D]) ? yu : 0,
                  op = _u ? vu : jr - R[Ro] - S[Ro] - rp + X.altAxis,
                  sp = _u ? jr + R[Ro] + S[Ro] - rp - X.altAxis : Is,
                  ap =
                    f && _u
                      ? (function hZ(n, e, t) {
                          var i = iu(n, e, t);
                          return i > t ? t : i;
                        })(op, jr, sp)
                      : iu(f ? op : vu, jr, f ? sp : Is);
                (C[D] = ap), (ve[D] = ap - jr);
              }
              e.modifiersData[i] = ve;
            }
          },
          requiresIfExists: ["offset"],
        },
        vZ = {
          name: "arrow",
          enabled: !0,
          phase: "main",
          fn: function mZ(n) {
            var e,
              t = n.state,
              i = n.name,
              r = n.options,
              o = t.elements.arrow,
              s = t.modifiersData.popperOffsets,
              a = cr(t.placement),
              l = tb(a),
              u = [Mn, ri].indexOf(a) >= 0 ? "height" : "width";
            if (o && s) {
              var d = (function (e, t) {
                  return nk(
                    "number" !=
                      typeof (e =
                        "function" == typeof e
                          ? e(
                              Object.assign({}, t.rects, {
                                placement: t.placement,
                              })
                            )
                          : e)
                      ? e
                      : ik(e, Xc)
                  );
                })(r.padding, t),
                h = X_(o),
                f = "y" === l ? Sn : Mn,
                p = "y" === l ? ii : ri,
                g =
                  t.rects.reference[u] +
                  t.rects.reference[l] -
                  s[l] -
                  t.rects.popper[u],
                m = s[l] - t.rects.reference[l],
                v = Jc(o),
                _ = v
                  ? "y" === l
                    ? v.clientHeight || 0
                    : v.clientWidth || 0
                  : 0,
                C = _ / 2 - h[u] / 2 + (g / 2 - m / 2),
                R = iu(d[f], C, _ - h[u] - d[p]);
              t.modifiersData[i] =
                (((e = {})[l] = R), (e.centerOffset = R - C), e);
            }
          },
          effect: function yZ(n) {
            var e = n.state,
              i = n.options.element,
              r = void 0 === i ? "[data-popper-arrow]" : i;
            null != r &&
              (("string" == typeof r &&
                !(r = e.elements.popper.querySelector(r))) ||
                !X1(e.elements.popper, r) ||
                (e.elements.arrow = r));
          },
          requires: ["popperOffsets"],
          requiresIfExists: ["preventOverflow"],
        };
      function rk(n, e, t) {
        return (
          void 0 === t && (t = { x: 0, y: 0 }),
          {
            top: n.top - e.height - t.y,
            right: n.right - e.width + t.x,
            bottom: n.bottom - e.height + t.y,
            left: n.left - e.width - t.x,
          }
        );
      }
      function ok(n) {
        return [Sn, ri, ii, Mn].some(function (e) {
          return n[e] >= 0;
        });
      }
      var bZ = [
          UY,
          $Y,
          KY,
          Q1,
          XY,
          uZ,
          pZ,
          vZ,
          {
            name: "hide",
            enabled: !0,
            phase: "main",
            requiresIfExists: ["preventOverflow"],
            fn: function _Z(n) {
              var e = n.state,
                t = n.name,
                i = e.rects.reference,
                r = e.rects.popper,
                o = e.modifiersData.preventOverflow,
                s = nu(e, { elementContext: "reference" }),
                a = nu(e, { altBoundary: !0 }),
                l = rk(s, i),
                c = rk(a, r, o),
                u = ok(l),
                d = ok(c);
              (e.modifiersData[t] = {
                referenceClippingOffsets: l,
                popperEscapeOffsets: c,
                isReferenceHidden: u,
                hasPopperEscaped: d,
              }),
                (e.attributes.popper = Object.assign({}, e.attributes.popper, {
                  "data-popper-reference-hidden": u,
                  "data-popper-escaped": d,
                }));
            },
          },
        ],
        DZ = jY({ defaultModifiers: bZ }),
        sk = "tippy-content",
        lk = "tippy-arrow",
        ck = "tippy-svg-arrow",
        To = { passive: !0, capture: !0 },
        uk = function () {
          return document.body;
        };
      function ib(n, e, t) {
        return Array.isArray(n) ? n[e] ?? (Array.isArray(t) ? t[e] : t) : n;
      }
      function rb(n, e) {
        var t = {}.toString.call(n);
        return 0 === t.indexOf("[object") && t.indexOf(e + "]") > -1;
      }
      function dk(n, e) {
        return "function" == typeof n ? n.apply(void 0, e) : n;
      }
      function hk(n, e) {
        return 0 === e
          ? n
          : function (i) {
              clearTimeout(t),
                (t = setTimeout(function () {
                  n(i);
                }, e));
            };
        var t;
      }
      function xo(n) {
        return [].concat(n);
      }
      function fk(n, e) {
        -1 === n.indexOf(e) && n.push(e);
      }
      function Za(n) {
        return [].slice.call(n);
      }
      function gk(n) {
        return Object.keys(n).reduce(function (e, t) {
          return void 0 !== n[t] && (e[t] = n[t]), e;
        }, {});
      }
      function Cs() {
        return document.createElement("div");
      }
      function Mf(n) {
        return ["Element", "Fragment"].some(function (e) {
          return rb(n, e);
        });
      }
      function ab(n, e) {
        n.forEach(function (t) {
          t && (t.style.transitionDuration = e + "ms");
        });
      }
      function ru(n, e) {
        n.forEach(function (t) {
          t && t.setAttribute("data-state", e);
        });
      }
      function lb(n, e, t) {
        var i = e + "EventListener";
        ["transitionend", "webkitTransitionEnd"].forEach(function (r) {
          n[i](r, t);
        });
      }
      function vk(n, e) {
        for (var t = e; t; ) {
          var i;
          if (n.contains(t)) return !0;
          t =
            null == t.getRootNode || null == (i = t.getRootNode())
              ? void 0
              : i.host;
        }
        return !1;
      }
      var ur = { isTouch: !1 },
        _k = 0;
      function xZ() {
        ur.isTouch ||
          ((ur.isTouch = !0),
          window.performance && document.addEventListener("mousemove", bk));
      }
      function bk() {
        var n = performance.now();
        n - _k < 20 &&
          ((ur.isTouch = !1), document.removeEventListener("mousemove", bk)),
          (_k = n);
      }
      function AZ() {
        var n = document.activeElement;
        (function mk(n) {
          return !(!n || !n._tippy || n._tippy.reference !== n);
        })(n) &&
          n.blur &&
          !n._tippy.state.isVisible &&
          n.blur();
      }
      var NZ =
          !!(typeof window < "u" && typeof document < "u") && !!window.msCrypto,
        In = Object.assign(
          {
            appendTo: uk,
            aria: { content: "auto", expanded: "auto" },
            delay: 0,
            duration: [300, 250],
            getReferenceClientRect: null,
            hideOnClick: !0,
            ignoreAttributes: !1,
            interactive: !1,
            interactiveBorder: 2,
            interactiveDebounce: 0,
            moveTransition: "",
            offset: [0, 10],
            onAfterUpdate: function () {},
            onBeforeUpdate: function () {},
            onCreate: function () {},
            onDestroy: function () {},
            onHidden: function () {},
            onHide: function () {},
            onMount: function () {},
            onShow: function () {},
            onShown: function () {},
            onTrigger: function () {},
            onUntrigger: function () {},
            onClickOutside: function () {},
            placement: "top",
            plugins: [],
            popperOptions: {},
            render: null,
            showOnCreate: !1,
            touch: !0,
            trigger: "mouseenter focus",
            triggerTarget: null,
          },
          {
            animateFill: !1,
            followCursor: !1,
            inlinePositioning: !1,
            sticky: !1,
          },
          {
            allowHTML: !1,
            animation: "fade",
            arrow: !0,
            content: "",
            inertia: !1,
            maxWidth: 350,
            role: "tooltip",
            theme: "",
            zIndex: 9999,
          }
        ),
        LZ = Object.keys(In);
      function Sk(n) {
        var t = (n.plugins || []).reduce(function (i, r) {
          var a,
            o = r.name;
          return (
            o &&
              (i[o] =
                void 0 !== n[o]
                  ? n[o]
                  : null != (a = In[o])
                  ? a
                  : r.defaultValue),
            i
          );
        }, {});
        return Object.assign({}, n, t);
      }
      function Mk(n, e) {
        var t = Object.assign(
          {},
          e,
          { content: dk(e.content, [n]) },
          e.ignoreAttributes
            ? {}
            : (function BZ(n, e) {
                return (
                  e
                    ? Object.keys(Sk(Object.assign({}, In, { plugins: e })))
                    : LZ
                ).reduce(function (r, o) {
                  var s = (n.getAttribute("data-tippy-" + o) || "").trim();
                  if (!s) return r;
                  if ("content" === o) r[o] = s;
                  else
                    try {
                      r[o] = JSON.parse(s);
                    } catch {
                      r[o] = s;
                    }
                  return r;
                }, {});
              })(n, e.plugins)
        );
        return (
          (t.aria = Object.assign({}, In.aria, t.aria)),
          (t.aria = {
            expanded:
              "auto" === t.aria.expanded ? e.interactive : t.aria.expanded,
            content:
              "auto" === t.aria.content
                ? e.interactive
                  ? null
                  : "describedby"
                : t.aria.content,
          }),
          t
        );
      }
      function cb(n, e) {
        n.innerHTML = e;
      }
      function Ik(n) {
        var e = Cs();
        return (
          !0 === n
            ? (e.className = lk)
            : ((e.className = ck), Mf(n) ? e.appendChild(n) : cb(e, n)),
          e
        );
      }
      function Tk(n, e) {
        Mf(e.content)
          ? (cb(n, ""), n.appendChild(e.content))
          : "function" != typeof e.content &&
            (e.allowHTML ? cb(n, e.content) : (n.textContent = e.content));
      }
      function If(n) {
        var e = n.firstElementChild,
          t = Za(e.children);
        return {
          box: e,
          content: t.find(function (i) {
            return i.classList.contains(sk);
          }),
          arrow: t.find(function (i) {
            return i.classList.contains(lk) || i.classList.contains(ck);
          }),
          backdrop: t.find(function (i) {
            return i.classList.contains("tippy-backdrop");
          }),
        };
      }
      function xk(n) {
        var e = Cs(),
          t = Cs();
        (t.className = "tippy-box"),
          t.setAttribute("data-state", "hidden"),
          t.setAttribute("tabindex", "-1");
        var i = Cs();
        function r(o, s) {
          var a = If(e),
            l = a.box,
            c = a.content,
            u = a.arrow;
          s.theme
            ? l.setAttribute("data-theme", s.theme)
            : l.removeAttribute("data-theme"),
            "string" == typeof s.animation
              ? l.setAttribute("data-animation", s.animation)
              : l.removeAttribute("data-animation"),
            s.inertia
              ? l.setAttribute("data-inertia", "")
              : l.removeAttribute("data-inertia"),
            (l.style.maxWidth =
              "number" == typeof s.maxWidth ? s.maxWidth + "px" : s.maxWidth),
            s.role ? l.setAttribute("role", s.role) : l.removeAttribute("role"),
            (o.content !== s.content || o.allowHTML !== s.allowHTML) &&
              Tk(c, n.props),
            s.arrow
              ? u
                ? o.arrow !== s.arrow &&
                  (l.removeChild(u), l.appendChild(Ik(s.arrow)))
                : l.appendChild(Ik(s.arrow))
              : u && l.removeChild(u);
        }
        return (
          (i.className = sk),
          i.setAttribute("data-state", "hidden"),
          Tk(i, n.props),
          e.appendChild(t),
          t.appendChild(i),
          r(n.props, n.props),
          { popper: e, onUpdate: r }
        );
      }
      xk.$$tippy = !0;
      var HZ = 1,
        Tf = [],
        xf = [];
      function UZ(n, e) {
        var i,
          r,
          o,
          u,
          d,
          h,
          g,
          t = Mk(n, Object.assign({}, In, Sk(gk(e)))),
          s = !1,
          a = !1,
          l = !1,
          c = !1,
          f = [],
          p = hk(ep, t.interactiveDebounce),
          m = HZ++,
          _ = (function SZ(n) {
            return n.filter(function (e, t) {
              return n.indexOf(e) === t;
            });
          })(t.plugins),
          y = {
            id: m,
            reference: n,
            popper: Cs(),
            popperInstance: null,
            props: t,
            state: {
              isEnabled: !0,
              isVisible: !1,
              isDestroyed: !1,
              isMounted: !1,
              isShown: !1,
            },
            plugins: _,
            clearDelayTimeouts: function op() {
              clearTimeout(i), clearTimeout(r), cancelAnimationFrame(o);
            },
            setProps: function sp(E) {
              if (!y.state.isDestroyed) {
                it("onBeforeUpdate", [y, E]), Xf();
                var B = y.props,
                  ee = Mk(
                    n,
                    Object.assign({}, B, gk(E), { ignoreAttributes: !0 })
                  );
                (y.props = ee),
                  ol(),
                  B.interactiveDebounce !== ee.interactiveDebounce &&
                    (Tt(), (p = hk(ep, ee.interactiveDebounce))),
                  B.triggerTarget && !ee.triggerTarget
                    ? xo(B.triggerTarget).forEach(function (ke) {
                        ke.removeAttribute("aria-expanded");
                      })
                    : ee.triggerTarget && n.removeAttribute("aria-expanded"),
                  Ae(),
                  Je(),
                  R && R(B, ee),
                  y.popperInstance &&
                    (np(),
                    Ro().forEach(function (ke) {
                      requestAnimationFrame(
                        ke._tippy.popperInstance.forceUpdate
                      );
                    })),
                  it("onAfterUpdate", [y, E]);
              }
            },
            setContent: function ap(E) {
              y.setProps({ content: E });
            },
            show: function UJ() {
              var E = y.state.isVisible,
                B = y.state.isDestroyed,
                ee = !y.state.isEnabled,
                ke = ur.isTouch && !y.props.touch,
                Ee = ib(y.props.duration, 0, In.duration);
              if (
                !(
                  E ||
                  B ||
                  ee ||
                  ke ||
                  he().hasAttribute("disabled") ||
                  (it("onShow", [y], !1), !1 === y.props.onShow(y))
                )
              ) {
                if (
                  ((y.state.isVisible = !0),
                  ve() && (C.style.visibility = "visible"),
                  Je(),
                  Oi(),
                  y.state.isMounted || (C.style.transition = "none"),
                  ve())
                ) {
                  var mn = qe();
                  ab([mn.box, mn.content], 0);
                }
                (h = function () {
                  var Ts;
                  if (y.state.isVisible && !c) {
                    if (
                      ((c = !0),
                      (C.style.transition = y.props.moveTransition),
                      ve() && y.props.animation)
                    ) {
                      var Ib = qe(),
                        lp = Ib.box,
                        al = Ib.content;
                      ab([lp, al], Ee), ru([lp, al], "visible");
                    }
                    Ce(),
                      Ae(),
                      fk(xf, y),
                      null == (Ts = y.popperInstance) || Ts.forceUpdate(),
                      it("onMount", [y]),
                      y.props.animation &&
                        ve() &&
                        (function Br(E, B) {
                          rl(E, B);
                        })(Ee, function () {
                          (y.state.isShown = !0), it("onShown", [y]);
                        });
                  }
                }),
                  (function jr() {
                    var B,
                      E = y.props.appendTo,
                      ee = he();
                    (B =
                      (y.props.interactive && E === uk) || "parent" === E
                        ? ee.parentNode
                        : dk(E, [ee])).contains(C) || B.appendChild(C),
                      (y.state.isMounted = !0),
                      np();
                  })();
              }
            },
            hide: function zJ() {
              var E = !y.state.isVisible,
                B = y.state.isDestroyed,
                ee = !y.state.isEnabled,
                ke = ib(y.props.duration, 1, In.duration);
              if (
                !(E || B || ee) &&
                (it("onHide", [y], !1), !1 !== y.props.onHide(y))
              ) {
                if (
                  ((y.state.isVisible = !1),
                  (y.state.isShown = !1),
                  (c = !1),
                  (s = !1),
                  ve() && (C.style.visibility = "hidden"),
                  Tt(),
                  Vr(),
                  Je(!0),
                  ve())
                ) {
                  var Ee = qe(),
                    mn = Ee.box,
                    li = Ee.content;
                  y.props.animation &&
                    (ab([mn, li], ke), ru([mn, li], "hidden"));
                }
                Ce(),
                  Ae(),
                  y.props.animation
                    ? ve() &&
                      (function il(E, B) {
                        rl(E, function () {
                          !y.state.isVisible &&
                            C.parentNode &&
                            C.parentNode.contains(C) &&
                            B();
                        });
                      })(ke, y.unmount)
                    : y.unmount();
              }
            },
            hideWithInteractivity: function $J(E) {
              Ge().addEventListener("mousemove", p), fk(Tf, p), p(E);
            },
            enable: function _u() {
              y.state.isEnabled = !0;
            },
            disable: function rp() {
              y.hide(), (y.state.isEnabled = !1);
            },
            unmount: function WJ() {
              y.state.isVisible && y.hide(),
                y.state.isMounted &&
                  (ip(),
                  Ro().forEach(function (E) {
                    E._tippy.unmount();
                  }),
                  C.parentNode && C.parentNode.removeChild(C),
                  (xf = xf.filter(function (E) {
                    return E !== y;
                  })),
                  (y.state.isMounted = !1),
                  it("onHidden", [y]));
            },
            destroy: function GJ() {
              y.state.isDestroyed ||
                (y.clearDelayTimeouts(),
                y.unmount(),
                Xf(),
                delete n._tippy,
                (y.state.isDestroyed = !0),
                it("onDestroy", [y]));
            },
          };
        if (!t.render) return y;
        var D = t.render(y),
          C = D.popper,
          R = D.onUpdate;
        C.setAttribute("data-tippy-root", ""),
          (C.id = "tippy-" + y.id),
          (y.popper = C),
          (n._tippy = y),
          (C._tippy = y);
        var S = _.map(function (E) {
            return E.fn(y);
          }),
          $ = n.hasAttribute("aria-expanded");
        return (
          ol(),
          Ae(),
          Je(),
          it("onCreate", [y]),
          t.showOnCreate && vu(),
          C.addEventListener("mouseenter", function () {
            y.props.interactive && y.state.isVisible && y.clearDelayTimeouts();
          }),
          C.addEventListener("mouseleave", function () {
            y.props.interactive &&
              y.props.trigger.indexOf("mouseenter") >= 0 &&
              Ge().addEventListener("mousemove", p);
          }),
          y
        );
        function X() {
          var E = y.props.touch;
          return Array.isArray(E) ? E : [E, 0];
        }
        function se() {
          return "hold" === X()[0];
        }
        function ve() {
          var E;
          return !(null == (E = y.props.render) || !E.$$tippy);
        }
        function he() {
          return g || n;
        }
        function Ge() {
          var E = he().parentNode;
          return E
            ? (function yk(n) {
                var e,
                  i = xo(n)[0];
                return null != i && null != (e = i.ownerDocument) && e.body
                  ? i.ownerDocument
                  : document;
              })(E)
            : document;
        }
        function qe() {
          return If(C);
        }
        function De(E) {
          return (y.state.isMounted && !y.state.isVisible) ||
            ur.isTouch ||
            (u && "focus" === u.type)
            ? 0
            : ib(y.props.delay, E ? 0 : 1, In.delay);
        }
        function Je(E) {
          void 0 === E && (E = !1),
            (C.style.pointerEvents = y.props.interactive && !E ? "" : "none"),
            (C.style.zIndex = "" + y.props.zIndex);
        }
        function it(E, B, ee) {
          var ke;
          void 0 === ee && (ee = !0),
            S.forEach(function (Ee) {
              Ee[E] && Ee[E].apply(Ee, B);
            }),
            ee && (ke = y.props)[E].apply(ke, B);
        }
        function Ce() {
          var E = y.props.aria;
          if (E.content) {
            var B = "aria-" + E.content,
              ee = C.id;
            xo(y.props.triggerTarget || n).forEach(function (Ee) {
              var mn = Ee.getAttribute(B);
              if (y.state.isVisible)
                Ee.setAttribute(B, mn ? mn + " " + ee : ee);
              else {
                var li = mn && mn.replace(ee, "").trim();
                li ? Ee.setAttribute(B, li) : Ee.removeAttribute(B);
              }
            });
          }
        }
        function Ae() {
          !$ &&
            y.props.aria.expanded &&
            xo(y.props.triggerTarget || n).forEach(function (B) {
              y.props.interactive
                ? B.setAttribute(
                    "aria-expanded",
                    y.state.isVisible && B === he() ? "true" : "false"
                  )
                : B.removeAttribute("aria-expanded");
            });
        }
        function Tt() {
          Ge().removeEventListener("mousemove", p),
            (Tf = Tf.filter(function (E) {
              return E !== p;
            }));
        }
        function ai(E) {
          if (!ur.isTouch || (!l && "mousedown" !== E.type)) {
            var B = (E.composedPath && E.composedPath()[0]) || E.target;
            if (!y.props.interactive || !vk(C, B)) {
              if (
                xo(y.props.triggerTarget || n).some(function (ee) {
                  return vk(ee, B);
                })
              ) {
                if (
                  ur.isTouch ||
                  (y.state.isVisible && y.props.trigger.indexOf("click") >= 0)
                )
                  return;
              } else it("onClickOutside", [y, E]);
              !0 === y.props.hideOnClick &&
                (y.clearDelayTimeouts(),
                y.hide(),
                (a = !0),
                setTimeout(function () {
                  a = !1;
                }),
                y.state.isMounted || Vr());
            }
          }
        }
        function Ai() {
          l = !0;
        }
        function Lr() {
          l = !1;
        }
        function Oi() {
          var E = Ge();
          E.addEventListener("mousedown", ai, !0),
            E.addEventListener("touchend", ai, To),
            E.addEventListener("touchstart", Lr, To),
            E.addEventListener("touchmove", Ai, To);
        }
        function Vr() {
          var E = Ge();
          E.removeEventListener("mousedown", ai, !0),
            E.removeEventListener("touchend", ai, To),
            E.removeEventListener("touchstart", Lr, To),
            E.removeEventListener("touchmove", Ai, To);
        }
        function rl(E, B) {
          var ee = qe().box;
          function ke(Ee) {
            Ee.target === ee && (lb(ee, "remove", ke), B());
          }
          if (0 === E) return B();
          lb(ee, "remove", d), lb(ee, "add", ke), (d = ke);
        }
        function No(E, B, ee) {
          void 0 === ee && (ee = !1),
            xo(y.props.triggerTarget || n).forEach(function (Ee) {
              Ee.addEventListener(E, B, ee),
                f.push({ node: Ee, eventType: E, handler: B, options: ee });
            });
        }
        function ol() {
          se() &&
            (No("touchstart", gu, { passive: !0 }),
            No("touchend", tp, { passive: !0 })),
            (function wZ(n) {
              return n.split(/\s+/).filter(Boolean);
            })(y.props.trigger).forEach(function (E) {
              if ("manual" !== E)
                switch ((No(E, gu), E)) {
                  case "mouseenter":
                    No("mouseleave", tp);
                    break;
                  case "focus":
                    No(NZ ? "focusout" : "blur", mu);
                    break;
                  case "focusin":
                    No("focusout", mu);
                }
            });
        }
        function Xf() {
          f.forEach(function (E) {
            E.node.removeEventListener(E.eventType, E.handler, E.options);
          }),
            (f = []);
        }
        function gu(E) {
          var B,
            ee = !1;
          if (y.state.isEnabled && !yu(E) && !a) {
            var ke = "focus" === (null == (B = u) ? void 0 : B.type);
            (u = E),
              (g = E.currentTarget),
              Ae(),
              !y.state.isVisible &&
                (function sb(n) {
                  return rb(n, "MouseEvent");
                })(E) &&
                Tf.forEach(function (Ee) {
                  return Ee(E);
                }),
              "click" === E.type &&
              (y.props.trigger.indexOf("mouseenter") < 0 || s) &&
              !1 !== y.props.hideOnClick &&
              y.state.isVisible
                ? (ee = !0)
                : vu(E),
              "click" === E.type && (s = !ee),
              ee && !ke && Is(E);
          }
        }
        function ep(E) {
          var B = E.target,
            ee = he().contains(B) || C.contains(B);
          ("mousemove" === E.type && ee) ||
            ((function TZ(n, e) {
              var t = e.clientX,
                i = e.clientY;
              return n.every(function (r) {
                var o = r.popperRect,
                  s = r.popperState,
                  l = r.props.interactiveBorder,
                  c = (function pk(n) {
                    return n.split("-")[0];
                  })(s.placement),
                  u = s.modifiersData.offset;
                return (
                  !u ||
                  o.top - i + ("bottom" === c ? u.top.y : 0) > l ||
                  i - o.bottom - ("top" === c ? u.bottom.y : 0) > l ||
                  o.left - t + ("right" === c ? u.left.x : 0) > l ||
                  t - o.right - ("left" === c ? u.right.x : 0) > l
                );
              });
            })(
              Ro()
                .concat(C)
                .map(function (Ee) {
                  var mn,
                    sl =
                      null == (mn = Ee._tippy.popperInstance)
                        ? void 0
                        : mn.state;
                  return sl
                    ? {
                        popperRect: Ee.getBoundingClientRect(),
                        popperState: sl,
                        props: t,
                      }
                    : null;
                })
                .filter(Boolean),
              E
            ) &&
              (Tt(), Is(E)));
        }
        function tp(E) {
          if (!(yu(E) || (y.props.trigger.indexOf("click") >= 0 && s))) {
            if (y.props.interactive) return void y.hideWithInteractivity(E);
            Is(E);
          }
        }
        function mu(E) {
          (y.props.trigger.indexOf("focusin") < 0 && E.target !== he()) ||
            (y.props.interactive &&
              E.relatedTarget &&
              C.contains(E.relatedTarget)) ||
            Is(E);
        }
        function yu(E) {
          return !!ur.isTouch && se() !== E.type.indexOf("touch") >= 0;
        }
        function np() {
          ip();
          var E = y.props,
            B = E.popperOptions,
            ee = E.placement,
            ke = E.offset,
            Ee = E.getReferenceClientRect,
            mn = E.moveTransition,
            li = ve() ? If(C).arrow : null,
            sl = Ee
              ? {
                  getBoundingClientRect: Ee,
                  contextElement: Ee.contextElement || he(),
                }
              : n,
            Ts = [
              { name: "offset", options: { offset: ke } },
              {
                name: "preventOverflow",
                options: { padding: { top: 2, bottom: 2, left: 5, right: 5 } },
              },
              { name: "flip", options: { padding: 5 } },
              { name: "computeStyles", options: { adaptive: !mn } },
              {
                name: "$$tippy",
                enabled: !0,
                phase: "beforeWrite",
                requires: ["computeStyles"],
                fn: function (lp) {
                  var al = lp.state;
                  if (ve()) {
                    var Tb = qe().box;
                    ["placement", "reference-hidden", "escaped"].forEach(
                      function (cp) {
                        "placement" === cp
                          ? Tb.setAttribute("data-placement", al.placement)
                          : al.attributes.popper["data-popper-" + cp]
                          ? Tb.setAttribute("data-" + cp, "")
                          : Tb.removeAttribute("data-" + cp);
                      }
                    ),
                      (al.attributes.popper = {});
                  }
                },
              },
            ];
          ve() &&
            li &&
            Ts.push({ name: "arrow", options: { element: li, padding: 3 } }),
            Ts.push.apply(Ts, B?.modifiers || []),
            (y.popperInstance = DZ(
              sl,
              C,
              Object.assign({}, B, {
                placement: ee,
                onFirstUpdate: h,
                modifiers: Ts,
              })
            ));
        }
        function ip() {
          y.popperInstance &&
            (y.popperInstance.destroy(), (y.popperInstance = null));
        }
        function Ro() {
          return Za(C.querySelectorAll("[data-tippy-root]"));
        }
        function vu(E) {
          y.clearDelayTimeouts(), E && it("onTrigger", [y, E]), Oi();
          var B = De(!0),
            ee = X(),
            Ee = ee[1];
          ur.isTouch && "hold" === ee[0] && Ee && (B = Ee),
            B
              ? (i = setTimeout(function () {
                  y.show();
                }, B))
              : y.show();
        }
        function Is(E) {
          if (
            (y.clearDelayTimeouts(),
            it("onUntrigger", [y, E]),
            y.state.isVisible)
          ) {
            if (
              !(
                y.props.trigger.indexOf("mouseenter") >= 0 &&
                y.props.trigger.indexOf("click") >= 0 &&
                ["mouseleave", "mousemove"].indexOf(E.type) >= 0 &&
                s
              )
            ) {
              var B = De(!1);
              B
                ? (r = setTimeout(function () {
                    y.state.isVisible && y.hide();
                  }, B))
                : (o = requestAnimationFrame(function () {
                    y.hide();
                  }));
            }
          } else Vr();
        }
      }
      function Ao(n, e) {
        void 0 === e && (e = {});
        var t = In.plugins.concat(e.plugins || []);
        !(function OZ() {
          document.addEventListener("touchstart", xZ, To),
            window.addEventListener("blur", AZ);
        })();
        var i = Object.assign({}, e, { plugins: t }),
          a = (function IZ(n) {
            return Mf(n)
              ? [n]
              : (function MZ(n) {
                  return rb(n, "NodeList");
                })(n)
              ? Za(n)
              : Array.isArray(n)
              ? n
              : Za(document.querySelectorAll(n));
          })(n).reduce(function (l, c) {
            var u = c && UZ(c, i);
            return u && l.push(u), l;
          }, []);
        return Mf(n) ? a[0] : a;
      }
      (Ao.defaultProps = In),
        (Ao.setDefaultProps = function (e) {
          Object.keys(e).forEach(function (i) {
            In[i] = e[i];
          });
        }),
        (Ao.currentInput = ur),
        Object.assign({}, Q1, {
          effect: function (e) {
            var t = e.state,
              i = {
                popper: {
                  position: t.options.strategy,
                  left: "0",
                  top: "0",
                  margin: "0",
                },
                arrow: { position: "absolute" },
                reference: {},
              };
            Object.assign(t.elements.popper.style, i.popper),
              (t.styles = i),
              t.elements.arrow &&
                Object.assign(t.elements.arrow.style, i.arrow);
          },
        }),
        Ao.setDefaultProps({ render: xk });
      const su = Ao,
        db = "menuFloating";
      class ZZ {
        constructor({
          editor: e,
          element: t,
          view: i,
          tippyOptions: r,
          render: o,
          command: s,
          key: a,
        }) {
          (this.invalidNodes = ["codeBlock", "blockquote"]),
            (this.mousedownHandler = (l) => {
              l.preventDefault(), this.editor.chain().insertContent("/").run();
            }),
            (this.editor = e),
            (this.element = t),
            (this.view = i),
            this.element.addEventListener("mousedown", this.mousedownHandler, {
              capture: !0,
            }),
            this.editor.on("focus", () => {
              this.tippy.unmount(), this.update(this.editor.view);
            }),
            (this.element.style.visibility = "visible"),
            (this.render = o),
            (this.command = s),
            (this.key = a),
            this.createTooltip(r);
        }
        createTooltip(e = {}) {
          this.tippy = su(this.view.dom, {
            duration: 0,
            getReferenceClientRect: null,
            content: this.element,
            interactive: !0,
            trigger: "manual",
            placement: "left",
            hideOnClick: "toggle",
            ...e,
          });
        }
        update(e, t) {
          const { selection: i } = e.state,
            { $anchor: r, empty: o, from: s, to: a } = i,
            u =
              1 === r.depth &&
              !i.$anchor.parent.isLeaf &&
              !i.$anchor.parent.textContent,
            d = r.parent.type.name,
            h = this.key?.getState(e.state),
            f = t ? this.key?.getState(t) : null;
          if (f?.open || (o && u))
            if (f?.open || !this.invalidNodes.includes(d))
              if (
                (this.tippy.setProps({
                  getReferenceClientRect: () => Fc(e, s, a),
                }),
                this.show(),
                h.open)
              ) {
                const { from: p, to: g } = this.editor.state.selection,
                  m = Fc(this.view, p, g);
                this.render().onStart({
                  clientRect: () => m,
                  range: { from: p, to: g },
                  editor: this.editor,
                  command: this.command,
                });
              } else f && f.open && this.render().onExit(null);
            else this.hide();
          else this.hide();
        }
        show() {
          this.tippy.show();
        }
        hide() {
          this.tippy.hide();
        }
        destroy() {
          this.tippy.destroy(),
            this.element.removeEventListener(
              "mousedown",
              this.mousedownHandler
            );
        }
      }
      const kk = new It(db),
        QZ = (n) =>
          new Qe({
            key: kk,
            view: (e) => new ZZ({ key: kk, view: e, ...n }),
            state: {
              init: () => ({ open: !1 }),
              apply(e) {
                const t = e.getMeta(db);
                return t?.open ? { open: t?.open } : { open: !1 };
              },
            },
            props: {
              handleKeyDown(e, t) {
                const { open: i, range: r } = this.getState(e.state);
                return (
                  !!i && n.render().onKeyDown({ event: t, range: r, view: e })
                );
              },
            },
          });
      let JZ = (() => {
        class n {}
        return (
          (n.ɵfac = function (t) {
            return new (t || n)();
          }),
          (n.ɵcmp = ht({
            type: n,
            selectors: [["dotcms-action-button"]],
            decls: 3,
            vars: 0,
            consts: [[1, "material-icons"]],
            template: function (t, i) {
              1 & t && (H(0, "button")(1, "i", 0), ze(2, "add"), z()());
            },
            styles: [
              "[_nghost-%COMP%]{display:block}button[_ngcontent-%COMP%]{all:unset;cursor:pointer;border:solid 1px #eee;width:32px;height:32px;display:flex;align-items:center;justify-content:center;color:#666;background:#ffffff}",
            ],
          })),
          n
        );
      })();
      const XZ = [
          "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMiAzMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTYuNjMyODEgMjJWMjEuMDE1Nkw3LjkwNjI1IDIwLjc5NjlWMTEuODM1OUw2LjYzMjgxIDExLjYxNzJWMTAuNjI1SDEwLjcxODhWMTEuNjE3Mkw5LjQ0NTMxIDExLjgzNTlWMTUuNzY1NkgxNC44ODI4VjExLjgzNTlMMTMuNjA5NCAxMS42MTcyVjEwLjYyNUgxNy42OTUzVjExLjYxNzJMMTYuNDIxOSAxMS44MzU5VjIwLjc5NjlMMTcuNjk1MyAyMS4wMTU2VjIySDEzLjYwOTRWMjEuMDE1NkwxNC44ODI4IDIwLjc5NjlWMTYuOTc2Nkg5LjQ0NTMxVjIwLjc5NjlMMTAuNzE4OCAyMS4wMTU2VjIySDYuNjMyODFaTTE5LjI3MzQgMjJWMjEuMDE1NkwyMS4wMzEyIDIwLjc5NjlWMTIuMjczNEwxOS4yNDIyIDEyLjMwNDdWMTEuMzQzOEwyMi41NzAzIDEwLjYyNVYyMC43OTY5TDI0LjMyMDMgMjEuMDE1NlYyMkgxOS4yNzM0WiIgZmlsbD0iIzIyMjIyMiIvPgo8L3N2Zz4K",
          "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMiAzMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTUuNjMyODEgMjJWMjEuMDE1Nkw2LjkwNjI1IDIwLjc5NjlWMTEuODM1OUw1LjYzMjgxIDExLjYxNzJWMTAuNjI1SDkuNzE4NzVWMTEuNjE3Mkw4LjQ0NTMxIDExLjgzNTlWMTUuNzY1NkgxMy44ODI4VjExLjgzNTlMMTIuNjA5NCAxMS42MTcyVjEwLjYyNUgxNi42OTUzVjExLjYxNzJMMTUuNDIxOSAxMS44MzU5VjIwLjc5NjlMMTYuNjk1MyAyMS4wMTU2VjIySDEyLjYwOTRWMjEuMDE1NkwxMy44ODI4IDIwLjc5NjlWMTYuOTc2Nkg4LjQ0NTMxVjIwLjc5NjlMOS43MTg3NSAyMS4wMTU2VjIySDUuNjMyODFaTTE4LjA4NTkgMjJWMjAuOTQ1M0wyMS44MTI1IDE2LjgwNDdDMjIuMjU1MiAxNi4zMDk5IDIyLjYwMTYgMTUuODg4IDIyLjg1MTYgMTUuNTM5MUMyMy4xMDE2IDE1LjE4NDkgMjMuMjc2IDE0Ljg2NDYgMjMuMzc1IDE0LjU3ODFDMjMuNDc0IDE0LjI5MTcgMjMuNTIzNCAxMy45OTQ4IDIzLjUyMzQgMTMuNjg3NUMyMy41MjM0IDEzLjExOTggMjMuMzUxNiAxMi42NDMyIDIzLjAwNzggMTIuMjU3OEMyMi42NjQxIDExLjg2NzIgMjIuMTcxOSAxMS42NzE5IDIxLjUzMTIgMTEuNjcxOUMyMC44NjQ2IDExLjY3MTkgMjAuMzQzOCAxMS44NzI0IDE5Ljk2ODggMTIuMjczNEMxOS41OTkgMTIuNjc0NSAxOS40MTQxIDEzLjI0MjIgMTkuNDE0MSAxMy45NzY2SDE3LjkzNzVMMTcuOTIxOSAxMy45Mjk3QzE3LjkwNjIgMTMuMjczNCAxOC4wNDQzIDEyLjY4NDkgMTguMzM1OSAxMi4xNjQxQzE4LjYyNzYgMTEuNjM4IDE5LjA0OTUgMTEuMjI0IDE5LjYwMTYgMTAuOTIxOUMyMC4xNTg5IDEwLjYxNDYgMjAuODIwMyAxMC40NjA5IDIxLjU4NTkgMTAuNDYwOUMyMi4zMDQ3IDEwLjQ2MDkgMjIuOTIxOSAxMC41OTkgMjMuNDM3NSAxMC44NzVDMjMuOTU4MyAxMS4xNDU4IDI0LjM1OTQgMTEuNTE4MiAyNC42NDA2IDExLjk5MjJDMjQuOTIxOSAxMi40NjYxIDI1LjA2MjUgMTMuMDEwNCAyNS4wNjI1IDEzLjYyNUMyNS4wNjI1IDE0LjI1IDI0Ljg3NzYgMTQuODcyNCAyNC41MDc4IDE1LjQ5MjJDMjQuMTQzMiAxNi4xMTIgMjMuNjI3NiAxNi43ODEyIDIyLjk2MDkgMTcuNUwxOS45Njg4IDIwLjc1NzhMMTkuOTg0NCAyMC43OTY5SDI0LjAyMzRMMjQuMTQ4NCAxOS40OTIySDI1LjQ1MzFWMjJIMTguMDg1OVoiIGZpbGw9IiMyMjIyMjIiLz4KPC9zdmc+Cg==",
          "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMiAzMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTUuNjMyODEgMjJWMjEuMDE1Nkw2LjkwNjI1IDIwLjc5NjlWMTEuODM1OUw1LjYzMjgxIDExLjYxNzJWMTAuNjI1SDkuNzE4NzVWMTEuNjE3Mkw4LjQ0NTMxIDExLjgzNTlWMTUuNzY1NkgxMy44ODI4VjExLjgzNTlMMTIuNjA5NCAxMS42MTcyVjEwLjYyNUgxNi42OTUzVjExLjYxNzJMMTUuNDIxOSAxMS44MzU5VjIwLjc5NjlMMTYuNjk1MyAyMS4wMTU2VjIySDEyLjYwOTRWMjEuMDE1NkwxMy44ODI4IDIwLjc5NjlWMTYuOTc2Nkg4LjQ0NTMxVjIwLjc5NjlMOS43MTg3NSAyMS4wMTU2VjIySDUuNjMyODFaTTIxLjQ2ODggMjIuMTY0MUMyMC43NzYgMjIuMTY0MSAyMC4xNTg5IDIyLjAzOTEgMTkuNjE3MiAyMS43ODkxQzE5LjA3NTUgMjEuNTMzOSAxOC42NTEgMjEuMTc0NSAxOC4zNDM4IDIwLjcxMDlDMTguMDQxNyAyMC4yNDIyIDE3Ljg5ODQgMTkuNjg3NSAxNy45MTQxIDE5LjA0NjlMMTcuOTM3NSAxOUgxOS40MDYyQzE5LjQwNjIgMTkuNTk5IDE5LjU4ODUgMjAuMDc1NSAxOS45NTMxIDIwLjQyOTdDMjAuMzIyOSAyMC43ODM5IDIwLjgyODEgMjAuOTYwOSAyMS40Njg4IDIwLjk2MDlDMjIuMTE5OCAyMC45NjA5IDIyLjYzMDIgMjAuNzgzOSAyMyAyMC40Mjk3QzIzLjM2OTggMjAuMDc1NSAyMy41NTQ3IDE5LjU1MjEgMjMuNTU0NyAxOC44NTk0QzIzLjU1NDcgMTguMTU2MiAyMy4zOTA2IDE3LjYzOCAyMy4wNjI1IDE3LjMwNDdDMjIuNzM0NCAxNi45NzE0IDIyLjIxNjEgMTYuODA0NyAyMS41MDc4IDE2LjgwNDdIMjAuMTY0MVYxNS42MDE2SDIxLjUwNzhDMjIuMTkwMSAxNS42MDE2IDIyLjY3MTkgMTUuNDMyMyAyMi45NTMxIDE1LjA5MzhDMjMuMjM5NiAxNC43NSAyMy4zODI4IDE0LjI3MzQgMjMuMzgyOCAxMy42NjQxQzIzLjM4MjggMTIuMzM1OSAyMi43NDQ4IDExLjY3MTkgMjEuNDY4OCAxMS42NzE5QzIwLjg2OTggMTEuNjcxOSAyMC4zODggMTEuODQ5IDIwLjAyMzQgMTIuMjAzMUMxOS42NjQxIDEyLjU1MjEgMTkuNDg0NCAxMy4wMTgyIDE5LjQ4NDQgMTMuNjAxNkgxOC4wMDc4TDE3Ljk5MjIgMTMuNTU0N0MxNy45NzY2IDEyLjk4MTggMTguMTEyIDEyLjQ2MDkgMTguMzk4NCAxMS45OTIyQzE4LjY5MDEgMTEuNTIzNCAxOS4wOTkgMTEuMTUxIDE5LjYyNSAxMC44NzVDMjAuMTU2MiAxMC41OTkgMjAuNzcwOCAxMC40NjA5IDIxLjQ2ODggMTAuNDYwOUMyMi41MjA4IDEwLjQ2MDkgMjMuMzU5NCAxMC43NDIyIDIzLjk4NDQgMTEuMzA0N0MyNC42MDk0IDExLjg2MiAyNC45MjE5IDEyLjY1ODkgMjQuOTIxOSAxMy42OTUzQzI0LjkyMTkgMTQuMTY0MSAyNC43Nzg2IDE0LjYzMjggMjQuNDkyMiAxNS4xMDE2QzI0LjIxMDkgMTUuNTY1MSAyMy43ODY1IDE1LjkxOTMgMjMuMjE4OCAxNi4xNjQxQzIzLjkwMSAxNi4zODggMjQuMzgyOCAxNi43Mzk2IDI0LjY2NDEgMTcuMjE4OEMyNC45NTA1IDE3LjY5NzkgMjUuMDkzOCAxOC4yMzQ0IDI1LjA5MzggMTguODI4MUMyNS4wOTM4IDE5LjUyMDggMjQuOTM3NSAyMC4xMTcyIDI0LjYyNSAyMC42MTcyQzI0LjMxNzcgMjEuMTEyIDIzLjg5MDYgMjEuNDk0OCAyMy4zNDM4IDIxLjc2NTZDMjIuNzk2OSAyMi4wMzEyIDIyLjE3MTkgMjIuMTY0MSAyMS40Njg4IDIyLjE2NDFaIiBmaWxsPSIjMjIyMjIyIi8+Cjwvc3ZnPgo=",
        ],
        sQ = new wy(document),
        aQ = [...Array(3).keys()].map((n) => {
          const e = n + 1;
          return {
            label: `Heading ${e}`,
            icon: Es(XZ[n]),
            id: `heading${e}`,
            attributes: { level: e },
          };
        });
      function Es(n) {
        return sQ.bypassSecurityTrustUrl(n);
      }
      const Nk = [
          ...aQ,
          {
            label: "Paragraph",
            icon: Es(
              "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMiAzMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTYuNDc0NjEgMTZWMTUuMjYxN0w3LjQyOTY5IDE1LjA5NzdWOC4zNzY5NUw2LjQ3NDYxIDguMjEyODlWNy40Njg3NUgxMC4zOTQ1QzExLjMwNDcgNy40Njg3NSAxMi4wMTE3IDcuNzAzMTIgMTIuNTE1NiA4LjE3MTg4QzEzLjAyMzQgOC42NDA2MiAxMy4yNzczIDkuMjU3ODEgMTMuMjc3MyAxMC4wMjM0QzEzLjI3NzMgMTAuNzk2OSAxMy4wMjM0IDExLjQxNiAxMi41MTU2IDExLjg4MDlDMTIuMDExNyAxMi4zNDU3IDExLjMwNDcgMTIuNTc4MSAxMC4zOTQ1IDEyLjU3ODFIOC41ODM5OFYxNS4wOTc3TDkuNTM5MDYgMTUuMjYxN1YxNkg2LjQ3NDYxWk04LjU4Mzk4IDExLjY3NThIMTAuMzk0NUMxMC45NzI3IDExLjY3NTggMTEuNDA0MyAxMS41MjE1IDExLjY4OTUgMTEuMjEyOUMxMS45Nzg1IDEwLjkwMDQgMTIuMTIzIDEwLjUwNzggMTIuMTIzIDEwLjAzNTJDMTIuMTIzIDkuNTYyNSAxMS45Nzg1IDkuMTY3OTcgMTEuNjg5NSA4Ljg1MTU2QzExLjQwNDMgOC41MzUxNiAxMC45NzI3IDguMzc2OTUgMTAuMzk0NSA4LjM3Njk1SDguNTgzOThWMTEuNjc1OFoiIGZpbGw9IiMyMjIyMjIiLz4KPHJlY3QgeD0iMTUiIHk9IjE0IiB3aWR0aD0iMTEiIGhlaWdodD0iMSIgZmlsbD0iIzIyMjIyMiIvPgo8cmVjdCB4PSI2IiB5PSIxOCIgd2lkdGg9IjIwIiBoZWlnaHQ9IjEiIGZpbGw9IiMyMjIyMjIiLz4KPHJlY3QgeD0iNiIgeT0iMjIiIHdpZHRoPSIyMCIgaGVpZ2h0PSIxIiBmaWxsPSIjMjIyMjIyIi8+Cjwvc3ZnPgo="
            ),
            id: "paragraph",
          },
          {
            label: "List Ordered",
            icon: Es(
              "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMiAzMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTYuNzA4OTggMjAuNTMxMlYxOS43OTNMOC4wMjczNCAxOS42Mjg5VjEzLjIzNjNMNi42ODU1NSAxMy4yNTk4VjEyLjUzOTFMOS4xODE2NCAxMlYxOS42Mjg5TDEwLjQ5NDEgMTkuNzkzVjIwLjUzMTJINi43MDg5OFoiIGZpbGw9IiMyMjIyMjIiLz4KPHBhdGggZD0iTTExLjc5NDkgMjAuNTMxMlYxOS4zNDc3SDEyLjk0OTJWMjAuNTMxMkgxMS43OTQ5WiIgZmlsbD0iIzIyMjIyMiIvPgo8cmVjdCB4PSIxNSIgeT0iMTMiIHdpZHRoPSIxMSIgaGVpZ2h0PSIxIiBmaWxsPSIjMjIyMjIyIi8+CjxyZWN0IHg9IjE1IiB5PSIxNiIgd2lkdGg9IjExIiBoZWlnaHQ9IjEiIGZpbGw9IiMyMjIyMjIiLz4KPHJlY3QgeD0iMTUiIHk9IjE5IiB3aWR0aD0iMTEiIGhlaWdodD0iMSIgZmlsbD0iIzIyMjIyMiIvPgo8L3N2Zz4K"
            ),
            id: "orderedList",
          },
          {
            label: "List Unordered",
            icon: Es(
              "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMiAzMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3QgeD0iMTQiIHk9IjEyIiB3aWR0aD0iMTIiIGhlaWdodD0iMSIgZmlsbD0iIzIyMjIyMiIvPgo8cmVjdCB4PSIxNCIgeT0iMTUiIHdpZHRoPSIxMiIgaGVpZ2h0PSIxIiBmaWxsPSIjMjIyMjIyIi8+CjxyZWN0IHg9IjE0IiB5PSIxOCIgd2lkdGg9IjEyIiBoZWlnaHQ9IjEiIGZpbGw9IiMyMjIyMjIiLz4KPGNpcmNsZSBjeD0iOC41IiBjeT0iMTUuNSIgcj0iMi41IiBmaWxsPSIjMjIyMjIyIi8+Cjwvc3ZnPgo="
            ),
            id: "bulletList",
          },
          {
            label: "Blockquote",
            icon: Es(
              "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMiAzMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTcuNjI1IDEzQzcuMTI1IDEzIDYuNzI1IDEyLjg1IDYuNDI1IDEyLjU1QzYuMTQxNjcgMTIuMjMzMyA2IDExLjggNiAxMS4yNUM2IDEwLjAzMzMgNi4zNzUgOC45NjY2NyA3LjEyNSA4LjA1QzcuNDU4MzMgNy42MTY2NyA3LjgzMzMzIDcuMjY2NjcgOC4yNSA3TDkgNy44NzVDOC43NjY2NyA4LjA0MTY3IDguNTMzMzMgOC4yNTgzMyA4LjMgOC41MjVDNy44NSA5LjAwODMzIDcuNjI1IDkuNSA3LjYyNSAxMEM4LjAwODMzIDEwIDguMzMzMzMgMTAuMTQxNyA4LjYgMTAuNDI1QzguODY2NjcgMTAuNzA4MyA5IDExLjA2NjcgOSAxMS41QzkgMTEuOTMzMyA4Ljg2NjY3IDEyLjI5MTcgOC42IDEyLjU3NUM4LjMzMzMzIDEyLjg1ODMgOC4wMDgzMyAxMyA3LjYyNSAxM1pNMTEuNjI1IDEzQzExLjEyNSAxMyAxMC43MjUgMTIuODUgMTAuNDI1IDEyLjU1QzEwLjE0MTcgMTIuMjMzMyAxMCAxMS44IDEwIDExLjI1QzEwIDEwLjAzMzMgMTAuMzc1IDguOTY2NjcgMTEuMTI1IDguMDVDMTEuNDU4MyA3LjYxNjY3IDExLjgzMzMgNy4yNjY2NyAxMi4yNSA3TDEzIDcuODc1QzEyLjc2NjcgOC4wNDE2NyAxMi41MzMzIDguMjU4MzMgMTIuMyA4LjUyNUMxMS44NSA5LjAwODMzIDExLjYyNSA5LjUgMTEuNjI1IDEwQzEyLjAwODMgMTAgMTIuMzMzMyAxMC4xNDE3IDEyLjYgMTAuNDI1QzEyLjg2NjcgMTAuNzA4MyAxMyAxMS4wNjY3IDEzIDExLjVDMTMgMTEuOTMzMyAxMi44NjY3IDEyLjI5MTcgMTIuNiAxMi41NzVDMTIuMzMzMyAxMi44NTgzIDEyLjAwODMgMTMgMTEuNjI1IDEzWiIgZmlsbD0iIzIyMjIyMiIvPgo8cmVjdCB4PSIxNSIgeT0iMTQiIHdpZHRoPSIxMSIgaGVpZ2h0PSIxIiBmaWxsPSIjMjIyMjIyIi8+CjxyZWN0IHg9IjYiIHk9IjE4IiB3aWR0aD0iMjAiIGhlaWdodD0iMSIgZmlsbD0iIzIyMjIyMiIvPgo8cmVjdCB4PSI2IiB5PSIyMiIgd2lkdGg9IjIwIiBoZWlnaHQ9IjEiIGZpbGw9IiMyMjIyMjIiLz4KPC9zdmc+Cg=="
            ),
            id: "blockquote",
          },
          {
            label: "Code Block",
            icon: Es(
              "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMiAzMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTEzLjQgMjAuNkw4LjggMTZMMTMuNCAxMS40TDEyIDEwTDYgMTZMMTIgMjJMMTMuNCAyMC42Wk0xOC42IDIwLjZMMjMuMiAxNkwxOC42IDExLjRMMjAgMTBMMjYgMTZMMjAgMjJMMTguNiAyMC42WiIgZmlsbD0iYmxhY2siLz4KPC9zdmc+Cg=="
            ),
            id: "codeBlock",
          },
          {
            label: "Horizontal Line",
            icon: Es(
              "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMiAzMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3QgeD0iNiIgeT0iMTUiIHdpZHRoPSIyMCIgaGVpZ2h0PSIyIiBmaWxsPSJibGFjayIvPgo8L3N2Zz4K"
            ),
            id: "horizontalLine",
          },
        ],
        dQ = [
          { name: "flip", options: { fallbackPlacements: ["top"] } },
          { name: "preventOverflow", options: { altAxis: !1, tether: !1 } },
        ];
      function Rk({ editor: n, range: e, props: t }) {
        const i = {
          dotContent: () => {
            n.chain()
              .addContentletBlock({ range: e, payload: t.payload })
              .run();
          },
          heading: () => {
            n.chain().addHeading({ range: e, type: t.type }).run();
          },
          orderedList: () => {
            n.chain().deleteRange(e).toggleOrderedList().focus().run();
          },
          bulletList: () => {
            n.chain().deleteRange(e).toggleBulletList().focus().run();
          },
          blockquote: () => {
            n.chain().deleteRange(e).setBlockquote().focus().run();
          },
          codeBlock: () => {
            n.chain().deleteRange(e).setCodeBlock().focus().run();
          },
          horizontalLine: () => {
            n.chain().deleteRange(e).setHorizontalRule().focus().run();
          },
        };
        i[t.type.name]
          ? i[t.type.name]()
          : n.chain().setTextSelection(e).focus().run();
      }
      const pQ = (n) => {
        let e, t;
        const i = new It("suggestionPlugin"),
          r = new _e();
        function o({ editor: l, range: c, clientRect: u }) {
          (t = (function hQ(n) {
            const e = n.createComponent(H1);
            return e.changeDetectorRef.detectChanges(), e;
          })(n)),
            (t.instance.currentLanguage = l.storage.dotConfig.lang),
            (t.instance.allowedContentTypes =
              l.storage.dotConfig.allowedContentTypes),
            (t.instance.onSelection = (d) => {
              const h = i.getState(l.view.state).query?.length || 0;
              (c.to = c.to + h), Rk({ editor: l, range: c, props: d });
            }),
            t.instance.clearFilter.pipe(WI(r)).subscribe((d) => {
              const h = {
                to: c.to + i.getState(l.view.state).query.length,
                from: d === tn.BLOCK ? c.from : c.from + 1,
              };
              l.chain().deleteRange(h).run();
            }),
            (e = (function fQ({ element: n, content: e, rect: t, onHide: i }) {
              return su(n, {
                appendTo: document.body,
                content: e,
                placement: "bottom",
                popperOptions: { modifiers: dQ },
                getReferenceClientRect: t,
                showOnCreate: !0,
                interactive: !0,
                offset: [120, 10],
                trigger: "manual",
                maxWidth: "none",
                onHide: i,
              });
            })({
              element: l.view.dom,
              content: t.location.nativeElement,
              rect: u,
              onHide: () => {
                const d = l.state.tr.setMeta(db, { open: !1 });
                l.view.dispatch(d);
              },
            }));
        }
        function s({ event: l }) {
          const { key: c } = l;
          return "Escape" === c
            ? (e.hide(), !0)
            : "Enter" === c
            ? (t.instance.execCommand(), !0)
            : ("ArrowDown" === c || "ArrowUp" === c) &&
              (t.instance.updateSelection(l), !0);
        }
        function a() {
          e?.destroy(), (t = null), r.next(!0), r.complete();
        }
        return bt.create({
          name: "actionsMenu",
          defaultOptions: {
            pluginKey: "actionsMenu",
            element: null,
            suggestion: {
              char: "/",
              pluginKey: i,
              allowSpaces: !0,
              startOfLine: !0,
              render: () => ({ onStart: o, onKeyDown: s, onExit: a }),
              items: ({ query: l }) => (t && t.instance.filterItems(l), []),
            },
          },
          addCommands: () => ({
            addHeading:
              ({ range: l, type: c }) =>
              ({ chain: u }) =>
                u()
                  .focus()
                  .deleteRange(l)
                  .toggleHeading({ level: c.level })
                  .focus()
                  .run(),
            addContentletBlock:
              ({ range: l, payload: c }) =>
              ({ chain: u }) =>
                u()
                  .deleteRange(l)
                  .command((d) => {
                    const h = d.editor.schema.nodes.dotContent.create({
                      data: c,
                    });
                    return d.tr.replaceSelectionWith(h), !0;
                  })
                  .focus()
                  .run(),
          }),
          addProseMirrorPlugins() {
            const l = n.createComponent(JZ);
            return [
              QZ({
                command: Rk,
                editor: this.editor,
                element: l.location.nativeElement,
                render: () => ({ onStart: o, onKeyDown: s, onExit: a }),
              }),
              yY({ editor: this.editor, ...this.options.suggestion }),
            ];
          },
        });
      };
      class gQ {
        constructor(e, t, i) {
          this.applicationRef = t.get(Da);
          const o = t.get(Qr).resolveComponentFactory(e);
          (this.componentRef = o.create(t, [])),
            this.updateProps(i),
            this.applicationRef.attachView(this.componentRef.hostView);
        }
        get instance() {
          return this.componentRef.instance;
        }
        get elementRef() {
          return this.componentRef.injector.get(ut);
        }
        get dom() {
          return this.elementRef.nativeElement;
        }
        updateProps(e) {
          Object.entries(e).forEach(([t, i]) => {
            this.instance[t] = i;
          });
        }
        detectChanges() {
          this.componentRef.changeDetectorRef.detectChanges();
        }
        destroy() {
          this.componentRef.destroy(),
            this.applicationRef.detachView(this.componentRef.hostView);
        }
      }
      let hb = (() => {
        class n {}
        return (
          (n.ɵfac = function (t) {
            return new (t || n)();
          }),
          (n.ɵcmp = ht({
            type: n,
            selectors: [["ng-component"]],
            inputs: {
              editor: "editor",
              node: "node",
              decorations: "decorations",
              selected: "selected",
              extension: "extension",
              getPos: "getPos",
              updateAttributes: "updateAttributes",
              deleteNode: "deleteNode",
            },
            decls: 0,
            vars: 0,
            template: function (t, i) {},
            encapsulation: 2,
          })),
          n
        );
      })();
      class mQ extends class H6 {
        constructor(e, t, i) {
          (this.isDragging = !1),
            (this.component = e),
            (this.editor = t.editor),
            (this.options = { stopEvent: null, ignoreMutation: null, ...i }),
            (this.extension = t.extension),
            (this.node = t.node),
            (this.decorations = t.decorations),
            (this.getPos = t.getPos),
            this.mount();
        }
        mount() {}
        get dom() {
          return this.editor.view.dom;
        }
        get contentDOM() {
          return null;
        }
        onDragStart(e) {
          var t, i, r, o, s, a, l;
          const { view: c } = this.editor,
            u = e.target,
            d =
              3 === u.nodeType
                ? null === (t = u.parentElement) || void 0 === t
                  ? void 0
                  : t.closest("[data-drag-handle]")
                : u.closest("[data-drag-handle]");
          if (
            !this.dom ||
            (null === (i = this.contentDOM) || void 0 === i
              ? void 0
              : i.contains(u)) ||
            !d
          )
            return;
          let h = 0,
            f = 0;
          if (this.dom !== d) {
            const m = this.dom.getBoundingClientRect(),
              v = d.getBoundingClientRect(),
              _ =
                null !== (r = e.offsetX) && void 0 !== r
                  ? r
                  : null === (o = e.nativeEvent) || void 0 === o
                  ? void 0
                  : o.offsetX,
              b =
                null !== (s = e.offsetY) && void 0 !== s
                  ? s
                  : null === (a = e.nativeEvent) || void 0 === a
                  ? void 0
                  : a.offsetY;
            (h = v.x - m.x + _), (f = v.y - m.y + b);
          }
          null === (l = e.dataTransfer) ||
            void 0 === l ||
            l.setDragImage(this.dom, h, f);
          const p = Y.create(c.state.doc, this.getPos()),
            g = c.state.tr.setSelection(p);
          c.dispatch(g);
        }
        stopEvent(e) {
          var t;
          if (!this.dom) return !1;
          if ("function" == typeof this.options.stopEvent)
            return this.options.stopEvent({ event: e });
          const i = e.target;
          if (
            !this.dom.contains(i) ||
            (null !== (t = this.contentDOM) && void 0 !== t && t.contains(i))
          )
            return !1;
          const o = "drop" === e.type;
          if (
            (["INPUT", "BUTTON", "SELECT", "TEXTAREA"].includes(i.tagName) ||
              i.isContentEditable) &&
            !o
          )
            return !0;
          const { isEditable: a } = this.editor,
            { isDragging: l } = this,
            c = !!this.node.type.spec.draggable,
            u = Y.isSelectable(this.node),
            d = "copy" === e.type,
            h = "paste" === e.type,
            f = "cut" === e.type,
            p = "mousedown" === e.type,
            g = e.type.startsWith("drag");
          if ((!c && u && g && e.preventDefault(), c && g && !l))
            return e.preventDefault(), !1;
          if (c && a && !l && p) {
            const m = i.closest("[data-drag-handle]");
            m &&
              (this.dom === m || this.dom.contains(m)) &&
              ((this.isDragging = !0),
              document.addEventListener(
                "dragend",
                () => {
                  this.isDragging = !1;
                },
                { once: !0 }
              ),
              document.addEventListener(
                "mouseup",
                () => {
                  this.isDragging = !1;
                },
                { once: !0 }
              ));
          }
          return !(l || o || d || h || f || (p && u));
        }
        ignoreMutation(e) {
          return (
            !this.dom ||
            !this.contentDOM ||
            ("function" == typeof this.options.ignoreMutation
              ? this.options.ignoreMutation({ mutation: e })
              : !(
                  !this.node.isLeaf &&
                  !this.node.isAtom &&
                  ("selection" === e.type ||
                    (this.dom.contains(e.target) &&
                      "childList" === e.type &&
                      Gh() &&
                      this.editor.isFocused &&
                      [
                        ...Array.from(e.addedNodes),
                        ...Array.from(e.removedNodes),
                      ].every((i) => i.isContentEditable)) ||
                    ((this.contentDOM !== e.target ||
                      "attributes" !== e.type) &&
                      this.contentDOM.contains(e.target)))
                ))
          );
        }
        updateAttributes(e) {
          this.editor.commands.command(({ tr: t }) => {
            const i = this.getPos();
            return t.setNodeMarkup(i, void 0, { ...this.node.attrs, ...e }), !0;
          });
        }
        deleteNode() {
          const e = this.getPos();
          this.editor.commands.deleteRange({
            from: e,
            to: e + this.node.nodeSize,
          });
        }
      } {
        mount() {
          (this.renderer = new gQ(this.component, this.options.injector, {
            editor: this.editor,
            node: this.node,
            decorations: this.decorations,
            selected: !1,
            extension: this.extension,
            getPos: () => this.getPos(),
            updateAttributes: (i = {}) => this.updateAttributes(i),
            deleteNode: () => this.deleteNode(),
          })),
            this.extension.config.draggable &&
              (this.renderer.elementRef.nativeElement.ondragstart = (i) => {
                this.onDragStart(i);
              }),
            (this.contentDOMElement = this.node.isLeaf
              ? null
              : document.createElement(this.node.isInline ? "span" : "div")),
            this.contentDOMElement &&
              ((this.contentDOMElement.style.whiteSpace = "inherit"),
              this.renderer.detectChanges());
        }
        get dom() {
          return this.renderer.dom;
        }
        get contentDOM() {
          return this.node.isLeaf
            ? null
            : (this.maybeMoveContentDOM(), this.contentDOMElement);
        }
        maybeMoveContentDOM() {
          const e = this.dom.querySelector("[data-node-view-content]");
          this.contentDOMElement &&
            e &&
            !e.contains(this.contentDOMElement) &&
            e.appendChild(this.contentDOMElement);
        }
        update(e, t) {
          return this.options.update
            ? this.options.update(e, t)
            : e.type === this.node.type &&
                ((e === this.node && this.decorations === t) ||
                  ((this.node = e),
                  (this.decorations = t),
                  this.renderer.updateProps({ node: e, decorations: t }),
                  this.maybeMoveContentDOM()),
                !0);
        }
        selectNode() {
          this.renderer.updateProps({ selected: !0 });
        }
        deselectNode() {
          this.renderer.updateProps({ selected: !1 });
        }
        destroy() {
          this.renderer.destroy();
        }
      }
      const Pk = (n, e) => (t) => new mQ(n, t, e);
      function yQ(n, e) {
        if ((1 & n && (H(0, "a", 2), Lt(1, "img", 3), z()), 2 & n)) {
          const t = V();
          A("href", t.href, qr),
            O(1),
            A("src", t.data.asset, qr)("alt", t.data.name);
        }
      }
      function vQ(n, e) {
        if ((1 & n && Lt(0, "img", 4), 2 & n)) {
          const t = V();
          A("src", t.data.asset, qr)("alt", t.data.name);
        }
      }
      let _Q = (() => {
        class n extends hb {
          constructor(t) {
            super(), (this._elementRef = t);
          }
          ngOnInit() {
            (this.data = this.node.attrs.data),
              this.editor.on("update", this.updateImageAttributes.bind(this)),
              this.updateImageAttributes();
          }
          ngOnDestroy() {
            this.editor.off("update", this.updateImageAttributes.bind(this));
          }
          updateImageAttributes() {
            (this._elementRef.nativeElement.style.textAlign =
              this.node.attrs.textAlign),
              (this.href = this.node.attrs.href);
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(w(ut));
          }),
          (n.ɵcmp = ht({
            type: n,
            selectors: [["dotcms-image-block"]],
            features: [we],
            decls: 3,
            vars: 2,
            consts: [
              [
                "target",
                "_blank",
                "rel",
                "noreferrer",
                3,
                "href",
                4,
                "ngIf",
                "ngIfElse",
              ],
              ["noLink", ""],
              ["target", "_blank", "rel", "noreferrer", 3, "href"],
              [3, "src", "alt"],
              ["loading", "lazy", 3, "src", "alt"],
            ],
            template: function (t, i) {
              if (
                (1 & t &&
                  (U(0, yQ, 2, 3, "a", 0),
                  U(1, vQ, 1, 2, "ng-template", null, 1, Xr)),
                2 & t)
              ) {
                const r = Dr(2);
                A("ngIf", i.href)("ngIfElse", r);
              }
            },
            dependencies: [to],
            styles: [
              "[_nghost-%COMP%]{display:block;margin-bottom:16px}[_nghost-%COMP%]   img[_ngcontent-%COMP%]{max-width:100%}",
            ],
          })),
          n
        );
      })();
      const bQ = (n) =>
        en.create({
          name: "dotImage",
          group: "block",
          inline: !1,
          draggable: !0,
          addAttributes: () => ({
            data: {
              default: null,
              parseHTML: (e) => e.getAttribute("data"),
              renderHTML: (e) => ({ data: e.data }),
            },
            href: {
              default: null,
              parseHTML: (e) => e.getAttribute("href"),
              renderHTML: (e) => ({ href: e.href }),
            },
          }),
          addCommands: () => ({
            setImageLink:
              (e) =>
              ({ commands: t }) =>
                t.updateAttributes("dotImage", e),
            unsetImageLink:
              () =>
              ({ commands: e }) =>
                e.updateAttributes("dotImage", { href: "" }),
          }),
          parseHTML: () => [{ tag: "dotcms-image-block" }],
          renderHTML: ({ HTMLAttributes: e }) => ["dotcms-image-block", _t(e)],
          addNodeView: () => Pk(_Q, { injector: n }),
        });
      let DQ = (() => {
        class n extends hb {}
        return (
          (n.ɵfac = (function () {
            let e;
            return function (i) {
              return (e || (e = Nt(n)))(i || n);
            };
          })()),
          (n.ɵcmp = ht({
            type: n,
            selectors: [["dotcms-message"]],
            features: [we],
            decls: 2,
            vars: 2,
            consts: [[3, "ngClass"]],
            template: function (t, i) {
              1 & t && (H(0, "span", 0), ze(1), z()),
                2 & t && (A("ngClass", i.data.type), O(1), _n(i.data.message));
            },
            dependencies: [sc],
            styles: [
              "dotcms-message{background-color:#b3b1b8;display:block;padding:16px}\n",
            ],
            encapsulation: 2,
          })),
          n
        );
      })();
      const fb = new Qe({
          state: {
            init: () => vt.empty,
            apply(n, e) {
              e = e.map(n.mapping, n.doc);
              const t = n.getMeta(this);
              if (t && t.add) {
                const r = pn.widget(t.add.pos, t.add.element, {
                  key: t.add.id,
                });
                e = e.add(n.doc, [r]);
              } else
                t &&
                  t.remove &&
                  (e = e.remove(
                    e.find(null, null, (i) => i.id == t.remove.id)
                  ));
              return e;
            },
          },
          props: {
            decorations(n) {
              return this.getState(n);
            },
          },
        }),
        CQ = (n, e) =>
          bt.create({
            name: "imageUpload",
            addProseMirrorPlugins() {
              const t = n.get(B1),
                i = this.editor;
              function r(c) {
                let u;
                if (
                  ((u =
                    "drop" === c.type
                      ? c.dataTransfer.files
                      : c.clipboardData.files),
                  u.length > 0)
                )
                  for (let d = 0; d < u.length; d++)
                    if (!u[d].type.startsWith("image/")) return !1;
                return !!u.length;
              }
              function s(c, u, d) {
                const h = u[0].name;
                (function o(c, u, d) {
                  const h = e.createComponent(DQ),
                    f = c.state.tr;
                  (h.instance.data = { message: "Uploading...", type: "info" }),
                    h.changeDetectorRef.detectChanges(),
                    f.setMeta(fb, {
                      add: { id: d, pos: u, element: h.location.nativeElement },
                    }),
                    c.dispatch(f);
                })(c, d, h),
                  t
                    .publishContent(u)
                    .pipe(wo(1))
                    .subscribe(
                      (f) => {
                        const g = {
                          attrs: { data: f[0][Object.keys(f[0])[0]] },
                          type: "dotImage",
                        };
                        i.commands.insertContentAt(d, g);
                      },
                      (f) => alert(f.message),
                      () =>
                        (function a(c) {
                          const { view: u } = i,
                            { state: d } = u;
                          u.dispatch(d.tr.setMeta(fb, { remove: { id: c } }));
                        })(h)
                    );
              }
              return [
                fb,
                new Qe({
                  key: new It("imageUpload"),
                  props: {
                    handleDOMEvents: {
                      paste(c, u) {
                        if (r(u)) {
                          if (1 !== u.clipboardData.files.length)
                            return (
                              alert("Can paste just one image at a time"), !1
                            );
                          const { from: d } = (function l(c) {
                            const { state: u } = c,
                              { selection: d } = u,
                              { ranges: h } = d;
                            return {
                              from: Math.min(...h.map((g) => g.$from.pos)),
                              to: Math.max(...h.map((g) => g.$to.pos)),
                            };
                          })(c);
                          s(c, Array.from(u.clipboardData.files), d);
                        }
                        return !1;
                      },
                      drop(c, u) {
                        if (r(u)) {
                          if (
                            (u.preventDefault(),
                            1 !== u.dataTransfer.files.length)
                          )
                            return (
                              alert("Can drop just one image at a time"), !1
                            );
                          const { pos: d } = c.posAtCoords({
                            left: u.clientX,
                            top: u.clientY,
                          });
                          s(c, Array.from(u.dataTransfer.files), d);
                        }
                        return !1;
                      },
                    },
                  },
                }),
              ];
            },
          });
      let EQ = (() => {
        class n {}
        return (
          (n.ɵfac = function (t) {
            return new (t || n)();
          }),
          (n.ɵcmp = ht({
            type: n,
            selectors: [["dotcms-drag-handler"]],
            decls: 2,
            vars: 0,
            consts: [[1, "material-icons"]],
            template: function (t, i) {
              1 & t && (H(0, "i", 0), ze(1, "drag_indicator"), z());
            },
            styles: [
              "[_nghost-%COMP%]{position:absolute;cursor:grab;z-index:1;opacity:0;color:var(--color-background);transition:opacity .25s,top .15s}.visible[_nghost-%COMP%]{opacity:1}",
            ],
          })),
          n
        );
      })();
      const wQ = (n) =>
          bt.create({
            name: "dragHandler",
            addProseMirrorPlugins() {
              let e = null;
              const r = n.createComponent(EQ).location.nativeElement;
              function c(p) {
                for (
                  ;
                  p &&
                  p.parentNode &&
                  !p.classList?.contains("ProseMirror") &&
                  !p.parentNode.classList?.contains("ProseMirror");

                )
                  p = p.parentNode;
                return p;
              }
              function h() {
                r.classList.remove("visible");
              }
              return [
                new Qe({
                  key: new It("dragHandler"),
                  view: (p) => (
                    requestAnimationFrame(() =>
                      (function d(p) {
                        r.setAttribute("draggable", "true"),
                          r.addEventListener("dragstart", (g) =>
                            (function l(p, g) {
                              if (!p.dataTransfer) return;
                              const v = (function a(p, g) {
                                const m = g.posAtCoords(p);
                                if (m) {
                                  const v = c(g.nodeDOM(m.inside));
                                  if (v && 1 === v.nodeType) {
                                    const _ = g.docView.nearestDesc(v, !0);
                                    if (_ && _ !== g.docView)
                                      return _.posBefore;
                                  }
                                }
                                return null;
                              })({ left: p.clientX + 50, top: p.clientY }, g);
                              if (null != v) {
                                g.dispatch(
                                  g.state.tr.setSelection(
                                    Y.create(g.state.doc, v)
                                  )
                                );
                                const _ = g.state.selection.content();
                                p.dataTransfer.clearData(),
                                  p.dataTransfer.setDragImage(e, 10, 10),
                                  (g.dragging = { slice: _, move: !0 });
                              }
                            })(g, p)
                          ),
                          r.classList.remove("visible"),
                          p.dom.parentElement.appendChild(r);
                      })(p)
                    ),
                    document.body.addEventListener("scroll", h, !0),
                    {
                      destroy() {
                        (function s(p) {
                          p && p.parentNode && p.parentNode.removeChild(p);
                        })(r),
                          document.body.removeEventListener("scroll", h, !0);
                      },
                    }
                  ),
                  props: {
                    handleDOMEvents: {
                      drop: () => (
                        setTimeout(() => {
                          const p = document.querySelector(
                            ".ProseMirror-hideselection"
                          );
                          p && p.classList.remove("ProseMirror-hideselection"),
                            r.classList.remove("visible");
                        }),
                        !1
                      ),
                      mousemove(p, g) {
                        const v = p.posAtCoords({
                          left: g.clientX + 50,
                          top: g.clientY,
                        });
                        if (
                          v &&
                          (function u(p, g) {
                            const m = p.nodeDOM(g);
                            return !(
                              !m?.hasChildNodes() ||
                              (1 === m.childNodes.length &&
                                "BR" == m.childNodes[0].nodeName)
                            );
                          })(p, v.inside)
                        )
                          if (
                            ((e = c(p.nodeDOM(v.inside))),
                            (function f(p) {
                              return (
                                p &&
                                !p.classList?.contains("ProseMirror") &&
                                !p.innerText.startsWith("/")
                              );
                            })(e))
                          ) {
                            const { top: _, left: b } = (function o(p, g) {
                              return {
                                top:
                                  g.getBoundingClientRect().top -
                                  p.getBoundingClientRect().top,
                                left:
                                  g.getBoundingClientRect().left -
                                  p.getBoundingClientRect().left,
                              };
                            })(p.dom.parentElement, e);
                            (r.style.left = b - 25 + "px"),
                              (r.style.top = _ < 0 ? 0 : _ + "px"),
                              r.classList.add("visible");
                          } else r.classList.remove("visible");
                        else (e = null), r.classList.remove("visible");
                        return !1;
                      },
                    },
                  },
                }),
              ];
            },
          }),
        SQ = ["input"];
      function MQ(n, e) {
        if (1 & n) {
          const t = Ui();
          H(0, "div", 6)(1, "div", 7)(2, "span", 8),
            ze(3, "LINKED TO"),
            z(),
            H(4, "div", 9)(5, "a", 10)(6, "span", 11),
            ze(7, "language"),
            z(),
            ze(8),
            Sd(9, "slice"),
            z()()(),
            H(10, "div", 12)(11, "button", 13),
            Oe("click", function () {
              return Ot(t), kt(V().copyLink());
            }),
            ze(12, " COPY LINK "),
            z(),
            H(13, "button", 14),
            Oe("click", function () {
              return Ot(t), kt(V().removeLink.emit(!0));
            }),
            ze(14, " REMOVE LINK "),
            z()()();
        }
        if (2 & n) {
          const t = V();
          O(5),
            A("href", t.nodeLink, qr),
            O(3),
            Zr(
              " ",
              t.nodeLink.length > 50
                ? (function Aw(n, e, t, i, r) {
                    const o = n + 22,
                      s = M(),
                      a = Fs(s, o);
                    return Jl(s, o)
                      ? Iw(s, sn(), e, a.transform, t, i, r, a)
                      : a.transform(t, i, r);
                  })(9, 2, t.nodeLink, 0, 50) + "..."
                : t.nodeLink,
              " "
            );
        }
      }
      let IQ = (() => {
        class n {
          constructor() {
            (this.hideForm = new Ie(!1)),
              (this.removeLink = new Ie(!1)),
              (this.setLink = new Ie()),
              (this.nodeLink = ""),
              (this.newLink = "");
          }
          addLink() {
            this.setLink.emit(this.newLink);
          }
          copyLink() {
            navigator.clipboard
              .writeText(this.nodeLink)
              .then(() => this.hideForm.emit(!0))
              .catch(() => alert("Could not copy link"));
          }
          focusInput() {
            this.input.nativeElement.focus();
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)();
          }),
          (n.ɵcmp = ht({
            type: n,
            selectors: [["dotcms-bubble-menu-link-form"]],
            viewQuery: function (t, i) {
              if ((1 & t && ec(SQ, 5), 2 & t)) {
                let r;
                bn((r = Dn())) && (i.input = r.first);
              }
            },
            inputs: { nodeLink: "nodeLink", newLink: "newLink" },
            outputs: {
              hideForm: "hideForm",
              removeLink: "removeLink",
              setLink: "setLink",
            },
            decls: 7,
            vars: 2,
            consts: [
              [1, "form-container"],
              ["autoComplete", "off", 3, "mousedown", "submit"],
              [
                "name",
                "link",
                "placeholder",
                "Type or Paste Link",
                "type",
                "text",
                3,
                "ngModel",
                "ngModelChange",
              ],
              ["input", ""],
              ["click", "addLink()", 1, "btn", "btn-add"],
              ["class", "card-container", 4, "ngIf"],
              [1, "card-container"],
              [1, "card-header"],
              [1, "linked-to"],
              [1, "link-container"],
              ["target", "_blank", 1, "link", 3, "href"],
              [1, "material-icons"],
              [1, "card-footer"],
              [1, "btn", "btn-copy", 3, "click"],
              [1, "btn", "btn-remove", 3, "click"],
            ],
            template: function (t, i) {
              1 & t &&
                (H(0, "div", 0)(1, "form", 1),
                Oe("mousedown", function () {
                  return i.focusInput();
                })("submit", function () {
                  return i.addLink();
                }),
                H(2, "input", 2, 3),
                Oe("ngModelChange", function (o) {
                  return (i.newLink = o);
                }),
                z(),
                H(4, "button", 4),
                ze(5, "ADD"),
                z()(),
                U(6, MQ, 15, 6, "div", 5),
                z()),
                2 & t &&
                  (O(2), A("ngModel", i.newLink), O(4), A("ngIf", i.nodeLink));
            },
            dependencies: [to, lI, eh, Ty, WM, dh, uh, JS],
            styles: [
              ".form-container[_ngcontent-%COMP%]{box-sizing:border-box;background:#ffffff;border-radius:2px;box-shadow:0 4px 10px #0a07251a;display:flex;flex-direction:column;padding:7.2px;width:400px}form[_ngcontent-%COMP%]{align-items:center;display:flex;flex-direction:row;gap:8px;justify-content:space-between;width:100%}form[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]{background:#ffffff;border-radius:2px;border:1px solid #b3b1b8;box-sizing:border-box;padding:13.6px;width:calc(100% - 5.5rem)}form[_ngcontent-%COMP%]   input[_ngcontent-%COMP%]:focus{outline:none}.card-container[_ngcontent-%COMP%]{padding:8px}.card-header[_ngcontent-%COMP%]{display:flex;flex-direction:column;gap:8px;padding-bottom:12px;padding-top:16px}.linked-to[_ngcontent-%COMP%]{color:#7e7a86;font-size:.85rem;font-weight:500}.link-container[_ngcontent-%COMP%]{cursor:pointer;white-space:nowrap;word-wrap:normal}.link-container[_ngcontent-%COMP%]:hover{background-color:#f1f3f4}.link[_ngcontent-%COMP%]{align-items:center;color:#0a0725;display:flex;font-size:1rem;gap:8px;height:100%;justify-content:flex-start;padding:8px 0;text-decoration:none;width:100%}.card-footer[_ngcontent-%COMP%]{align-items:center;display:flex;justify-content:space-between}.btn[_ngcontent-%COMP%]{align-items:center;background:#ffffff;border-radius:2px;cursor:pointer;display:flex;font-weight:700;justify-content:center;padding:12px 16px;width:180px}.btn-add[_ngcontent-%COMP%]{width:88px;background:#576be8;border:1px solid #576be8;color:#fff}.btn-copy[_ngcontent-%COMP%]{border:1px solid #576be8;color:#576be8}.btn-[_ngcontent-%COMP%]   *[_ngcontent-%COMP%]   remove[_ngcontent-%COMP%]{border:1px solid #ec4b41;color:#ec4b41}",
            ],
          })),
          n
        );
      })();
      class TQ {
        constructor({
          editor: e,
          element: t,
          view: i,
          tippyOptions: r = {},
          pluginKey: o,
          storage: s,
          component: a,
        }) {
          (this.focusHandler = () => {
            this.tippy?.state.isVisible && this.hide();
          }),
            (this.editor = e),
            (this.element = t),
            (this.view = i),
            (this.tippyOptions = r),
            this.element.remove(),
            (this.element.style.visibility = "visible"),
            (this.pluginKey = o),
            (this.component = a),
            (this.storage = s),
            this.editor.on("focus", this.focusHandler),
            this.setComponentEvents(),
            document.body.addEventListener(
              "scroll",
              this.hanlderScroll.bind(this),
              !0
            );
        }
        update(e, t) {
          const i = this.pluginKey.getState(e.state),
            r = this.pluginKey.getState(t);
          i.toggle !== r.toggle
            ? (this.createTooltip(),
              this.tippy?.state.isVisible ? this.hide() : this.show(),
              this.detectLinkFormChanges())
            : this.detectLinkFormChanges();
        }
        createTooltip() {
          const { element: e } = this.editor.options;
          this.tippy ||
            !e.parentElement ||
            (this.tippy = su(e, {
              appendTo: document.body,
              duration: 250,
              getReferenceClientRect: null,
              content: this.element,
              interactive: !0,
              trigger: "manual",
              placement: "bottom-start",
              hideOnClick: "toggle",
              ...this.tippyOptions,
            }));
        }
        show() {
          this.tippy?.show(),
            this.setInputValues(),
            this.focusInput(),
            this.tippy?.setProps({
              getReferenceClientRect: () => this.setTippyPosition(),
            });
        }
        hide() {
          this.tippy?.hide(),
            this.editor.view.focus(),
            this.editor.commands.unsetHighlight();
        }
        setTippyPosition() {
          const { view: e } = this.editor,
            { state: t } = e,
            { doc: i, selection: r } = t,
            { ranges: o } = r,
            s = Math.min(...o.map((g) => g.$from.pos)),
            l = Fc(e, s, Math.max(...o.map((g) => g.$to.pos))),
            { element: c } = this.editor.options,
            u = c.parentElement.getBoundingClientRect(),
            d = document.querySelector("#bubble-menu").getBoundingClientRect(),
            h = u.bottom < l.bottom,
            p = "dotImage" === i?.nodeAt(s).type.name;
          return h || p ? d : l;
        }
        addLink(e) {
          this.isDotImageNode()
            ? this.editor.commands.setImageLink({ href: e })
            : this.editor.commands.setLink({ href: e }),
            this.hide();
        }
        removeLink() {
          this.isDotImageNode()
            ? this.editor.commands.unsetImageLink()
            : this.editor.commands.unsetLink(),
            this.hide();
        }
        setInputValues() {
          (this.component.instance.nodeLink = this.getNodeLink()),
            (this.component.instance.newLink =
              this.getNodeLink() || this.getLinkSelect());
        }
        focusInput() {
          this.component.instance.focusInput();
        }
        setComponentEvents() {
          this.component.instance.hideForm.subscribe(() => this.hide()),
            this.component.instance.removeLink.subscribe(() =>
              this.removeLink()
            ),
            this.component.instance.setLink.subscribe((e) => this.addLink(e));
        }
        detectLinkFormChanges() {
          this.component.changeDetectorRef.detectChanges();
        }
        getNodeLink() {
          return this.editor.isActive("link")
            ? this.editor.getAttributes("link").href
            : this.editor.getAttributes("dotImage").href || "";
        }
        getLinkSelect() {
          const { state: e } = this.editor,
            { from: t, to: i } = e.selection,
            r = e.doc.textBetween(t, i, " ");
          return this.isLink(r) ? r : "";
        }
        isLink(e) {
          return !!new RegExp(
            "^(https?:\\/\\/)?((([a-z\\d]([a-z\\d-]*[a-z\\d])*)\\.)+[a-z]{2,}|((\\d{1,3}\\.){3}\\d{1,3}))(\\:\\d+)?(\\/[-a-z\\d%_.~+]*)*(\\?[;&a-z\\d%_.~+=-]*)?(\\#[-a-z\\d_]*)?$",
            "i"
          ).test(e);
        }
        isDotImageNode() {
          const { type: e } = this.editor.state.doc.nodeAt(
            this.editor.state.selection.from
          );
          return "dotImage" === e.name;
        }
        destroy() {
          this.tippy?.destroy(), this.editor.off("focus", this.focusHandler);
        }
        hanlderScroll() {
          this.tippy?.state.isVisible && this.tippy?.hide();
        }
      }
      const xQ = (n) =>
          new Qe({
            key: n.pluginKey,
            view: (e) => new TQ({ view: e, ...n }),
            state: {
              init: () => ({ toggle: !0 }),
              apply: (e) => (
                e.getMeta(n.pluginKey), { toggle: n.storage.show }
              ),
            },
          }),
        AQ = new It("addLink"),
        OQ = (n, e) =>
          bt.create({
            name: "bubbleLinkForm",
            defaultOptions: { element: null, tippyOptions: {}, pluginKey: AQ },
            addStorage: () => ({ show: !0 }),
            addCommands() {
              return {
                toogleLinkForm:
                  () =>
                  ({ commands: t }) => (
                    (this.storage.show = !this.storage.show), t.setHighlight()
                  ),
              };
            },
            addProseMirrorPlugins() {
              const t = e.createComponent(IQ);
              return (
                t.changeDetectorRef.detectChanges(),
                [
                  xQ({
                    pluginKey: this.options.pluginKey,
                    editor: this.editor,
                    element: t.location.nativeElement,
                    tippyOptions: this.options.tippyOptions,
                    storage: this.storage,
                    component: t,
                  }),
                ]
              );
            },
          });
      class Fk {
        constructor({
          editor: e,
          element: t,
          view: i,
          tippyOptions: r = {},
          shouldShow: o,
        }) {
          (this.preventHide = !1),
            (this.shouldShow = ({ view: s, state: a, from: l, to: c }) => {
              const { doc: u, selection: d } = a,
                { empty: h } = d,
                f = !u.textBetween(l, c).length && s_(a.selection);
              return !(!s.hasFocus() || h || f);
            }),
            (this.mousedownHandler = () => {
              this.preventHide = !0;
            }),
            (this.dragstartHandler = () => {
              this.hide();
            }),
            (this.focusHandler = () => {
              setTimeout(() => this.update(this.editor.view));
            }),
            (this.blurHandler = ({ event: s }) => {
              var a;
              this.preventHide
                ? (this.preventHide = !1)
                : (s?.relatedTarget &&
                    (null === (a = this.element.parentNode) || void 0 === a
                      ? void 0
                      : a.contains(s.relatedTarget))) ||
                  this.hide();
            }),
            (this.editor = e),
            (this.element = t),
            (this.view = i),
            o && (this.shouldShow = o),
            this.element.addEventListener("mousedown", this.mousedownHandler, {
              capture: !0,
            }),
            this.view.dom.addEventListener("dragstart", this.dragstartHandler),
            this.editor.on("focus", this.focusHandler),
            this.editor.on("blur", this.blurHandler),
            (this.tippyOptions = r),
            this.element.remove(),
            (this.element.style.visibility = "visible");
        }
        createTooltip() {
          const { element: e } = this.editor.options;
          this.tippy ||
            !e.parentElement ||
            ((this.tippy = su(e, {
              duration: 0,
              getReferenceClientRect: null,
              content: this.element,
              interactive: !0,
              trigger: "manual",
              placement: "top",
              hideOnClick: "toggle",
              ...this.tippyOptions,
            })),
            this.tippy.popper.firstChild &&
              this.tippy.popper.firstChild.addEventListener("blur", (i) => {
                this.blurHandler({ event: i });
              }));
        }
        update(e, t) {
          var i, r, o;
          const { state: s, composing: a } = e,
            { doc: l, selection: c } = s,
            u = t && t.doc.eq(l) && t.selection.eq(c);
          if (a || u) return;
          this.createTooltip();
          const { ranges: d } = c,
            h = Math.min(...d.map((g) => g.$from.pos)),
            f = Math.max(...d.map((g) => g.$to.pos));
          (
            null === (i = this.shouldShow) || void 0 === i
              ? void 0
              : i.call(this, {
                  editor: this.editor,
                  view: e,
                  state: s,
                  oldState: t,
                  from: h,
                  to: f,
                })
          )
            ? (null === (r = this.tippy) ||
                void 0 === r ||
                r.setProps({
                  getReferenceClientRect:
                    (null === (o = this.tippyOptions) || void 0 === o
                      ? void 0
                      : o.getReferenceClientRect) ||
                    (() => {
                      if (YA(s.selection)) {
                        const g = e.nodeDOM(h);
                        if (g) return g.getBoundingClientRect();
                      }
                      return Fc(e, h, f);
                    }),
                }),
              this.show())
            : this.hide();
        }
        show() {
          var e;
          null === (e = this.tippy) || void 0 === e || e.show();
        }
        hide() {
          var e;
          null === (e = this.tippy) || void 0 === e || e.hide();
        }
        destroy() {
          var e;
          null === (e = this.tippy) || void 0 === e || e.destroy(),
            this.element.removeEventListener(
              "mousedown",
              this.mousedownHandler,
              { capture: !0 }
            ),
            this.view.dom.removeEventListener(
              "dragstart",
              this.dragstartHandler
            ),
            this.editor.off("focus", this.focusHandler),
            this.editor.off("blur", this.blurHandler);
        }
      }
      const kQ = (n) =>
          new Qe({
            key:
              "string" == typeof n.pluginKey
                ? new It(n.pluginKey)
                : n.pluginKey,
            view: (e) => new Fk({ view: e, ...n }),
          }),
        NQ = bt.create({
          name: "bubbleMenu",
          addOptions: () => ({
            element: null,
            tippyOptions: {},
            pluginKey: "bubbleMenu",
            shouldShow: null,
          }),
          addProseMirrorPlugins() {
            return this.options.element
              ? [
                  kQ({
                    pluginKey: this.options.pluginKey,
                    editor: this.editor,
                    element: this.options.element,
                    tippyOptions: this.options.tippyOptions,
                    shouldShow: this.options.shouldShow,
                  }),
                ]
              : [];
          },
        }),
        RQ = ({ editor: n, state: e, from: t, to: i }) => {
          const { doc: r, selection: o } = e,
            { empty: s } = o,
            a = n.state.doc.nodeAt(n.state.selection.from),
            l = !r.textBetween(t, i).length && s_(e.selection);
          return !(!n.isFocused || s || l || "dotContent" == a?.type.name);
        },
        Lk = (n) => n.isActive("bulletList") || n.isActive("orderedList"),
        FQ = [
          { icon: "format_bold", markAction: "bold", active: !1 },
          { icon: "format_underlined", markAction: "underline", active: !1 },
          { icon: "format_italic", markAction: "italic", active: !1 },
          {
            icon: "strikethrough_s",
            markAction: "strike",
            active: !1,
            divider: !0,
          },
          { icon: "format_align_left", markAction: "left", active: !1 },
          { icon: "format_align_center", markAction: "center", active: !1 },
          {
            icon: "format_align_right",
            markAction: "right",
            active: !1,
            divider: !0,
          },
          {
            icon: "format_list_bulleted",
            markAction: "bulletList",
            active: !1,
          },
          {
            icon: "format_list_numbered",
            markAction: "orderedList",
            active: !1,
          },
          { icon: "format_indent_decrease", markAction: "outdent", active: !1 },
          {
            icon: "format_indent_increase",
            markAction: "indent",
            active: !1,
            divider: !0,
          },
          { icon: "link", markAction: "link", active: !1, divider: !0 },
          {
            icon: "format_clear",
            markAction: "clearAll",
            active: !1,
            divider: !0,
          },
          { icon: "delete", markAction: "deleteNode", active: !1 },
        ],
        LQ = [
          { icon: "format_align_left", markAction: "left", active: !1 },
          { icon: "format_align_center", markAction: "center", active: !1 },
          {
            icon: "format_align_right",
            markAction: "right",
            active: !1,
            divider: !0,
          },
          { icon: "link", markAction: "link", active: !1, divider: !0 },
          { icon: "delete", markAction: "deleteNode", active: !1, divider: !1 },
        ],
        VQ = [
          { name: "offset", options: { offset: [0, 5] } },
          {
            name: "flip",
            options: { fallbackPlacements: ["bottom-start", "top-start"] },
          },
          { name: "preventOverflow", options: { altAxis: !0, tether: !0 } },
        ],
        Vk = (n, e) => {
          let i,
            t = n.depth;
          do {
            if (((i = n.node(t)), i)) {
              if (Array.isArray(e) && e.includes(i.type.name)) break;
              t--;
            }
          } while (t > 0 && i);
          return i;
        },
        BQ = (n) => {
          const e = n.component.instance,
            t = n.changeToComponent.instance;
          return new Qe({
            key:
              "string" == typeof n.pluginKey
                ? new It(n.pluginKey)
                : n.pluginKey,
            view: (i) => new jQ({ view: i, ...n }),
            props: {
              handleKeyDown(i, r) {
                const { key: o } = r;
                if (t.isOpen) {
                  if ("Escape" === o) return e.toggleChangeTo.emit(), !0;
                  if ("Enter" === o) return t.execCommand(), !0;
                  if ("ArrowDown" === o || "ArrowUp" === o)
                    return t.updateSelection(r), !0;
                }
                return !1;
              },
            },
          });
        };
      class jQ extends Fk {
        constructor(e) {
          super(e),
            (this.shouldShowProp = !1),
            (this.updateActiveItems = (r = [], o) =>
              r.map((s) => ((s.active = o.includes(s.markAction)), s))),
            (this.enabledMarks = () => [
              ...Object.keys(this.editor.schema.marks),
              ...Object.keys(this.editor.schema.nodes),
            ]),
            (this.setActiveMarks = (r = []) => [
              ...this.enabledMarks().filter((o) => this.editor.isActive(o)),
              ...r.filter((o) => this.editor.isActive({ textAlign: o })),
            ]);
          const { component: t, changeToComponent: i } = e;
          (this.component = t),
            (this.changeTo = i),
            (this.changeToElement = this.changeTo.location.nativeElement),
            this.component.instance.command.subscribe(
              this.exeCommand.bind(this)
            ),
            this.component.instance.toggleChangeTo.subscribe(
              this.toggleChangeTo.bind(this)
            ),
            (this.changeTo.instance.items = this.setChangeToOptions()),
            (this.changeTo.instance.title = "Change To"),
            this.changeToElement.remove(),
            this.changeTo.changeDetectorRef.detectChanges(),
            document.body.addEventListener(
              "scroll",
              this.hanlderScroll.bind(this),
              !0
            ),
            document.body.addEventListener(
              "mouseup",
              this.showMenu.bind(this),
              !0
            ),
            document.body.addEventListener(
              "keyup",
              this.showMenu.bind(this),
              !0
            );
        }
        showMenu() {
          this.shouldShowProp &&
            (this.tippyChangeTo?.setProps({
              getReferenceClientRect: () =>
                this.tippy?.popper.getBoundingClientRect(),
            }),
            this.show());
        }
        update(e, t) {
          const { state: i, composing: r } = e,
            { doc: o, selection: s } = i,
            a = t && t.doc.eq(o) && t.selection.eq(s);
          if (r || a) return;
          this.createTooltip(), this.createChangeToTooltip();
          const { ranges: l } = s;
          (this.selectionRange = l[0]),
            (this.selectionNodesCount = 0),
            o.nodesBetween(
              this.selectionRange.$from.pos,
              this.selectionRange.$to.pos,
              (d, h) => {
                d.isBlock && this.selectionNodesCount++;
              }
            );
          const c = Math.min(...l.map((d) => d.$from.pos)),
            u = Math.max(...l.map((d) => d.$to.pos));
          if (
            ((this.shouldShowProp = this.shouldShow?.({
              editor: this.editor,
              view: e,
              state: i,
              oldState: t,
              from: c,
              to: u,
            })),
            !this.shouldShowProp)
          )
            return this.hide(), void this.tippyChangeTo?.hide();
          this.tippy?.setProps({
            getReferenceClientRect: () => {
              if (YA(s)) {
                const d = e.nodeDOM(c);
                if (d)
                  return ((n, e) => {
                    const t = n.getElementsByTagName("img")[0];
                    return "dotImage" === e && t
                      ? t.getBoundingClientRect()
                      : n.getBoundingClientRect();
                  })(d, o.nodeAt(c).type.name);
              }
              return Fc(e, c, u);
            },
          }),
            this.updateComponent(),
            this.setMenuItems(o, c);
        }
        destroy() {
          this.tippy?.destroy(),
            this.tippyChangeTo?.destroy(),
            this.element.removeEventListener(
              "mousedown",
              this.mousedownHandler,
              { capture: !0 }
            ),
            this.view.dom.removeEventListener(
              "dragstart",
              this.dragstartHandler
            ),
            this.editor.off("focus", this.focusHandler),
            this.editor.off("blur", this.blurHandler),
            this.component.instance.command.unsubscribe(),
            this.component.instance.toggleChangeTo.unsubscribe(),
            this.component.destroy(),
            this.changeTo.destroy(),
            document.body.removeEventListener(
              "scroll",
              this.hanlderScroll.bind(this),
              !0
            ),
            document.body.removeEventListener(
              "mouseup",
              this.showMenu.bind(this),
              !0
            ),
            document.body.removeEventListener(
              "keyup",
              this.showMenu.bind(this),
              !0
            );
        }
        updateComponent() {
          const { items: e } = this.component.instance,
            i = this.setActiveMarks(["left", "center", "right"]);
          this.setSelectedNodeItem(),
            (this.component.instance.items = this.updateActiveItems(e, i)),
            this.component.changeDetectorRef.detectChanges();
        }
        setMenuItems(e, t) {
          const i = e.nodeAt(t),
            r = "dotImage" == i?.type.name;
          (this.selectionNode = i),
            (this.component.instance.items = r ? LQ : FQ);
        }
        exeCommand(e) {
          const { markAction: t, active: i } = e;
          switch (t) {
            case "bold":
              this.editor.commands.toggleBold();
              break;
            case "italic":
              this.editor.commands.toggleItalic();
              break;
            case "strike":
              this.editor.commands.toggleStrike();
              break;
            case "underline":
              this.editor.commands.toggleUnderline();
              break;
            case "left":
            case "center":
            case "right":
              this.toggleTextAlign(t, i);
              break;
            case "bulletList":
              this.editor.commands.toggleBulletList();
              break;
            case "orderedList":
              this.editor.commands.toggleOrderedList();
              break;
            case "indent":
              Lk(this.editor) && this.editor.commands.sinkListItem("listItem");
              break;
            case "outdent":
              Lk(this.editor) && this.editor.commands.liftListItem("listItem");
              break;
            case "link":
              this.editor.commands.toogleLinkForm();
              break;
            case "deleteNode":
              this.selectionNodesCount > 1
                ? this.deleteByRange()
                : this.deleteByNode();
              break;
            case "clearAll":
              this.editor.commands.unsetAllMarks(),
                this.editor.commands.clearNodes();
          }
        }
        toggleTextAlign(e, t) {
          t
            ? this.editor.commands.unsetTextAlign()
            : this.editor.commands.setTextAlign(e);
        }
        setChangeToOptions() {
          const e = Nk.filter((i) => "horizontalLine" != i.id),
            t = {
              heading1: () => {
                this.editor
                  .chain()
                  .focus()
                  .clearNodes()
                  .setHeading({ level: 1 })
                  .run();
              },
              heading2: () => {
                this.editor
                  .chain()
                  .focus()
                  .clearNodes()
                  .setHeading({ level: 2 })
                  .run();
              },
              heading3: () => {
                this.editor
                  .chain()
                  .focus()
                  .clearNodes()
                  .setHeading({ level: 3 })
                  .run();
              },
              paragraph: () => {
                this.editor.chain().focus().clearNodes().setParagraph().run();
              },
              orderedList: () => {
                this.editor
                  .chain()
                  .focus()
                  .clearNodes()
                  .toggleOrderedList()
                  .run();
              },
              bulletList: () => {
                this.editor
                  .chain()
                  .focus()
                  .clearNodes()
                  .toggleBulletList()
                  .run();
              },
              blockquote: () => {
                this.editor
                  .chain()
                  .focus()
                  .clearNodes()
                  .toggleBlockquote()
                  .run();
              },
              codeBlock: () => {
                this.editor
                  .chain()
                  .focus()
                  .clearNodes()
                  .toggleCodeBlock()
                  .run();
              },
            };
          return (
            e.forEach((i) => {
              (i.isActive = () =>
                i.id.includes("heading")
                  ? this.editor.isActive("heading", i.attributes)
                  : this.editor.isActive(i.id)),
                (i.command = () => {
                  t[i.id](),
                    this.tippyChangeTo.hide(),
                    this.setSelectedNodeItem();
                });
            }),
            e
          );
        }
        setSelectedNodeItem() {
          const e = this.changeTo.instance.items,
            t = e.filter((r) => r?.isActive()),
            i = t.length > 1 ? t[1] : t[0];
          this.changeTo.instance.updateActiveItem(e.findIndex((r) => r === i)),
            (this.component.instance.selected = i?.label || "");
        }
        createChangeToTooltip() {
          const { element: e } = this.editor.options;
          this.tippyChangeTo ||
            !e ||
            (this.tippyChangeTo = su(e, {
              ...this.tippyOptions,
              appendTo: document.body,
              getReferenceClientRect: null,
              content: this.changeToElement,
              placement: "bottom-start",
              duration: 0,
              hideOnClick: !1,
              popperOptions: { modifiers: VQ },
              onHide: () => {
                this.changeTo.instance.isOpen = !1;
              },
              onShow: () => {
                (this.changeTo.instance.isOpen = !0),
                  this.setSelectedNodeItem();
              },
            }));
        }
        toggleChangeTo() {
          this.tippyChangeTo.state.isVisible
            ? this.tippyChangeTo?.hide()
            : this.tippyChangeTo?.show();
        }
        hanlderScroll() {
          this.tippyChangeTo?.state.isVisible && this.tippyChangeTo?.hide();
        }
        deleteByNode() {
          ZQ.includes(this.selectionNode.type.name)
            ? this.deleteSelectedCustomNodeType()
            : this.deleteSelectionNode();
        }
        deleteByRange() {
          const e = this.selectionRange.$from.pos,
            t = this.selectionRange.$to.pos + 1;
          this.editor.chain().deleteRange({ from: e, to: t }).blur().run();
        }
        deleteSelectedCustomNodeType() {
          const e = this.selectionRange.$from.pos,
            t = e + 1;
          this.editor.chain().deleteRange({ from: e, to: t }).blur().run();
        }
        deleteSelectionNode() {
          const e = Vk(this.selectionRange.$from);
          switch (e.type.name) {
            case dr.ORDERED_LIST:
            case dr.BULLET_LIST:
              const i = Vk(this.selectionRange.$from, [
                  dr.ORDERED_LIST,
                  dr.BULLET_LIST,
                ]),
                { childCount: r } = i;
              r > 1
                ? this.editor.chain().deleteNode(dr.LIST_ITEM).blur().run()
                : this.editor.chain().deleteNode(i.type).blur().run();
              break;
            default:
              this.editor.chain().deleteNode(e.type).blur().run();
          }
        }
      }
      const HQ = {
        duration: 500,
        maxWidth: "none",
        placement: "top-start",
        trigger: "manual",
        interactive: !0,
      };
      function UQ(n) {
        const e = n.createComponent(pY),
          t = e.location.nativeElement,
          i = n.createComponent(H1),
          r = i.location.nativeElement;
        return NQ.extend({
          addOptions: () => ({
            element: null,
            tippyOptions: HQ,
            pluginKey: "bubbleMenu",
            shouldShow: RQ,
          }),
          addProseMirrorPlugins() {
            return t
              ? [
                  BQ({
                    component: e,
                    changeToComponent: i,
                    pluginKey: this.options.pluginKey,
                    editor: this.editor,
                    element: t,
                    changeToElement: r,
                    tippyOptions: this.options.tippyOptions,
                    shouldShow: this.options.shouldShow,
                  }),
                ]
              : [];
          },
        });
      }
      let zQ = (() => {
        class n {
          transform({ live: t, working: i, deleted: r, hasLiveVersion: o }) {
            return { live: t, working: i, deleted: r, hasLiveVersion: o };
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)();
          }),
          (n.ɵpipe = nn({ name: "contentletState", type: n, pure: !0 })),
          n
        );
      })();
      function $Q(n, e) {
        if ((1 & n && Lt(0, "dot-contentlet-thumbnail", 3), 2 & n)) {
          const t = V();
          A("width", 94)("height", 94)("iconSize", "72px")(
            "contentlet",
            t.data
          );
        }
      }
      function WQ(n, e) {
        if ((1 & n && (H(0, "h3"), ze(1), z()), 2 & n)) {
          const t = V();
          O(1), _n(t.data.title);
        }
      }
      function GQ(n, e) {
        if ((1 & n && (H(0, "span"), ze(1), z()), 2 & n)) {
          const t = V();
          O(1), _n(t.data.contentType);
        }
      }
      function qQ(n, e) {
        if (
          (1 & n &&
            (H(0, "div", 4),
            Lt(1, "dot-state-icon", 5),
            Sd(2, "contentletState"),
            H(3, "dot-badge", 6),
            ze(4),
            Sd(5, "lowercase"),
            z()()),
          2 & n)
        ) {
          const t = V();
          O(1),
            A("state", Tm(2, 3, t.data)),
            O(2),
            A("bordered", !0),
            O(1),
            _n(Tm(5, 5, t.data.language));
        }
      }
      let KQ = (() => {
        class n extends hb {
          ngOnInit() {
            this.data = this.node.attrs.data;
          }
        }
        return (
          (n.ɵfac = (function () {
            let e;
            return function (i) {
              return (e || (e = Nt(n)))(i || n);
            };
          })()),
          (n.ɵcmp = ht({
            type: n,
            selectors: [["dotcms-contentlet-block"]],
            features: [we],
            decls: 5,
            vars: 2,
            consts: [
              ["pTemplate", "header"],
              [4, "pTemplate"],
              ["pTemplate", "footer"],
              [3, "width", "height", "iconSize", "contentlet"],
              [1, "state"],
              ["size", "16px", 3, "state"],
              [3, "bordered"],
            ],
            template: function (t, i) {
              1 & t &&
                (H(0, "p-card"),
                U(1, $Q, 1, 4, "ng-template", 0),
                U(2, WQ, 2, 1, "h3", 1),
                U(3, GQ, 2, 1, "span", 1),
                U(4, qQ, 6, 7, "ng-template", 2),
                z()),
                2 & t &&
                  (O(2),
                  A("pTemplate", "title"),
                  O(1),
                  A("pTemplate", "subtitle"));
            },
            dependencies: [yK, $y, ZS, zQ],
            styles: [
              "dotcms-contentlet-block{display:block;height:100%;width:100%;box-sizing:border-box;margin-bottom:1rem}.p-card{background:#ffffff;border:1px solid #b3b1b8;color:#0a0725;display:flex}.p-card .p-card-header{box-sizing:border-box;min-width:110px;padding:.5rem;width:110px}.p-card .p-card-body{box-sizing:border-box;min-width:100px;padding:1rem 1.5rem 1rem 1rem;flex:1}.p-card .p-card-body .p-card-content{padding:0}.p-card .p-card-content{padding:1rem 0}.p-card .p-card-title{overflow:hidden;width:100%}.p-card .p-card-title h3{font-size:1.5rem;overflow:hidden;font-weight:700;margin:0;margin-bottom:.5rem;text-overflow:ellipsis;white-space:nowrap}.p-card .p-card-subtitle{color:#7e7a86;font-size:.85rem;font-weight:regular;margin-bottom:1rem}.p-card dot-contentlet-thumbnail{align-items:center;display:block;position:relative;width:94px;height:94px}.p-card .state{align-items:center;display:flex}.p-card .state>*{margin-right:.5rem}.p-card .state>*:last-child{margin-right:0}\n",
            ],
            encapsulation: 2,
          })),
          n
        );
      })();
      const YQ = (n) =>
          en.create({
            name: "dotContent",
            group: "block",
            inline: !1,
            draggable: !0,
            addAttributes: () => ({
              data: {
                default: null,
                parseHTML: (e) => ({ data: e.getAttribute("data") }),
                renderHTML: (e) => ({ data: e.data }),
              },
            }),
            parseHTML: () => [{ tag: "dotcms-contentlet-block" }],
            renderHTML: ({ HTMLAttributes: e }) => [
              "dotcms-contentlet-block",
              _t(e),
            ],
            addNodeView: () => Pk(KQ, { injector: n }),
          }),
        Bk = 1;
      var dr = (() => (
        (function (n) {
          (n.DOT_IMAGE = "dotImage"),
            (n.LIST_ITEM = "listItem"),
            (n.BULLET_LIST = "bulletList"),
            (n.ORDERED_LIST = "orderedList"),
            (n.BLOCKQUOTE = "blockquote"),
            (n.CODE_BLOCK = "codeBlock"),
            (n.DOC = "doc"),
            (n.DOT_CONTENT = "dotContent"),
            (n.PARAGRAPH = "paragraph"),
            (n.HARD_BREAK = "hardBreak"),
            (n.HEADING = "heading"),
            (n.HORIZONTAL_RULE = "horizontalRule"),
            (n.TEXT = "text");
        })(dr || (dr = {})),
        dr
      ))();
      const ZQ = [dr.DOT_IMAGE, dr.DOT_CONTENT],
        QQ = /(?:^|\s)((?:==)((?:[^~=]+))(?:==))$/,
        JQ = /(?:^|\s)((?:==)((?:[^~=]+))(?:==))/g,
        XQ = nr.create({
          name: "highlight",
          addOptions: () => ({ multicolor: !1, HTMLAttributes: {} }),
          addAttributes() {
            return this.options.multicolor
              ? {
                  color: {
                    default: null,
                    parseHTML: (n) =>
                      n.getAttribute("data-color") || n.style.backgroundColor,
                    renderHTML: (n) =>
                      n.color
                        ? {
                            "data-color": n.color,
                            style: `background-color: ${n.color}`,
                          }
                        : {},
                  },
                }
              : {};
          },
          parseHTML: () => [{ tag: "mark" }],
          renderHTML({ HTMLAttributes: n }) {
            return ["mark", _t(this.options.HTMLAttributes, n), 0];
          },
          addCommands() {
            return {
              setHighlight:
                (n) =>
                ({ commands: e }) =>
                  e.setMark(this.name, n),
              toggleHighlight:
                (n) =>
                ({ commands: e }) =>
                  e.toggleMark(this.name, n),
              unsetHighlight:
                () =>
                ({ commands: n }) =>
                  n.unsetMark(this.name),
            };
          },
          addKeyboardShortcuts() {
            return {
              "Mod-Shift-h": () => this.editor.commands.toggleHighlight(),
            };
          },
          addInputRules() {
            return [ps({ find: QQ, type: this.type })];
          },
          addPasteRules() {
            return [Co({ find: JQ, type: this.type })];
          },
        });
      function pb(n) {
        (this.j = {}), (this.jr = []), (this.jd = null), (this.t = n);
      }
      pb.prototype = {
        accepts: function () {
          return !!this.t;
        },
        tt: function (e, t) {
          if (t && t.j) return (this.j[e] = t), t;
          var i = t,
            r = this.j[e];
          if (r) return i && (r.t = i), r;
          r = Pe();
          var o = Of(this, e);
          return (
            o
              ? (Object.assign(r.j, o.j),
                r.jr.append(o.jr),
                (r.jr = o.jd),
                (r.t = i || o.t))
              : (r.t = i),
            (this.j[e] = r),
            r
          );
        },
      };
      var Pe = function () {
          return new pb();
        },
        Z = function (e) {
          return new pb(e);
        },
        x = function (e, t, i) {
          e.j[t] || (e.j[t] = i);
        },
        Ft = function (e, t, i) {
          e.jr.push([t, i]);
        },
        Of = function (e, t) {
          var i = e.j[t];
          if (i) return i;
          for (var r = 0; r < e.jr.length; r++) {
            var s = e.jr[r][1];
            if (e.jr[r][0].test(t)) return s;
          }
          return e.jd;
        },
        ge = function (e, t, i) {
          for (var r = 0; r < t.length; r++) x(e, t[r], i);
        },
        eJ = function (e, t) {
          for (var i = 0; i < t.length; i++) x(e, t[i][0], t[i][1]);
        },
        ws = function (e, t, i, r) {
          for (var a, o = 0, s = t.length; o < s && (a = e.j[t[o]]); )
            (e = a), o++;
          if (o >= s) return [];
          for (; o < s - 1; ) (a = r()), x(e, t[o], a), (e = a), o++;
          x(e, t[s - 1], i);
        },
        xi = "DOMAIN",
        Pr = "LOCALHOST",
        hr = "TLD",
        oi = "NUM",
        Qa = "PROTOCOL",
        gb = "MAILTO",
        Ja = "OPENBRACE",
        au = "OPENBRACKET",
        lu = "OPENANGLEBRACKET",
        cu = "OPENPAREN",
        Ss = "CLOSEBRACE",
        Xa = "CLOSEBRACKET",
        el = "CLOSEANGLEBRACKET",
        tl = "CLOSEPAREN",
        kf = "AMPERSAND",
        Nf = "APOSTROPHE",
        Rf = "ASTERISK",
        nl = "AT",
        Pf = "BACKSLASH",
        Ff = "BACKTICK",
        Lf = "CARET",
        uu = "COLON",
        yb = "COMMA",
        Vf = "DOLLAR",
        Oo = "DOT",
        Bf = "EQUALS",
        vb = "EXCLAMATION",
        jf = "HYPHEN",
        Hf = "PERCENT",
        Uf = "PIPE",
        zf = "PLUS",
        $f = "POUND",
        Wf = "QUERY",
        _b = "QUOTE",
        bb = "SEMI",
        Fr = "SLASH",
        Gf = "TILDE",
        qf = "UNDERSCORE",
        Kf = "SYM",
        tJ = Object.freeze({
          __proto__: null,
          DOMAIN: xi,
          LOCALHOST: Pr,
          TLD: hr,
          NUM: oi,
          PROTOCOL: Qa,
          MAILTO: gb,
          WS: "WS",
          NL: "NL",
          OPENBRACE: Ja,
          OPENBRACKET: au,
          OPENANGLEBRACKET: lu,
          OPENPAREN: cu,
          CLOSEBRACE: Ss,
          CLOSEBRACKET: Xa,
          CLOSEANGLEBRACKET: el,
          CLOSEPAREN: tl,
          AMPERSAND: kf,
          APOSTROPHE: Nf,
          ASTERISK: Rf,
          AT: nl,
          BACKSLASH: Pf,
          BACKTICK: Ff,
          CARET: Lf,
          COLON: uu,
          COMMA: yb,
          DOLLAR: Vf,
          DOT: Oo,
          EQUALS: Bf,
          EXCLAMATION: vb,
          HYPHEN: jf,
          PERCENT: Hf,
          PIPE: Uf,
          PLUS: zf,
          POUND: $f,
          QUERY: Wf,
          QUOTE: _b,
          SEMI: bb,
          SLASH: Fr,
          TILDE: Gf,
          UNDERSCORE: qf,
          SYM: Kf,
        }),
        Hk =
          "aaa aarp abarth abb abbott abbvie abc able abogado abudhabi ac academy accenture accountant accountants aco actor ad adac ads adult ae aeg aero aetna af afamilycompany afl africa ag agakhan agency ai aig airbus airforce airtel akdn al alfaromeo alibaba alipay allfinanz allstate ally alsace alstom am amazon americanexpress americanfamily amex amfam amica amsterdam analytics android anquan anz ao aol apartments app apple aq aquarelle ar arab aramco archi army arpa art arte as asda asia associates at athleta attorney au auction audi audible audio auspost author auto autos avianca aw aws ax axa az azure ba baby baidu banamex bananarepublic band bank bar barcelona barclaycard barclays barefoot bargains baseball basketball bauhaus bayern bb bbc bbt bbva bcg bcn bd be beats beauty beer bentley berlin best bestbuy bet bf bg bh bharti bi bible bid bike bing bingo bio biz bj black blackfriday blockbuster blog bloomberg blue bm bms bmw bn bnpparibas bo boats boehringer bofa bom bond boo book booking bosch bostik boston bot boutique box br bradesco bridgestone broadway broker brother brussels bs bt budapest bugatti build builders business buy buzz bv bw by bz bzh ca cab cafe cal call calvinklein cam camera camp cancerresearch canon capetown capital capitalone car caravan cards care career careers cars casa case cash casino cat catering catholic cba cbn cbre cbs cc cd center ceo cern cf cfa cfd cg ch chanel channel charity chase chat cheap chintai christmas chrome church ci cipriani circle cisco citadel citi citic city cityeats ck cl claims cleaning click clinic clinique clothing cloud club clubmed cm cn co coach codes coffee college cologne com comcast commbank community company compare computer comsec condos construction consulting contact contractors cooking cookingchannel cool coop corsica country coupon coupons courses cpa cr credit creditcard creditunion cricket crown crs cruise cruises csc cu cuisinella cv cw cx cy cymru cyou cz dabur dad dance data date dating datsun day dclk dds de deal dealer deals degree delivery dell deloitte delta democrat dental dentist desi design dev dhl diamonds diet digital direct directory discount discover dish diy dj dk dm dnp do docs doctor dog domains dot download drive dtv dubai duck dunlop dupont durban dvag dvr dz earth eat ec eco edeka edu education ee eg email emerck energy engineer engineering enterprises epson equipment er ericsson erni es esq estate et etisalat eu eurovision eus events exchange expert exposed express extraspace fage fail fairwinds faith family fan fans farm farmers fashion fast fedex feedback ferrari ferrero fi fiat fidelity fido film final finance financial fire firestone firmdale fish fishing fit fitness fj fk flickr flights flir florist flowers fly fm fo foo food foodnetwork football ford forex forsale forum foundation fox fr free fresenius frl frogans frontdoor frontier ftr fujitsu fujixerox fun fund furniture futbol fyi ga gal gallery gallo gallup game games gap garden gay gb gbiz gd gdn ge gea gent genting george gf gg ggee gh gi gift gifts gives giving gl glade glass gle global globo gm gmail gmbh gmo gmx gn godaddy gold goldpoint golf goo goodyear goog google gop got gov gp gq gr grainger graphics gratis green gripe grocery group gs gt gu guardian gucci guge guide guitars guru gw gy hair hamburg hangout haus hbo hdfc hdfcbank health healthcare help helsinki here hermes hgtv hiphop hisamitsu hitachi hiv hk hkt hm hn hockey holdings holiday homedepot homegoods homes homesense honda horse hospital host hosting hot hoteles hotels hotmail house how hr hsbc ht hu hughes hyatt hyundai ibm icbc ice icu id ie ieee ifm ikano il im imamat imdb immo immobilien in inc industries infiniti info ing ink institute insurance insure int international intuit investments io ipiranga iq ir irish is ismaili ist istanbul it itau itv iveco jaguar java jcb je jeep jetzt jewelry jio jll jm jmp jnj jo jobs joburg jot joy jp jpmorgan jprs juegos juniper kaufen kddi ke kerryhotels kerrylogistics kerryproperties kfh kg kh ki kia kim kinder kindle kitchen kiwi km kn koeln komatsu kosher kp kpmg kpn kr krd kred kuokgroup kw ky kyoto kz la lacaixa lamborghini lamer lancaster lancia land landrover lanxess lasalle lat latino latrobe law lawyer lb lc lds lease leclerc lefrak legal lego lexus lgbt li lidl life lifeinsurance lifestyle lighting like lilly limited limo lincoln linde link lipsy live living lixil lk llc llp loan loans locker locus loft lol london lotte lotto love lpl lplfinancial lr ls lt ltd ltda lu lundbeck luxe luxury lv ly ma macys madrid maif maison makeup man management mango map market marketing markets marriott marshalls maserati mattel mba mc mckinsey md me med media meet melbourne meme memorial men menu merckmsd mg mh miami microsoft mil mini mint mit mitsubishi mk ml mlb mls mm mma mn mo mobi mobile moda moe moi mom monash money monster mormon mortgage moscow moto motorcycles mov movie mp mq mr ms msd mt mtn mtr mu museum mutual mv mw mx my mz na nab nagoya name nationwide natura navy nba nc ne nec net netbank netflix network neustar new news next nextdirect nexus nf nfl ng ngo nhk ni nico nike nikon ninja nissan nissay nl no nokia northwesternmutual norton now nowruz nowtv np nr nra nrw ntt nu nyc nz obi observer off office okinawa olayan olayangroup oldnavy ollo om omega one ong onl online onyourside ooo open oracle orange org organic origins osaka otsuka ott ovh pa page panasonic paris pars partners parts party passagens pay pccw pe pet pf pfizer pg ph pharmacy phd philips phone photo photography photos physio pics pictet pictures pid pin ping pink pioneer pizza pk pl place play playstation plumbing plus pm pn pnc pohl poker politie porn post pr pramerica praxi press prime pro prod productions prof progressive promo properties property protection pru prudential ps pt pub pw pwc py qa qpon quebec quest qvc racing radio raid re read realestate realtor realty recipes red redstone redumbrella rehab reise reisen reit reliance ren rent rentals repair report republican rest restaurant review reviews rexroth rich richardli ricoh ril rio rip rmit ro rocher rocks rodeo rogers room rs rsvp ru rugby ruhr run rw rwe ryukyu sa saarland safe safety sakura sale salon samsclub samsung sandvik sandvikcoromant sanofi sap sarl sas save saxo sb sbi sbs sc sca scb schaeffler schmidt scholarships school schule schwarz science scjohnson scot sd se search seat secure security seek select sener services ses seven sew sex sexy sfr sg sh shangrila sharp shaw shell shia shiksha shoes shop shopping shouji show showtime si silk sina singles site sj sk ski skin sky skype sl sling sm smart smile sn sncf so soccer social softbank software sohu solar solutions song sony soy spa space sport spot spreadbetting sr srl ss st stada staples star statebank statefarm stc stcgroup stockholm storage store stream studio study style su sucks supplies supply support surf surgery suzuki sv swatch swiftcover swiss sx sy sydney systems sz tab taipei talk taobao target tatamotors tatar tattoo tax taxi tc tci td tdk team tech technology tel temasek tennis teva tf tg th thd theater theatre tiaa tickets tienda tiffany tips tires tirol tj tjmaxx tjx tk tkmaxx tl tm tmall tn to today tokyo tools top toray toshiba total tours town toyota toys tr trade trading training travel travelchannel travelers travelersinsurance trust trv tt tube tui tunes tushu tv tvs tw tz ua ubank ubs ug uk unicom university uno uol ups us uy uz va vacations vana vanguard vc ve vegas ventures verisign versicherung vet vg vi viajes video vig viking villas vin vip virgin visa vision viva vivo vlaanderen vn vodka volkswagen volvo vote voting voto voyage vu vuelos wales walmart walter wang wanggou watch watches weather weatherchannel webcam weber website wed wedding weibo weir wf whoswho wien wiki williamhill win windows wine winners wme wolterskluwer woodside work works world wow ws wtc wtf xbox xerox xfinity xihuan xin xxx xyz yachts yahoo yamaxun yandex ye yodobashi yoga yokohama you youtube yt yun za zappos zara zero zip zm zone zuerich zw verm\xf6gensberater-ctb verm\xf6gensberatung-pwb \u03b5\u03bb \u03b5\u03c5 \u0431\u0433 \u0431\u0435\u043b \u0434\u0435\u0442\u0438 \u0435\u044e \u043a\u0430\u0442\u043e\u043b\u0438\u043a \u043a\u043e\u043c \u049b\u0430\u0437 \u043c\u043a\u0434 \u043c\u043e\u043d \u043c\u043e\u0441\u043a\u0432\u0430 \u043e\u043d\u043b\u0430\u0439\u043d \u043e\u0440\u0433 \u0440\u0443\u0441 \u0440\u0444 \u0441\u0430\u0439\u0442 \u0441\u0440\u0431 \u0443\u043a\u0440 \u10d2\u10d4 \u0570\u0561\u0575 \u05d9\u05e9\u05e8\u05d0\u05dc \u05e7\u05d5\u05dd \u0627\u0628\u0648\u0638\u0628\u064a \u0627\u062a\u0635\u0627\u0644\u0627\u062a \u0627\u0631\u0627\u0645\u0643\u0648 \u0627\u0644\u0627\u0631\u062f\u0646 \u0627\u0644\u0628\u062d\u0631\u064a\u0646 \u0627\u0644\u062c\u0632\u0627\u0626\u0631 \u0627\u0644\u0633\u0639\u0648\u062f\u064a\u0629 \u0627\u0644\u0639\u0644\u064a\u0627\u0646 \u0627\u0644\u0645\u063a\u0631\u0628 \u0627\u0645\u0627\u0631\u0627\u062a \u0627\u06cc\u0631\u0627\u0646 \u0628\u0627\u0631\u062a \u0628\u0627\u0632\u0627\u0631 \u0628\u06be\u0627\u0631\u062a \u0628\u064a\u062a\u0643 \u067e\u0627\u06a9\u0633\u062a\u0627\u0646 \u0680\u0627\u0631\u062a \u062a\u0648\u0646\u0633 \u0633\u0648\u062f\u0627\u0646 \u0633\u0648\u0631\u064a\u0629 \u0634\u0628\u0643\u0629 \u0639\u0631\u0627\u0642 \u0639\u0631\u0628 \u0639\u0645\u0627\u0646 \u0641\u0644\u0633\u0637\u064a\u0646 \u0642\u0637\u0631 \u0643\u0627\u062b\u0648\u0644\u064a\u0643 \u0643\u0648\u0645 \u0645\u0635\u0631 \u0645\u0644\u064a\u0633\u064a\u0627 \u0645\u0648\u0631\u064a\u062a\u0627\u0646\u064a\u0627 \u0645\u0648\u0642\u0639 \u0647\u0645\u0631\u0627\u0647 \u0915\u0949\u092e \u0928\u0947\u091f \u092d\u093e\u0930\u0924 \u092d\u093e\u0930\u0924\u092e\u094d \u092d\u093e\u0930\u094b\u0924 \u0938\u0902\u0917\u0920\u0928 \u09ac\u09be\u0982\u09b2\u09be \u09ad\u09be\u09b0\u09a4 \u09ad\u09be\u09f0\u09a4 \u0a2d\u0a3e\u0a30\u0a24 \u0aad\u0abe\u0ab0\u0aa4 \u0b2d\u0b3e\u0b30\u0b24 \u0b87\u0ba8\u0bcd\u0ba4\u0bbf\u0baf\u0bbe \u0b87\u0bb2\u0b99\u0bcd\u0b95\u0bc8 \u0b9a\u0bbf\u0b99\u0bcd\u0b95\u0baa\u0bcd\u0baa\u0bc2\u0bb0\u0bcd \u0c2d\u0c3e\u0c30\u0c24\u0c4d \u0cad\u0cbe\u0cb0\u0ca4 \u0d2d\u0d3e\u0d30\u0d24\u0d02 \u0dbd\u0d82\u0d9a\u0dcf \u0e04\u0e2d\u0e21 \u0e44\u0e17\u0e22 \u0ea5\u0eb2\u0ea7 \ub2f7\ub137 \ub2f7\ucef4 \uc0bc\uc131 \ud55c\uad6d \u30a2\u30de\u30be\u30f3 \u30b0\u30fc\u30b0\u30eb \u30af\u30e9\u30a6\u30c9 \u30b3\u30e0 \u30b9\u30c8\u30a2 \u30bb\u30fc\u30eb \u30d5\u30a1\u30c3\u30b7\u30e7\u30f3 \u30dd\u30a4\u30f3\u30c8 \u307f\u3093\u306a \u4e16\u754c \u4e2d\u4fe1 \u4e2d\u56fd \u4e2d\u570b \u4e2d\u6587\u7f51 \u4e9a\u9a6c\u900a \u4f01\u4e1a \u4f5b\u5c71 \u4fe1\u606f \u5065\u5eb7 \u516b\u5366 \u516c\u53f8 \u516c\u76ca \u53f0\u6e7e \u53f0\u7063 \u5546\u57ce \u5546\u5e97 \u5546\u6807 \u5609\u91cc \u5609\u91cc\u5927\u9152\u5e97 \u5728\u7ebf \u5927\u4f17\u6c7d\u8f66 \u5927\u62ff \u5929\u4e3b\u6559 \u5a31\u4e50 \u5bb6\u96fb \u5e7f\u4e1c \u5fae\u535a \u6148\u5584 \u6211\u7231\u4f60 \u624b\u673a \u62db\u8058 \u653f\u52a1 \u653f\u5e9c \u65b0\u52a0\u5761 \u65b0\u95fb \u65f6\u5c1a \u66f8\u7c4d \u673a\u6784 \u6de1\u9a6c\u9521 \u6e38\u620f \u6fb3\u9580 \u70b9\u770b \u79fb\u52a8 \u7ec4\u7ec7\u673a\u6784 \u7f51\u5740 \u7f51\u5e97 \u7f51\u7ad9 \u7f51\u7edc \u8054\u901a \u8bfa\u57fa\u4e9a \u8c37\u6b4c \u8d2d\u7269 \u901a\u8ca9 \u96c6\u56e2 \u96fb\u8a0a\u76c8\u79d1 \u98de\u5229\u6d66 \u98df\u54c1 \u9910\u5385 \u9999\u683c\u91cc\u62c9 \u9999\u6e2f".split(
            " "
          ),
        du =
          /(?:[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD50-\uDD52\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E]|\uD838[\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF38\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A])/,
        hu =
          /(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEDD-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB\uDFF0]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDDFF\uDE70-\uDE74\uDE78-\uDE7C\uDE80-\uDE86\uDE90-\uDEAC\uDEB0-\uDEBA\uDEC0-\uDEC5\uDED0-\uDED9\uDEE0-\uDEE7\uDEF0-\uDEF6])/,
        fu = /\uFE0F/,
        pu = /\d/,
        Uk = /\s/;
      function nJ() {
        var n =
            arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
          e = Pe(),
          t = Z(oi),
          i = Z(xi),
          r = Pe(),
          o = Z("WS"),
          s = [
            [pu, i],
            [du, i],
            [hu, i],
            [fu, i],
          ],
          a = function () {
            var y = Z(xi);
            return (y.j = { "-": r }), (y.jr = [].concat(s)), y;
          },
          l = function (y) {
            var D = a();
            return (D.t = y), D;
          };
        eJ(e, [
          ["'", Z(Nf)],
          ["{", Z(Ja)],
          ["[", Z(au)],
          ["<", Z(lu)],
          ["(", Z(cu)],
          ["}", Z(Ss)],
          ["]", Z(Xa)],
          [">", Z(el)],
          [")", Z(tl)],
          ["&", Z(kf)],
          ["*", Z(Rf)],
          ["@", Z(nl)],
          ["`", Z(Ff)],
          ["^", Z(Lf)],
          [":", Z(uu)],
          [",", Z(yb)],
          ["$", Z(Vf)],
          [".", Z(Oo)],
          ["=", Z(Bf)],
          ["!", Z(vb)],
          ["-", Z(jf)],
          ["%", Z(Hf)],
          ["|", Z(Uf)],
          ["+", Z(zf)],
          ["#", Z($f)],
          ["?", Z(Wf)],
          ['"', Z(_b)],
          ["/", Z(Fr)],
          [";", Z(bb)],
          ["~", Z(Gf)],
          ["_", Z(qf)],
          ["\\", Z(Pf)],
        ]),
          x(e, "\n", Z("NL")),
          Ft(e, Uk, o),
          x(o, "\n", Pe()),
          Ft(o, Uk, o);
        for (var c = 0; c < Hk.length; c++) ws(e, Hk[c], l(hr), a);
        var u = a(),
          d = a(),
          h = a(),
          f = a();
        ws(e, "file", u, a),
          ws(e, "ftp", d, a),
          ws(e, "http", h, a),
          ws(e, "mailto", f, a);
        var p = a(),
          g = Z(Qa),
          m = Z(gb);
        x(d, "s", p),
          x(d, ":", g),
          x(h, "s", p),
          x(h, ":", g),
          x(u, ":", g),
          x(p, ":", g),
          x(f, ":", m);
        for (var v = a(), _ = 0; _ < n.length; _++) ws(e, n[_], v, a);
        return (
          x(v, ":", g),
          ws(e, "localhost", l(Pr), a),
          Ft(e, pu, t),
          Ft(e, du, i),
          Ft(e, hu, i),
          Ft(e, fu, i),
          Ft(t, pu, t),
          Ft(t, du, i),
          Ft(t, hu, i),
          Ft(t, fu, i),
          x(t, "-", r),
          x(i, "-", r),
          x(r, "-", r),
          Ft(i, pu, i),
          Ft(i, du, i),
          Ft(i, hu, i),
          Ft(i, fu, i),
          Ft(r, pu, i),
          Ft(r, du, i),
          Ft(r, hu, i),
          Ft(r, fu, i),
          (e.jd = Z(Kf)),
          e
        );
      }
      var Ut = {
        defaultProtocol: "http",
        events: null,
        format: $k,
        formatHref: $k,
        nl2br: !1,
        tagName: "a",
        target: null,
        rel: null,
        validate: !0,
        truncate: 0,
        className: null,
        attributes: null,
        ignoreTags: [],
      };
      function $k(n) {
        return n;
      }
      function Zf() {}
      function Ms(n, e) {
        function t(i, r) {
          (this.t = n), (this.v = i), (this.tk = r);
        }
        return (
          (function oJ(n, e) {
            var t =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : {},
              i = Object.create(n.prototype);
            for (var r in t) i[r] = t[r];
            (i.constructor = e), (e.prototype = i);
          })(Zf, t, e),
          t
        );
      }
      Zf.prototype = {
        t: "token",
        isLink: !1,
        toString: function () {
          return this.v;
        },
        toHref: function () {
          return this.toString();
        },
        startIndex: function () {
          return this.tk[0].s;
        },
        endIndex: function () {
          return this.tk[this.tk.length - 1].e;
        },
        toObject: function () {
          var e =
            arguments.length > 0 && void 0 !== arguments[0]
              ? arguments[0]
              : Ut.defaultProtocol;
          return {
            type: this.t,
            value: this.v,
            isLink: this.isLink,
            href: this.toHref(e),
            start: this.startIndex(),
            end: this.endIndex(),
          };
        },
      };
      var Wk = Ms("email", { isLink: !0 }),
        Db = Ms("email", {
          isLink: !0,
          toHref: function () {
            return "mailto:" + this.toString();
          },
        }),
        Cb = Ms("text"),
        Gk = Ms("nl"),
        ko = Ms("url", {
          isLink: !0,
          toHref: function () {
            for (
              var e =
                  arguments.length > 0 && void 0 !== arguments[0]
                    ? arguments[0]
                    : Ut.defaultProtocol,
                t = this.tk,
                i = !1,
                r = !1,
                o = [],
                s = 0;
              t[s].t === Qa;

            )
              (i = !0), o.push(t[s].v), s++;
            for (; t[s].t === Fr; ) (r = !0), o.push(t[s].v), s++;
            for (; s < t.length; s++) o.push(t[s].v);
            return (
              (o = o.join("")), i || r || (o = "".concat(e, "://").concat(o)), o
            );
          },
          hasProtocol: function () {
            return this.tk[0].t === Qa;
          },
        }),
        sJ = Object.freeze({
          __proto__: null,
          MultiToken: Zf,
          Base: Zf,
          createTokenClass: Ms,
          MailtoEmail: Wk,
          Email: Db,
          Text: Cb,
          Nl: Gk,
          Url: ko,
        });
      function aJ() {
        var n = Pe(),
          e = Pe(),
          t = Pe(),
          i = Pe(),
          r = Pe(),
          o = Pe(),
          s = Pe(),
          a = Z(ko),
          l = Pe(),
          c = Z(ko),
          u = Z(ko),
          d = Pe(),
          h = Pe(),
          f = Pe(),
          p = Pe(),
          g = Pe(),
          m = Z(ko),
          v = Z(ko),
          _ = Z(ko),
          b = Z(ko),
          y = Pe(),
          D = Pe(),
          C = Pe(),
          R = Pe(),
          S = Pe(),
          $ = Pe(),
          X = Z(Db),
          se = Pe(),
          ve = Z(Db),
          he = Z(Wk),
          Ge = Pe(),
          qe = Pe(),
          De = Pe(),
          Je = Pe(),
          it = Z(Gk);
        x(n, "NL", it),
          x(n, Qa, e),
          x(n, gb, t),
          x(e, Fr, i),
          x(i, Fr, r),
          x(n, hr, o),
          x(n, xi, o),
          x(n, Pr, a),
          x(n, oi, o),
          x(r, hr, u),
          x(r, xi, u),
          x(r, oi, u),
          x(r, Pr, u),
          x(o, Oo, s),
          x(S, Oo, $),
          x(s, hr, a),
          x(s, xi, o),
          x(s, oi, o),
          x(s, Pr, o),
          x($, hr, X),
          x($, xi, S),
          x($, oi, S),
          x($, Pr, S),
          x(a, Oo, s),
          x(X, Oo, $),
          x(a, uu, l),
          x(a, Fr, u),
          x(l, oi, c),
          x(c, Fr, u),
          x(X, uu, se),
          x(se, oi, ve);
        var Ce = [
            kf,
            Rf,
            nl,
            Pf,
            Ff,
            Lf,
            Vf,
            xi,
            Bf,
            jf,
            Pr,
            oi,
            Hf,
            Uf,
            zf,
            $f,
            Qa,
            Fr,
            Kf,
            Gf,
            hr,
            qf,
          ],
          Ae = [Nf, el, Ss, Xa, tl, uu, yb, Oo, vb, lu, Ja, au, cu, Wf, _b, bb];
        x(u, Ja, h),
          x(u, au, f),
          x(u, lu, p),
          x(u, cu, g),
          x(d, Ja, h),
          x(d, au, f),
          x(d, lu, p),
          x(d, cu, g),
          x(h, Ss, u),
          x(f, Xa, u),
          x(p, el, u),
          x(g, tl, u),
          x(m, Ss, u),
          x(v, Xa, u),
          x(_, el, u),
          x(b, tl, u),
          x(y, Ss, u),
          x(D, Xa, u),
          x(C, el, u),
          x(R, tl, u),
          ge(h, Ce, m),
          ge(f, Ce, v),
          ge(p, Ce, _),
          ge(g, Ce, b),
          ge(h, Ae, y),
          ge(f, Ae, D),
          ge(p, Ae, C),
          ge(g, Ae, R),
          ge(m, Ce, m),
          ge(v, Ce, v),
          ge(_, Ce, _),
          ge(b, Ce, b),
          ge(m, Ae, m),
          ge(v, Ae, v),
          ge(_, Ae, _),
          ge(b, Ae, b),
          ge(y, Ce, m),
          ge(D, Ce, v),
          ge(C, Ce, _),
          ge(R, Ce, b),
          ge(y, Ae, y),
          ge(D, Ae, D),
          ge(C, Ae, C),
          ge(R, Ae, R),
          ge(u, Ce, u),
          ge(d, Ce, u),
          ge(u, Ae, d),
          ge(d, Ae, d),
          x(t, hr, he),
          x(t, xi, he),
          x(t, oi, he),
          x(t, Pr, he),
          ge(he, Ce, he),
          ge(he, Ae, Ge),
          ge(Ge, Ce, he),
          ge(Ge, Ae, Ge);
        var Tt = [
          kf,
          Nf,
          Rf,
          Pf,
          Ff,
          Lf,
          Ss,
          Vf,
          xi,
          Bf,
          jf,
          oi,
          Ja,
          Hf,
          Uf,
          zf,
          $f,
          Wf,
          Fr,
          Kf,
          Gf,
          hr,
          qf,
        ];
        return (
          ge(o, Tt, qe),
          x(o, nl, De),
          ge(a, Tt, qe),
          x(a, nl, De),
          ge(s, Tt, qe),
          ge(qe, Tt, qe),
          x(qe, nl, De),
          x(qe, Oo, Je),
          ge(Je, Tt, qe),
          x(De, hr, S),
          x(De, xi, S),
          x(De, oi, S),
          x(De, Pr, X),
          n
        );
      }
      function Eb(n, e, t) {
        var i = t[0].s;
        return new n(e.substr(i, t[t.length - 1].e - i), t);
      }
      var wb =
          (typeof console < "u" && console && console.warn) || function () {},
        nt = {
          scanner: null,
          parser: null,
          pluginQueue: [],
          customProtocols: [],
          initialized: !1,
        };
      function cJ(n) {
        if (
          (nt.initialized &&
            wb(
              'linkifyjs: already initialized - will not register custom protocol "'.concat(
                n,
                '" until you manually call linkify.init(). To avoid this warning, please register all custom protocols before invoking linkify the first time.'
              )
            ),
          !/^[a-z-]+$/.test(n))
        )
          throw Error(
            "linkifyjs: protocols containing characters other than a-z or - (hyphen) are not supported"
          );
        nt.customProtocols.push(n);
      }
      function qk(n) {
        return (
          nt.initialized ||
            (function uJ() {
              (nt.scanner = { start: nJ(nt.customProtocols), tokens: tJ }),
                (nt.parser = { start: aJ(), tokens: sJ });
              for (
                var n = { createTokenClass: Ms }, e = 0;
                e < nt.pluginQueue.length;
                e++
              )
                nt.pluginQueue[e][1]({
                  scanner: nt.scanner,
                  parser: nt.parser,
                  utils: n,
                });
              nt.initialized = !0;
            })(),
          (function lJ(n, e, t) {
            for (var i = t.length, r = 0, o = [], s = []; r < i; ) {
              for (
                var a = n, l = null, c = null, u = 0, d = null, h = -1;
                r < i && !(l = Of(a, t[r].t));

              )
                s.push(t[r++]);
              for (; r < i && (c = l || Of(a, t[r].t)); )
                (l = null),
                  (a = c).accepts() ? ((h = 0), (d = a)) : h >= 0 && h++,
                  r++,
                  u++;
              if (h < 0) for (var f = r - u; f < r; f++) s.push(t[f]);
              else {
                s.length > 0 && (o.push(Eb(Cb, e, s)), (s = []));
                var p = d.t,
                  g = t.slice((r -= h) - (u -= h), r);
                o.push(Eb(p, e, g));
              }
            }
            return s.length > 0 && o.push(Eb(Cb, e, s)), o;
          })(
            nt.parser.start,
            n,
            (function iJ(n, e) {
              for (
                var t = (function rJ(n) {
                    for (var e = [], t = n.length, i = 0; i < t; ) {
                      var r = n.charCodeAt(i),
                        o = void 0,
                        s =
                          r < 55296 ||
                          r > 56319 ||
                          i + 1 === t ||
                          (o = n.charCodeAt(i + 1)) < 56320 ||
                          o > 57343
                            ? n[i]
                            : n.slice(i, i + 2);
                      e.push(s), (i += s.length);
                    }
                    return e;
                  })(
                    e.replace(/[A-Z]/g, function (f) {
                      return f.toLowerCase();
                    })
                  ),
                  i = t.length,
                  r = [],
                  o = 0,
                  s = 0;
                s < i;

              ) {
                for (
                  var a = n, l = null, c = 0, u = null, d = -1, h = -1;
                  s < i && (l = Of(a, t[s]));

                )
                  (a = l).accepts()
                    ? ((d = 0), (h = 0), (u = a))
                    : d >= 0 && ((d += t[s].length), h++),
                    (c += t[s].length),
                    (o += t[s].length),
                    s++;
                (s -= h),
                  r.push({
                    t: u.t,
                    v: e.substr((o -= d) - (c -= d), c),
                    s: o - c,
                    e: o,
                  });
              }
              return r;
            })(nt.scanner.start, n)
          )
        );
      }
      function Sb(n) {
        for (
          var e =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : null,
            t = qk(n),
            i = [],
            r = 0;
          r < t.length;
          r++
        ) {
          var o = t[r];
          o.isLink && (!e || o.t === e) && i.push(o.toObject());
        }
        return i;
      }
      function Kk(n) {
        var e =
            arguments.length > 1 && void 0 !== arguments[1]
              ? arguments[1]
              : null,
          t = qk(n);
        return 1 === t.length && t[0].isLink && (!e || t[0].t === e);
      }
      function dJ(n) {
        return new Qe({
          key: new It("autolink"),
          appendTransaction: (e, t, i) => {
            const r = e.some((u) => u.docChanged) && !t.doc.eq(i.doc),
              o = e.some((u) => u.getMeta("preventAutolink"));
            if (!r || o) return;
            const { tr: s } = i,
              a = (function R6(n, e) {
                const t = new qT(n);
                return (
                  e.forEach((i) => {
                    i.steps.forEach((r) => {
                      t.step(r);
                    });
                  }),
                  t
                );
              })(t.doc, [...e]),
              { mapping: l } = a;
            return (
              (function V6(n) {
                const { mapping: e, steps: t } = n,
                  i = [];
                return (
                  e.maps.forEach((r, o) => {
                    const s = [];
                    if (r.ranges.length)
                      r.forEach((a, l) => {
                        s.push({ from: a, to: l });
                      });
                    else {
                      const { from: a, to: l } = t[o];
                      if (void 0 === a || void 0 === l) return;
                      s.push({ from: a, to: l });
                    }
                    s.forEach(({ from: a, to: l }) => {
                      const c = e.slice(o).map(a, -1),
                        u = e.slice(o).map(l),
                        d = e.invert().map(c, -1),
                        h = e.invert().map(u);
                      i.push({
                        oldRange: { from: d, to: h },
                        newRange: { from: c, to: u },
                      });
                    });
                  }),
                  (function L6(n) {
                    const e = (function F6(n, e = JSON.stringify) {
                      const t = {};
                      return n.filter((i) => {
                        const r = e(i);
                        return (
                          !Object.prototype.hasOwnProperty.call(t, r) &&
                          (t[r] = !0)
                        );
                      });
                    })(n);
                    return 1 === e.length
                      ? e
                      : e.filter(
                          (t, i) =>
                            !e
                              .filter((o, s) => s !== i)
                              .some(
                                (o) =>
                                  t.oldRange.from >= o.oldRange.from &&
                                  t.oldRange.to <= o.oldRange.to &&
                                  t.newRange.from >= o.newRange.from &&
                                  t.newRange.to <= o.newRange.to
                              )
                        );
                  })(i)
                );
              })(a).forEach(({ oldRange: u, newRange: d }) => {
                Zh(u.from, u.to, t.doc)
                  .filter((h) => h.mark.type === n.type)
                  .forEach((h) => {
                    const g = Zh(l.map(h.from), l.map(h.to), i.doc).filter(
                      (D) => D.mark.type === n.type
                    );
                    if (!g.length) return;
                    const m = g[0],
                      v = t.doc.textBetween(h.from, h.to, void 0, " "),
                      _ = i.doc.textBetween(m.from, m.to, void 0, " "),
                      b = Kk(v),
                      y = Kk(_);
                    b && !y && s.removeMark(m.from, m.to, n.type);
                  }),
                  (function P6(n, e, t) {
                    const i = [];
                    return (
                      n.nodesBetween(e.from, e.to, (r, o) => {
                        t(r) && i.push({ node: r, pos: o });
                      }),
                      i
                    );
                  })(i.doc, d, (h) => h.isTextblock).forEach((h) => {
                    Sb(
                      i.doc.textBetween(
                        h.pos,
                        h.pos + h.node.nodeSize,
                        void 0,
                        " "
                      )
                    )
                      .filter((p) => p.isLink)
                      .filter((p) => !n.validate || n.validate(p.value))
                      .map((p) => ({
                        ...p,
                        from: h.pos + p.start + 1,
                        to: h.pos + p.end + 1,
                      }))
                      .filter(
                        (p) =>
                          (d.from >= p.from && d.from <= p.to) ||
                          (d.to >= p.from && d.to <= p.to)
                      )
                      .forEach((p) => {
                        s.addMark(
                          p.from,
                          p.to,
                          n.type.create({ href: p.href })
                        );
                      });
                  });
              }),
              s.steps.length ? s : void 0
            );
          },
        });
      }
      const pJ = nr.create({
          name: "link",
          priority: 1e3,
          keepOnSplit: !1,
          onCreate() {
            this.options.protocols.forEach(cJ);
          },
          inclusive() {
            return this.options.autolink;
          },
          addOptions: () => ({
            openOnClick: !0,
            linkOnPaste: !0,
            autolink: !0,
            protocols: [],
            HTMLAttributes: {
              target: "_blank",
              rel: "noopener noreferrer nofollow",
              class: null,
            },
            validate: void 0,
          }),
          addAttributes() {
            return {
              href: { default: null },
              target: { default: this.options.HTMLAttributes.target },
              class: { default: this.options.HTMLAttributes.class },
            };
          },
          parseHTML: () => [{ tag: 'a[href]:not([href *= "javascript:" i])' }],
          renderHTML({ HTMLAttributes: n }) {
            return ["a", _t(this.options.HTMLAttributes, n), 0];
          },
          addCommands() {
            return {
              setLink:
                (n) =>
                ({ chain: e }) =>
                  e()
                    .setMark(this.name, n)
                    .setMeta("preventAutolink", !0)
                    .run(),
              toggleLink:
                (n) =>
                ({ chain: e }) =>
                  e()
                    .toggleMark(this.name, n, { extendEmptyMarkRange: !0 })
                    .setMeta("preventAutolink", !0)
                    .run(),
              unsetLink:
                () =>
                ({ chain: n }) =>
                  n()
                    .unsetMark(this.name, { extendEmptyMarkRange: !0 })
                    .setMeta("preventAutolink", !0)
                    .run(),
            };
          },
          addPasteRules() {
            return [
              Co({
                find: (n) =>
                  Sb(n)
                    .filter(
                      (e) =>
                        !this.options.validate || this.options.validate(e.value)
                    )
                    .filter((e) => e.isLink)
                    .map((e) => ({ text: e.value, index: e.start, data: e })),
                type: this.type,
                getAttributes: (n) => {
                  var e;
                  return {
                    href:
                      null === (e = n.data) || void 0 === e ? void 0 : e.href,
                  };
                },
              }),
            ];
          },
          addProseMirrorPlugins() {
            const n = [];
            return (
              this.options.autolink &&
                n.push(
                  dJ({ type: this.type, validate: this.options.validate })
                ),
              this.options.openOnClick &&
                n.push(
                  (function hJ(n) {
                    return new Qe({
                      key: new It("handleClickLink"),
                      props: {
                        handleClick: (e, t, i) => {
                          var r;
                          const o = GA(e.state, n.type.name);
                          return !(
                            !(null === (r = i.target) || void 0 === r
                              ? void 0
                              : r.closest("a")) ||
                            !o.href ||
                            (window.open(o.href, o.target), 0)
                          );
                        },
                      },
                    });
                  })({ type: this.type })
                ),
              this.options.linkOnPaste &&
                n.push(
                  (function fJ(n) {
                    return new Qe({
                      key: new It("handlePasteLink"),
                      props: {
                        handlePaste: (e, t, i) => {
                          const { state: r } = e,
                            { selection: o } = r,
                            { empty: s } = o;
                          if (s) return !1;
                          let a = "";
                          i.content.forEach((c) => {
                            a += c.textContent;
                          });
                          const l = Sb(a).find(
                            (c) => c.isLink && c.value === a
                          );
                          return !(
                            !a ||
                            !l ||
                            (n.editor.commands.setMark(n.type, {
                              href: l.href,
                            }),
                            0)
                          );
                        },
                      },
                    });
                  })({ editor: this.editor, type: this.type })
                ),
              n
            );
          },
        }),
        gJ = bt.create({
          name: "textAlign",
          addOptions: () => ({
            types: [],
            alignments: ["left", "center", "right", "justify"],
            defaultAlignment: "left",
          }),
          addGlobalAttributes() {
            return [
              {
                types: this.options.types,
                attributes: {
                  textAlign: {
                    default: this.options.defaultAlignment,
                    parseHTML: (n) =>
                      n.style.textAlign || this.options.defaultAlignment,
                    renderHTML: (n) =>
                      n.textAlign === this.options.defaultAlignment
                        ? {}
                        : { style: `text-align: ${n.textAlign}` },
                  },
                },
              },
            ];
          },
          addCommands() {
            return {
              setTextAlign:
                (n) =>
                ({ commands: e }) =>
                  !!this.options.alignments.includes(n) &&
                  this.options.types.every((t) =>
                    e.updateAttributes(t, { textAlign: n })
                  ),
              unsetTextAlign:
                () =>
                ({ commands: n }) =>
                  this.options.types.every((e) =>
                    n.resetAttributes(e, "textAlign")
                  ),
            };
          },
          addKeyboardShortcuts() {
            return {
              "Mod-Shift-l": () => this.editor.commands.setTextAlign("left"),
              "Mod-Shift-e": () => this.editor.commands.setTextAlign("center"),
              "Mod-Shift-r": () => this.editor.commands.setTextAlign("right"),
              "Mod-Shift-j": () => this.editor.commands.setTextAlign("justify"),
            };
          },
        }),
        mJ = nr.create({
          name: "underline",
          addOptions: () => ({ HTMLAttributes: {} }),
          parseHTML: () => [
            { tag: "u" },
            {
              style: "text-decoration",
              consuming: !1,
              getAttrs: (n) => !!n.includes("underline") && {},
            },
          ],
          renderHTML({ HTMLAttributes: n }) {
            return ["u", _t(this.options.HTMLAttributes, n), 0];
          },
          addCommands() {
            return {
              setUnderline:
                () =>
                ({ commands: n }) =>
                  n.setMark(this.name),
              toggleUnderline:
                () =>
                ({ commands: n }) =>
                  n.toggleMark(this.name),
              unsetUnderline:
                () =>
                ({ commands: n }) =>
                  n.unsetMark(this.name),
            };
          },
          addKeyboardShortcuts() {
            return {
              "Mod-u": () => this.editor.commands.toggleUnderline(),
              "Mod-U": () => this.editor.commands.toggleUnderline(),
            };
          },
        });
      let yJ = (() => {
          class n {
            constructor(t, i) {
              (this.el = t),
                (this._renderer = i),
                (this.outputFormat = "html"),
                (this.onChange = () => {}),
                (this.onTouched = () => {}),
                (this.handleChange = ({ transaction: r }) => {
                  if (r.docChanged) {
                    if ("html" === this.outputFormat)
                      return void this.onChange(this.editor.getHTML());
                    this.onChange(this.editor.getJSON());
                  }
                });
            }
            writeValue(t) {
              !t ||
                (!this.outputFormat &&
                  "string" == typeof t &&
                  (this.outputFormat = "html"),
                this.editor.chain().setContent(t, !1).run());
            }
            registerOnChange(t) {
              this.onChange = t;
            }
            registerOnTouched(t) {
              this.onTouched = t;
            }
            setDisabledState(t) {
              this.editor.setEditable(!t),
                this._renderer.setProperty(
                  this.el.nativeElement,
                  "disabled",
                  t
                );
            }
            ngOnInit() {
              if (!this.editor) throw new Error("Required: Input `editor`");
              const t = this.el.nativeElement.innerHTML;
              (this.el.nativeElement.innerHTML = ""),
                this.el.nativeElement.appendChild(
                  this.editor.options.element.firstChild
                ),
                this.editor.setOptions({ element: this.el.nativeElement }),
                t && this.editor.chain().setContent(t, !1).run(),
                this.editor.on("blur", () => {
                  this.onTouched();
                }),
                this.editor.on("transaction", this.handleChange);
            }
            ngOnDestroy() {
              this.editor.destroy();
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(w(ut), w(Wi));
            }),
            (n.ɵdir = q({
              type: n,
              selectors: [
                ["tiptap", "editor", ""],
                ["", "tiptap", "", "editor", ""],
                ["tiptap-editor", "editor", ""],
                ["", "tiptapEditor", "", "editor", ""],
              ],
              inputs: { editor: "editor", outputFormat: "outputFormat" },
              features: [
                $e([{ provide: Jn, useExisting: Ne(() => n), multi: !0 }]),
              ],
            })),
            n
          );
        })(),
        _J = (() => {
          class n {
            constructor(t, i) {
              (this.injector = t),
                (this.viewContainerRef = i),
                (this.lang = Bk),
                (this.allowedContentTypes = ""),
                (this.value = "");
            }
            ngOnInit() {
              (this.editor = new N6({
                extensions: [
                  HG,
                  YQ(this.injector),
                  bQ(this.injector),
                  pQ(this.viewContainerRef),
                  wQ(this.viewContainerRef),
                  CQ(this.injector, this.viewContainerRef),
                  OQ(0, this.viewContainerRef),
                  UQ(this.viewContainerRef),
                  mJ,
                  gJ.configure({
                    types: ["heading", "paragraph", "listItem", "dotImage"],
                  }),
                  XQ.configure({
                    HTMLAttributes: { style: "background: #accef7;" },
                  }),
                  pJ.configure({ openOnClick: !0 }),
                  UG.configure({
                    placeholder: ({ node: t }) =>
                      "heading" === t.type.name
                        ? `${(function vJ(n) {
                            return n.replace(
                              /\p{L}+('\p{L}+)?/gu,
                              function (e) {
                                return e.charAt(0).toUpperCase() + e.slice(1);
                              }
                            );
                          })(t.type.name)} ${t.attrs.level}`
                        : 'Type "/" for commmands',
                  }),
                ],
              })),
                this.setEditorStorageData();
            }
            setEditorStorageData() {
              this.editor.storage.dotConfig = {
                lang: this.lang,
                allowedContentTypes: this.allowedContentTypes,
              };
            }
          }
          return (
            (n.ɵfac = function (t) {
              return new (t || n)(w(pt), w(Yn));
            }),
            (n.ɵcmp = ht({
              type: n,
              selectors: [["dotcms-block-editor"]],
              inputs: {
                lang: "lang",
                allowedContentTypes: "allowedContentTypes",
              },
              decls: 1,
              vars: 2,
              consts: [[3, "editor", "ngModel", "ngModelChange"]],
              template: function (t, i) {
                1 & t &&
                  (H(0, "tiptap-editor", 0),
                  Oe("ngModelChange", function (o) {
                    return (i.value = o);
                  }),
                  z()),
                  2 & t && A("editor", i.editor)("ngModel", i.value);
              },
              dependencies: [Ty, dh, yJ],
              styles: [
                '@import"https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,300;0,400;0,500;0,700;1,300;1,400&display=swap";@import"https://fonts.googleapis.com/icon?family=Material+Icons";[_nghost-%COMP%]{border-radius:4px;display:block;height:500px;overflow-y:hidden;position:relative;outline:#b3b1b8 solid 1px;resize:vertical}[_nghost-%COMP%]:focus-within{outline-color:var(--color-main)}[_nghost-%COMP%]   tiptap-editor[_ngcontent-%COMP%]    {display:block;height:100%;overflow-y:auto;width:100%}[_nghost-%COMP%]   tiptap-editor[_ngcontent-%COMP%]     .ProseMirror{box-sizing:border-box;display:block;min-height:100%;outline:none;padding:16px 64px;font:14px/1.3}[_nghost-%COMP%]   tiptap-editor[_ngcontent-%COMP%]     .ProseMirror ul, [_nghost-%COMP%]   tiptap-editor[_ngcontent-%COMP%]     .ProseMirror ol{padding-inline-start:16px;margin:0 0 0 16px}[_nghost-%COMP%]   tiptap-editor[_ngcontent-%COMP%]     .ProseMirror ol li{list-style-type:decimal}[_nghost-%COMP%]   tiptap-editor[_ngcontent-%COMP%]     .ProseMirror ul li{list-style-type:disc}[_nghost-%COMP%]   tiptap-editor[_ngcontent-%COMP%]     .ProseMirror li{padding-top:.286em}[_nghost-%COMP%]   tiptap-editor[_ngcontent-%COMP%]     .ProseMirror li p{padding:0;margin:0}[_nghost-%COMP%]   tiptap-editor[_ngcontent-%COMP%]     .ProseMirror h1{font-size:2.43em;line-height:1.06em;padding-top:.176em;margin-bottom:.353em}[_nghost-%COMP%]   tiptap-editor[_ngcontent-%COMP%]     .ProseMirror h2{font-size:1.93em;line-height:1.33em;padding-top:.333em;margin-bottom:.333em}[_nghost-%COMP%]   tiptap-editor[_ngcontent-%COMP%]     .ProseMirror h3{font-size:1.57em;line-height:1.64em;padding-top:.5em;margin-bottom:.318em}[_nghost-%COMP%]   tiptap-editor[_ngcontent-%COMP%]     .ProseMirror h4{font-size:1.29em;line-height:2em;padding-top:.667em;margin-bottom:.333em}[_nghost-%COMP%]   tiptap-editor[_ngcontent-%COMP%]     .ProseMirror p{font-size:1em;line-height:1.29em;padding-top:.286em;margin-bottom:1em}[_nghost-%COMP%]   tiptap-editor[_ngcontent-%COMP%]     .ProseMirror blockquote{margin:16px;border-left:3px solid rgba(10,7,37,.1);padding-left:16px}[_nghost-%COMP%]   tiptap-editor[_ngcontent-%COMP%]     .ProseMirror pre{background:#0a0725;border-radius:8px;color:#fff;padding:12px 16px}[_nghost-%COMP%]   tiptap-editor[_ngcontent-%COMP%]     .ProseMirror pre code{font-family:SFMono-Regular,Menlo,Monaco,Consolas,Liberation Mono,Courier New,monospace;background:none;color:inherit;padding:0}[_nghost-%COMP%]   tiptap-editor[_ngcontent-%COMP%]     .ProseMirror .is-empty:before{color:#b3b1b8;content:attr(data-placeholder);float:left;height:0;pointer-events:none}',
              ],
            })),
            n
          );
        })();
      const CJ = new (class DJ extends Di {})(
        class bJ extends fh {
          constructor(e, t) {
            super(e, t), (this.scheduler = e), (this.work = t);
          }
          schedule(e, t = 0) {
            return t > 0
              ? super.schedule(e, t)
              : ((this.delay = t),
                (this.state = e),
                this.scheduler.flush(this),
                this);
          }
          execute(e, t) {
            return t > 0 || this.closed
              ? super.execute(e, t)
              : this._execute(e, t);
          }
          requestAsyncId(e, t, i = 0) {
            return (null !== i && i > 0) || (null === i && this.delay > 0)
              ? super.requestAsyncId(e, t, i)
              : e.flush(this);
          }
        }
      );
      class si {
        constructor(e, t, i) {
          (this.kind = e),
            (this.value = t),
            (this.error = i),
            (this.hasValue = "N" === e);
        }
        observe(e) {
          switch (this.kind) {
            case "N":
              return e.next && e.next(this.value);
            case "E":
              return e.error && e.error(this.error);
            case "C":
              return e.complete && e.complete();
          }
        }
        do(e, t, i) {
          switch (this.kind) {
            case "N":
              return e && e(this.value);
            case "E":
              return t && t(this.error);
            case "C":
              return i && i();
          }
        }
        accept(e, t, i) {
          return e && "function" == typeof e.next
            ? this.observe(e)
            : this.do(e, t, i);
        }
        toObservable() {
          switch (this.kind) {
            case "N":
              return ne(this.value);
            case "E":
              return gs(this.error);
            case "C":
              return ef();
          }
          throw new Error("unexpected notification kind value");
        }
        static createNext(e) {
          return typeof e < "u"
            ? new si("N", e)
            : si.undefinedValueNotification;
        }
        static createError(e) {
          return new si("E", void 0, e);
        }
        static createComplete() {
          return si.completeNotification;
        }
      }
      (si.completeNotification = new si("C")),
        (si.undefinedValueNotification = new si("N", void 0));
      class Qf extends Be {
        constructor(e, t, i = 0) {
          super(e), (this.scheduler = t), (this.delay = i);
        }
        static dispatch(e) {
          const { notification: t, destination: i } = e;
          t.observe(i), this.unsubscribe();
        }
        scheduleMessage(e) {
          this.destination.add(
            this.scheduler.schedule(
              Qf.dispatch,
              this.delay,
              new wJ(e, this.destination)
            )
          );
        }
        _next(e) {
          this.scheduleMessage(si.createNext(e));
        }
        _error(e) {
          this.scheduleMessage(si.createError(e)), this.unsubscribe();
        }
        _complete() {
          this.scheduleMessage(si.createComplete()), this.unsubscribe();
        }
      }
      class wJ {
        constructor(e, t) {
          (this.notification = e), (this.destination = t);
        }
      }
      class SJ extends _e {
        constructor(
          e = Number.POSITIVE_INFINITY,
          t = Number.POSITIVE_INFINITY,
          i
        ) {
          super(),
            (this.scheduler = i),
            (this._events = []),
            (this._infiniteTimeWindow = !1),
            (this._bufferSize = e < 1 ? 1 : e),
            (this._windowTime = t < 1 ? 1 : t),
            t === Number.POSITIVE_INFINITY
              ? ((this._infiniteTimeWindow = !0),
                (this.next = this.nextInfiniteTimeWindow))
              : (this.next = this.nextTimeWindow);
        }
        nextInfiniteTimeWindow(e) {
          if (!this.isStopped) {
            const t = this._events;
            t.push(e), t.length > this._bufferSize && t.shift();
          }
          super.next(e);
        }
        nextTimeWindow(e) {
          this.isStopped ||
            (this._events.push(new MJ(this._getNow(), e)),
            this._trimBufferThenGetEvents()),
            super.next(e);
        }
        _subscribe(e) {
          const t = this._infiniteTimeWindow,
            i = t ? this._events : this._trimBufferThenGetEvents(),
            r = this.scheduler,
            o = i.length;
          let s;
          if (this.closed) throw new Fo();
          if (
            (this.isStopped || this.hasError
              ? (s = Te.EMPTY)
              : (this.observers.push(e), (s = new Nb(this, e))),
            r && e.add((e = new Qf(e, r))),
            t)
          )
            for (let a = 0; a < o && !e.closed; a++) e.next(i[a]);
          else for (let a = 0; a < o && !e.closed; a++) e.next(i[a].value);
          return (
            this.hasError
              ? e.error(this.thrownError)
              : this.isStopped && e.complete(),
            s
          );
        }
        _getNow() {
          return (this.scheduler || CJ).now();
        }
        _trimBufferThenGetEvents() {
          const e = this._getNow(),
            t = this._bufferSize,
            i = this._windowTime,
            r = this._events,
            o = r.length;
          let s = 0;
          for (; s < o && !(e - r[s].time < i); ) s++;
          return o > t && (s = Math.max(s, o - t)), s > 0 && r.splice(0, s), r;
        }
      }
      class MJ {
        constructor(e, t) {
          (this.time = e), (this.value = t);
        }
      }
      const Jf = {
        schedule(n, e) {
          const t = setTimeout(n, e);
          return () => clearTimeout(t);
        },
        scheduleBeforeRender(n) {
          if (typeof window > "u") return Jf.schedule(n, 0);
          if (typeof window.requestAnimationFrame > "u")
            return Jf.schedule(n, 16);
          const e = window.requestAnimationFrame(n);
          return () => window.cancelAnimationFrame(e);
        },
      };
      let Mb;
      function PJ(n, e, t) {
        let i = t;
        return (
          (function TJ(n) {
            return !!n && n.nodeType === Node.ELEMENT_NODE;
          })(n) &&
            e.some(
              (r, o) =>
                !(
                  "*" === r ||
                  !(function AJ(n, e) {
                    if (!Mb) {
                      const t = Element.prototype;
                      Mb =
                        t.matches ||
                        t.matchesSelector ||
                        t.mozMatchesSelector ||
                        t.msMatchesSelector ||
                        t.oMatchesSelector ||
                        t.webkitMatchesSelector;
                    }
                    return n.nodeType === Node.ELEMENT_NODE && Mb.call(n, e);
                  })(n, r) ||
                  ((i = o), 0)
                )
            ),
          i
        );
      }
      class LJ {
        constructor(e, t) {
          this.componentFactory = t.get(Qr).resolveComponentFactory(e);
        }
        create(e) {
          return new VJ(this.componentFactory, e);
        }
      }
      class VJ {
        constructor(e, t) {
          (this.componentFactory = e),
            (this.injector = t),
            (this.eventEmitters = new SJ(1)),
            (this.events = this.eventEmitters.pipe(or((i) => pp(...i)))),
            (this.componentRef = null),
            (this.viewChangeDetectorRef = null),
            (this.inputChanges = null),
            (this.hasInputChanges = !1),
            (this.implementsOnChanges = !1),
            (this.scheduledChangeDetectionFn = null),
            (this.scheduledDestroyFn = null),
            (this.initialInputValues = new Map()),
            (this.unchangedInputs = new Set(
              this.componentFactory.inputs.map(({ propName: i }) => i)
            )),
            (this.ngZone = this.injector.get(Ke)),
            (this.elementZone =
              typeof Zone > "u" ? null : this.ngZone.run(() => Zone.current));
        }
        connect(e) {
          this.runInZone(() => {
            if (null !== this.scheduledDestroyFn)
              return (
                this.scheduledDestroyFn(), void (this.scheduledDestroyFn = null)
              );
            null === this.componentRef && this.initializeComponent(e);
          });
        }
        disconnect() {
          this.runInZone(() => {
            null === this.componentRef ||
              null !== this.scheduledDestroyFn ||
              (this.scheduledDestroyFn = Jf.schedule(() => {
                null !== this.componentRef &&
                  (this.componentRef.destroy(),
                  (this.componentRef = null),
                  (this.viewChangeDetectorRef = null));
              }, 10));
          });
        }
        getInputValue(e) {
          return this.runInZone(() =>
            null === this.componentRef
              ? this.initialInputValues.get(e)
              : this.componentRef.instance[e]
          );
        }
        setInputValue(e, t) {
          this.runInZone(() => {
            null !== this.componentRef
              ? ((function OJ(n, e) {
                  return n === e || (n != n && e != e);
                })(t, this.getInputValue(e)) &&
                  (void 0 !== t || !this.unchangedInputs.has(e))) ||
                (this.recordInputChange(e, t),
                this.unchangedInputs.delete(e),
                (this.hasInputChanges = !0),
                (this.componentRef.instance[e] = t),
                this.scheduleDetectChanges())
              : this.initialInputValues.set(e, t);
          });
        }
        initializeComponent(e) {
          const t = pt.create({ providers: [], parent: this.injector }),
            i = (function RJ(n, e) {
              const t = n.childNodes,
                i = e.map(() => []);
              let r = -1;
              e.some((o, s) => "*" === o && ((r = s), !0));
              for (let o = 0, s = t.length; o < s; ++o) {
                const a = t[o],
                  l = PJ(a, e, r);
                -1 !== l && i[l].push(a);
              }
              return i;
            })(e, this.componentFactory.ngContentSelectors);
          (this.componentRef = this.componentFactory.create(t, i, e)),
            (this.viewChangeDetectorRef = this.componentRef.injector.get(Zo)),
            (this.implementsOnChanges = (function xJ(n) {
              return "function" == typeof n;
            })(this.componentRef.instance.ngOnChanges)),
            this.initializeInputs(),
            this.initializeOutputs(this.componentRef),
            this.detectChanges(),
            this.injector.get(Da).attachView(this.componentRef.hostView);
        }
        initializeInputs() {
          this.componentFactory.inputs.forEach(({ propName: e }) => {
            this.initialInputValues.has(e) &&
              this.setInputValue(e, this.initialInputValues.get(e));
          }),
            this.initialInputValues.clear();
        }
        initializeOutputs(e) {
          const t = this.componentFactory.outputs.map(
            ({ propName: i, templateName: r }) =>
              e.instance[i].pipe(ye((s) => ({ name: r, value: s })))
          );
          this.eventEmitters.next(t);
        }
        callNgOnChanges(e) {
          if (!this.implementsOnChanges || null === this.inputChanges) return;
          const t = this.inputChanges;
          (this.inputChanges = null), e.instance.ngOnChanges(t);
        }
        markViewForCheck(e) {
          this.hasInputChanges &&
            ((this.hasInputChanges = !1), e.markForCheck());
        }
        scheduleDetectChanges() {
          this.scheduledChangeDetectionFn ||
            (this.scheduledChangeDetectionFn = Jf.scheduleBeforeRender(() => {
              (this.scheduledChangeDetectionFn = null), this.detectChanges();
            }));
        }
        recordInputChange(e, t) {
          if (!this.implementsOnChanges) return;
          null === this.inputChanges && (this.inputChanges = {});
          const i = this.inputChanges[e];
          if (i) return void (i.currentValue = t);
          const r = this.unchangedInputs.has(e),
            o = r ? void 0 : this.getInputValue(e);
          this.inputChanges[e] = new Yb(o, t, r);
        }
        detectChanges() {
          null !== this.componentRef &&
            (this.callNgOnChanges(this.componentRef),
            this.markViewForCheck(this.viewChangeDetectorRef),
            this.componentRef.changeDetectorRef.detectChanges());
        }
        runInZone(e) {
          return this.elementZone && Zone.current !== this.elementZone
            ? this.ngZone.run(e)
            : e();
        }
      }
      class BJ extends HTMLElement {
        constructor() {
          super(...arguments), (this.ngElementEventsSubscription = null);
        }
      }
      let HJ = (() => {
        class n {
          constructor(t) {
            this.injector = t;
          }
          ngDoBootstrap() {
            const t = (function jJ(n, e) {
              const t = (function NJ(n, e) {
                  return e.get(Qr).resolveComponentFactory(n).inputs;
                })(n, e.injector),
                i = e.strategyFactory || new LJ(n, e.injector),
                r = (function kJ(n) {
                  const e = {};
                  return (
                    n.forEach(({ propName: t, templateName: i }) => {
                      e[
                        (function IJ(n) {
                          return n.replace(
                            /[A-Z]/g,
                            (e) => `-${e.toLowerCase()}`
                          );
                        })(i)
                      ] = t;
                    }),
                    e
                  );
                })(t);
              class o extends BJ {
                constructor(a) {
                  super(), (this.injector = a);
                }
                get ngElementStrategy() {
                  if (!this._ngElementStrategy) {
                    const a = (this._ngElementStrategy = i.create(
                      this.injector || e.injector
                    ));
                    t.forEach(({ propName: l }) => {
                      if (!this.hasOwnProperty(l)) return;
                      const c = this[l];
                      delete this[l], a.setInputValue(l, c);
                    });
                  }
                  return this._ngElementStrategy;
                }
                attributeChangedCallback(a, l, c, u) {
                  this.ngElementStrategy.setInputValue(r[a], c);
                }
                connectedCallback() {
                  let a = !1;
                  this.ngElementStrategy.events &&
                    (this.subscribeToEvents(), (a = !0)),
                    this.ngElementStrategy.connect(this),
                    a || this.subscribeToEvents();
                }
                disconnectedCallback() {
                  this._ngElementStrategy &&
                    this._ngElementStrategy.disconnect(),
                    this.ngElementEventsSubscription &&
                      (this.ngElementEventsSubscription.unsubscribe(),
                      (this.ngElementEventsSubscription = null));
                }
                subscribeToEvents() {
                  this.ngElementEventsSubscription =
                    this.ngElementStrategy.events.subscribe((a) => {
                      const l = new CustomEvent(a.name, { detail: a.value });
                      this.dispatchEvent(l);
                    });
                }
              }
              return (
                (o.observedAttributes = Object.keys(r)),
                t.forEach(({ propName: s }) => {
                  Object.defineProperty(o.prototype, s, {
                    get() {
                      return this.ngElementStrategy.getInputValue(s);
                    },
                    set(a) {
                      this.ngElementStrategy.setInputValue(s, a);
                    },
                    configurable: !0,
                    enumerable: !0,
                  });
                }),
                o
              );
            })(_J, { injector: this.injector });
            customElements.define("dotcms-block-editor", t);
          }
        }
        return (
          (n.ɵfac = function (t) {
            return new (t || n)(T(pt));
          }),
          (n.ɵmod = rt({ type: n })),
          (n.ɵinj = Xe({ imports: [BU, bi, TI, YK, P4, C$, NK] })),
          n
        );
      })();
      (function I2() {
        _S = !1;
      })(),
        VU()
          .bootstrapModule(HJ)
          .catch((n) => console.error(n));
    },
  },
  (Po) => {
    Po((Po.s = 81));
  },
]);
