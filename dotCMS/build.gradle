buildscript {
    repositories {
        
        maven { url "https://repo.dotcms.com/artifactory/libs-release" }
        jcenter()
    }
    dependencies {
        classpath 'org.ajoberstar:grgit:1.7.0'
        classpath 'org.unbroken-dome.gradle-plugins:gradle-testsets-plugin:2.0.0'
        classpath 'com.dotcms.lib:dot.commons-io:2.0.1_2'
        classpath 'nl.eveoh:gradle-aspectj:1.6'
    }
}

plugins {
    id "com.moowork.node" version "1.3.1"
    id "com.palantir.docker" version "0.17.2"  // reference:  https://github.com/palantir/gradle-docker
}

project.ext {
    aspectjVersion = '1.8.10'
}


node {
    // Version of node to use.
    version = nodeVersion

    // Base URL for fetching node distributions (change if you have a mirror).
    distBaseUrl = 'https://nodejs.org/dist'
    // If true, it will download node using above parameters.
    // If false, it will try to use globally installed node.
    download = false
}
import com.dotcms.repackage.org.apache.commons.io.FileUtils;

configurations {
    compile
    buildlibs
    starter
    profiler
    profilerDependencies
    provided
    felix
}

configurations.all({
    // dynamic: e.g. 'version: 2.0+'
    resolutionStrategy.cacheDynamicVersionsFor 1, 'hours'
    // changing: e.g. 'version 2.0.0-SNAPSHOT'
    resolutionStrategy.cacheChangingModulesFor 0, 'seconds'

    /*POM relocation to an other version number is not fully supported in Gradle : xml-apis#xml-apis;2.0.2 relocated to xml-apis#xml-apis;1.0.b2.
            Please update your dependency to directly use the correct version 'xml-apis#xml-apis;1.0.b2'.
    Resolution will only pick dependencies of the relocated element.  Artifacts and other metadata will be ignored.*/
    resolutionStrategy {
        force 'xml-apis:xml-apis:1.4.01'
    }
})


// Apply the java plugin to add support for Java.
apply plugin: 'java'
apply plugin: 'aspectj'
apply plugin: 'war'
apply plugin: 'org.unbroken-dome.test-sets'
apply plugin: 'project-report' /*For gradle dependencies: ./gradlew htmlDependencyReport*/
apply plugin: 'idea'
apply plugin: 'eclipse'
eclipse {
    project {
        name = 'dotcms_5'
    }
}

// In this section you declare where to find the dependencies of your project.
repositories {

    maven { url "https://repo.dotcms.com/artifactory/libs-release" }
    maven { url "https://repo.dotcms.com/artifactory/libs-snapshot-local" }
    maven { url 'https://jitpack.io' }

}

testSets {
    individualTest { dirName = 'test' }
    integrationTest { dirName = 'integration-test' }
    functionalTest { dirName = 'functional-test' }
}


tasks.matching {it instanceof Test}.all {
    testLogging.events = ["failed", "passed", "skipped"]
}

//Avoid skipping running tests when the integrationTest task is invoked
project.integrationTest {
    outputs.upToDateWhen { false }
}

//Avoid skipping running tests when the test task is invoked
project.test {
    outputs.upToDateWhen { false }
    reports.junitXml.destination = file("$buildDir/test-results/unit-tests/xml")
    reports.html.destination = file("$buildDir/test-results/unit-tests/html")
}

idea {

    module {

        name = 'dotCMS'
        contentRoot = file('..')
        excludeDirs += file('build')
        excludeDirs += file('.idea')
        excludeDirs += file('.gradle')
        //if you prefer different output folders
        inheritOutputDirs = true
        outputDir = file('build/classes/main')
        testOutputDir = file('build/classes/test')

        //Extra source dirs
        sourceDirs += file('src/main/generated')
        generatedSourceDirs += file('src/main/generated')


        //Extra test source dirs
        testSourceDirs += file('integration-test/java')
        testSourceDirs += file('functional-test/java')
    }
}

eclipse.project {
    natures 'org.springsource.ide.eclipse.gradle.core.nature'
}


dependencies {
    /*****  Felix libs need to be placed in the WEB-INF/felix/bundle directory. This was previously handled using a pre-build copy task.  *****/
    felix group: 'org.apache.felix', name: 'org.apache.felix.fileinstall', version: '3.6.4'
    felix (group: 'org.apache.felix', name: 'org.apache.felix.configadmin', version: '1.9.2') {
        transitive = false
    }
    felix (group: 'org.osgi', name: 'org.osgi.compendium', version: '4.3.1') {
        transitive = false
    }
    felix(group: 'org.apache.tika', name: 'tika-core', version: '1.17') {
        transitive = false
    }
    felix(group: 'org.apache.tika', name: 'tika-bundle', version: '1.17') {
        transitive = false
    }
    felix group: 'org.slf4j', name: 'slf4j-simple', version: '1.7.25'
    felix group: 'org.slf4j', name: 'jcl-over-slf4j', version: '1.7.25'
    felix group: 'com.dotcms.tika', name: 'com.dotcms.tika', version: '0.2'

    /**** And now the libs we pull in from internal company sources - libs stored in ./plugins, ./bin, ./libs, the starter site, etc. ****/
    compile fileTree("src/main/plugins/com.dotcms.config/build/jar").include('plugin-com.dotcms.config.jar')

    starter group: 'com.dotcms', name: 'starter', version: '20190425', ext: 'zip'

    profiler group: 'glowroot-custom', name: 'glowroot-agent', version: '0.13.1'
    profilerDependencies group: 'glowroot-custom', name: 'collector-https-linux', version: '0.13.1'
    profilerDependencies group: 'glowroot-custom', name: 'collector-https-osx', version: '0.13.1'
    profilerDependencies group: 'glowroot-custom', name: 'collector-https-windows', version: '0.13.1'
    profilerDependencies group: 'glowroot-custom', name: 'embedded-collector', version: '0.13.1'

    providedCompile "javax.servlet:javax.servlet-api:3.1.0"
    providedCompile fileTree("../libs/buildlibs").include('**/*.jar')
    providedCompile fileTree("../libs/buildlibs").include('mail.jar', 'mysql-conn*.jar', 'ojdbc*.jar', 'postgres*.jar', 'mssql-jdbc*.jar')

    individualTestCompile sourceSets.test.output
    integrationTestCompile sourceSets.test.output
    functionalTestCompile sourceSets.test.output
    functionalTestCompile sourceSets.integrationTest.output


}

// Import and apply the dependencies from the dependencies scripts.
apply from: "$rootDir/dependencies.gradle"




ant.lifecycleLogLevel = "INFO"

ext {
    // Open the Git repository in the current directory.

    dotcmsReleaseBuild = ''
    dotcmsReleaseName='dotCMS Platform'
    dotcmsReleaseCodename='Panther'
    dotcmsReleaseBuild='999999'
    dotcmsReleaseDdate='Jun 08, 1986'
    dotcmsReleaseDdate = getDate()
    serverFolder = "$tomcatDistInstallLocation-$tomcatInstallVersion"
    homeFolder = serverFolder + webAppRootFolder
    dotcmsHome = serverFolder + webAppRootFolder

    if (project.gradle.startParameter.taskNames.contains('deployWarTomcat') || project.gradle.startParameter.taskNames.contains('createDist')|| project.gradle.startParameter.taskNames.contains('docker')){
        try {
            git = org.ajoberstar.grgit.Grgit.open(file('..'))
            dotcmsReleaseBuild = git.head().abbreviatedId // abbreviatedId of head() method.
        } catch (Exception exception) {
            //Do nothing, this will fail only if git is not installed on this machine
        }
    }
}


if (project.hasProperty('jarBaseName')) {
    archivesBaseName = "$jarBaseName"
}else{
    archivesBaseName = 'dotcms_'+dotcmsReleaseVersion+'_'+dotcmsReleaseBuild
}

def tomcatDownloadUrl = uri("https://repo.maven.apache.org/maven2/org/apache/tomcat/tomcat/${tomcatInstallVersion}/tomcat-${tomcatInstallVersion}.zip")
def tomcatDownloadZipFile = file("${buildDir}/tmp/apache-tomcat-${tomcatInstallVersion}.zip")
def tomcatDistBase = "$distLocation/$tomcatDistInstallLocation-$tomcatInstallVersion"
def dotcmsDistBase = "../$tomcatDistInstallLocation-$tomcatInstallVersion"

def tomcatDistBaseFile = file(tomcatDistBase)
def tomcatDistBinDir = new File(tomcatDistBaseFile, "bin")
def tomcatDistConfDir = new File(tomcatDistBaseFile, "conf")

// Compile Java.
compileJava {
    targetCompatibility = 1.8
    sourceCompatibility = 1.8
    options.incremental = true
}

jar{

    if (gradle.startParameter.taskNames.contains("deployWarTomcatTests")) {
        from project.sourceSets.main.output + project.sourceSets.test.output + project.sourceSets.integrationTest.output + project.sourceSets.functionalTest.output
    }
}

task copyTestRuntimeLibs(type: Copy) {
    into "build/libs/test"
    from configurations.testCompile - configurations.compile
}

// Expand the release properties.
processResources {
    filesMatching("release.properties") {
        expand( project.properties )
    }
}

// By default the war task compiles everything under src/main/java into WEB-INF/classes/
// but, instead, we want to compile everything on a .jar file and put it under WEB-INF/lib.
war.dependsOn 'deployPlugins','initNpm'

war {

    sourceSets {
        main {
            java {
                //We only want to compile using the submodules code when using the deployWarTomcatDev task
                if (project.gradle.startParameter.taskNames.contains('deployWarTomcatDev')
                        || project.gradle.startParameter.taskNames.contains('testDev')) {

                    srcDirs = ["src/main/java", "$generatedSourceFolder"]
                    
                } else {
                    srcDirs = ["src/main/java", "$generatedSourceFolder"]
                }
            }
        }

    }

    classpath = classpath - sourceSets.main.output.classesDir

    if (gradle.startParameter.taskNames.contains("deployWarTomcatTests")) {
        classpath = configurations.testRuntime
    }

    from (jar) {
        into 'WEB-INF/lib'
    }

    from (configurations.felix) {
        into felixFolder
    }

    from(configurations.compile) {
        into felixFolder
        include '**/org.apache.felix.http.api*.jar'
    }

    from(configurations.compile) {
        into felixFolder
        include '**/org.apache.felix.http.bundle*.jar'
    }

    from (configurations.starter) {
        into dotcmsFolder
        rename ( /starter(.+)\.zip/, "starter.zip" )
    }

    from (configurations.profiler) {
        into profilerFolder
        rename ( /glowroot(.+)\.jar/, "profiler.jar" )
    }
    from (configurations.profilerDependencies) {
        into profilerFolder.plus("/lib")
        rename ( /embedded-collector(.+)\.jar/, "glowroot-embedded-collector.jar" )
        rename ( /collector-https-linux(.+)\.jar/, "glowroot-central-collector-https-linux.jar" )
        rename ( /collector-https-osx(.+)\.jar/, "glowroot-central-collector-https-osx.jar" )
        rename ( /collector-https-windows(.+)\.jar/, "glowroot-central-collector-https-windows.jar" )
    }
}
war.finalizedBy 'undeployPlugins'

task testDev(type: Test) {
    reports.junitXml.setDestination(file("$buildDir/test-results/unit-tests/xml"))
    reports.html.setDestination(file("$buildDir/test-results/unit-tests/html"))
}

compileIntegrationTestJava {
    classpath += files(sourceSets.main.output)
}

integrationTest{
    doFirst
            {
                if (project.hasProperty('databaseType')){
                    systemProperty "databaseType", "$databaseType"
                }
            }
}

// Delete ROOT under tomcat8/webapps
task undeployWarTomcat(type: Delete) {
    delete tomcatInstallLocation + webAppRootFolder
    followSymlinks = true
}
undeployWarTomcat.group='dotCMS Util'
undeployWarTomcat.description='Removes /tomcat8/webapps folder. (reset tomcat)'

undeployWarTomcat.mustRunAfter 'backupWarTomcatData'

// Makes all the magic to place the webapp under tomcat8 for devs.
task deployWarTomcat(type: DeployWarTomcatTask) {
    dependsOn 'war', 'unpackTomcatToInstallLocation', 'undeployWarTomcat'
    tomcatPath = file(tomcatInstallLocation)
}
deployWarTomcat.group='dotCMS Development'
deployWarTomcat.description='Will checkout the tomcat app server, generate a war structure and copy it to the just checked out tomcat. If the app server exist instead of a checkout a git pull will be use.'


//Same as the deploy-war-tomcat except that it will backup the assets, dotsecure, META-INF and H2 folders
//in order to restore them after the deploy.
//This is useful in cases when you need to make a deploy-war-tomcat but keeping your current data.
task deployWarTomcatBackup(type: DeployWarTomcatTask){
    dependsOn 'war', 'unpackTomcatToInstallLocation', 'backupWarTomcatData', 'undeployWarTomcat'
    tomcatPath = file(tomcatInstallLocation)
}
deployWarTomcatBackup.finalizedBy 'restoreBackupWarTomcatData'
deployWarTomcatBackup.group='dotCMS Development'
deployWarTomcatBackup.description='Same as deployWarTomcat but will also backup and restore the assets, dotsecure, META-INF and h2 database folders. (Useful for development)'


//Executes deployWarTomcat task compiling tests as well
task deployWarTomcatTests(type: DeployWarTomcatTask){
    dependsOn 'war', 'unpackTomcatToInstallLocation', 'undeployWarTomcat'
    tomcatPath = file(tomcatInstallLocation)
}
deployWarTomcatTests.group='dotCMS Development'
deployWarTomcatTests.description='Same as deployWarTomcat but also includes the junit tests.'

//Executes deployWarTomcat task from dist version
task deployWarTomcatDist(type: DeployWarTomcatTask) {
    dependsOn 'war', 'prepareTomcatDist'
    tomcatPath = file(tomcatDistBase)
}
deployWarTomcatDist.group='dotCMS Util'
deployWarTomcatDist.description='Same as deployWarTomcat but ran inside the Distribution. (Useful for development)'

//Same as deployWarTomcat but will use the no obfuscated version of the enterprise jars.
//(Useful for development)
task deployWarTomcatDev (dependsOn: 'deployWarTomcat') {

}

deployWarTomcatDev.group='dotCMS Development'
deployWarTomcatDev.description='Same as deployWarTomcat but will use the no obfuscated version of the enterprise jar. (Useful for development)'

//Executes a pull or clone to get tomcat from the repository
task clonePullTomcat(type: ClonePullTomcatTask) {

}
clonePullTomcat.group='dotCMS Util'
clonePullTomcat.description='Clones or pull /tomcat8 folder.'

//Executes clonePullTomcat task from dist version
task clonePullTomcatDist(type: ClonePullTomcatTask) {
    tomcatLocation = tomcatDistBase
}
clonePullTomcatDist.group='dotCMS Util'
clonePullTomcatDist.description='Clones or pull /tomcat8 folder to be used on on the distribution.'

task downloadTomcatDist {
    outputs.file tomcatDownloadZipFile
    doLast {
        if (!tomcatDownloadZipFile.exists()) {
            println "Downloading Tomcat $tomcatInstallVersion..."
            ant.get(
                    src: tomcatDownloadUrl,
                    dest: tomcatDownloadZipFile
            )
        } else {
            println "Tomcat zip already exists: $tomcatDownloadZipFile"
        }
    }
}

task unpackTomcatDist(type: UnpackTomcatTask) {
    dependsOn 'downloadTomcatDist'
    tomcatZipFile = tomcatDownloadZipFile
    destinationDir = tomcatDistBase
}

task unpackTomcatToInstallLocation(type: UnpackTomcatTask) {
    dependsOn 'downloadTomcatDist'
    tomcatZipFile = tomcatDownloadZipFile
    destinationDir = tomcatInstallLocation
}

task prepareTomcatDist {
    dependsOn 'unpackTomcatDist'
    outputs.dir file(tomcatDistBaseFile)
    outputs.upToDateWhen {
        tomcatDistBinDir.exists() && tomcatDistBinDir.listFiles()?.length > 0 &&
        tomcatDistConfDir.exists() && tomcatDistConfDir.listFiles()?.length > 0
    }
    doLast {
        println "Tomcat is prepared at: $tomcatDistBase"
    }
}

//Creates the final distribution files for dotCMS.
task createDistPrep(type: Copy, dependsOn: ['prepareTomcatDist', 'deployWarTomcatDist']) {

    into "$distLocation"

    from("$rootDir/../bin") {
        into "$distBinLocation"
        filesMatching('build.con*') {
            expand(project.properties)
        }
    }

    from("$rootDir/../") {
        into "$distBinLocation/ant"
        include "build.xml"
    }

    from(sourceSets.main.resources) {
        into "$confDistLocation"
        exclude "com", "org", "release.properties"
    }

    from("src/main/plugins") {
        into "$pluginsDistLocation"
        exclude "**/.git"
    }

    from("$rootDir/../docs") {
        into "$docsDistLocation"
    }

    doLast {
        replaceText(file("$distLocation$distBinLocation/build.conf"), "#SERVER_FOLDER", "SERVER_FOLDER")
        replaceText(file("$distLocation$distBinLocation/build.conf"), "#HOME_FOLDER", "HOME_FOLDER")
        replaceText(file("$distLocation$distBinLocation/build.conf"), "#target.root", "target.root")

        replaceText(file("$distLocation$distBinLocation/build.conf.bat"), "rem set", "set")
        replaceText(file("$distLocation$distBinLocation/build.conf.bat"), "/", "\\\\")

        if ("$distUpdate".toBoolean()) {
            delete "$tomcatDistBase$webAppRootFolder/starter.zip"
        }
    }

}

task createDist(dependsOn: ['createDistPrep','zip', 'tgzTask']) {
    group 'dotCMS Development'
    description 'Creates the final distribution files for dotCMS.'
}
createDist.finalizedBy 'removeDistFolder'

//Task used to create a .zip file from the distribution
task zip(type: Zip) {
    from "$distLocation"
    destinationDir file("$outputDistLocation")
    baseName 'dotcms_'+dotcmsReleaseVersion
}
zip.group='dotCMS Util'
zip.description='Creates distribution as a .zip file.'

//Task used to create a tar.gz from the distribution
task tgzTask(type: Tar) {
    if (!"$distUpdate".toBoolean()) {
        from ("$distLocation"){
            eachFile { file ->
                if (file.getName().endsWith(".sh") || file.getName().startsWith("gradle")) {
                    file.setMode(0755)
                }
            }
        }
        destinationDir file("$outputDistLocation")
        baseName 'dotcms_'+dotcmsReleaseVersion
        extension = 'tar.gz'
        compression = Compression.GZIP
    }
}
tgzTask.group='dotCMS Util'
tgzTask.description='Creates distribution as a .tgz file.'

task removeDistFolder(type: Delete){
    delete "$distLocation"
}
removeDistFolder.group='dotCMS Util'
removeDistFolder.description='Removes the distribution folder.'

removeDistFolder.mustRunAfter 'zip', 'tgzTask', 'docker'

javadoc {

    options.addStringOption('sourcepath', sourceSets.main.allJava.asPath)
    //doclint html standards in Java 8 are very strict that's why is better to turn in off
    options.addBooleanOption('Xdoclint:none', true)

    /*
     Not working, gradle bug
      https://groups.google.com/forum/#!topic/gradle-dev/R83dy_6PHMc/discussion
      https://discuss.gradle.org/t/javadoc-exclusion-question/11875
     */
    options.addStringOption('subpackages', 'com.dotmarketing:com.dotcms')

    title       = "dotCMS API"
    maxMemory   = "1024m"
    failOnError = false
    options.noQualifiers 'all'
    options.author(true)
    options.version(true)
    options.use(true)
    options.encoding 'utf-8'
    options.docEncoding 'utf-8'
    options.charSet 'utf-8'
    options.linkSource false
    options.links 'https://docs.oracle.com/javase/8/docs/api/'
}

//Task meant to be use from a distribution structure using the buildwar.sh script.
//This task will just use the already deployed folder inside the app server and compressed to a war file.
task customDistWar(type: War) {
    dependsOn 'deployPlugins'
    from "$dotcmsDistBase$webAppRootFolder"
    exclude "assets/**", "dotsecure/**"
    baseName "dotcms"
    destinationDir = file("../WAR")
}
customDistWar.group='dotCMS Development'
customDistWar.description='Builds a dotCMS as a war. (Task mean to be use from a distribution structure using the buildwar.sh script. This task will just use the already deployed folder inside the app server and compressed into a war file.)'

compileAspect.dependsOn 'immutables'
compileAspect {
    println "\nCompiling Aspect..."
}
// This task defines if the immutables folder is generated, otherwise will generate it.
task immutables() {
    doLast {
        println "\nChecking immutables..."
        def generatedFolder = new File("$generatedSourceFolder");
        if (!generatedFolder.exists()) {

            println "Generating immutables...\n"

            def gradleTask = "compileJava"
            def artefactBuild = project.tasks.create([name: "artefactBuild_$gradleTask", type: GradleBuild])
            artefactBuild.buildFile = project.file("immutables.gradle")
            artefactBuild.tasks = [gradleTask]
            artefactBuild.execute()
        } else {
            println "Immutables already generated, skipping generation... (Delete $generatedSourceFolder folder in order to regenerate them)\n"
        }
    }
}
immutables.group='dotCMS Development'
immutables.description='Compiles the source code using the compileJava task and generate the immutables, those immutables will be located under the src/main/generated folder'

task cleanImmutables() {
    doLast {
        println "\nDeleting immutables folder..."
        delete "$generatedSourceFolder"
    }
}
cleanImmutables.group='dotCMS Development'
cleanImmutables.description='Deletes the folder where the immutables are generated'

clean {
    println "\nExecuting clean task..."
}
clean.finalizedBy 'cleanImmutables'

// This task finds all th plugins and runs 'ant build' inside each one.
// In order to compile everything it need the dependency jars in a folder ($buildDir/pluginsLib)
task buildPlugins(dependsOn: 'jar') {
//    doLast {
//        delete "$buildDir/pluginsLib"
//
//        copy {
//            into "$buildDir/pluginsLib"
//            from configurations.compile
//            from "$buildDir/libs/"
//        }
//
//        def pluginsFolder = new File("src/main/plugins");
//
//        if (!pluginsFolder.exists()) {
//            pluginsFolder = new File("../plugins");
//        }
//
//        pluginsFolder.eachDir() {
//            def pluginPath = it
//            println "Compile Plugin: " + pluginPath
//
//            javaexec {
//                workingDir pluginPath
//                main = "-jar";
//                args = [
//                        "$rootDir/../bin/ant/ant-launcher.jar",
//                        "-buildfile",
//                        pluginPath.getAbsolutePath() + "/build.xml"
//                ]
//            }
//        }
//    }
}
buildPlugins.group='dotCMS Development'
buildPlugins.description='Compiles and Builds all the plugins but does not deploy.'

// TODO I think there are variables for this paths.
// This task will copy what is used to be src-conf (now under resources)
// to webapp/WEB-INF/classes in order to be merged with the plugins.
task deployConfig(type: Copy) {

    def webAppFolder = 'src/main/webapp'

    if (new File('src/main/resources').exists()){
        from 'src/main/resources'
    }else{
        webAppFolder = "$dotcmsDistBase$webAppRootFolder"
        from "../$confDistLocation"

    }
    into "$webAppFolder/WEB-INF/classes"

    filesMatching("release.properties") {
        expand( project.properties )
    }
}
deployConfig.group='dotCMS Util'
deployConfig.description='This task will copy what is used to be src-conf to webapp/WEB-INF/classes in order to be merged with the plugins.'

//TODO Need to check ROOT folder functionality is working.
// This task will:
// 1. Copy the plugins.xml from plugins folder.
// 2. Loop over each plugin and copy the .jar file into WEB-INF/lib
// 3. Call the and task def com.dotmarketing.plugin.ant.DeployTask to merge
//    all the properties/files from the static plugins.
task deployPlugins(dependsOn: ['buildPlugins']) {

//    doLast {
//
//        def pluginsFolder = new File("src/main/plugins")
//        def webAppFolder = 'src/main/webapp'
//
//        if (!pluginsFolder.exists()) {
//            pluginsFolder = new File("../plugins");
//            webAppFolder = "$dotcmsDistBase$webAppRootFolder"
//        }
//
//        copy {
//            from "$pluginsFolder.path"
//            into "$webAppFolder/WEB-INF/classes"
//            include 'plugins.xml'
//        }
//
//        //<target name="deploy-plugin"/>
//        pluginsFolder.eachDir() {
//            def pluginPath = it
//            copy {
//                from pluginPath.getPath() + '/build/jar'
//                into "$webAppFolder/WEB-INF/lib"
//                include '*.jar'
//            }
//        }
//
//        ant.taskdef(
//                name: 'pluginDeployTask',
//                classname: 'com.dotmarketing.plugin.ant.DeployTask',
//                classpath: configurations.compile.asPath)
//
//        ant.pluginDeployTask(
//                distributionPath: '../',
//                dotcmsHome: "$webAppFolder",
//                plugins: "$webAppFolder/WEB-INF/lib")
//    }
}
deployPlugins.group='dotCMS Development'
deployPlugins.description='Builds and deploys all the plugins under /plugins folder.'

// This task will:
// 1. Call the and task def com.dotmarketing.plugin.ant.UndeployTask to remove
//    all the properties/files from the static plugins.
// 2. Delete plugin.xml from classes and the html of the static plugins.
task undeployPlugins() {

    doLast {
        def webAppFolder = 'src/main/webapp'

        if( !new File("$webAppFolder").exists() ) {
            webAppFolder = "$dotcmsDistBase$webAppRootFolder"
        }


        ant.taskdef(
                name: 'pluginUndeployTask',
                classname: 'com.dotmarketing.plugin.ant.UndeployTask',
                classpath: configurations.compile.asPath)
        ant.pluginUndeployTask(
                distributionPath: '../',
                dotcmsHome: "$webAppFolder",
                plugins: "$webAppFolder/WEB-INF/lib")

        delete fileTree("$webAppFolder/WEB-INF/lib") {
            include '**/plugin-*.jar'
            include '**/pluginlib-*.jar'
        }
        delete "$webAppFolder/WEB-INF/classes/plugins.xml"
        delete "$webAppFolder/html/plugins"
    }
}
undeployPlugins.group='dotCMS Development'
undeployPlugins.description='Undeploys all plugins, returns overridden files to default state. This task does not need to be executed as a pre-condition of deployPlugins because that task executes it automatically.'

//Creates a backup of assets, dotsecure, META-INF and H2_Database
task backupWarTomcatData() {
    doLast {
        delete "$tomcatInstallLocation/temp"

        copy {
            into "$tomcatInstallLocation/temp/assets"
            from "$tomcatInstallLocation$webAppRootFolder/assets"
            include "**/*"
        }

        copy {
            into "$tomcatInstallLocation/temp/dotsecure"
            from "$tomcatInstallLocation$webAppRootFolder/dotsecure"
            include "**/*"
        }

        copy {
            into "$tomcatInstallLocation/temp/META-INF"
            from "$tomcatInstallLocation$webAppRootFolder/META-INF"
            include "**/*"
        }

        copy {
            into "$tomcatInstallLocation/temp/h2"
            from "$tomcatInstallLocation$webAppRootFolder/WEB-INF/H2_DATABASE"
            include "*.db"
        }
    }
}
backupWarTomcatData.group='dotCMS Util'
backupWarTomcatData.description='Creates a backup of assets, dotsecure, META-INF and H2_Database.'

//Restores content of assets, dotsecure, META-INF and H2_Database (copy back to webapps/ROOT)
task restoreBackupWarTomcatData() {
    doLast {
        delete "$tomcatInstallLocation$webAppRootFolder/assets"
        copy {
            from "$tomcatInstallLocation/temp/assets"
            into "$tomcatInstallLocation$webAppRootFolder/assets"
            include "**/*"
        }

        delete "$tomcatInstallLocation$webAppRootFolder/dotsecure"
        copy {
            from "$tomcatInstallLocation/temp/dotsecure"
            into "$tomcatInstallLocation$webAppRootFolder/dotsecure"
            include "**/*"
        }

        delete "$tomcatInstallLocation$webAppRootFolder/META-INF"
        copy {
            from "$tomcatInstallLocation/temp/META-INF"
            into "$tomcatInstallLocation$webAppRootFolder/META-INF"
            include "**/*"
        }

        delete "$tomcatInstallLocation$webAppRootFolder/WEB-INF/H2_DATABASE"
        copy {
            from "$tomcatInstallLocation/temp/h2"
            into "$tomcatInstallLocation$webAppRootFolder/WEB-INF/H2_DATABASE"
            include "*.db"
        }

        FileUtils.cleanDirectory(new File("$tomcatInstallLocation/temp"));
        delete "$tomcatInstallLocation$webAppRootFolder/WEB-INF/classes/com"
    }
}
restoreBackupWarTomcatData.group='dotCMS Util'
restoreBackupWarTomcatData.description='Restores content of assets, dotsecure, META-INF and H2_Database.'

undeployPlugins.finalizedBy 'deployConfig'


// Util methods.
def getDate() {
    def fmt = new java.text.SimpleDateFormat("MMMM dd, yyyy", Locale.US)
    def formattedDate = fmt.format(new Date())
    return formattedDate
}

//Util method that replaces the occurrence of a string in a specified file
static def replaceText(File sourceFile, String fromString, String toString) {
    if (!sourceFile.exists()) {
        throw new GradleException("File not found: ${sourceFile.absolutePath}")
    }
    def updatedContent = sourceFile.getText('UTF-8').replaceAll(fromString, toString)
    sourceFile.write(updatedContent, 'UTF-8')
}

// Append a line to a file only if it doesn't already exist
static def appendLineIfMissing(File file, String lineToAdd) {
    if (!file.exists()) {
        throw new GradleException("File not found: ${file.absolutePath}")
    }
    def lines = file.readLines('UTF-8')
    if (!lines.contains(lineToAdd)) {
        file.append(System.lineSeparator() + lineToAdd, 'UTF-8')
    }
}

// Configure TomcatPropertyDecoder in catalina.properties
static def configureTomcatPropertyDecoder(String tomcatPath) {
    File catalinaProps = new File(tomcatPath, "conf/catalina.properties")
    if (catalinaProps.exists()) {
        appendLineIfMissing(catalinaProps,
                "org.apache.tomcat.util.digester.PROPERTY_SOURCE=com.dotcms.tomcat.context.TomcatPropertyDecoder")
        println "Configured TomcatPropertyDecoder in ${catalinaProps.absolutePath}"
    } else {
        println "Warning: catalina.properties not found at ${catalinaProps.absolutePath}"
    }
}

// Clones dotCMS's tomcat repo following tomcatInstall under gradle.properties.
// If the tomcat folder exists: git pull, if not: git clone.
class ClonePullTomcatTask extends DefaultTask{

    String tomcatLocation = project.tomcatInstallLocation

    @TaskAction
    def pull(){
        def folder = new File( tomcatLocation )
        
        println "Cloning the $project.tomcatInstallRepo, branch $project.tomcatInstallBranch on $tomcatLocation";
        
        
        if( !folder.exists() ) {

            try {

                println "Cloning the $project.tomcatInstallRepo, branch $project.tomcatInstallBranch on $tomcatLocation";
                org.ajoberstar.grgit.Grgit.clone(dir: "$tomcatLocation", uri: "$project.tomcatInstallRepo", refToCheckout: "$project.tomcatInstallBranch")
            } catch (Exception exception) {
                //Do nothing, this will fail only if git is not installed on this machine
            }
        } else {
            def tomcatGit = org.ajoberstar.grgit.Grgit.open(folder);
            tomcatGit.pull();
        }
    }

}

// Parametrized task to unpack Tomcat to any destination directory
class UnpackTomcatTask extends DefaultTask {
    @InputFile
    File tomcatZipFile

    @Input
    String destinationDir

    @TaskAction
    def unpack() {
        def destDir = project.file(destinationDir)

        // Skip if Tomcat dir already exists and is non-empty
        def binDir = new File(destDir, "bin")
        def confDir = new File(destDir, "conf")
        def binOk = binDir.exists() && binDir.listFiles()?.length > 0
        def confOk = confDir.exists() && confDir.listFiles()?.length > 0

        if (binOk && confOk) {
            println "Tomcat already exists at $destDir, skipping unpack"
            return
        }

        project.copy {
            from project.zipTree(tomcatZipFile)

            // Remove first directory level (Gradle 4.10 compatible)
            eachFile { fcd ->
                def segments = fcd.relativePath.segments
                if (segments.length > 1) {
                    // Create a new RelativePath without the first segment
                    fcd.relativePath = new RelativePath(
                            fcd.relativePath.file,
                            segments[1..segments.length-1] as String[]
                    )
                } else {
                    fcd.exclude() // skip the top-level directory itself
                }
            }
            includeEmptyDirs = false
            into destDir
        }

        println "Unpacked Tomcat to $destDir"
        if (tomcatZipFile.exists()) {
            tomcatZipFile.delete()
            println "Deleted Tomcat zip: ${tomcatZipFile}"
        }
    }
}

//Gradle Custom Task that contains the logic for deploying the app war in the application server
//It works for dist and development versions
//Also, copies specific libraries from /libs/buildlibs to tomcat/lib folder
class DeployWarTomcatTask extends DefaultTask{
    @InputDirectory
    String tomcatPath;

    @TaskAction
    def deploy(){
        cleanWebapps(tomcatPath)
        copyBuildLibs(tomcatPath)
        copyLocalTomcatFiles(tomcatPath, 'local-tomcat-bin', 'bin')
        copyLocalTomcatFiles(tomcatPath, 'local-tomcat-conf', 'conf')

        def zipFile = project.file("$project.buildDir/libs/$project.archivesBaseName" + ".war")
        project.copy{
            from project.zipTree(zipFile)
            into tomcatPath + project.webAppRootFolder
        }

        if (project.gradle.startParameter.taskNames.contains("deployWarTomcatTests")) {
            project.replaceText(new File("$tomcatPath$project.webAppRootFolder/WEB-INF/web.xml"),
                    "<!-- TEST FRAMEWORK SERVLETS", "<!-- TEST FRAMEWORK SERVLETS -->")
            project.replaceText(new File("$tomcatPath$project.webAppRootFolder/WEB-INF/web.xml"),
                    "END OF TEST FRAMEWORK SERVLETS -->", "<!-- END OF TEST FRAMEWORK SERVLETS -->")
        }
        
        // Configure TomcatPropertyDecoder for local deployment
        project.configureTomcatPropertyDecoder(tomcatPath)
    }

    // Remove all subfolders under webapps directory
    def cleanWebapps(tomcatPath) {
        def webappsDir = new File(tomcatPath, "webapps")
        if (webappsDir.exists() && webappsDir.isDirectory()) {
            webappsDir.listFiles().each { file ->
                if (file.isDirectory()) {
                    println "Removing webapps subdirectory: ${file.name}"
                    project.delete file
                }
            }
        } else {
            println "Webapps directory not found or is not a directory: ${webappsDir.absolutePath}"
        }
    }

    // Copying libs/buildlibs under tomcat8/lib.
    def copyBuildLibs(buildLibLocation) {
        project.copy{
            from '../libs/buildlibs'
            into buildLibLocation + '/lib'
            include 'mail.jar'
            include 'mssql-jdbc-6.2.2.jre8.jar'
            include 'mysql-connector-java-5.1.37-bin.jar'
            include 'postgresql-42.2.2.jar'
            include 'ojdbc5.jar'
            include 'ContextPropertyDecoder.jar'
        }

    }

    // Unified function to copy files from local tomcat directories to tomcat subdirectories.
    def copyLocalTomcatFiles(tomcatPath, localDirName, targetSubDir) {
        def localDir = project.file("../${localDirName}")
        if (localDir.exists() && localDir.isDirectory()) {
            println "Copying files from ${localDir.absolutePath} to ${tomcatPath}/${targetSubDir}"
            project.copy{
                from localDir
                into tomcatPath + "/${targetSubDir}"
                include '**/*'
            }
        } else {
            println "Local directory not found: ${localDir.absolutePath}"
        }
    }
}

task initNpm(type: NpmTask) {
    args = ['init', '--yes']

    finalizedBy 'installDotcmsUI'
}

task installDotcmsUI(type: NpmTask) {
    if ("latest".equals(coreWebReleaseVersion)) {
        args = ['install', 'dotcms-ui']
    }else{
        args = ['install', 'dotcms-ui@' + coreWebReleaseVersion]
    }

    finalizedBy 'copyNodeModules'
}

task makeDotAdminFolder(type: DefaultTask) {
    String dotAdminFolder = "./src/main/webapp/$angularFolder"
    project.mkdir(dotAdminFolder)
}

task cleanNodeModules(type: Delete) {
    delete './package.json'
    delete './package-lock.json'
    delete "./node_modules"
    followSymlinks = true
}

task copyNodeModules(type: Copy) {
    dependsOn 'makeDotAdminFolder'

    delete "./src/main/webapp/$angularFolder"
    from (file("./node_modules/dotcms-ui"))
    into("./src/main/webapp/$angularFolder")

    finalizedBy 'cleanNodeModules'
}

task downloadDependencies(type: Exec) {
    configurations.compile.files
    configurations.buildlibs.files
    configurations.starter.files
    configurations.profiler.files
    configurations.profilerDependencies.files
    configurations.provided.files
    configurations.felix.files

    commandLine 'echo', 'Downloaded all dependencies'
}

// reference:  https://github.com/palantir/gradle-docker
docker {
    name "dotcms/dotcms:base-$dotcmsReleaseVersion-$dotcmsReleaseBuild"
    tags 'latest'
    dockerfile file('docker/Dockerfile')
    files 'docker/entrypoint.sh', tgzTask.archivePath, 'docker/log4j2.xml'
    pull true
    noCache false
}
docker.dependsOn createDist

task wrapper(type: Wrapper) {
    gradleVersion = '4.10.2'
}
